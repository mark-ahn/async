// This file was automatically generated by genny.
// Any changes will be lost if this file is regenerated.
// see https://github.com/cheekybits/genny

package async

import (
	"context"
	"fmt"
	"sync"
)

type PoolOfBoolThenBool interface {
	GetBoolArg() *bool
	PutBoolArg(*bool)
	GetBoolReturn() *bool
	PutBoolReturn(*bool)

	GetWorkOfBoolThenBool() *WorkOfBoolThenBool
	GetReturnOfBool() *ReturnOfBool
	PutWorkOfBoolThenBool(*WorkOfBoolThenBool)
	PutReturnOfBool(*ReturnOfBool)

	GetChReturnOfBool() chan *ReturnOfBool
	PutChReturnOfBool(chan *ReturnOfBool)
}

type PoolOfBoolThenBoolImpl struct {
	BoolArg        sync.Pool
	BoolRtn        sync.Pool
	BoolWork       sync.Pool
	BoolReturn     sync.Pool
	ChReturnOfBool sync.Pool
}

func (__ *PoolOfBoolThenBoolImpl) GetBoolArg() *bool {
	return __.BoolArg.Get().(*bool)
}
func (__ *PoolOfBoolThenBoolImpl) PutBoolArg(p *bool) {
	__.BoolArg.Put(p)
}
func (__ *PoolOfBoolThenBoolImpl) GetBoolReturn() *bool {
	return __.BoolRtn.Get().(*bool)
}
func (__ *PoolOfBoolThenBoolImpl) PutBoolReturn(p *bool) {
	__.BoolRtn.Put(p)
}

func (__ *PoolOfBoolThenBoolImpl) GetWorkOfBoolThenBool() *WorkOfBoolThenBool {
	return __.BoolWork.Get().(*WorkOfBoolThenBool)
}
func (__ *PoolOfBoolThenBoolImpl) PutWorkOfBoolThenBool(p *WorkOfBoolThenBool) {
	__.BoolWork.Put(p)
}
func (__ *PoolOfBoolThenBoolImpl) GetReturnOfBool() *ReturnOfBool {
	return __.BoolReturn.Get().(*ReturnOfBool)
}
func (__ *PoolOfBoolThenBoolImpl) PutReturnOfBool(p *ReturnOfBool) {
	__.BoolReturn.Put(p)
}

func (__ *PoolOfBoolThenBoolImpl) GetChReturnOfBool() chan *ReturnOfBool {
	return __.ChReturnOfBool.Get().(chan *ReturnOfBool)
}
func (__ *PoolOfBoolThenBoolImpl) PutChReturnOfBool(p chan *ReturnOfBool) {
	__.ChReturnOfBool.Put(p)
}

func NewPoolOfBoolThenBoolImpl() *PoolOfBoolThenBoolImpl {
	return &PoolOfBoolThenBoolImpl{
		BoolArg: sync.Pool{
			New: func() interface{} {
				return new(bool)
			},
		},
		BoolWork: sync.Pool{
			New: func() interface{} {
				return new(WorkOfBoolThenBool)
			},
		},
		BoolRtn: sync.Pool{
			New: func() interface{} {
				return new(bool)
			},
		},
		BoolReturn: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfBool)
			},
		},
		ChReturnOfBool: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfBool, 1)
			},
		},
	}
}

type ApiDecouplerOfBoolThenBool struct {
	pool PoolOfBoolThenBool
}

func NewApiDecouplerOfBoolThenBool() *ApiDecouplerOfBoolThenBool {
	return &ApiDecouplerOfBoolThenBool{
		pool: NewPoolOfBoolThenBoolImpl(),
	}
}

func (__ *ApiDecouplerOfBoolThenBool) ReturnError(rtn_ch chan<- *ReturnOfBool, err error) {
	rtn := __.pool.GetReturnOfBool()
	var other bool
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfBoolThenBool) HandleOfBoolThenBool(ctx context.Context, req *WorkOfBoolThenBool, h func(ctx context.Context, arg bool) (bool, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfBool()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfBoolThenBool) DoOfBoolThenBool(ctx context.Context, worker WorkerOfPushBoolThenBool, arg bool) (bool, error) {
	// ch := make(chan *ReturnOfBool, 1)
	ch := __.pool.GetChReturnOfBool()
	defer __.pool.PutChReturnOfBool(ch)

	req := __.pool.GetWorkOfBoolThenBool()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfBoolThenBool(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfBool(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfBoolThenBool = func(ctx context.Context, arg bool) (bool, error)

type WorkerOfBoolThenBool struct {
	api_syncer *ApiDecouplerOfBoolThenBool
	handler    WorkHandlerOfBoolThenBool

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfBoolThenBool
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfBoolThenBool(ctx context.Context, h WorkHandlerOfBoolThenBool, n int) *WorkerOfBoolThenBool {
	__ := &WorkerOfBoolThenBool{
		api_syncer: NewApiDecouplerOfBoolThenBool(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfBoolThenBool, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfBoolThenBool{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfBoolThenBool(req.Context, req.WorkOfBoolThenBool, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfBoolThenBool) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfBoolThenBool) Push(ctx context.Context, req *WorkOfBoolThenBool) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfBoolThenBool)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfBoolThenBool = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfBoolThenBool) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfBoolThenBool) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfBoolThenBool) Call(ctx context.Context, arg bool) (bool, error) {
	return __.api_syncer.DoOfBoolThenBool(ctx, __, arg)
}

type PoolOfBoolThenByte interface {
	GetBoolArg() *bool
	PutBoolArg(*bool)
	GetByteReturn() *byte
	PutByteReturn(*byte)

	GetWorkOfBoolThenByte() *WorkOfBoolThenByte
	GetReturnOfByte() *ReturnOfByte
	PutWorkOfBoolThenByte(*WorkOfBoolThenByte)
	PutReturnOfByte(*ReturnOfByte)

	GetChReturnOfByte() chan *ReturnOfByte
	PutChReturnOfByte(chan *ReturnOfByte)
}

type PoolOfBoolThenByteImpl struct {
	BoolArg        sync.Pool
	ByteRtn        sync.Pool
	BoolWork       sync.Pool
	ByteReturn     sync.Pool
	ChReturnOfByte sync.Pool
}

func (__ *PoolOfBoolThenByteImpl) GetBoolArg() *bool {
	return __.BoolArg.Get().(*bool)
}
func (__ *PoolOfBoolThenByteImpl) PutBoolArg(p *bool) {
	__.BoolArg.Put(p)
}
func (__ *PoolOfBoolThenByteImpl) GetByteReturn() *byte {
	return __.ByteRtn.Get().(*byte)
}
func (__ *PoolOfBoolThenByteImpl) PutByteReturn(p *byte) {
	__.ByteRtn.Put(p)
}

func (__ *PoolOfBoolThenByteImpl) GetWorkOfBoolThenByte() *WorkOfBoolThenByte {
	return __.BoolWork.Get().(*WorkOfBoolThenByte)
}
func (__ *PoolOfBoolThenByteImpl) PutWorkOfBoolThenByte(p *WorkOfBoolThenByte) {
	__.BoolWork.Put(p)
}
func (__ *PoolOfBoolThenByteImpl) GetReturnOfByte() *ReturnOfByte {
	return __.ByteReturn.Get().(*ReturnOfByte)
}
func (__ *PoolOfBoolThenByteImpl) PutReturnOfByte(p *ReturnOfByte) {
	__.ByteReturn.Put(p)
}

func (__ *PoolOfBoolThenByteImpl) GetChReturnOfByte() chan *ReturnOfByte {
	return __.ChReturnOfByte.Get().(chan *ReturnOfByte)
}
func (__ *PoolOfBoolThenByteImpl) PutChReturnOfByte(p chan *ReturnOfByte) {
	__.ChReturnOfByte.Put(p)
}

func NewPoolOfBoolThenByteImpl() *PoolOfBoolThenByteImpl {
	return &PoolOfBoolThenByteImpl{
		BoolArg: sync.Pool{
			New: func() interface{} {
				return new(bool)
			},
		},
		BoolWork: sync.Pool{
			New: func() interface{} {
				return new(WorkOfBoolThenByte)
			},
		},
		ByteRtn: sync.Pool{
			New: func() interface{} {
				return new(byte)
			},
		},
		ByteReturn: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfByte)
			},
		},
		ChReturnOfByte: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfByte, 1)
			},
		},
	}
}

type ApiDecouplerOfBoolThenByte struct {
	pool PoolOfBoolThenByte
}

func NewApiDecouplerOfBoolThenByte() *ApiDecouplerOfBoolThenByte {
	return &ApiDecouplerOfBoolThenByte{
		pool: NewPoolOfBoolThenByteImpl(),
	}
}

func (__ *ApiDecouplerOfBoolThenByte) ReturnError(rtn_ch chan<- *ReturnOfByte, err error) {
	rtn := __.pool.GetReturnOfByte()
	var other byte
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfBoolThenByte) HandleOfBoolThenByte(ctx context.Context, req *WorkOfBoolThenByte, h func(ctx context.Context, arg bool) (byte, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfByte()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfBoolThenByte) DoOfBoolThenByte(ctx context.Context, worker WorkerOfPushBoolThenByte, arg bool) (byte, error) {
	// ch := make(chan *ReturnOfByte, 1)
	ch := __.pool.GetChReturnOfByte()
	defer __.pool.PutChReturnOfByte(ch)

	req := __.pool.GetWorkOfBoolThenByte()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfBoolThenByte(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfByte(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfBoolThenByte = func(ctx context.Context, arg bool) (byte, error)

type WorkerOfBoolThenByte struct {
	api_syncer *ApiDecouplerOfBoolThenByte
	handler    WorkHandlerOfBoolThenByte

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfBoolThenByte
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfBoolThenByte(ctx context.Context, h WorkHandlerOfBoolThenByte, n int) *WorkerOfBoolThenByte {
	__ := &WorkerOfBoolThenByte{
		api_syncer: NewApiDecouplerOfBoolThenByte(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfBoolThenByte, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfBoolThenByte{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfBoolThenByte(req.Context, req.WorkOfBoolThenByte, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfBoolThenByte) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfBoolThenByte) Push(ctx context.Context, req *WorkOfBoolThenByte) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfBoolThenByte)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfBoolThenByte = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfBoolThenByte) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfBoolThenByte) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfBoolThenByte) Call(ctx context.Context, arg bool) (byte, error) {
	return __.api_syncer.DoOfBoolThenByte(ctx, __, arg)
}

type PoolOfBoolThenComplex128 interface {
	GetBoolArg() *bool
	PutBoolArg(*bool)
	GetComplex128Return() *complex128
	PutComplex128Return(*complex128)

	GetWorkOfBoolThenComplex128() *WorkOfBoolThenComplex128
	GetReturnOfComplex128() *ReturnOfComplex128
	PutWorkOfBoolThenComplex128(*WorkOfBoolThenComplex128)
	PutReturnOfComplex128(*ReturnOfComplex128)

	GetChReturnOfComplex128() chan *ReturnOfComplex128
	PutChReturnOfComplex128(chan *ReturnOfComplex128)
}

type PoolOfBoolThenComplex128Impl struct {
	BoolArg              sync.Pool
	Complex128Rtn        sync.Pool
	BoolWork             sync.Pool
	Complex128Return     sync.Pool
	ChReturnOfComplex128 sync.Pool
}

func (__ *PoolOfBoolThenComplex128Impl) GetBoolArg() *bool {
	return __.BoolArg.Get().(*bool)
}
func (__ *PoolOfBoolThenComplex128Impl) PutBoolArg(p *bool) {
	__.BoolArg.Put(p)
}
func (__ *PoolOfBoolThenComplex128Impl) GetComplex128Return() *complex128 {
	return __.Complex128Rtn.Get().(*complex128)
}
func (__ *PoolOfBoolThenComplex128Impl) PutComplex128Return(p *complex128) {
	__.Complex128Rtn.Put(p)
}

func (__ *PoolOfBoolThenComplex128Impl) GetWorkOfBoolThenComplex128() *WorkOfBoolThenComplex128 {
	return __.BoolWork.Get().(*WorkOfBoolThenComplex128)
}
func (__ *PoolOfBoolThenComplex128Impl) PutWorkOfBoolThenComplex128(p *WorkOfBoolThenComplex128) {
	__.BoolWork.Put(p)
}
func (__ *PoolOfBoolThenComplex128Impl) GetReturnOfComplex128() *ReturnOfComplex128 {
	return __.Complex128Return.Get().(*ReturnOfComplex128)
}
func (__ *PoolOfBoolThenComplex128Impl) PutReturnOfComplex128(p *ReturnOfComplex128) {
	__.Complex128Return.Put(p)
}

func (__ *PoolOfBoolThenComplex128Impl) GetChReturnOfComplex128() chan *ReturnOfComplex128 {
	return __.ChReturnOfComplex128.Get().(chan *ReturnOfComplex128)
}
func (__ *PoolOfBoolThenComplex128Impl) PutChReturnOfComplex128(p chan *ReturnOfComplex128) {
	__.ChReturnOfComplex128.Put(p)
}

func NewPoolOfBoolThenComplex128Impl() *PoolOfBoolThenComplex128Impl {
	return &PoolOfBoolThenComplex128Impl{
		BoolArg: sync.Pool{
			New: func() interface{} {
				return new(bool)
			},
		},
		BoolWork: sync.Pool{
			New: func() interface{} {
				return new(WorkOfBoolThenComplex128)
			},
		},
		Complex128Rtn: sync.Pool{
			New: func() interface{} {
				return new(complex128)
			},
		},
		Complex128Return: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfComplex128)
			},
		},
		ChReturnOfComplex128: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfComplex128, 1)
			},
		},
	}
}

type ApiDecouplerOfBoolThenComplex128 struct {
	pool PoolOfBoolThenComplex128
}

func NewApiDecouplerOfBoolThenComplex128() *ApiDecouplerOfBoolThenComplex128 {
	return &ApiDecouplerOfBoolThenComplex128{
		pool: NewPoolOfBoolThenComplex128Impl(),
	}
}

func (__ *ApiDecouplerOfBoolThenComplex128) ReturnError(rtn_ch chan<- *ReturnOfComplex128, err error) {
	rtn := __.pool.GetReturnOfComplex128()
	var other complex128
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfBoolThenComplex128) HandleOfBoolThenComplex128(ctx context.Context, req *WorkOfBoolThenComplex128, h func(ctx context.Context, arg bool) (complex128, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfComplex128()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfBoolThenComplex128) DoOfBoolThenComplex128(ctx context.Context, worker WorkerOfPushBoolThenComplex128, arg bool) (complex128, error) {
	// ch := make(chan *ReturnOfComplex128, 1)
	ch := __.pool.GetChReturnOfComplex128()
	defer __.pool.PutChReturnOfComplex128(ch)

	req := __.pool.GetWorkOfBoolThenComplex128()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfBoolThenComplex128(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfComplex128(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfBoolThenComplex128 = func(ctx context.Context, arg bool) (complex128, error)

type WorkerOfBoolThenComplex128 struct {
	api_syncer *ApiDecouplerOfBoolThenComplex128
	handler    WorkHandlerOfBoolThenComplex128

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfBoolThenComplex128
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfBoolThenComplex128(ctx context.Context, h WorkHandlerOfBoolThenComplex128, n int) *WorkerOfBoolThenComplex128 {
	__ := &WorkerOfBoolThenComplex128{
		api_syncer: NewApiDecouplerOfBoolThenComplex128(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfBoolThenComplex128, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfBoolThenComplex128{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfBoolThenComplex128(req.Context, req.WorkOfBoolThenComplex128, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfBoolThenComplex128) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfBoolThenComplex128) Push(ctx context.Context, req *WorkOfBoolThenComplex128) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfBoolThenComplex128)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfBoolThenComplex128 = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfBoolThenComplex128) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfBoolThenComplex128) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfBoolThenComplex128) Call(ctx context.Context, arg bool) (complex128, error) {
	return __.api_syncer.DoOfBoolThenComplex128(ctx, __, arg)
}

type PoolOfBoolThenComplex64 interface {
	GetBoolArg() *bool
	PutBoolArg(*bool)
	GetComplex64Return() *complex64
	PutComplex64Return(*complex64)

	GetWorkOfBoolThenComplex64() *WorkOfBoolThenComplex64
	GetReturnOfComplex64() *ReturnOfComplex64
	PutWorkOfBoolThenComplex64(*WorkOfBoolThenComplex64)
	PutReturnOfComplex64(*ReturnOfComplex64)

	GetChReturnOfComplex64() chan *ReturnOfComplex64
	PutChReturnOfComplex64(chan *ReturnOfComplex64)
}

type PoolOfBoolThenComplex64Impl struct {
	BoolArg             sync.Pool
	Complex64Rtn        sync.Pool
	BoolWork            sync.Pool
	Complex64Return     sync.Pool
	ChReturnOfComplex64 sync.Pool
}

func (__ *PoolOfBoolThenComplex64Impl) GetBoolArg() *bool {
	return __.BoolArg.Get().(*bool)
}
func (__ *PoolOfBoolThenComplex64Impl) PutBoolArg(p *bool) {
	__.BoolArg.Put(p)
}
func (__ *PoolOfBoolThenComplex64Impl) GetComplex64Return() *complex64 {
	return __.Complex64Rtn.Get().(*complex64)
}
func (__ *PoolOfBoolThenComplex64Impl) PutComplex64Return(p *complex64) {
	__.Complex64Rtn.Put(p)
}

func (__ *PoolOfBoolThenComplex64Impl) GetWorkOfBoolThenComplex64() *WorkOfBoolThenComplex64 {
	return __.BoolWork.Get().(*WorkOfBoolThenComplex64)
}
func (__ *PoolOfBoolThenComplex64Impl) PutWorkOfBoolThenComplex64(p *WorkOfBoolThenComplex64) {
	__.BoolWork.Put(p)
}
func (__ *PoolOfBoolThenComplex64Impl) GetReturnOfComplex64() *ReturnOfComplex64 {
	return __.Complex64Return.Get().(*ReturnOfComplex64)
}
func (__ *PoolOfBoolThenComplex64Impl) PutReturnOfComplex64(p *ReturnOfComplex64) {
	__.Complex64Return.Put(p)
}

func (__ *PoolOfBoolThenComplex64Impl) GetChReturnOfComplex64() chan *ReturnOfComplex64 {
	return __.ChReturnOfComplex64.Get().(chan *ReturnOfComplex64)
}
func (__ *PoolOfBoolThenComplex64Impl) PutChReturnOfComplex64(p chan *ReturnOfComplex64) {
	__.ChReturnOfComplex64.Put(p)
}

func NewPoolOfBoolThenComplex64Impl() *PoolOfBoolThenComplex64Impl {
	return &PoolOfBoolThenComplex64Impl{
		BoolArg: sync.Pool{
			New: func() interface{} {
				return new(bool)
			},
		},
		BoolWork: sync.Pool{
			New: func() interface{} {
				return new(WorkOfBoolThenComplex64)
			},
		},
		Complex64Rtn: sync.Pool{
			New: func() interface{} {
				return new(complex64)
			},
		},
		Complex64Return: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfComplex64)
			},
		},
		ChReturnOfComplex64: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfComplex64, 1)
			},
		},
	}
}

type ApiDecouplerOfBoolThenComplex64 struct {
	pool PoolOfBoolThenComplex64
}

func NewApiDecouplerOfBoolThenComplex64() *ApiDecouplerOfBoolThenComplex64 {
	return &ApiDecouplerOfBoolThenComplex64{
		pool: NewPoolOfBoolThenComplex64Impl(),
	}
}

func (__ *ApiDecouplerOfBoolThenComplex64) ReturnError(rtn_ch chan<- *ReturnOfComplex64, err error) {
	rtn := __.pool.GetReturnOfComplex64()
	var other complex64
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfBoolThenComplex64) HandleOfBoolThenComplex64(ctx context.Context, req *WorkOfBoolThenComplex64, h func(ctx context.Context, arg bool) (complex64, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfComplex64()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfBoolThenComplex64) DoOfBoolThenComplex64(ctx context.Context, worker WorkerOfPushBoolThenComplex64, arg bool) (complex64, error) {
	// ch := make(chan *ReturnOfComplex64, 1)
	ch := __.pool.GetChReturnOfComplex64()
	defer __.pool.PutChReturnOfComplex64(ch)

	req := __.pool.GetWorkOfBoolThenComplex64()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfBoolThenComplex64(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfComplex64(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfBoolThenComplex64 = func(ctx context.Context, arg bool) (complex64, error)

type WorkerOfBoolThenComplex64 struct {
	api_syncer *ApiDecouplerOfBoolThenComplex64
	handler    WorkHandlerOfBoolThenComplex64

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfBoolThenComplex64
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfBoolThenComplex64(ctx context.Context, h WorkHandlerOfBoolThenComplex64, n int) *WorkerOfBoolThenComplex64 {
	__ := &WorkerOfBoolThenComplex64{
		api_syncer: NewApiDecouplerOfBoolThenComplex64(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfBoolThenComplex64, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfBoolThenComplex64{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfBoolThenComplex64(req.Context, req.WorkOfBoolThenComplex64, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfBoolThenComplex64) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfBoolThenComplex64) Push(ctx context.Context, req *WorkOfBoolThenComplex64) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfBoolThenComplex64)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfBoolThenComplex64 = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfBoolThenComplex64) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfBoolThenComplex64) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfBoolThenComplex64) Call(ctx context.Context, arg bool) (complex64, error) {
	return __.api_syncer.DoOfBoolThenComplex64(ctx, __, arg)
}

type PoolOfBoolThenError interface {
	GetBoolArg() *bool
	PutBoolArg(*bool)
	GetErrorReturn() *error
	PutErrorReturn(*error)

	GetWorkOfBoolThenError() *WorkOfBoolThenError
	GetReturnOfError() *ReturnOfError
	PutWorkOfBoolThenError(*WorkOfBoolThenError)
	PutReturnOfError(*ReturnOfError)

	GetChReturnOfError() chan *ReturnOfError
	PutChReturnOfError(chan *ReturnOfError)
}

type PoolOfBoolThenErrorImpl struct {
	BoolArg         sync.Pool
	ErrorRtn        sync.Pool
	BoolWork        sync.Pool
	ErrorReturn     sync.Pool
	ChReturnOfError sync.Pool
}

func (__ *PoolOfBoolThenErrorImpl) GetBoolArg() *bool {
	return __.BoolArg.Get().(*bool)
}
func (__ *PoolOfBoolThenErrorImpl) PutBoolArg(p *bool) {
	__.BoolArg.Put(p)
}
func (__ *PoolOfBoolThenErrorImpl) GetErrorReturn() *error {
	return __.ErrorRtn.Get().(*error)
}
func (__ *PoolOfBoolThenErrorImpl) PutErrorReturn(p *error) {
	__.ErrorRtn.Put(p)
}

func (__ *PoolOfBoolThenErrorImpl) GetWorkOfBoolThenError() *WorkOfBoolThenError {
	return __.BoolWork.Get().(*WorkOfBoolThenError)
}
func (__ *PoolOfBoolThenErrorImpl) PutWorkOfBoolThenError(p *WorkOfBoolThenError) {
	__.BoolWork.Put(p)
}
func (__ *PoolOfBoolThenErrorImpl) GetReturnOfError() *ReturnOfError {
	return __.ErrorReturn.Get().(*ReturnOfError)
}
func (__ *PoolOfBoolThenErrorImpl) PutReturnOfError(p *ReturnOfError) {
	__.ErrorReturn.Put(p)
}

func (__ *PoolOfBoolThenErrorImpl) GetChReturnOfError() chan *ReturnOfError {
	return __.ChReturnOfError.Get().(chan *ReturnOfError)
}
func (__ *PoolOfBoolThenErrorImpl) PutChReturnOfError(p chan *ReturnOfError) {
	__.ChReturnOfError.Put(p)
}

func NewPoolOfBoolThenErrorImpl() *PoolOfBoolThenErrorImpl {
	return &PoolOfBoolThenErrorImpl{
		BoolArg: sync.Pool{
			New: func() interface{} {
				return new(bool)
			},
		},
		BoolWork: sync.Pool{
			New: func() interface{} {
				return new(WorkOfBoolThenError)
			},
		},
		ErrorRtn: sync.Pool{
			New: func() interface{} {
				return new(error)
			},
		},
		ErrorReturn: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfError)
			},
		},
		ChReturnOfError: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfError, 1)
			},
		},
	}
}

type ApiDecouplerOfBoolThenError struct {
	pool PoolOfBoolThenError
}

func NewApiDecouplerOfBoolThenError() *ApiDecouplerOfBoolThenError {
	return &ApiDecouplerOfBoolThenError{
		pool: NewPoolOfBoolThenErrorImpl(),
	}
}

func (__ *ApiDecouplerOfBoolThenError) ReturnError(rtn_ch chan<- *ReturnOfError, err error) {
	rtn := __.pool.GetReturnOfError()
	var other error
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfBoolThenError) HandleOfBoolThenError(ctx context.Context, req *WorkOfBoolThenError, h func(ctx context.Context, arg bool) (error, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfError()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfBoolThenError) DoOfBoolThenError(ctx context.Context, worker WorkerOfPushBoolThenError, arg bool) (error, error) {
	// ch := make(chan *ReturnOfError, 1)
	ch := __.pool.GetChReturnOfError()
	defer __.pool.PutChReturnOfError(ch)

	req := __.pool.GetWorkOfBoolThenError()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfBoolThenError(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfError(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfBoolThenError = func(ctx context.Context, arg bool) (error, error)

type WorkerOfBoolThenError struct {
	api_syncer *ApiDecouplerOfBoolThenError
	handler    WorkHandlerOfBoolThenError

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfBoolThenError
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfBoolThenError(ctx context.Context, h WorkHandlerOfBoolThenError, n int) *WorkerOfBoolThenError {
	__ := &WorkerOfBoolThenError{
		api_syncer: NewApiDecouplerOfBoolThenError(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfBoolThenError, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfBoolThenError{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfBoolThenError(req.Context, req.WorkOfBoolThenError, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfBoolThenError) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfBoolThenError) Push(ctx context.Context, req *WorkOfBoolThenError) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfBoolThenError)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfBoolThenError = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfBoolThenError) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfBoolThenError) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfBoolThenError) Call(ctx context.Context, arg bool) (error, error) {
	return __.api_syncer.DoOfBoolThenError(ctx, __, arg)
}

type PoolOfBoolThenFloat32 interface {
	GetBoolArg() *bool
	PutBoolArg(*bool)
	GetFloat32Return() *float32
	PutFloat32Return(*float32)

	GetWorkOfBoolThenFloat32() *WorkOfBoolThenFloat32
	GetReturnOfFloat32() *ReturnOfFloat32
	PutWorkOfBoolThenFloat32(*WorkOfBoolThenFloat32)
	PutReturnOfFloat32(*ReturnOfFloat32)

	GetChReturnOfFloat32() chan *ReturnOfFloat32
	PutChReturnOfFloat32(chan *ReturnOfFloat32)
}

type PoolOfBoolThenFloat32Impl struct {
	BoolArg           sync.Pool
	Float32Rtn        sync.Pool
	BoolWork          sync.Pool
	Float32Return     sync.Pool
	ChReturnOfFloat32 sync.Pool
}

func (__ *PoolOfBoolThenFloat32Impl) GetBoolArg() *bool {
	return __.BoolArg.Get().(*bool)
}
func (__ *PoolOfBoolThenFloat32Impl) PutBoolArg(p *bool) {
	__.BoolArg.Put(p)
}
func (__ *PoolOfBoolThenFloat32Impl) GetFloat32Return() *float32 {
	return __.Float32Rtn.Get().(*float32)
}
func (__ *PoolOfBoolThenFloat32Impl) PutFloat32Return(p *float32) {
	__.Float32Rtn.Put(p)
}

func (__ *PoolOfBoolThenFloat32Impl) GetWorkOfBoolThenFloat32() *WorkOfBoolThenFloat32 {
	return __.BoolWork.Get().(*WorkOfBoolThenFloat32)
}
func (__ *PoolOfBoolThenFloat32Impl) PutWorkOfBoolThenFloat32(p *WorkOfBoolThenFloat32) {
	__.BoolWork.Put(p)
}
func (__ *PoolOfBoolThenFloat32Impl) GetReturnOfFloat32() *ReturnOfFloat32 {
	return __.Float32Return.Get().(*ReturnOfFloat32)
}
func (__ *PoolOfBoolThenFloat32Impl) PutReturnOfFloat32(p *ReturnOfFloat32) {
	__.Float32Return.Put(p)
}

func (__ *PoolOfBoolThenFloat32Impl) GetChReturnOfFloat32() chan *ReturnOfFloat32 {
	return __.ChReturnOfFloat32.Get().(chan *ReturnOfFloat32)
}
func (__ *PoolOfBoolThenFloat32Impl) PutChReturnOfFloat32(p chan *ReturnOfFloat32) {
	__.ChReturnOfFloat32.Put(p)
}

func NewPoolOfBoolThenFloat32Impl() *PoolOfBoolThenFloat32Impl {
	return &PoolOfBoolThenFloat32Impl{
		BoolArg: sync.Pool{
			New: func() interface{} {
				return new(bool)
			},
		},
		BoolWork: sync.Pool{
			New: func() interface{} {
				return new(WorkOfBoolThenFloat32)
			},
		},
		Float32Rtn: sync.Pool{
			New: func() interface{} {
				return new(float32)
			},
		},
		Float32Return: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfFloat32)
			},
		},
		ChReturnOfFloat32: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfFloat32, 1)
			},
		},
	}
}

type ApiDecouplerOfBoolThenFloat32 struct {
	pool PoolOfBoolThenFloat32
}

func NewApiDecouplerOfBoolThenFloat32() *ApiDecouplerOfBoolThenFloat32 {
	return &ApiDecouplerOfBoolThenFloat32{
		pool: NewPoolOfBoolThenFloat32Impl(),
	}
}

func (__ *ApiDecouplerOfBoolThenFloat32) ReturnError(rtn_ch chan<- *ReturnOfFloat32, err error) {
	rtn := __.pool.GetReturnOfFloat32()
	var other float32
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfBoolThenFloat32) HandleOfBoolThenFloat32(ctx context.Context, req *WorkOfBoolThenFloat32, h func(ctx context.Context, arg bool) (float32, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfFloat32()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfBoolThenFloat32) DoOfBoolThenFloat32(ctx context.Context, worker WorkerOfPushBoolThenFloat32, arg bool) (float32, error) {
	// ch := make(chan *ReturnOfFloat32, 1)
	ch := __.pool.GetChReturnOfFloat32()
	defer __.pool.PutChReturnOfFloat32(ch)

	req := __.pool.GetWorkOfBoolThenFloat32()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfBoolThenFloat32(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfFloat32(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfBoolThenFloat32 = func(ctx context.Context, arg bool) (float32, error)

type WorkerOfBoolThenFloat32 struct {
	api_syncer *ApiDecouplerOfBoolThenFloat32
	handler    WorkHandlerOfBoolThenFloat32

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfBoolThenFloat32
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfBoolThenFloat32(ctx context.Context, h WorkHandlerOfBoolThenFloat32, n int) *WorkerOfBoolThenFloat32 {
	__ := &WorkerOfBoolThenFloat32{
		api_syncer: NewApiDecouplerOfBoolThenFloat32(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfBoolThenFloat32, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfBoolThenFloat32{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfBoolThenFloat32(req.Context, req.WorkOfBoolThenFloat32, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfBoolThenFloat32) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfBoolThenFloat32) Push(ctx context.Context, req *WorkOfBoolThenFloat32) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfBoolThenFloat32)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfBoolThenFloat32 = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfBoolThenFloat32) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfBoolThenFloat32) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfBoolThenFloat32) Call(ctx context.Context, arg bool) (float32, error) {
	return __.api_syncer.DoOfBoolThenFloat32(ctx, __, arg)
}

type PoolOfBoolThenFloat64 interface {
	GetBoolArg() *bool
	PutBoolArg(*bool)
	GetFloat64Return() *float64
	PutFloat64Return(*float64)

	GetWorkOfBoolThenFloat64() *WorkOfBoolThenFloat64
	GetReturnOfFloat64() *ReturnOfFloat64
	PutWorkOfBoolThenFloat64(*WorkOfBoolThenFloat64)
	PutReturnOfFloat64(*ReturnOfFloat64)

	GetChReturnOfFloat64() chan *ReturnOfFloat64
	PutChReturnOfFloat64(chan *ReturnOfFloat64)
}

type PoolOfBoolThenFloat64Impl struct {
	BoolArg           sync.Pool
	Float64Rtn        sync.Pool
	BoolWork          sync.Pool
	Float64Return     sync.Pool
	ChReturnOfFloat64 sync.Pool
}

func (__ *PoolOfBoolThenFloat64Impl) GetBoolArg() *bool {
	return __.BoolArg.Get().(*bool)
}
func (__ *PoolOfBoolThenFloat64Impl) PutBoolArg(p *bool) {
	__.BoolArg.Put(p)
}
func (__ *PoolOfBoolThenFloat64Impl) GetFloat64Return() *float64 {
	return __.Float64Rtn.Get().(*float64)
}
func (__ *PoolOfBoolThenFloat64Impl) PutFloat64Return(p *float64) {
	__.Float64Rtn.Put(p)
}

func (__ *PoolOfBoolThenFloat64Impl) GetWorkOfBoolThenFloat64() *WorkOfBoolThenFloat64 {
	return __.BoolWork.Get().(*WorkOfBoolThenFloat64)
}
func (__ *PoolOfBoolThenFloat64Impl) PutWorkOfBoolThenFloat64(p *WorkOfBoolThenFloat64) {
	__.BoolWork.Put(p)
}
func (__ *PoolOfBoolThenFloat64Impl) GetReturnOfFloat64() *ReturnOfFloat64 {
	return __.Float64Return.Get().(*ReturnOfFloat64)
}
func (__ *PoolOfBoolThenFloat64Impl) PutReturnOfFloat64(p *ReturnOfFloat64) {
	__.Float64Return.Put(p)
}

func (__ *PoolOfBoolThenFloat64Impl) GetChReturnOfFloat64() chan *ReturnOfFloat64 {
	return __.ChReturnOfFloat64.Get().(chan *ReturnOfFloat64)
}
func (__ *PoolOfBoolThenFloat64Impl) PutChReturnOfFloat64(p chan *ReturnOfFloat64) {
	__.ChReturnOfFloat64.Put(p)
}

func NewPoolOfBoolThenFloat64Impl() *PoolOfBoolThenFloat64Impl {
	return &PoolOfBoolThenFloat64Impl{
		BoolArg: sync.Pool{
			New: func() interface{} {
				return new(bool)
			},
		},
		BoolWork: sync.Pool{
			New: func() interface{} {
				return new(WorkOfBoolThenFloat64)
			},
		},
		Float64Rtn: sync.Pool{
			New: func() interface{} {
				return new(float64)
			},
		},
		Float64Return: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfFloat64)
			},
		},
		ChReturnOfFloat64: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfFloat64, 1)
			},
		},
	}
}

type ApiDecouplerOfBoolThenFloat64 struct {
	pool PoolOfBoolThenFloat64
}

func NewApiDecouplerOfBoolThenFloat64() *ApiDecouplerOfBoolThenFloat64 {
	return &ApiDecouplerOfBoolThenFloat64{
		pool: NewPoolOfBoolThenFloat64Impl(),
	}
}

func (__ *ApiDecouplerOfBoolThenFloat64) ReturnError(rtn_ch chan<- *ReturnOfFloat64, err error) {
	rtn := __.pool.GetReturnOfFloat64()
	var other float64
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfBoolThenFloat64) HandleOfBoolThenFloat64(ctx context.Context, req *WorkOfBoolThenFloat64, h func(ctx context.Context, arg bool) (float64, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfFloat64()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfBoolThenFloat64) DoOfBoolThenFloat64(ctx context.Context, worker WorkerOfPushBoolThenFloat64, arg bool) (float64, error) {
	// ch := make(chan *ReturnOfFloat64, 1)
	ch := __.pool.GetChReturnOfFloat64()
	defer __.pool.PutChReturnOfFloat64(ch)

	req := __.pool.GetWorkOfBoolThenFloat64()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfBoolThenFloat64(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfFloat64(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfBoolThenFloat64 = func(ctx context.Context, arg bool) (float64, error)

type WorkerOfBoolThenFloat64 struct {
	api_syncer *ApiDecouplerOfBoolThenFloat64
	handler    WorkHandlerOfBoolThenFloat64

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfBoolThenFloat64
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfBoolThenFloat64(ctx context.Context, h WorkHandlerOfBoolThenFloat64, n int) *WorkerOfBoolThenFloat64 {
	__ := &WorkerOfBoolThenFloat64{
		api_syncer: NewApiDecouplerOfBoolThenFloat64(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfBoolThenFloat64, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfBoolThenFloat64{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfBoolThenFloat64(req.Context, req.WorkOfBoolThenFloat64, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfBoolThenFloat64) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfBoolThenFloat64) Push(ctx context.Context, req *WorkOfBoolThenFloat64) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfBoolThenFloat64)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfBoolThenFloat64 = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfBoolThenFloat64) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfBoolThenFloat64) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfBoolThenFloat64) Call(ctx context.Context, arg bool) (float64, error) {
	return __.api_syncer.DoOfBoolThenFloat64(ctx, __, arg)
}

type PoolOfBoolThenInt interface {
	GetBoolArg() *bool
	PutBoolArg(*bool)
	GetIntReturn() *int
	PutIntReturn(*int)

	GetWorkOfBoolThenInt() *WorkOfBoolThenInt
	GetReturnOfInt() *ReturnOfInt
	PutWorkOfBoolThenInt(*WorkOfBoolThenInt)
	PutReturnOfInt(*ReturnOfInt)

	GetChReturnOfInt() chan *ReturnOfInt
	PutChReturnOfInt(chan *ReturnOfInt)
}

type PoolOfBoolThenIntImpl struct {
	BoolArg       sync.Pool
	IntRtn        sync.Pool
	BoolWork      sync.Pool
	IntReturn     sync.Pool
	ChReturnOfInt sync.Pool
}

func (__ *PoolOfBoolThenIntImpl) GetBoolArg() *bool {
	return __.BoolArg.Get().(*bool)
}
func (__ *PoolOfBoolThenIntImpl) PutBoolArg(p *bool) {
	__.BoolArg.Put(p)
}
func (__ *PoolOfBoolThenIntImpl) GetIntReturn() *int {
	return __.IntRtn.Get().(*int)
}
func (__ *PoolOfBoolThenIntImpl) PutIntReturn(p *int) {
	__.IntRtn.Put(p)
}

func (__ *PoolOfBoolThenIntImpl) GetWorkOfBoolThenInt() *WorkOfBoolThenInt {
	return __.BoolWork.Get().(*WorkOfBoolThenInt)
}
func (__ *PoolOfBoolThenIntImpl) PutWorkOfBoolThenInt(p *WorkOfBoolThenInt) {
	__.BoolWork.Put(p)
}
func (__ *PoolOfBoolThenIntImpl) GetReturnOfInt() *ReturnOfInt {
	return __.IntReturn.Get().(*ReturnOfInt)
}
func (__ *PoolOfBoolThenIntImpl) PutReturnOfInt(p *ReturnOfInt) {
	__.IntReturn.Put(p)
}

func (__ *PoolOfBoolThenIntImpl) GetChReturnOfInt() chan *ReturnOfInt {
	return __.ChReturnOfInt.Get().(chan *ReturnOfInt)
}
func (__ *PoolOfBoolThenIntImpl) PutChReturnOfInt(p chan *ReturnOfInt) {
	__.ChReturnOfInt.Put(p)
}

func NewPoolOfBoolThenIntImpl() *PoolOfBoolThenIntImpl {
	return &PoolOfBoolThenIntImpl{
		BoolArg: sync.Pool{
			New: func() interface{} {
				return new(bool)
			},
		},
		BoolWork: sync.Pool{
			New: func() interface{} {
				return new(WorkOfBoolThenInt)
			},
		},
		IntRtn: sync.Pool{
			New: func() interface{} {
				return new(int)
			},
		},
		IntReturn: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfInt)
			},
		},
		ChReturnOfInt: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfInt, 1)
			},
		},
	}
}

type ApiDecouplerOfBoolThenInt struct {
	pool PoolOfBoolThenInt
}

func NewApiDecouplerOfBoolThenInt() *ApiDecouplerOfBoolThenInt {
	return &ApiDecouplerOfBoolThenInt{
		pool: NewPoolOfBoolThenIntImpl(),
	}
}

func (__ *ApiDecouplerOfBoolThenInt) ReturnError(rtn_ch chan<- *ReturnOfInt, err error) {
	rtn := __.pool.GetReturnOfInt()
	var other int
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfBoolThenInt) HandleOfBoolThenInt(ctx context.Context, req *WorkOfBoolThenInt, h func(ctx context.Context, arg bool) (int, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfInt()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfBoolThenInt) DoOfBoolThenInt(ctx context.Context, worker WorkerOfPushBoolThenInt, arg bool) (int, error) {
	// ch := make(chan *ReturnOfInt, 1)
	ch := __.pool.GetChReturnOfInt()
	defer __.pool.PutChReturnOfInt(ch)

	req := __.pool.GetWorkOfBoolThenInt()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfBoolThenInt(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfInt(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfBoolThenInt = func(ctx context.Context, arg bool) (int, error)

type WorkerOfBoolThenInt struct {
	api_syncer *ApiDecouplerOfBoolThenInt
	handler    WorkHandlerOfBoolThenInt

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfBoolThenInt
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfBoolThenInt(ctx context.Context, h WorkHandlerOfBoolThenInt, n int) *WorkerOfBoolThenInt {
	__ := &WorkerOfBoolThenInt{
		api_syncer: NewApiDecouplerOfBoolThenInt(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfBoolThenInt, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfBoolThenInt{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfBoolThenInt(req.Context, req.WorkOfBoolThenInt, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfBoolThenInt) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfBoolThenInt) Push(ctx context.Context, req *WorkOfBoolThenInt) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfBoolThenInt)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfBoolThenInt = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfBoolThenInt) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfBoolThenInt) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfBoolThenInt) Call(ctx context.Context, arg bool) (int, error) {
	return __.api_syncer.DoOfBoolThenInt(ctx, __, arg)
}

type PoolOfBoolThenInt16 interface {
	GetBoolArg() *bool
	PutBoolArg(*bool)
	GetInt16Return() *int16
	PutInt16Return(*int16)

	GetWorkOfBoolThenInt16() *WorkOfBoolThenInt16
	GetReturnOfInt16() *ReturnOfInt16
	PutWorkOfBoolThenInt16(*WorkOfBoolThenInt16)
	PutReturnOfInt16(*ReturnOfInt16)

	GetChReturnOfInt16() chan *ReturnOfInt16
	PutChReturnOfInt16(chan *ReturnOfInt16)
}

type PoolOfBoolThenInt16Impl struct {
	BoolArg         sync.Pool
	Int16Rtn        sync.Pool
	BoolWork        sync.Pool
	Int16Return     sync.Pool
	ChReturnOfInt16 sync.Pool
}

func (__ *PoolOfBoolThenInt16Impl) GetBoolArg() *bool {
	return __.BoolArg.Get().(*bool)
}
func (__ *PoolOfBoolThenInt16Impl) PutBoolArg(p *bool) {
	__.BoolArg.Put(p)
}
func (__ *PoolOfBoolThenInt16Impl) GetInt16Return() *int16 {
	return __.Int16Rtn.Get().(*int16)
}
func (__ *PoolOfBoolThenInt16Impl) PutInt16Return(p *int16) {
	__.Int16Rtn.Put(p)
}

func (__ *PoolOfBoolThenInt16Impl) GetWorkOfBoolThenInt16() *WorkOfBoolThenInt16 {
	return __.BoolWork.Get().(*WorkOfBoolThenInt16)
}
func (__ *PoolOfBoolThenInt16Impl) PutWorkOfBoolThenInt16(p *WorkOfBoolThenInt16) {
	__.BoolWork.Put(p)
}
func (__ *PoolOfBoolThenInt16Impl) GetReturnOfInt16() *ReturnOfInt16 {
	return __.Int16Return.Get().(*ReturnOfInt16)
}
func (__ *PoolOfBoolThenInt16Impl) PutReturnOfInt16(p *ReturnOfInt16) {
	__.Int16Return.Put(p)
}

func (__ *PoolOfBoolThenInt16Impl) GetChReturnOfInt16() chan *ReturnOfInt16 {
	return __.ChReturnOfInt16.Get().(chan *ReturnOfInt16)
}
func (__ *PoolOfBoolThenInt16Impl) PutChReturnOfInt16(p chan *ReturnOfInt16) {
	__.ChReturnOfInt16.Put(p)
}

func NewPoolOfBoolThenInt16Impl() *PoolOfBoolThenInt16Impl {
	return &PoolOfBoolThenInt16Impl{
		BoolArg: sync.Pool{
			New: func() interface{} {
				return new(bool)
			},
		},
		BoolWork: sync.Pool{
			New: func() interface{} {
				return new(WorkOfBoolThenInt16)
			},
		},
		Int16Rtn: sync.Pool{
			New: func() interface{} {
				return new(int16)
			},
		},
		Int16Return: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfInt16)
			},
		},
		ChReturnOfInt16: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfInt16, 1)
			},
		},
	}
}

type ApiDecouplerOfBoolThenInt16 struct {
	pool PoolOfBoolThenInt16
}

func NewApiDecouplerOfBoolThenInt16() *ApiDecouplerOfBoolThenInt16 {
	return &ApiDecouplerOfBoolThenInt16{
		pool: NewPoolOfBoolThenInt16Impl(),
	}
}

func (__ *ApiDecouplerOfBoolThenInt16) ReturnError(rtn_ch chan<- *ReturnOfInt16, err error) {
	rtn := __.pool.GetReturnOfInt16()
	var other int16
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfBoolThenInt16) HandleOfBoolThenInt16(ctx context.Context, req *WorkOfBoolThenInt16, h func(ctx context.Context, arg bool) (int16, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfInt16()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfBoolThenInt16) DoOfBoolThenInt16(ctx context.Context, worker WorkerOfPushBoolThenInt16, arg bool) (int16, error) {
	// ch := make(chan *ReturnOfInt16, 1)
	ch := __.pool.GetChReturnOfInt16()
	defer __.pool.PutChReturnOfInt16(ch)

	req := __.pool.GetWorkOfBoolThenInt16()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfBoolThenInt16(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfInt16(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfBoolThenInt16 = func(ctx context.Context, arg bool) (int16, error)

type WorkerOfBoolThenInt16 struct {
	api_syncer *ApiDecouplerOfBoolThenInt16
	handler    WorkHandlerOfBoolThenInt16

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfBoolThenInt16
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfBoolThenInt16(ctx context.Context, h WorkHandlerOfBoolThenInt16, n int) *WorkerOfBoolThenInt16 {
	__ := &WorkerOfBoolThenInt16{
		api_syncer: NewApiDecouplerOfBoolThenInt16(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfBoolThenInt16, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfBoolThenInt16{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfBoolThenInt16(req.Context, req.WorkOfBoolThenInt16, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfBoolThenInt16) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfBoolThenInt16) Push(ctx context.Context, req *WorkOfBoolThenInt16) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfBoolThenInt16)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfBoolThenInt16 = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfBoolThenInt16) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfBoolThenInt16) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfBoolThenInt16) Call(ctx context.Context, arg bool) (int16, error) {
	return __.api_syncer.DoOfBoolThenInt16(ctx, __, arg)
}

type PoolOfBoolThenInt32 interface {
	GetBoolArg() *bool
	PutBoolArg(*bool)
	GetInt32Return() *int32
	PutInt32Return(*int32)

	GetWorkOfBoolThenInt32() *WorkOfBoolThenInt32
	GetReturnOfInt32() *ReturnOfInt32
	PutWorkOfBoolThenInt32(*WorkOfBoolThenInt32)
	PutReturnOfInt32(*ReturnOfInt32)

	GetChReturnOfInt32() chan *ReturnOfInt32
	PutChReturnOfInt32(chan *ReturnOfInt32)
}

type PoolOfBoolThenInt32Impl struct {
	BoolArg         sync.Pool
	Int32Rtn        sync.Pool
	BoolWork        sync.Pool
	Int32Return     sync.Pool
	ChReturnOfInt32 sync.Pool
}

func (__ *PoolOfBoolThenInt32Impl) GetBoolArg() *bool {
	return __.BoolArg.Get().(*bool)
}
func (__ *PoolOfBoolThenInt32Impl) PutBoolArg(p *bool) {
	__.BoolArg.Put(p)
}
func (__ *PoolOfBoolThenInt32Impl) GetInt32Return() *int32 {
	return __.Int32Rtn.Get().(*int32)
}
func (__ *PoolOfBoolThenInt32Impl) PutInt32Return(p *int32) {
	__.Int32Rtn.Put(p)
}

func (__ *PoolOfBoolThenInt32Impl) GetWorkOfBoolThenInt32() *WorkOfBoolThenInt32 {
	return __.BoolWork.Get().(*WorkOfBoolThenInt32)
}
func (__ *PoolOfBoolThenInt32Impl) PutWorkOfBoolThenInt32(p *WorkOfBoolThenInt32) {
	__.BoolWork.Put(p)
}
func (__ *PoolOfBoolThenInt32Impl) GetReturnOfInt32() *ReturnOfInt32 {
	return __.Int32Return.Get().(*ReturnOfInt32)
}
func (__ *PoolOfBoolThenInt32Impl) PutReturnOfInt32(p *ReturnOfInt32) {
	__.Int32Return.Put(p)
}

func (__ *PoolOfBoolThenInt32Impl) GetChReturnOfInt32() chan *ReturnOfInt32 {
	return __.ChReturnOfInt32.Get().(chan *ReturnOfInt32)
}
func (__ *PoolOfBoolThenInt32Impl) PutChReturnOfInt32(p chan *ReturnOfInt32) {
	__.ChReturnOfInt32.Put(p)
}

func NewPoolOfBoolThenInt32Impl() *PoolOfBoolThenInt32Impl {
	return &PoolOfBoolThenInt32Impl{
		BoolArg: sync.Pool{
			New: func() interface{} {
				return new(bool)
			},
		},
		BoolWork: sync.Pool{
			New: func() interface{} {
				return new(WorkOfBoolThenInt32)
			},
		},
		Int32Rtn: sync.Pool{
			New: func() interface{} {
				return new(int32)
			},
		},
		Int32Return: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfInt32)
			},
		},
		ChReturnOfInt32: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfInt32, 1)
			},
		},
	}
}

type ApiDecouplerOfBoolThenInt32 struct {
	pool PoolOfBoolThenInt32
}

func NewApiDecouplerOfBoolThenInt32() *ApiDecouplerOfBoolThenInt32 {
	return &ApiDecouplerOfBoolThenInt32{
		pool: NewPoolOfBoolThenInt32Impl(),
	}
}

func (__ *ApiDecouplerOfBoolThenInt32) ReturnError(rtn_ch chan<- *ReturnOfInt32, err error) {
	rtn := __.pool.GetReturnOfInt32()
	var other int32
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfBoolThenInt32) HandleOfBoolThenInt32(ctx context.Context, req *WorkOfBoolThenInt32, h func(ctx context.Context, arg bool) (int32, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfInt32()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfBoolThenInt32) DoOfBoolThenInt32(ctx context.Context, worker WorkerOfPushBoolThenInt32, arg bool) (int32, error) {
	// ch := make(chan *ReturnOfInt32, 1)
	ch := __.pool.GetChReturnOfInt32()
	defer __.pool.PutChReturnOfInt32(ch)

	req := __.pool.GetWorkOfBoolThenInt32()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfBoolThenInt32(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfInt32(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfBoolThenInt32 = func(ctx context.Context, arg bool) (int32, error)

type WorkerOfBoolThenInt32 struct {
	api_syncer *ApiDecouplerOfBoolThenInt32
	handler    WorkHandlerOfBoolThenInt32

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfBoolThenInt32
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfBoolThenInt32(ctx context.Context, h WorkHandlerOfBoolThenInt32, n int) *WorkerOfBoolThenInt32 {
	__ := &WorkerOfBoolThenInt32{
		api_syncer: NewApiDecouplerOfBoolThenInt32(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfBoolThenInt32, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfBoolThenInt32{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfBoolThenInt32(req.Context, req.WorkOfBoolThenInt32, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfBoolThenInt32) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfBoolThenInt32) Push(ctx context.Context, req *WorkOfBoolThenInt32) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfBoolThenInt32)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfBoolThenInt32 = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfBoolThenInt32) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfBoolThenInt32) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfBoolThenInt32) Call(ctx context.Context, arg bool) (int32, error) {
	return __.api_syncer.DoOfBoolThenInt32(ctx, __, arg)
}

type PoolOfBoolThenInt64 interface {
	GetBoolArg() *bool
	PutBoolArg(*bool)
	GetInt64Return() *int64
	PutInt64Return(*int64)

	GetWorkOfBoolThenInt64() *WorkOfBoolThenInt64
	GetReturnOfInt64() *ReturnOfInt64
	PutWorkOfBoolThenInt64(*WorkOfBoolThenInt64)
	PutReturnOfInt64(*ReturnOfInt64)

	GetChReturnOfInt64() chan *ReturnOfInt64
	PutChReturnOfInt64(chan *ReturnOfInt64)
}

type PoolOfBoolThenInt64Impl struct {
	BoolArg         sync.Pool
	Int64Rtn        sync.Pool
	BoolWork        sync.Pool
	Int64Return     sync.Pool
	ChReturnOfInt64 sync.Pool
}

func (__ *PoolOfBoolThenInt64Impl) GetBoolArg() *bool {
	return __.BoolArg.Get().(*bool)
}
func (__ *PoolOfBoolThenInt64Impl) PutBoolArg(p *bool) {
	__.BoolArg.Put(p)
}
func (__ *PoolOfBoolThenInt64Impl) GetInt64Return() *int64 {
	return __.Int64Rtn.Get().(*int64)
}
func (__ *PoolOfBoolThenInt64Impl) PutInt64Return(p *int64) {
	__.Int64Rtn.Put(p)
}

func (__ *PoolOfBoolThenInt64Impl) GetWorkOfBoolThenInt64() *WorkOfBoolThenInt64 {
	return __.BoolWork.Get().(*WorkOfBoolThenInt64)
}
func (__ *PoolOfBoolThenInt64Impl) PutWorkOfBoolThenInt64(p *WorkOfBoolThenInt64) {
	__.BoolWork.Put(p)
}
func (__ *PoolOfBoolThenInt64Impl) GetReturnOfInt64() *ReturnOfInt64 {
	return __.Int64Return.Get().(*ReturnOfInt64)
}
func (__ *PoolOfBoolThenInt64Impl) PutReturnOfInt64(p *ReturnOfInt64) {
	__.Int64Return.Put(p)
}

func (__ *PoolOfBoolThenInt64Impl) GetChReturnOfInt64() chan *ReturnOfInt64 {
	return __.ChReturnOfInt64.Get().(chan *ReturnOfInt64)
}
func (__ *PoolOfBoolThenInt64Impl) PutChReturnOfInt64(p chan *ReturnOfInt64) {
	__.ChReturnOfInt64.Put(p)
}

func NewPoolOfBoolThenInt64Impl() *PoolOfBoolThenInt64Impl {
	return &PoolOfBoolThenInt64Impl{
		BoolArg: sync.Pool{
			New: func() interface{} {
				return new(bool)
			},
		},
		BoolWork: sync.Pool{
			New: func() interface{} {
				return new(WorkOfBoolThenInt64)
			},
		},
		Int64Rtn: sync.Pool{
			New: func() interface{} {
				return new(int64)
			},
		},
		Int64Return: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfInt64)
			},
		},
		ChReturnOfInt64: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfInt64, 1)
			},
		},
	}
}

type ApiDecouplerOfBoolThenInt64 struct {
	pool PoolOfBoolThenInt64
}

func NewApiDecouplerOfBoolThenInt64() *ApiDecouplerOfBoolThenInt64 {
	return &ApiDecouplerOfBoolThenInt64{
		pool: NewPoolOfBoolThenInt64Impl(),
	}
}

func (__ *ApiDecouplerOfBoolThenInt64) ReturnError(rtn_ch chan<- *ReturnOfInt64, err error) {
	rtn := __.pool.GetReturnOfInt64()
	var other int64
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfBoolThenInt64) HandleOfBoolThenInt64(ctx context.Context, req *WorkOfBoolThenInt64, h func(ctx context.Context, arg bool) (int64, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfInt64()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfBoolThenInt64) DoOfBoolThenInt64(ctx context.Context, worker WorkerOfPushBoolThenInt64, arg bool) (int64, error) {
	// ch := make(chan *ReturnOfInt64, 1)
	ch := __.pool.GetChReturnOfInt64()
	defer __.pool.PutChReturnOfInt64(ch)

	req := __.pool.GetWorkOfBoolThenInt64()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfBoolThenInt64(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfInt64(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfBoolThenInt64 = func(ctx context.Context, arg bool) (int64, error)

type WorkerOfBoolThenInt64 struct {
	api_syncer *ApiDecouplerOfBoolThenInt64
	handler    WorkHandlerOfBoolThenInt64

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfBoolThenInt64
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfBoolThenInt64(ctx context.Context, h WorkHandlerOfBoolThenInt64, n int) *WorkerOfBoolThenInt64 {
	__ := &WorkerOfBoolThenInt64{
		api_syncer: NewApiDecouplerOfBoolThenInt64(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfBoolThenInt64, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfBoolThenInt64{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfBoolThenInt64(req.Context, req.WorkOfBoolThenInt64, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfBoolThenInt64) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfBoolThenInt64) Push(ctx context.Context, req *WorkOfBoolThenInt64) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfBoolThenInt64)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfBoolThenInt64 = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfBoolThenInt64) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfBoolThenInt64) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfBoolThenInt64) Call(ctx context.Context, arg bool) (int64, error) {
	return __.api_syncer.DoOfBoolThenInt64(ctx, __, arg)
}

type PoolOfBoolThenInt8 interface {
	GetBoolArg() *bool
	PutBoolArg(*bool)
	GetInt8Return() *int8
	PutInt8Return(*int8)

	GetWorkOfBoolThenInt8() *WorkOfBoolThenInt8
	GetReturnOfInt8() *ReturnOfInt8
	PutWorkOfBoolThenInt8(*WorkOfBoolThenInt8)
	PutReturnOfInt8(*ReturnOfInt8)

	GetChReturnOfInt8() chan *ReturnOfInt8
	PutChReturnOfInt8(chan *ReturnOfInt8)
}

type PoolOfBoolThenInt8Impl struct {
	BoolArg        sync.Pool
	Int8Rtn        sync.Pool
	BoolWork       sync.Pool
	Int8Return     sync.Pool
	ChReturnOfInt8 sync.Pool
}

func (__ *PoolOfBoolThenInt8Impl) GetBoolArg() *bool {
	return __.BoolArg.Get().(*bool)
}
func (__ *PoolOfBoolThenInt8Impl) PutBoolArg(p *bool) {
	__.BoolArg.Put(p)
}
func (__ *PoolOfBoolThenInt8Impl) GetInt8Return() *int8 {
	return __.Int8Rtn.Get().(*int8)
}
func (__ *PoolOfBoolThenInt8Impl) PutInt8Return(p *int8) {
	__.Int8Rtn.Put(p)
}

func (__ *PoolOfBoolThenInt8Impl) GetWorkOfBoolThenInt8() *WorkOfBoolThenInt8 {
	return __.BoolWork.Get().(*WorkOfBoolThenInt8)
}
func (__ *PoolOfBoolThenInt8Impl) PutWorkOfBoolThenInt8(p *WorkOfBoolThenInt8) {
	__.BoolWork.Put(p)
}
func (__ *PoolOfBoolThenInt8Impl) GetReturnOfInt8() *ReturnOfInt8 {
	return __.Int8Return.Get().(*ReturnOfInt8)
}
func (__ *PoolOfBoolThenInt8Impl) PutReturnOfInt8(p *ReturnOfInt8) {
	__.Int8Return.Put(p)
}

func (__ *PoolOfBoolThenInt8Impl) GetChReturnOfInt8() chan *ReturnOfInt8 {
	return __.ChReturnOfInt8.Get().(chan *ReturnOfInt8)
}
func (__ *PoolOfBoolThenInt8Impl) PutChReturnOfInt8(p chan *ReturnOfInt8) {
	__.ChReturnOfInt8.Put(p)
}

func NewPoolOfBoolThenInt8Impl() *PoolOfBoolThenInt8Impl {
	return &PoolOfBoolThenInt8Impl{
		BoolArg: sync.Pool{
			New: func() interface{} {
				return new(bool)
			},
		},
		BoolWork: sync.Pool{
			New: func() interface{} {
				return new(WorkOfBoolThenInt8)
			},
		},
		Int8Rtn: sync.Pool{
			New: func() interface{} {
				return new(int8)
			},
		},
		Int8Return: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfInt8)
			},
		},
		ChReturnOfInt8: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfInt8, 1)
			},
		},
	}
}

type ApiDecouplerOfBoolThenInt8 struct {
	pool PoolOfBoolThenInt8
}

func NewApiDecouplerOfBoolThenInt8() *ApiDecouplerOfBoolThenInt8 {
	return &ApiDecouplerOfBoolThenInt8{
		pool: NewPoolOfBoolThenInt8Impl(),
	}
}

func (__ *ApiDecouplerOfBoolThenInt8) ReturnError(rtn_ch chan<- *ReturnOfInt8, err error) {
	rtn := __.pool.GetReturnOfInt8()
	var other int8
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfBoolThenInt8) HandleOfBoolThenInt8(ctx context.Context, req *WorkOfBoolThenInt8, h func(ctx context.Context, arg bool) (int8, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfInt8()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfBoolThenInt8) DoOfBoolThenInt8(ctx context.Context, worker WorkerOfPushBoolThenInt8, arg bool) (int8, error) {
	// ch := make(chan *ReturnOfInt8, 1)
	ch := __.pool.GetChReturnOfInt8()
	defer __.pool.PutChReturnOfInt8(ch)

	req := __.pool.GetWorkOfBoolThenInt8()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfBoolThenInt8(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfInt8(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfBoolThenInt8 = func(ctx context.Context, arg bool) (int8, error)

type WorkerOfBoolThenInt8 struct {
	api_syncer *ApiDecouplerOfBoolThenInt8
	handler    WorkHandlerOfBoolThenInt8

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfBoolThenInt8
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfBoolThenInt8(ctx context.Context, h WorkHandlerOfBoolThenInt8, n int) *WorkerOfBoolThenInt8 {
	__ := &WorkerOfBoolThenInt8{
		api_syncer: NewApiDecouplerOfBoolThenInt8(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfBoolThenInt8, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfBoolThenInt8{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfBoolThenInt8(req.Context, req.WorkOfBoolThenInt8, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfBoolThenInt8) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfBoolThenInt8) Push(ctx context.Context, req *WorkOfBoolThenInt8) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfBoolThenInt8)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfBoolThenInt8 = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfBoolThenInt8) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfBoolThenInt8) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfBoolThenInt8) Call(ctx context.Context, arg bool) (int8, error) {
	return __.api_syncer.DoOfBoolThenInt8(ctx, __, arg)
}

type PoolOfBoolThenRune interface {
	GetBoolArg() *bool
	PutBoolArg(*bool)
	GetRuneReturn() *rune
	PutRuneReturn(*rune)

	GetWorkOfBoolThenRune() *WorkOfBoolThenRune
	GetReturnOfRune() *ReturnOfRune
	PutWorkOfBoolThenRune(*WorkOfBoolThenRune)
	PutReturnOfRune(*ReturnOfRune)

	GetChReturnOfRune() chan *ReturnOfRune
	PutChReturnOfRune(chan *ReturnOfRune)
}

type PoolOfBoolThenRuneImpl struct {
	BoolArg        sync.Pool
	RuneRtn        sync.Pool
	BoolWork       sync.Pool
	RuneReturn     sync.Pool
	ChReturnOfRune sync.Pool
}

func (__ *PoolOfBoolThenRuneImpl) GetBoolArg() *bool {
	return __.BoolArg.Get().(*bool)
}
func (__ *PoolOfBoolThenRuneImpl) PutBoolArg(p *bool) {
	__.BoolArg.Put(p)
}
func (__ *PoolOfBoolThenRuneImpl) GetRuneReturn() *rune {
	return __.RuneRtn.Get().(*rune)
}
func (__ *PoolOfBoolThenRuneImpl) PutRuneReturn(p *rune) {
	__.RuneRtn.Put(p)
}

func (__ *PoolOfBoolThenRuneImpl) GetWorkOfBoolThenRune() *WorkOfBoolThenRune {
	return __.BoolWork.Get().(*WorkOfBoolThenRune)
}
func (__ *PoolOfBoolThenRuneImpl) PutWorkOfBoolThenRune(p *WorkOfBoolThenRune) {
	__.BoolWork.Put(p)
}
func (__ *PoolOfBoolThenRuneImpl) GetReturnOfRune() *ReturnOfRune {
	return __.RuneReturn.Get().(*ReturnOfRune)
}
func (__ *PoolOfBoolThenRuneImpl) PutReturnOfRune(p *ReturnOfRune) {
	__.RuneReturn.Put(p)
}

func (__ *PoolOfBoolThenRuneImpl) GetChReturnOfRune() chan *ReturnOfRune {
	return __.ChReturnOfRune.Get().(chan *ReturnOfRune)
}
func (__ *PoolOfBoolThenRuneImpl) PutChReturnOfRune(p chan *ReturnOfRune) {
	__.ChReturnOfRune.Put(p)
}

func NewPoolOfBoolThenRuneImpl() *PoolOfBoolThenRuneImpl {
	return &PoolOfBoolThenRuneImpl{
		BoolArg: sync.Pool{
			New: func() interface{} {
				return new(bool)
			},
		},
		BoolWork: sync.Pool{
			New: func() interface{} {
				return new(WorkOfBoolThenRune)
			},
		},
		RuneRtn: sync.Pool{
			New: func() interface{} {
				return new(rune)
			},
		},
		RuneReturn: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfRune)
			},
		},
		ChReturnOfRune: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfRune, 1)
			},
		},
	}
}

type ApiDecouplerOfBoolThenRune struct {
	pool PoolOfBoolThenRune
}

func NewApiDecouplerOfBoolThenRune() *ApiDecouplerOfBoolThenRune {
	return &ApiDecouplerOfBoolThenRune{
		pool: NewPoolOfBoolThenRuneImpl(),
	}
}

func (__ *ApiDecouplerOfBoolThenRune) ReturnError(rtn_ch chan<- *ReturnOfRune, err error) {
	rtn := __.pool.GetReturnOfRune()
	var other rune
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfBoolThenRune) HandleOfBoolThenRune(ctx context.Context, req *WorkOfBoolThenRune, h func(ctx context.Context, arg bool) (rune, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfRune()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfBoolThenRune) DoOfBoolThenRune(ctx context.Context, worker WorkerOfPushBoolThenRune, arg bool) (rune, error) {
	// ch := make(chan *ReturnOfRune, 1)
	ch := __.pool.GetChReturnOfRune()
	defer __.pool.PutChReturnOfRune(ch)

	req := __.pool.GetWorkOfBoolThenRune()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfBoolThenRune(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfRune(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfBoolThenRune = func(ctx context.Context, arg bool) (rune, error)

type WorkerOfBoolThenRune struct {
	api_syncer *ApiDecouplerOfBoolThenRune
	handler    WorkHandlerOfBoolThenRune

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfBoolThenRune
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfBoolThenRune(ctx context.Context, h WorkHandlerOfBoolThenRune, n int) *WorkerOfBoolThenRune {
	__ := &WorkerOfBoolThenRune{
		api_syncer: NewApiDecouplerOfBoolThenRune(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfBoolThenRune, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfBoolThenRune{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfBoolThenRune(req.Context, req.WorkOfBoolThenRune, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfBoolThenRune) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfBoolThenRune) Push(ctx context.Context, req *WorkOfBoolThenRune) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfBoolThenRune)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfBoolThenRune = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfBoolThenRune) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfBoolThenRune) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfBoolThenRune) Call(ctx context.Context, arg bool) (rune, error) {
	return __.api_syncer.DoOfBoolThenRune(ctx, __, arg)
}

type PoolOfBoolThenString interface {
	GetBoolArg() *bool
	PutBoolArg(*bool)
	GetStringReturn() *string
	PutStringReturn(*string)

	GetWorkOfBoolThenString() *WorkOfBoolThenString
	GetReturnOfString() *ReturnOfString
	PutWorkOfBoolThenString(*WorkOfBoolThenString)
	PutReturnOfString(*ReturnOfString)

	GetChReturnOfString() chan *ReturnOfString
	PutChReturnOfString(chan *ReturnOfString)
}

type PoolOfBoolThenStringImpl struct {
	BoolArg          sync.Pool
	StringRtn        sync.Pool
	BoolWork         sync.Pool
	StringReturn     sync.Pool
	ChReturnOfString sync.Pool
}

func (__ *PoolOfBoolThenStringImpl) GetBoolArg() *bool {
	return __.BoolArg.Get().(*bool)
}
func (__ *PoolOfBoolThenStringImpl) PutBoolArg(p *bool) {
	__.BoolArg.Put(p)
}
func (__ *PoolOfBoolThenStringImpl) GetStringReturn() *string {
	return __.StringRtn.Get().(*string)
}
func (__ *PoolOfBoolThenStringImpl) PutStringReturn(p *string) {
	__.StringRtn.Put(p)
}

func (__ *PoolOfBoolThenStringImpl) GetWorkOfBoolThenString() *WorkOfBoolThenString {
	return __.BoolWork.Get().(*WorkOfBoolThenString)
}
func (__ *PoolOfBoolThenStringImpl) PutWorkOfBoolThenString(p *WorkOfBoolThenString) {
	__.BoolWork.Put(p)
}
func (__ *PoolOfBoolThenStringImpl) GetReturnOfString() *ReturnOfString {
	return __.StringReturn.Get().(*ReturnOfString)
}
func (__ *PoolOfBoolThenStringImpl) PutReturnOfString(p *ReturnOfString) {
	__.StringReturn.Put(p)
}

func (__ *PoolOfBoolThenStringImpl) GetChReturnOfString() chan *ReturnOfString {
	return __.ChReturnOfString.Get().(chan *ReturnOfString)
}
func (__ *PoolOfBoolThenStringImpl) PutChReturnOfString(p chan *ReturnOfString) {
	__.ChReturnOfString.Put(p)
}

func NewPoolOfBoolThenStringImpl() *PoolOfBoolThenStringImpl {
	return &PoolOfBoolThenStringImpl{
		BoolArg: sync.Pool{
			New: func() interface{} {
				return new(bool)
			},
		},
		BoolWork: sync.Pool{
			New: func() interface{} {
				return new(WorkOfBoolThenString)
			},
		},
		StringRtn: sync.Pool{
			New: func() interface{} {
				return new(string)
			},
		},
		StringReturn: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfString)
			},
		},
		ChReturnOfString: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfString, 1)
			},
		},
	}
}

type ApiDecouplerOfBoolThenString struct {
	pool PoolOfBoolThenString
}

func NewApiDecouplerOfBoolThenString() *ApiDecouplerOfBoolThenString {
	return &ApiDecouplerOfBoolThenString{
		pool: NewPoolOfBoolThenStringImpl(),
	}
}

func (__ *ApiDecouplerOfBoolThenString) ReturnError(rtn_ch chan<- *ReturnOfString, err error) {
	rtn := __.pool.GetReturnOfString()
	var other string
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfBoolThenString) HandleOfBoolThenString(ctx context.Context, req *WorkOfBoolThenString, h func(ctx context.Context, arg bool) (string, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfString()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfBoolThenString) DoOfBoolThenString(ctx context.Context, worker WorkerOfPushBoolThenString, arg bool) (string, error) {
	// ch := make(chan *ReturnOfString, 1)
	ch := __.pool.GetChReturnOfString()
	defer __.pool.PutChReturnOfString(ch)

	req := __.pool.GetWorkOfBoolThenString()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfBoolThenString(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfString(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfBoolThenString = func(ctx context.Context, arg bool) (string, error)

type WorkerOfBoolThenString struct {
	api_syncer *ApiDecouplerOfBoolThenString
	handler    WorkHandlerOfBoolThenString

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfBoolThenString
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfBoolThenString(ctx context.Context, h WorkHandlerOfBoolThenString, n int) *WorkerOfBoolThenString {
	__ := &WorkerOfBoolThenString{
		api_syncer: NewApiDecouplerOfBoolThenString(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfBoolThenString, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfBoolThenString{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfBoolThenString(req.Context, req.WorkOfBoolThenString, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfBoolThenString) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfBoolThenString) Push(ctx context.Context, req *WorkOfBoolThenString) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfBoolThenString)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfBoolThenString = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfBoolThenString) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfBoolThenString) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfBoolThenString) Call(ctx context.Context, arg bool) (string, error) {
	return __.api_syncer.DoOfBoolThenString(ctx, __, arg)
}

type PoolOfBoolThenUint interface {
	GetBoolArg() *bool
	PutBoolArg(*bool)
	GetUintReturn() *uint
	PutUintReturn(*uint)

	GetWorkOfBoolThenUint() *WorkOfBoolThenUint
	GetReturnOfUint() *ReturnOfUint
	PutWorkOfBoolThenUint(*WorkOfBoolThenUint)
	PutReturnOfUint(*ReturnOfUint)

	GetChReturnOfUint() chan *ReturnOfUint
	PutChReturnOfUint(chan *ReturnOfUint)
}

type PoolOfBoolThenUintImpl struct {
	BoolArg        sync.Pool
	UintRtn        sync.Pool
	BoolWork       sync.Pool
	UintReturn     sync.Pool
	ChReturnOfUint sync.Pool
}

func (__ *PoolOfBoolThenUintImpl) GetBoolArg() *bool {
	return __.BoolArg.Get().(*bool)
}
func (__ *PoolOfBoolThenUintImpl) PutBoolArg(p *bool) {
	__.BoolArg.Put(p)
}
func (__ *PoolOfBoolThenUintImpl) GetUintReturn() *uint {
	return __.UintRtn.Get().(*uint)
}
func (__ *PoolOfBoolThenUintImpl) PutUintReturn(p *uint) {
	__.UintRtn.Put(p)
}

func (__ *PoolOfBoolThenUintImpl) GetWorkOfBoolThenUint() *WorkOfBoolThenUint {
	return __.BoolWork.Get().(*WorkOfBoolThenUint)
}
func (__ *PoolOfBoolThenUintImpl) PutWorkOfBoolThenUint(p *WorkOfBoolThenUint) {
	__.BoolWork.Put(p)
}
func (__ *PoolOfBoolThenUintImpl) GetReturnOfUint() *ReturnOfUint {
	return __.UintReturn.Get().(*ReturnOfUint)
}
func (__ *PoolOfBoolThenUintImpl) PutReturnOfUint(p *ReturnOfUint) {
	__.UintReturn.Put(p)
}

func (__ *PoolOfBoolThenUintImpl) GetChReturnOfUint() chan *ReturnOfUint {
	return __.ChReturnOfUint.Get().(chan *ReturnOfUint)
}
func (__ *PoolOfBoolThenUintImpl) PutChReturnOfUint(p chan *ReturnOfUint) {
	__.ChReturnOfUint.Put(p)
}

func NewPoolOfBoolThenUintImpl() *PoolOfBoolThenUintImpl {
	return &PoolOfBoolThenUintImpl{
		BoolArg: sync.Pool{
			New: func() interface{} {
				return new(bool)
			},
		},
		BoolWork: sync.Pool{
			New: func() interface{} {
				return new(WorkOfBoolThenUint)
			},
		},
		UintRtn: sync.Pool{
			New: func() interface{} {
				return new(uint)
			},
		},
		UintReturn: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfUint)
			},
		},
		ChReturnOfUint: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfUint, 1)
			},
		},
	}
}

type ApiDecouplerOfBoolThenUint struct {
	pool PoolOfBoolThenUint
}

func NewApiDecouplerOfBoolThenUint() *ApiDecouplerOfBoolThenUint {
	return &ApiDecouplerOfBoolThenUint{
		pool: NewPoolOfBoolThenUintImpl(),
	}
}

func (__ *ApiDecouplerOfBoolThenUint) ReturnError(rtn_ch chan<- *ReturnOfUint, err error) {
	rtn := __.pool.GetReturnOfUint()
	var other uint
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfBoolThenUint) HandleOfBoolThenUint(ctx context.Context, req *WorkOfBoolThenUint, h func(ctx context.Context, arg bool) (uint, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfUint()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfBoolThenUint) DoOfBoolThenUint(ctx context.Context, worker WorkerOfPushBoolThenUint, arg bool) (uint, error) {
	// ch := make(chan *ReturnOfUint, 1)
	ch := __.pool.GetChReturnOfUint()
	defer __.pool.PutChReturnOfUint(ch)

	req := __.pool.GetWorkOfBoolThenUint()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfBoolThenUint(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfUint(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfBoolThenUint = func(ctx context.Context, arg bool) (uint, error)

type WorkerOfBoolThenUint struct {
	api_syncer *ApiDecouplerOfBoolThenUint
	handler    WorkHandlerOfBoolThenUint

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfBoolThenUint
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfBoolThenUint(ctx context.Context, h WorkHandlerOfBoolThenUint, n int) *WorkerOfBoolThenUint {
	__ := &WorkerOfBoolThenUint{
		api_syncer: NewApiDecouplerOfBoolThenUint(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfBoolThenUint, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfBoolThenUint{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfBoolThenUint(req.Context, req.WorkOfBoolThenUint, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfBoolThenUint) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfBoolThenUint) Push(ctx context.Context, req *WorkOfBoolThenUint) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfBoolThenUint)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfBoolThenUint = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfBoolThenUint) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfBoolThenUint) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfBoolThenUint) Call(ctx context.Context, arg bool) (uint, error) {
	return __.api_syncer.DoOfBoolThenUint(ctx, __, arg)
}

type PoolOfBoolThenUint16 interface {
	GetBoolArg() *bool
	PutBoolArg(*bool)
	GetUint16Return() *uint16
	PutUint16Return(*uint16)

	GetWorkOfBoolThenUint16() *WorkOfBoolThenUint16
	GetReturnOfUint16() *ReturnOfUint16
	PutWorkOfBoolThenUint16(*WorkOfBoolThenUint16)
	PutReturnOfUint16(*ReturnOfUint16)

	GetChReturnOfUint16() chan *ReturnOfUint16
	PutChReturnOfUint16(chan *ReturnOfUint16)
}

type PoolOfBoolThenUint16Impl struct {
	BoolArg          sync.Pool
	Uint16Rtn        sync.Pool
	BoolWork         sync.Pool
	Uint16Return     sync.Pool
	ChReturnOfUint16 sync.Pool
}

func (__ *PoolOfBoolThenUint16Impl) GetBoolArg() *bool {
	return __.BoolArg.Get().(*bool)
}
func (__ *PoolOfBoolThenUint16Impl) PutBoolArg(p *bool) {
	__.BoolArg.Put(p)
}
func (__ *PoolOfBoolThenUint16Impl) GetUint16Return() *uint16 {
	return __.Uint16Rtn.Get().(*uint16)
}
func (__ *PoolOfBoolThenUint16Impl) PutUint16Return(p *uint16) {
	__.Uint16Rtn.Put(p)
}

func (__ *PoolOfBoolThenUint16Impl) GetWorkOfBoolThenUint16() *WorkOfBoolThenUint16 {
	return __.BoolWork.Get().(*WorkOfBoolThenUint16)
}
func (__ *PoolOfBoolThenUint16Impl) PutWorkOfBoolThenUint16(p *WorkOfBoolThenUint16) {
	__.BoolWork.Put(p)
}
func (__ *PoolOfBoolThenUint16Impl) GetReturnOfUint16() *ReturnOfUint16 {
	return __.Uint16Return.Get().(*ReturnOfUint16)
}
func (__ *PoolOfBoolThenUint16Impl) PutReturnOfUint16(p *ReturnOfUint16) {
	__.Uint16Return.Put(p)
}

func (__ *PoolOfBoolThenUint16Impl) GetChReturnOfUint16() chan *ReturnOfUint16 {
	return __.ChReturnOfUint16.Get().(chan *ReturnOfUint16)
}
func (__ *PoolOfBoolThenUint16Impl) PutChReturnOfUint16(p chan *ReturnOfUint16) {
	__.ChReturnOfUint16.Put(p)
}

func NewPoolOfBoolThenUint16Impl() *PoolOfBoolThenUint16Impl {
	return &PoolOfBoolThenUint16Impl{
		BoolArg: sync.Pool{
			New: func() interface{} {
				return new(bool)
			},
		},
		BoolWork: sync.Pool{
			New: func() interface{} {
				return new(WorkOfBoolThenUint16)
			},
		},
		Uint16Rtn: sync.Pool{
			New: func() interface{} {
				return new(uint16)
			},
		},
		Uint16Return: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfUint16)
			},
		},
		ChReturnOfUint16: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfUint16, 1)
			},
		},
	}
}

type ApiDecouplerOfBoolThenUint16 struct {
	pool PoolOfBoolThenUint16
}

func NewApiDecouplerOfBoolThenUint16() *ApiDecouplerOfBoolThenUint16 {
	return &ApiDecouplerOfBoolThenUint16{
		pool: NewPoolOfBoolThenUint16Impl(),
	}
}

func (__ *ApiDecouplerOfBoolThenUint16) ReturnError(rtn_ch chan<- *ReturnOfUint16, err error) {
	rtn := __.pool.GetReturnOfUint16()
	var other uint16
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfBoolThenUint16) HandleOfBoolThenUint16(ctx context.Context, req *WorkOfBoolThenUint16, h func(ctx context.Context, arg bool) (uint16, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfUint16()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfBoolThenUint16) DoOfBoolThenUint16(ctx context.Context, worker WorkerOfPushBoolThenUint16, arg bool) (uint16, error) {
	// ch := make(chan *ReturnOfUint16, 1)
	ch := __.pool.GetChReturnOfUint16()
	defer __.pool.PutChReturnOfUint16(ch)

	req := __.pool.GetWorkOfBoolThenUint16()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfBoolThenUint16(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfUint16(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfBoolThenUint16 = func(ctx context.Context, arg bool) (uint16, error)

type WorkerOfBoolThenUint16 struct {
	api_syncer *ApiDecouplerOfBoolThenUint16
	handler    WorkHandlerOfBoolThenUint16

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfBoolThenUint16
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfBoolThenUint16(ctx context.Context, h WorkHandlerOfBoolThenUint16, n int) *WorkerOfBoolThenUint16 {
	__ := &WorkerOfBoolThenUint16{
		api_syncer: NewApiDecouplerOfBoolThenUint16(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfBoolThenUint16, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfBoolThenUint16{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfBoolThenUint16(req.Context, req.WorkOfBoolThenUint16, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfBoolThenUint16) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfBoolThenUint16) Push(ctx context.Context, req *WorkOfBoolThenUint16) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfBoolThenUint16)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfBoolThenUint16 = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfBoolThenUint16) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfBoolThenUint16) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfBoolThenUint16) Call(ctx context.Context, arg bool) (uint16, error) {
	return __.api_syncer.DoOfBoolThenUint16(ctx, __, arg)
}

type PoolOfBoolThenUint32 interface {
	GetBoolArg() *bool
	PutBoolArg(*bool)
	GetUint32Return() *uint32
	PutUint32Return(*uint32)

	GetWorkOfBoolThenUint32() *WorkOfBoolThenUint32
	GetReturnOfUint32() *ReturnOfUint32
	PutWorkOfBoolThenUint32(*WorkOfBoolThenUint32)
	PutReturnOfUint32(*ReturnOfUint32)

	GetChReturnOfUint32() chan *ReturnOfUint32
	PutChReturnOfUint32(chan *ReturnOfUint32)
}

type PoolOfBoolThenUint32Impl struct {
	BoolArg          sync.Pool
	Uint32Rtn        sync.Pool
	BoolWork         sync.Pool
	Uint32Return     sync.Pool
	ChReturnOfUint32 sync.Pool
}

func (__ *PoolOfBoolThenUint32Impl) GetBoolArg() *bool {
	return __.BoolArg.Get().(*bool)
}
func (__ *PoolOfBoolThenUint32Impl) PutBoolArg(p *bool) {
	__.BoolArg.Put(p)
}
func (__ *PoolOfBoolThenUint32Impl) GetUint32Return() *uint32 {
	return __.Uint32Rtn.Get().(*uint32)
}
func (__ *PoolOfBoolThenUint32Impl) PutUint32Return(p *uint32) {
	__.Uint32Rtn.Put(p)
}

func (__ *PoolOfBoolThenUint32Impl) GetWorkOfBoolThenUint32() *WorkOfBoolThenUint32 {
	return __.BoolWork.Get().(*WorkOfBoolThenUint32)
}
func (__ *PoolOfBoolThenUint32Impl) PutWorkOfBoolThenUint32(p *WorkOfBoolThenUint32) {
	__.BoolWork.Put(p)
}
func (__ *PoolOfBoolThenUint32Impl) GetReturnOfUint32() *ReturnOfUint32 {
	return __.Uint32Return.Get().(*ReturnOfUint32)
}
func (__ *PoolOfBoolThenUint32Impl) PutReturnOfUint32(p *ReturnOfUint32) {
	__.Uint32Return.Put(p)
}

func (__ *PoolOfBoolThenUint32Impl) GetChReturnOfUint32() chan *ReturnOfUint32 {
	return __.ChReturnOfUint32.Get().(chan *ReturnOfUint32)
}
func (__ *PoolOfBoolThenUint32Impl) PutChReturnOfUint32(p chan *ReturnOfUint32) {
	__.ChReturnOfUint32.Put(p)
}

func NewPoolOfBoolThenUint32Impl() *PoolOfBoolThenUint32Impl {
	return &PoolOfBoolThenUint32Impl{
		BoolArg: sync.Pool{
			New: func() interface{} {
				return new(bool)
			},
		},
		BoolWork: sync.Pool{
			New: func() interface{} {
				return new(WorkOfBoolThenUint32)
			},
		},
		Uint32Rtn: sync.Pool{
			New: func() interface{} {
				return new(uint32)
			},
		},
		Uint32Return: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfUint32)
			},
		},
		ChReturnOfUint32: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfUint32, 1)
			},
		},
	}
}

type ApiDecouplerOfBoolThenUint32 struct {
	pool PoolOfBoolThenUint32
}

func NewApiDecouplerOfBoolThenUint32() *ApiDecouplerOfBoolThenUint32 {
	return &ApiDecouplerOfBoolThenUint32{
		pool: NewPoolOfBoolThenUint32Impl(),
	}
}

func (__ *ApiDecouplerOfBoolThenUint32) ReturnError(rtn_ch chan<- *ReturnOfUint32, err error) {
	rtn := __.pool.GetReturnOfUint32()
	var other uint32
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfBoolThenUint32) HandleOfBoolThenUint32(ctx context.Context, req *WorkOfBoolThenUint32, h func(ctx context.Context, arg bool) (uint32, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfUint32()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfBoolThenUint32) DoOfBoolThenUint32(ctx context.Context, worker WorkerOfPushBoolThenUint32, arg bool) (uint32, error) {
	// ch := make(chan *ReturnOfUint32, 1)
	ch := __.pool.GetChReturnOfUint32()
	defer __.pool.PutChReturnOfUint32(ch)

	req := __.pool.GetWorkOfBoolThenUint32()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfBoolThenUint32(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfUint32(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfBoolThenUint32 = func(ctx context.Context, arg bool) (uint32, error)

type WorkerOfBoolThenUint32 struct {
	api_syncer *ApiDecouplerOfBoolThenUint32
	handler    WorkHandlerOfBoolThenUint32

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfBoolThenUint32
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfBoolThenUint32(ctx context.Context, h WorkHandlerOfBoolThenUint32, n int) *WorkerOfBoolThenUint32 {
	__ := &WorkerOfBoolThenUint32{
		api_syncer: NewApiDecouplerOfBoolThenUint32(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfBoolThenUint32, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfBoolThenUint32{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfBoolThenUint32(req.Context, req.WorkOfBoolThenUint32, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfBoolThenUint32) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfBoolThenUint32) Push(ctx context.Context, req *WorkOfBoolThenUint32) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfBoolThenUint32)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfBoolThenUint32 = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfBoolThenUint32) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfBoolThenUint32) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfBoolThenUint32) Call(ctx context.Context, arg bool) (uint32, error) {
	return __.api_syncer.DoOfBoolThenUint32(ctx, __, arg)
}

type PoolOfBoolThenUint64 interface {
	GetBoolArg() *bool
	PutBoolArg(*bool)
	GetUint64Return() *uint64
	PutUint64Return(*uint64)

	GetWorkOfBoolThenUint64() *WorkOfBoolThenUint64
	GetReturnOfUint64() *ReturnOfUint64
	PutWorkOfBoolThenUint64(*WorkOfBoolThenUint64)
	PutReturnOfUint64(*ReturnOfUint64)

	GetChReturnOfUint64() chan *ReturnOfUint64
	PutChReturnOfUint64(chan *ReturnOfUint64)
}

type PoolOfBoolThenUint64Impl struct {
	BoolArg          sync.Pool
	Uint64Rtn        sync.Pool
	BoolWork         sync.Pool
	Uint64Return     sync.Pool
	ChReturnOfUint64 sync.Pool
}

func (__ *PoolOfBoolThenUint64Impl) GetBoolArg() *bool {
	return __.BoolArg.Get().(*bool)
}
func (__ *PoolOfBoolThenUint64Impl) PutBoolArg(p *bool) {
	__.BoolArg.Put(p)
}
func (__ *PoolOfBoolThenUint64Impl) GetUint64Return() *uint64 {
	return __.Uint64Rtn.Get().(*uint64)
}
func (__ *PoolOfBoolThenUint64Impl) PutUint64Return(p *uint64) {
	__.Uint64Rtn.Put(p)
}

func (__ *PoolOfBoolThenUint64Impl) GetWorkOfBoolThenUint64() *WorkOfBoolThenUint64 {
	return __.BoolWork.Get().(*WorkOfBoolThenUint64)
}
func (__ *PoolOfBoolThenUint64Impl) PutWorkOfBoolThenUint64(p *WorkOfBoolThenUint64) {
	__.BoolWork.Put(p)
}
func (__ *PoolOfBoolThenUint64Impl) GetReturnOfUint64() *ReturnOfUint64 {
	return __.Uint64Return.Get().(*ReturnOfUint64)
}
func (__ *PoolOfBoolThenUint64Impl) PutReturnOfUint64(p *ReturnOfUint64) {
	__.Uint64Return.Put(p)
}

func (__ *PoolOfBoolThenUint64Impl) GetChReturnOfUint64() chan *ReturnOfUint64 {
	return __.ChReturnOfUint64.Get().(chan *ReturnOfUint64)
}
func (__ *PoolOfBoolThenUint64Impl) PutChReturnOfUint64(p chan *ReturnOfUint64) {
	__.ChReturnOfUint64.Put(p)
}

func NewPoolOfBoolThenUint64Impl() *PoolOfBoolThenUint64Impl {
	return &PoolOfBoolThenUint64Impl{
		BoolArg: sync.Pool{
			New: func() interface{} {
				return new(bool)
			},
		},
		BoolWork: sync.Pool{
			New: func() interface{} {
				return new(WorkOfBoolThenUint64)
			},
		},
		Uint64Rtn: sync.Pool{
			New: func() interface{} {
				return new(uint64)
			},
		},
		Uint64Return: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfUint64)
			},
		},
		ChReturnOfUint64: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfUint64, 1)
			},
		},
	}
}

type ApiDecouplerOfBoolThenUint64 struct {
	pool PoolOfBoolThenUint64
}

func NewApiDecouplerOfBoolThenUint64() *ApiDecouplerOfBoolThenUint64 {
	return &ApiDecouplerOfBoolThenUint64{
		pool: NewPoolOfBoolThenUint64Impl(),
	}
}

func (__ *ApiDecouplerOfBoolThenUint64) ReturnError(rtn_ch chan<- *ReturnOfUint64, err error) {
	rtn := __.pool.GetReturnOfUint64()
	var other uint64
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfBoolThenUint64) HandleOfBoolThenUint64(ctx context.Context, req *WorkOfBoolThenUint64, h func(ctx context.Context, arg bool) (uint64, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfUint64()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfBoolThenUint64) DoOfBoolThenUint64(ctx context.Context, worker WorkerOfPushBoolThenUint64, arg bool) (uint64, error) {
	// ch := make(chan *ReturnOfUint64, 1)
	ch := __.pool.GetChReturnOfUint64()
	defer __.pool.PutChReturnOfUint64(ch)

	req := __.pool.GetWorkOfBoolThenUint64()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfBoolThenUint64(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfUint64(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfBoolThenUint64 = func(ctx context.Context, arg bool) (uint64, error)

type WorkerOfBoolThenUint64 struct {
	api_syncer *ApiDecouplerOfBoolThenUint64
	handler    WorkHandlerOfBoolThenUint64

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfBoolThenUint64
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfBoolThenUint64(ctx context.Context, h WorkHandlerOfBoolThenUint64, n int) *WorkerOfBoolThenUint64 {
	__ := &WorkerOfBoolThenUint64{
		api_syncer: NewApiDecouplerOfBoolThenUint64(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfBoolThenUint64, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfBoolThenUint64{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfBoolThenUint64(req.Context, req.WorkOfBoolThenUint64, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfBoolThenUint64) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfBoolThenUint64) Push(ctx context.Context, req *WorkOfBoolThenUint64) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfBoolThenUint64)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfBoolThenUint64 = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfBoolThenUint64) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfBoolThenUint64) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfBoolThenUint64) Call(ctx context.Context, arg bool) (uint64, error) {
	return __.api_syncer.DoOfBoolThenUint64(ctx, __, arg)
}

type PoolOfBoolThenUint8 interface {
	GetBoolArg() *bool
	PutBoolArg(*bool)
	GetUint8Return() *uint8
	PutUint8Return(*uint8)

	GetWorkOfBoolThenUint8() *WorkOfBoolThenUint8
	GetReturnOfUint8() *ReturnOfUint8
	PutWorkOfBoolThenUint8(*WorkOfBoolThenUint8)
	PutReturnOfUint8(*ReturnOfUint8)

	GetChReturnOfUint8() chan *ReturnOfUint8
	PutChReturnOfUint8(chan *ReturnOfUint8)
}

type PoolOfBoolThenUint8Impl struct {
	BoolArg         sync.Pool
	Uint8Rtn        sync.Pool
	BoolWork        sync.Pool
	Uint8Return     sync.Pool
	ChReturnOfUint8 sync.Pool
}

func (__ *PoolOfBoolThenUint8Impl) GetBoolArg() *bool {
	return __.BoolArg.Get().(*bool)
}
func (__ *PoolOfBoolThenUint8Impl) PutBoolArg(p *bool) {
	__.BoolArg.Put(p)
}
func (__ *PoolOfBoolThenUint8Impl) GetUint8Return() *uint8 {
	return __.Uint8Rtn.Get().(*uint8)
}
func (__ *PoolOfBoolThenUint8Impl) PutUint8Return(p *uint8) {
	__.Uint8Rtn.Put(p)
}

func (__ *PoolOfBoolThenUint8Impl) GetWorkOfBoolThenUint8() *WorkOfBoolThenUint8 {
	return __.BoolWork.Get().(*WorkOfBoolThenUint8)
}
func (__ *PoolOfBoolThenUint8Impl) PutWorkOfBoolThenUint8(p *WorkOfBoolThenUint8) {
	__.BoolWork.Put(p)
}
func (__ *PoolOfBoolThenUint8Impl) GetReturnOfUint8() *ReturnOfUint8 {
	return __.Uint8Return.Get().(*ReturnOfUint8)
}
func (__ *PoolOfBoolThenUint8Impl) PutReturnOfUint8(p *ReturnOfUint8) {
	__.Uint8Return.Put(p)
}

func (__ *PoolOfBoolThenUint8Impl) GetChReturnOfUint8() chan *ReturnOfUint8 {
	return __.ChReturnOfUint8.Get().(chan *ReturnOfUint8)
}
func (__ *PoolOfBoolThenUint8Impl) PutChReturnOfUint8(p chan *ReturnOfUint8) {
	__.ChReturnOfUint8.Put(p)
}

func NewPoolOfBoolThenUint8Impl() *PoolOfBoolThenUint8Impl {
	return &PoolOfBoolThenUint8Impl{
		BoolArg: sync.Pool{
			New: func() interface{} {
				return new(bool)
			},
		},
		BoolWork: sync.Pool{
			New: func() interface{} {
				return new(WorkOfBoolThenUint8)
			},
		},
		Uint8Rtn: sync.Pool{
			New: func() interface{} {
				return new(uint8)
			},
		},
		Uint8Return: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfUint8)
			},
		},
		ChReturnOfUint8: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfUint8, 1)
			},
		},
	}
}

type ApiDecouplerOfBoolThenUint8 struct {
	pool PoolOfBoolThenUint8
}

func NewApiDecouplerOfBoolThenUint8() *ApiDecouplerOfBoolThenUint8 {
	return &ApiDecouplerOfBoolThenUint8{
		pool: NewPoolOfBoolThenUint8Impl(),
	}
}

func (__ *ApiDecouplerOfBoolThenUint8) ReturnError(rtn_ch chan<- *ReturnOfUint8, err error) {
	rtn := __.pool.GetReturnOfUint8()
	var other uint8
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfBoolThenUint8) HandleOfBoolThenUint8(ctx context.Context, req *WorkOfBoolThenUint8, h func(ctx context.Context, arg bool) (uint8, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfUint8()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfBoolThenUint8) DoOfBoolThenUint8(ctx context.Context, worker WorkerOfPushBoolThenUint8, arg bool) (uint8, error) {
	// ch := make(chan *ReturnOfUint8, 1)
	ch := __.pool.GetChReturnOfUint8()
	defer __.pool.PutChReturnOfUint8(ch)

	req := __.pool.GetWorkOfBoolThenUint8()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfBoolThenUint8(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfUint8(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfBoolThenUint8 = func(ctx context.Context, arg bool) (uint8, error)

type WorkerOfBoolThenUint8 struct {
	api_syncer *ApiDecouplerOfBoolThenUint8
	handler    WorkHandlerOfBoolThenUint8

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfBoolThenUint8
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfBoolThenUint8(ctx context.Context, h WorkHandlerOfBoolThenUint8, n int) *WorkerOfBoolThenUint8 {
	__ := &WorkerOfBoolThenUint8{
		api_syncer: NewApiDecouplerOfBoolThenUint8(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfBoolThenUint8, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfBoolThenUint8{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfBoolThenUint8(req.Context, req.WorkOfBoolThenUint8, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfBoolThenUint8) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfBoolThenUint8) Push(ctx context.Context, req *WorkOfBoolThenUint8) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfBoolThenUint8)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfBoolThenUint8 = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfBoolThenUint8) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfBoolThenUint8) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfBoolThenUint8) Call(ctx context.Context, arg bool) (uint8, error) {
	return __.api_syncer.DoOfBoolThenUint8(ctx, __, arg)
}

type PoolOfBoolThenUintptr interface {
	GetBoolArg() *bool
	PutBoolArg(*bool)
	GetUintptrReturn() *uintptr
	PutUintptrReturn(*uintptr)

	GetWorkOfBoolThenUintptr() *WorkOfBoolThenUintptr
	GetReturnOfUintptr() *ReturnOfUintptr
	PutWorkOfBoolThenUintptr(*WorkOfBoolThenUintptr)
	PutReturnOfUintptr(*ReturnOfUintptr)

	GetChReturnOfUintptr() chan *ReturnOfUintptr
	PutChReturnOfUintptr(chan *ReturnOfUintptr)
}

type PoolOfBoolThenUintptrImpl struct {
	BoolArg           sync.Pool
	UintptrRtn        sync.Pool
	BoolWork          sync.Pool
	UintptrReturn     sync.Pool
	ChReturnOfUintptr sync.Pool
}

func (__ *PoolOfBoolThenUintptrImpl) GetBoolArg() *bool {
	return __.BoolArg.Get().(*bool)
}
func (__ *PoolOfBoolThenUintptrImpl) PutBoolArg(p *bool) {
	__.BoolArg.Put(p)
}
func (__ *PoolOfBoolThenUintptrImpl) GetUintptrReturn() *uintptr {
	return __.UintptrRtn.Get().(*uintptr)
}
func (__ *PoolOfBoolThenUintptrImpl) PutUintptrReturn(p *uintptr) {
	__.UintptrRtn.Put(p)
}

func (__ *PoolOfBoolThenUintptrImpl) GetWorkOfBoolThenUintptr() *WorkOfBoolThenUintptr {
	return __.BoolWork.Get().(*WorkOfBoolThenUintptr)
}
func (__ *PoolOfBoolThenUintptrImpl) PutWorkOfBoolThenUintptr(p *WorkOfBoolThenUintptr) {
	__.BoolWork.Put(p)
}
func (__ *PoolOfBoolThenUintptrImpl) GetReturnOfUintptr() *ReturnOfUintptr {
	return __.UintptrReturn.Get().(*ReturnOfUintptr)
}
func (__ *PoolOfBoolThenUintptrImpl) PutReturnOfUintptr(p *ReturnOfUintptr) {
	__.UintptrReturn.Put(p)
}

func (__ *PoolOfBoolThenUintptrImpl) GetChReturnOfUintptr() chan *ReturnOfUintptr {
	return __.ChReturnOfUintptr.Get().(chan *ReturnOfUintptr)
}
func (__ *PoolOfBoolThenUintptrImpl) PutChReturnOfUintptr(p chan *ReturnOfUintptr) {
	__.ChReturnOfUintptr.Put(p)
}

func NewPoolOfBoolThenUintptrImpl() *PoolOfBoolThenUintptrImpl {
	return &PoolOfBoolThenUintptrImpl{
		BoolArg: sync.Pool{
			New: func() interface{} {
				return new(bool)
			},
		},
		BoolWork: sync.Pool{
			New: func() interface{} {
				return new(WorkOfBoolThenUintptr)
			},
		},
		UintptrRtn: sync.Pool{
			New: func() interface{} {
				return new(uintptr)
			},
		},
		UintptrReturn: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfUintptr)
			},
		},
		ChReturnOfUintptr: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfUintptr, 1)
			},
		},
	}
}

type ApiDecouplerOfBoolThenUintptr struct {
	pool PoolOfBoolThenUintptr
}

func NewApiDecouplerOfBoolThenUintptr() *ApiDecouplerOfBoolThenUintptr {
	return &ApiDecouplerOfBoolThenUintptr{
		pool: NewPoolOfBoolThenUintptrImpl(),
	}
}

func (__ *ApiDecouplerOfBoolThenUintptr) ReturnError(rtn_ch chan<- *ReturnOfUintptr, err error) {
	rtn := __.pool.GetReturnOfUintptr()
	var other uintptr
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfBoolThenUintptr) HandleOfBoolThenUintptr(ctx context.Context, req *WorkOfBoolThenUintptr, h func(ctx context.Context, arg bool) (uintptr, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfUintptr()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfBoolThenUintptr) DoOfBoolThenUintptr(ctx context.Context, worker WorkerOfPushBoolThenUintptr, arg bool) (uintptr, error) {
	// ch := make(chan *ReturnOfUintptr, 1)
	ch := __.pool.GetChReturnOfUintptr()
	defer __.pool.PutChReturnOfUintptr(ch)

	req := __.pool.GetWorkOfBoolThenUintptr()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfBoolThenUintptr(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfUintptr(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfBoolThenUintptr = func(ctx context.Context, arg bool) (uintptr, error)

type WorkerOfBoolThenUintptr struct {
	api_syncer *ApiDecouplerOfBoolThenUintptr
	handler    WorkHandlerOfBoolThenUintptr

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfBoolThenUintptr
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfBoolThenUintptr(ctx context.Context, h WorkHandlerOfBoolThenUintptr, n int) *WorkerOfBoolThenUintptr {
	__ := &WorkerOfBoolThenUintptr{
		api_syncer: NewApiDecouplerOfBoolThenUintptr(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfBoolThenUintptr, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfBoolThenUintptr{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfBoolThenUintptr(req.Context, req.WorkOfBoolThenUintptr, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfBoolThenUintptr) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfBoolThenUintptr) Push(ctx context.Context, req *WorkOfBoolThenUintptr) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfBoolThenUintptr)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfBoolThenUintptr = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfBoolThenUintptr) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfBoolThenUintptr) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfBoolThenUintptr) Call(ctx context.Context, arg bool) (uintptr, error) {
	return __.api_syncer.DoOfBoolThenUintptr(ctx, __, arg)
}

type PoolOfBoolThenInterface interface {
	GetBoolArg() *bool
	PutBoolArg(*bool)
	GetInterfaceReturn() *interface{}
	PutInterfaceReturn(*interface{})

	GetWorkOfBoolThenInterface() *WorkOfBoolThenInterface
	GetReturnOfInterface() *ReturnOfInterface
	PutWorkOfBoolThenInterface(*WorkOfBoolThenInterface)
	PutReturnOfInterface(*ReturnOfInterface)

	GetChReturnOfInterface() chan *ReturnOfInterface
	PutChReturnOfInterface(chan *ReturnOfInterface)
}

type PoolOfBoolThenInterfaceImpl struct {
	BoolArg             sync.Pool
	InterfaceRtn        sync.Pool
	BoolWork            sync.Pool
	InterfaceReturn     sync.Pool
	ChReturnOfInterface sync.Pool
}

func (__ *PoolOfBoolThenInterfaceImpl) GetBoolArg() *bool {
	return __.BoolArg.Get().(*bool)
}
func (__ *PoolOfBoolThenInterfaceImpl) PutBoolArg(p *bool) {
	__.BoolArg.Put(p)
}
func (__ *PoolOfBoolThenInterfaceImpl) GetInterfaceReturn() *interface{} {
	return __.InterfaceRtn.Get().(*interface{})
}
func (__ *PoolOfBoolThenInterfaceImpl) PutInterfaceReturn(p *interface{}) {
	__.InterfaceRtn.Put(p)
}

func (__ *PoolOfBoolThenInterfaceImpl) GetWorkOfBoolThenInterface() *WorkOfBoolThenInterface {
	return __.BoolWork.Get().(*WorkOfBoolThenInterface)
}
func (__ *PoolOfBoolThenInterfaceImpl) PutWorkOfBoolThenInterface(p *WorkOfBoolThenInterface) {
	__.BoolWork.Put(p)
}
func (__ *PoolOfBoolThenInterfaceImpl) GetReturnOfInterface() *ReturnOfInterface {
	return __.InterfaceReturn.Get().(*ReturnOfInterface)
}
func (__ *PoolOfBoolThenInterfaceImpl) PutReturnOfInterface(p *ReturnOfInterface) {
	__.InterfaceReturn.Put(p)
}

func (__ *PoolOfBoolThenInterfaceImpl) GetChReturnOfInterface() chan *ReturnOfInterface {
	return __.ChReturnOfInterface.Get().(chan *ReturnOfInterface)
}
func (__ *PoolOfBoolThenInterfaceImpl) PutChReturnOfInterface(p chan *ReturnOfInterface) {
	__.ChReturnOfInterface.Put(p)
}

func NewPoolOfBoolThenInterfaceImpl() *PoolOfBoolThenInterfaceImpl {
	return &PoolOfBoolThenInterfaceImpl{
		BoolArg: sync.Pool{
			New: func() interface{} {
				return new(bool)
			},
		},
		BoolWork: sync.Pool{
			New: func() interface{} {
				return new(WorkOfBoolThenInterface)
			},
		},
		InterfaceRtn: sync.Pool{
			New: func() interface{} {
				return new(interface{})
			},
		},
		InterfaceReturn: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfInterface)
			},
		},
		ChReturnOfInterface: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfInterface, 1)
			},
		},
	}
}

type ApiDecouplerOfBoolThenInterface struct {
	pool PoolOfBoolThenInterface
}

func NewApiDecouplerOfBoolThenInterface() *ApiDecouplerOfBoolThenInterface {
	return &ApiDecouplerOfBoolThenInterface{
		pool: NewPoolOfBoolThenInterfaceImpl(),
	}
}

func (__ *ApiDecouplerOfBoolThenInterface) ReturnError(rtn_ch chan<- *ReturnOfInterface, err error) {
	rtn := __.pool.GetReturnOfInterface()
	var other interface{}
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfBoolThenInterface) HandleOfBoolThenInterface(ctx context.Context, req *WorkOfBoolThenInterface, h func(ctx context.Context, arg bool) (interface{}, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfInterface()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfBoolThenInterface) DoOfBoolThenInterface(ctx context.Context, worker WorkerOfPushBoolThenInterface, arg bool) (interface{}, error) {
	// ch := make(chan *ReturnOfInterface, 1)
	ch := __.pool.GetChReturnOfInterface()
	defer __.pool.PutChReturnOfInterface(ch)

	req := __.pool.GetWorkOfBoolThenInterface()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfBoolThenInterface(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfInterface(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfBoolThenInterface = func(ctx context.Context, arg bool) (interface{}, error)

type WorkerOfBoolThenInterface struct {
	api_syncer *ApiDecouplerOfBoolThenInterface
	handler    WorkHandlerOfBoolThenInterface

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfBoolThenInterface
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfBoolThenInterface(ctx context.Context, h WorkHandlerOfBoolThenInterface, n int) *WorkerOfBoolThenInterface {
	__ := &WorkerOfBoolThenInterface{
		api_syncer: NewApiDecouplerOfBoolThenInterface(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfBoolThenInterface, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfBoolThenInterface{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfBoolThenInterface(req.Context, req.WorkOfBoolThenInterface, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfBoolThenInterface) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfBoolThenInterface) Push(ctx context.Context, req *WorkOfBoolThenInterface) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfBoolThenInterface)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfBoolThenInterface = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfBoolThenInterface) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfBoolThenInterface) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfBoolThenInterface) Call(ctx context.Context, arg bool) (interface{}, error) {
	return __.api_syncer.DoOfBoolThenInterface(ctx, __, arg)
}

type PoolOfBoolThenStruct interface {
	GetBoolArg() *bool
	PutBoolArg(*bool)
	GetStructReturn() *struct{}
	PutStructReturn(*struct{})

	GetWorkOfBoolThenStruct() *WorkOfBoolThenStruct
	GetReturnOfStruct() *ReturnOfStruct
	PutWorkOfBoolThenStruct(*WorkOfBoolThenStruct)
	PutReturnOfStruct(*ReturnOfStruct)

	GetChReturnOfStruct() chan *ReturnOfStruct
	PutChReturnOfStruct(chan *ReturnOfStruct)
}

type PoolOfBoolThenStructImpl struct {
	BoolArg          sync.Pool
	StructRtn        sync.Pool
	BoolWork         sync.Pool
	StructReturn     sync.Pool
	ChReturnOfStruct sync.Pool
}

func (__ *PoolOfBoolThenStructImpl) GetBoolArg() *bool {
	return __.BoolArg.Get().(*bool)
}
func (__ *PoolOfBoolThenStructImpl) PutBoolArg(p *bool) {
	__.BoolArg.Put(p)
}
func (__ *PoolOfBoolThenStructImpl) GetStructReturn() *struct{} {
	return __.StructRtn.Get().(*struct{})
}
func (__ *PoolOfBoolThenStructImpl) PutStructReturn(p *struct{}) {
	__.StructRtn.Put(p)
}

func (__ *PoolOfBoolThenStructImpl) GetWorkOfBoolThenStruct() *WorkOfBoolThenStruct {
	return __.BoolWork.Get().(*WorkOfBoolThenStruct)
}
func (__ *PoolOfBoolThenStructImpl) PutWorkOfBoolThenStruct(p *WorkOfBoolThenStruct) {
	__.BoolWork.Put(p)
}
func (__ *PoolOfBoolThenStructImpl) GetReturnOfStruct() *ReturnOfStruct {
	return __.StructReturn.Get().(*ReturnOfStruct)
}
func (__ *PoolOfBoolThenStructImpl) PutReturnOfStruct(p *ReturnOfStruct) {
	__.StructReturn.Put(p)
}

func (__ *PoolOfBoolThenStructImpl) GetChReturnOfStruct() chan *ReturnOfStruct {
	return __.ChReturnOfStruct.Get().(chan *ReturnOfStruct)
}
func (__ *PoolOfBoolThenStructImpl) PutChReturnOfStruct(p chan *ReturnOfStruct) {
	__.ChReturnOfStruct.Put(p)
}

func NewPoolOfBoolThenStructImpl() *PoolOfBoolThenStructImpl {
	return &PoolOfBoolThenStructImpl{
		BoolArg: sync.Pool{
			New: func() interface{} {
				return new(bool)
			},
		},
		BoolWork: sync.Pool{
			New: func() interface{} {
				return new(WorkOfBoolThenStruct)
			},
		},
		StructRtn: sync.Pool{
			New: func() interface{} {
				return new(struct{})
			},
		},
		StructReturn: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfStruct)
			},
		},
		ChReturnOfStruct: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfStruct, 1)
			},
		},
	}
}

type ApiDecouplerOfBoolThenStruct struct {
	pool PoolOfBoolThenStruct
}

func NewApiDecouplerOfBoolThenStruct() *ApiDecouplerOfBoolThenStruct {
	return &ApiDecouplerOfBoolThenStruct{
		pool: NewPoolOfBoolThenStructImpl(),
	}
}

func (__ *ApiDecouplerOfBoolThenStruct) ReturnError(rtn_ch chan<- *ReturnOfStruct, err error) {
	rtn := __.pool.GetReturnOfStruct()
	var other struct{}
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfBoolThenStruct) HandleOfBoolThenStruct(ctx context.Context, req *WorkOfBoolThenStruct, h func(ctx context.Context, arg bool) (struct{}, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfStruct()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfBoolThenStruct) DoOfBoolThenStruct(ctx context.Context, worker WorkerOfPushBoolThenStruct, arg bool) (struct{}, error) {
	// ch := make(chan *ReturnOfStruct, 1)
	ch := __.pool.GetChReturnOfStruct()
	defer __.pool.PutChReturnOfStruct(ch)

	req := __.pool.GetWorkOfBoolThenStruct()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfBoolThenStruct(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfStruct(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfBoolThenStruct = func(ctx context.Context, arg bool) (struct{}, error)

type WorkerOfBoolThenStruct struct {
	api_syncer *ApiDecouplerOfBoolThenStruct
	handler    WorkHandlerOfBoolThenStruct

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfBoolThenStruct
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfBoolThenStruct(ctx context.Context, h WorkHandlerOfBoolThenStruct, n int) *WorkerOfBoolThenStruct {
	__ := &WorkerOfBoolThenStruct{
		api_syncer: NewApiDecouplerOfBoolThenStruct(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfBoolThenStruct, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfBoolThenStruct{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfBoolThenStruct(req.Context, req.WorkOfBoolThenStruct, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfBoolThenStruct) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfBoolThenStruct) Push(ctx context.Context, req *WorkOfBoolThenStruct) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfBoolThenStruct)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfBoolThenStruct = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfBoolThenStruct) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfBoolThenStruct) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfBoolThenStruct) Call(ctx context.Context, arg bool) (struct{}, error) {
	return __.api_syncer.DoOfBoolThenStruct(ctx, __, arg)
}

type PoolOfByteThenBool interface {
	GetByteArg() *byte
	PutByteArg(*byte)
	GetBoolReturn() *bool
	PutBoolReturn(*bool)

	GetWorkOfByteThenBool() *WorkOfByteThenBool
	GetReturnOfBool() *ReturnOfBool
	PutWorkOfByteThenBool(*WorkOfByteThenBool)
	PutReturnOfBool(*ReturnOfBool)

	GetChReturnOfBool() chan *ReturnOfBool
	PutChReturnOfBool(chan *ReturnOfBool)
}

type PoolOfByteThenBoolImpl struct {
	ByteArg        sync.Pool
	BoolRtn        sync.Pool
	ByteWork       sync.Pool
	BoolReturn     sync.Pool
	ChReturnOfBool sync.Pool
}

func (__ *PoolOfByteThenBoolImpl) GetByteArg() *byte {
	return __.ByteArg.Get().(*byte)
}
func (__ *PoolOfByteThenBoolImpl) PutByteArg(p *byte) {
	__.ByteArg.Put(p)
}
func (__ *PoolOfByteThenBoolImpl) GetBoolReturn() *bool {
	return __.BoolRtn.Get().(*bool)
}
func (__ *PoolOfByteThenBoolImpl) PutBoolReturn(p *bool) {
	__.BoolRtn.Put(p)
}

func (__ *PoolOfByteThenBoolImpl) GetWorkOfByteThenBool() *WorkOfByteThenBool {
	return __.ByteWork.Get().(*WorkOfByteThenBool)
}
func (__ *PoolOfByteThenBoolImpl) PutWorkOfByteThenBool(p *WorkOfByteThenBool) {
	__.ByteWork.Put(p)
}
func (__ *PoolOfByteThenBoolImpl) GetReturnOfBool() *ReturnOfBool {
	return __.BoolReturn.Get().(*ReturnOfBool)
}
func (__ *PoolOfByteThenBoolImpl) PutReturnOfBool(p *ReturnOfBool) {
	__.BoolReturn.Put(p)
}

func (__ *PoolOfByteThenBoolImpl) GetChReturnOfBool() chan *ReturnOfBool {
	return __.ChReturnOfBool.Get().(chan *ReturnOfBool)
}
func (__ *PoolOfByteThenBoolImpl) PutChReturnOfBool(p chan *ReturnOfBool) {
	__.ChReturnOfBool.Put(p)
}

func NewPoolOfByteThenBoolImpl() *PoolOfByteThenBoolImpl {
	return &PoolOfByteThenBoolImpl{
		ByteArg: sync.Pool{
			New: func() interface{} {
				return new(byte)
			},
		},
		ByteWork: sync.Pool{
			New: func() interface{} {
				return new(WorkOfByteThenBool)
			},
		},
		BoolRtn: sync.Pool{
			New: func() interface{} {
				return new(bool)
			},
		},
		BoolReturn: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfBool)
			},
		},
		ChReturnOfBool: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfBool, 1)
			},
		},
	}
}

type ApiDecouplerOfByteThenBool struct {
	pool PoolOfByteThenBool
}

func NewApiDecouplerOfByteThenBool() *ApiDecouplerOfByteThenBool {
	return &ApiDecouplerOfByteThenBool{
		pool: NewPoolOfByteThenBoolImpl(),
	}
}

func (__ *ApiDecouplerOfByteThenBool) ReturnError(rtn_ch chan<- *ReturnOfBool, err error) {
	rtn := __.pool.GetReturnOfBool()
	var other bool
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfByteThenBool) HandleOfByteThenBool(ctx context.Context, req *WorkOfByteThenBool, h func(ctx context.Context, arg byte) (bool, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfBool()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfByteThenBool) DoOfByteThenBool(ctx context.Context, worker WorkerOfPushByteThenBool, arg byte) (bool, error) {
	// ch := make(chan *ReturnOfBool, 1)
	ch := __.pool.GetChReturnOfBool()
	defer __.pool.PutChReturnOfBool(ch)

	req := __.pool.GetWorkOfByteThenBool()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfByteThenBool(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfBool(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfByteThenBool = func(ctx context.Context, arg byte) (bool, error)

type WorkerOfByteThenBool struct {
	api_syncer *ApiDecouplerOfByteThenBool
	handler    WorkHandlerOfByteThenBool

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfByteThenBool
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfByteThenBool(ctx context.Context, h WorkHandlerOfByteThenBool, n int) *WorkerOfByteThenBool {
	__ := &WorkerOfByteThenBool{
		api_syncer: NewApiDecouplerOfByteThenBool(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfByteThenBool, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfByteThenBool{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfByteThenBool(req.Context, req.WorkOfByteThenBool, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfByteThenBool) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfByteThenBool) Push(ctx context.Context, req *WorkOfByteThenBool) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfByteThenBool)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfByteThenBool = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfByteThenBool) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfByteThenBool) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfByteThenBool) Call(ctx context.Context, arg byte) (bool, error) {
	return __.api_syncer.DoOfByteThenBool(ctx, __, arg)
}

type PoolOfByteThenByte interface {
	GetByteArg() *byte
	PutByteArg(*byte)
	GetByteReturn() *byte
	PutByteReturn(*byte)

	GetWorkOfByteThenByte() *WorkOfByteThenByte
	GetReturnOfByte() *ReturnOfByte
	PutWorkOfByteThenByte(*WorkOfByteThenByte)
	PutReturnOfByte(*ReturnOfByte)

	GetChReturnOfByte() chan *ReturnOfByte
	PutChReturnOfByte(chan *ReturnOfByte)
}

type PoolOfByteThenByteImpl struct {
	ByteArg        sync.Pool
	ByteRtn        sync.Pool
	ByteWork       sync.Pool
	ByteReturn     sync.Pool
	ChReturnOfByte sync.Pool
}

func (__ *PoolOfByteThenByteImpl) GetByteArg() *byte {
	return __.ByteArg.Get().(*byte)
}
func (__ *PoolOfByteThenByteImpl) PutByteArg(p *byte) {
	__.ByteArg.Put(p)
}
func (__ *PoolOfByteThenByteImpl) GetByteReturn() *byte {
	return __.ByteRtn.Get().(*byte)
}
func (__ *PoolOfByteThenByteImpl) PutByteReturn(p *byte) {
	__.ByteRtn.Put(p)
}

func (__ *PoolOfByteThenByteImpl) GetWorkOfByteThenByte() *WorkOfByteThenByte {
	return __.ByteWork.Get().(*WorkOfByteThenByte)
}
func (__ *PoolOfByteThenByteImpl) PutWorkOfByteThenByte(p *WorkOfByteThenByte) {
	__.ByteWork.Put(p)
}
func (__ *PoolOfByteThenByteImpl) GetReturnOfByte() *ReturnOfByte {
	return __.ByteReturn.Get().(*ReturnOfByte)
}
func (__ *PoolOfByteThenByteImpl) PutReturnOfByte(p *ReturnOfByte) {
	__.ByteReturn.Put(p)
}

func (__ *PoolOfByteThenByteImpl) GetChReturnOfByte() chan *ReturnOfByte {
	return __.ChReturnOfByte.Get().(chan *ReturnOfByte)
}
func (__ *PoolOfByteThenByteImpl) PutChReturnOfByte(p chan *ReturnOfByte) {
	__.ChReturnOfByte.Put(p)
}

func NewPoolOfByteThenByteImpl() *PoolOfByteThenByteImpl {
	return &PoolOfByteThenByteImpl{
		ByteArg: sync.Pool{
			New: func() interface{} {
				return new(byte)
			},
		},
		ByteWork: sync.Pool{
			New: func() interface{} {
				return new(WorkOfByteThenByte)
			},
		},
		ByteRtn: sync.Pool{
			New: func() interface{} {
				return new(byte)
			},
		},
		ByteReturn: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfByte)
			},
		},
		ChReturnOfByte: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfByte, 1)
			},
		},
	}
}

type ApiDecouplerOfByteThenByte struct {
	pool PoolOfByteThenByte
}

func NewApiDecouplerOfByteThenByte() *ApiDecouplerOfByteThenByte {
	return &ApiDecouplerOfByteThenByte{
		pool: NewPoolOfByteThenByteImpl(),
	}
}

func (__ *ApiDecouplerOfByteThenByte) ReturnError(rtn_ch chan<- *ReturnOfByte, err error) {
	rtn := __.pool.GetReturnOfByte()
	var other byte
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfByteThenByte) HandleOfByteThenByte(ctx context.Context, req *WorkOfByteThenByte, h func(ctx context.Context, arg byte) (byte, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfByte()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfByteThenByte) DoOfByteThenByte(ctx context.Context, worker WorkerOfPushByteThenByte, arg byte) (byte, error) {
	// ch := make(chan *ReturnOfByte, 1)
	ch := __.pool.GetChReturnOfByte()
	defer __.pool.PutChReturnOfByte(ch)

	req := __.pool.GetWorkOfByteThenByte()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfByteThenByte(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfByte(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfByteThenByte = func(ctx context.Context, arg byte) (byte, error)

type WorkerOfByteThenByte struct {
	api_syncer *ApiDecouplerOfByteThenByte
	handler    WorkHandlerOfByteThenByte

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfByteThenByte
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfByteThenByte(ctx context.Context, h WorkHandlerOfByteThenByte, n int) *WorkerOfByteThenByte {
	__ := &WorkerOfByteThenByte{
		api_syncer: NewApiDecouplerOfByteThenByte(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfByteThenByte, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfByteThenByte{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfByteThenByte(req.Context, req.WorkOfByteThenByte, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfByteThenByte) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfByteThenByte) Push(ctx context.Context, req *WorkOfByteThenByte) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfByteThenByte)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfByteThenByte = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfByteThenByte) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfByteThenByte) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfByteThenByte) Call(ctx context.Context, arg byte) (byte, error) {
	return __.api_syncer.DoOfByteThenByte(ctx, __, arg)
}

type PoolOfByteThenComplex128 interface {
	GetByteArg() *byte
	PutByteArg(*byte)
	GetComplex128Return() *complex128
	PutComplex128Return(*complex128)

	GetWorkOfByteThenComplex128() *WorkOfByteThenComplex128
	GetReturnOfComplex128() *ReturnOfComplex128
	PutWorkOfByteThenComplex128(*WorkOfByteThenComplex128)
	PutReturnOfComplex128(*ReturnOfComplex128)

	GetChReturnOfComplex128() chan *ReturnOfComplex128
	PutChReturnOfComplex128(chan *ReturnOfComplex128)
}

type PoolOfByteThenComplex128Impl struct {
	ByteArg              sync.Pool
	Complex128Rtn        sync.Pool
	ByteWork             sync.Pool
	Complex128Return     sync.Pool
	ChReturnOfComplex128 sync.Pool
}

func (__ *PoolOfByteThenComplex128Impl) GetByteArg() *byte {
	return __.ByteArg.Get().(*byte)
}
func (__ *PoolOfByteThenComplex128Impl) PutByteArg(p *byte) {
	__.ByteArg.Put(p)
}
func (__ *PoolOfByteThenComplex128Impl) GetComplex128Return() *complex128 {
	return __.Complex128Rtn.Get().(*complex128)
}
func (__ *PoolOfByteThenComplex128Impl) PutComplex128Return(p *complex128) {
	__.Complex128Rtn.Put(p)
}

func (__ *PoolOfByteThenComplex128Impl) GetWorkOfByteThenComplex128() *WorkOfByteThenComplex128 {
	return __.ByteWork.Get().(*WorkOfByteThenComplex128)
}
func (__ *PoolOfByteThenComplex128Impl) PutWorkOfByteThenComplex128(p *WorkOfByteThenComplex128) {
	__.ByteWork.Put(p)
}
func (__ *PoolOfByteThenComplex128Impl) GetReturnOfComplex128() *ReturnOfComplex128 {
	return __.Complex128Return.Get().(*ReturnOfComplex128)
}
func (__ *PoolOfByteThenComplex128Impl) PutReturnOfComplex128(p *ReturnOfComplex128) {
	__.Complex128Return.Put(p)
}

func (__ *PoolOfByteThenComplex128Impl) GetChReturnOfComplex128() chan *ReturnOfComplex128 {
	return __.ChReturnOfComplex128.Get().(chan *ReturnOfComplex128)
}
func (__ *PoolOfByteThenComplex128Impl) PutChReturnOfComplex128(p chan *ReturnOfComplex128) {
	__.ChReturnOfComplex128.Put(p)
}

func NewPoolOfByteThenComplex128Impl() *PoolOfByteThenComplex128Impl {
	return &PoolOfByteThenComplex128Impl{
		ByteArg: sync.Pool{
			New: func() interface{} {
				return new(byte)
			},
		},
		ByteWork: sync.Pool{
			New: func() interface{} {
				return new(WorkOfByteThenComplex128)
			},
		},
		Complex128Rtn: sync.Pool{
			New: func() interface{} {
				return new(complex128)
			},
		},
		Complex128Return: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfComplex128)
			},
		},
		ChReturnOfComplex128: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfComplex128, 1)
			},
		},
	}
}

type ApiDecouplerOfByteThenComplex128 struct {
	pool PoolOfByteThenComplex128
}

func NewApiDecouplerOfByteThenComplex128() *ApiDecouplerOfByteThenComplex128 {
	return &ApiDecouplerOfByteThenComplex128{
		pool: NewPoolOfByteThenComplex128Impl(),
	}
}

func (__ *ApiDecouplerOfByteThenComplex128) ReturnError(rtn_ch chan<- *ReturnOfComplex128, err error) {
	rtn := __.pool.GetReturnOfComplex128()
	var other complex128
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfByteThenComplex128) HandleOfByteThenComplex128(ctx context.Context, req *WorkOfByteThenComplex128, h func(ctx context.Context, arg byte) (complex128, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfComplex128()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfByteThenComplex128) DoOfByteThenComplex128(ctx context.Context, worker WorkerOfPushByteThenComplex128, arg byte) (complex128, error) {
	// ch := make(chan *ReturnOfComplex128, 1)
	ch := __.pool.GetChReturnOfComplex128()
	defer __.pool.PutChReturnOfComplex128(ch)

	req := __.pool.GetWorkOfByteThenComplex128()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfByteThenComplex128(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfComplex128(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfByteThenComplex128 = func(ctx context.Context, arg byte) (complex128, error)

type WorkerOfByteThenComplex128 struct {
	api_syncer *ApiDecouplerOfByteThenComplex128
	handler    WorkHandlerOfByteThenComplex128

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfByteThenComplex128
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfByteThenComplex128(ctx context.Context, h WorkHandlerOfByteThenComplex128, n int) *WorkerOfByteThenComplex128 {
	__ := &WorkerOfByteThenComplex128{
		api_syncer: NewApiDecouplerOfByteThenComplex128(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfByteThenComplex128, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfByteThenComplex128{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfByteThenComplex128(req.Context, req.WorkOfByteThenComplex128, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfByteThenComplex128) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfByteThenComplex128) Push(ctx context.Context, req *WorkOfByteThenComplex128) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfByteThenComplex128)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfByteThenComplex128 = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfByteThenComplex128) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfByteThenComplex128) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfByteThenComplex128) Call(ctx context.Context, arg byte) (complex128, error) {
	return __.api_syncer.DoOfByteThenComplex128(ctx, __, arg)
}

type PoolOfByteThenComplex64 interface {
	GetByteArg() *byte
	PutByteArg(*byte)
	GetComplex64Return() *complex64
	PutComplex64Return(*complex64)

	GetWorkOfByteThenComplex64() *WorkOfByteThenComplex64
	GetReturnOfComplex64() *ReturnOfComplex64
	PutWorkOfByteThenComplex64(*WorkOfByteThenComplex64)
	PutReturnOfComplex64(*ReturnOfComplex64)

	GetChReturnOfComplex64() chan *ReturnOfComplex64
	PutChReturnOfComplex64(chan *ReturnOfComplex64)
}

type PoolOfByteThenComplex64Impl struct {
	ByteArg             sync.Pool
	Complex64Rtn        sync.Pool
	ByteWork            sync.Pool
	Complex64Return     sync.Pool
	ChReturnOfComplex64 sync.Pool
}

func (__ *PoolOfByteThenComplex64Impl) GetByteArg() *byte {
	return __.ByteArg.Get().(*byte)
}
func (__ *PoolOfByteThenComplex64Impl) PutByteArg(p *byte) {
	__.ByteArg.Put(p)
}
func (__ *PoolOfByteThenComplex64Impl) GetComplex64Return() *complex64 {
	return __.Complex64Rtn.Get().(*complex64)
}
func (__ *PoolOfByteThenComplex64Impl) PutComplex64Return(p *complex64) {
	__.Complex64Rtn.Put(p)
}

func (__ *PoolOfByteThenComplex64Impl) GetWorkOfByteThenComplex64() *WorkOfByteThenComplex64 {
	return __.ByteWork.Get().(*WorkOfByteThenComplex64)
}
func (__ *PoolOfByteThenComplex64Impl) PutWorkOfByteThenComplex64(p *WorkOfByteThenComplex64) {
	__.ByteWork.Put(p)
}
func (__ *PoolOfByteThenComplex64Impl) GetReturnOfComplex64() *ReturnOfComplex64 {
	return __.Complex64Return.Get().(*ReturnOfComplex64)
}
func (__ *PoolOfByteThenComplex64Impl) PutReturnOfComplex64(p *ReturnOfComplex64) {
	__.Complex64Return.Put(p)
}

func (__ *PoolOfByteThenComplex64Impl) GetChReturnOfComplex64() chan *ReturnOfComplex64 {
	return __.ChReturnOfComplex64.Get().(chan *ReturnOfComplex64)
}
func (__ *PoolOfByteThenComplex64Impl) PutChReturnOfComplex64(p chan *ReturnOfComplex64) {
	__.ChReturnOfComplex64.Put(p)
}

func NewPoolOfByteThenComplex64Impl() *PoolOfByteThenComplex64Impl {
	return &PoolOfByteThenComplex64Impl{
		ByteArg: sync.Pool{
			New: func() interface{} {
				return new(byte)
			},
		},
		ByteWork: sync.Pool{
			New: func() interface{} {
				return new(WorkOfByteThenComplex64)
			},
		},
		Complex64Rtn: sync.Pool{
			New: func() interface{} {
				return new(complex64)
			},
		},
		Complex64Return: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfComplex64)
			},
		},
		ChReturnOfComplex64: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfComplex64, 1)
			},
		},
	}
}

type ApiDecouplerOfByteThenComplex64 struct {
	pool PoolOfByteThenComplex64
}

func NewApiDecouplerOfByteThenComplex64() *ApiDecouplerOfByteThenComplex64 {
	return &ApiDecouplerOfByteThenComplex64{
		pool: NewPoolOfByteThenComplex64Impl(),
	}
}

func (__ *ApiDecouplerOfByteThenComplex64) ReturnError(rtn_ch chan<- *ReturnOfComplex64, err error) {
	rtn := __.pool.GetReturnOfComplex64()
	var other complex64
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfByteThenComplex64) HandleOfByteThenComplex64(ctx context.Context, req *WorkOfByteThenComplex64, h func(ctx context.Context, arg byte) (complex64, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfComplex64()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfByteThenComplex64) DoOfByteThenComplex64(ctx context.Context, worker WorkerOfPushByteThenComplex64, arg byte) (complex64, error) {
	// ch := make(chan *ReturnOfComplex64, 1)
	ch := __.pool.GetChReturnOfComplex64()
	defer __.pool.PutChReturnOfComplex64(ch)

	req := __.pool.GetWorkOfByteThenComplex64()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfByteThenComplex64(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfComplex64(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfByteThenComplex64 = func(ctx context.Context, arg byte) (complex64, error)

type WorkerOfByteThenComplex64 struct {
	api_syncer *ApiDecouplerOfByteThenComplex64
	handler    WorkHandlerOfByteThenComplex64

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfByteThenComplex64
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfByteThenComplex64(ctx context.Context, h WorkHandlerOfByteThenComplex64, n int) *WorkerOfByteThenComplex64 {
	__ := &WorkerOfByteThenComplex64{
		api_syncer: NewApiDecouplerOfByteThenComplex64(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfByteThenComplex64, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfByteThenComplex64{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfByteThenComplex64(req.Context, req.WorkOfByteThenComplex64, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfByteThenComplex64) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfByteThenComplex64) Push(ctx context.Context, req *WorkOfByteThenComplex64) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfByteThenComplex64)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfByteThenComplex64 = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfByteThenComplex64) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfByteThenComplex64) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfByteThenComplex64) Call(ctx context.Context, arg byte) (complex64, error) {
	return __.api_syncer.DoOfByteThenComplex64(ctx, __, arg)
}

type PoolOfByteThenError interface {
	GetByteArg() *byte
	PutByteArg(*byte)
	GetErrorReturn() *error
	PutErrorReturn(*error)

	GetWorkOfByteThenError() *WorkOfByteThenError
	GetReturnOfError() *ReturnOfError
	PutWorkOfByteThenError(*WorkOfByteThenError)
	PutReturnOfError(*ReturnOfError)

	GetChReturnOfError() chan *ReturnOfError
	PutChReturnOfError(chan *ReturnOfError)
}

type PoolOfByteThenErrorImpl struct {
	ByteArg         sync.Pool
	ErrorRtn        sync.Pool
	ByteWork        sync.Pool
	ErrorReturn     sync.Pool
	ChReturnOfError sync.Pool
}

func (__ *PoolOfByteThenErrorImpl) GetByteArg() *byte {
	return __.ByteArg.Get().(*byte)
}
func (__ *PoolOfByteThenErrorImpl) PutByteArg(p *byte) {
	__.ByteArg.Put(p)
}
func (__ *PoolOfByteThenErrorImpl) GetErrorReturn() *error {
	return __.ErrorRtn.Get().(*error)
}
func (__ *PoolOfByteThenErrorImpl) PutErrorReturn(p *error) {
	__.ErrorRtn.Put(p)
}

func (__ *PoolOfByteThenErrorImpl) GetWorkOfByteThenError() *WorkOfByteThenError {
	return __.ByteWork.Get().(*WorkOfByteThenError)
}
func (__ *PoolOfByteThenErrorImpl) PutWorkOfByteThenError(p *WorkOfByteThenError) {
	__.ByteWork.Put(p)
}
func (__ *PoolOfByteThenErrorImpl) GetReturnOfError() *ReturnOfError {
	return __.ErrorReturn.Get().(*ReturnOfError)
}
func (__ *PoolOfByteThenErrorImpl) PutReturnOfError(p *ReturnOfError) {
	__.ErrorReturn.Put(p)
}

func (__ *PoolOfByteThenErrorImpl) GetChReturnOfError() chan *ReturnOfError {
	return __.ChReturnOfError.Get().(chan *ReturnOfError)
}
func (__ *PoolOfByteThenErrorImpl) PutChReturnOfError(p chan *ReturnOfError) {
	__.ChReturnOfError.Put(p)
}

func NewPoolOfByteThenErrorImpl() *PoolOfByteThenErrorImpl {
	return &PoolOfByteThenErrorImpl{
		ByteArg: sync.Pool{
			New: func() interface{} {
				return new(byte)
			},
		},
		ByteWork: sync.Pool{
			New: func() interface{} {
				return new(WorkOfByteThenError)
			},
		},
		ErrorRtn: sync.Pool{
			New: func() interface{} {
				return new(error)
			},
		},
		ErrorReturn: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfError)
			},
		},
		ChReturnOfError: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfError, 1)
			},
		},
	}
}

type ApiDecouplerOfByteThenError struct {
	pool PoolOfByteThenError
}

func NewApiDecouplerOfByteThenError() *ApiDecouplerOfByteThenError {
	return &ApiDecouplerOfByteThenError{
		pool: NewPoolOfByteThenErrorImpl(),
	}
}

func (__ *ApiDecouplerOfByteThenError) ReturnError(rtn_ch chan<- *ReturnOfError, err error) {
	rtn := __.pool.GetReturnOfError()
	var other error
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfByteThenError) HandleOfByteThenError(ctx context.Context, req *WorkOfByteThenError, h func(ctx context.Context, arg byte) (error, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfError()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfByteThenError) DoOfByteThenError(ctx context.Context, worker WorkerOfPushByteThenError, arg byte) (error, error) {
	// ch := make(chan *ReturnOfError, 1)
	ch := __.pool.GetChReturnOfError()
	defer __.pool.PutChReturnOfError(ch)

	req := __.pool.GetWorkOfByteThenError()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfByteThenError(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfError(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfByteThenError = func(ctx context.Context, arg byte) (error, error)

type WorkerOfByteThenError struct {
	api_syncer *ApiDecouplerOfByteThenError
	handler    WorkHandlerOfByteThenError

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfByteThenError
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfByteThenError(ctx context.Context, h WorkHandlerOfByteThenError, n int) *WorkerOfByteThenError {
	__ := &WorkerOfByteThenError{
		api_syncer: NewApiDecouplerOfByteThenError(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfByteThenError, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfByteThenError{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfByteThenError(req.Context, req.WorkOfByteThenError, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfByteThenError) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfByteThenError) Push(ctx context.Context, req *WorkOfByteThenError) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfByteThenError)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfByteThenError = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfByteThenError) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfByteThenError) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfByteThenError) Call(ctx context.Context, arg byte) (error, error) {
	return __.api_syncer.DoOfByteThenError(ctx, __, arg)
}

type PoolOfByteThenFloat32 interface {
	GetByteArg() *byte
	PutByteArg(*byte)
	GetFloat32Return() *float32
	PutFloat32Return(*float32)

	GetWorkOfByteThenFloat32() *WorkOfByteThenFloat32
	GetReturnOfFloat32() *ReturnOfFloat32
	PutWorkOfByteThenFloat32(*WorkOfByteThenFloat32)
	PutReturnOfFloat32(*ReturnOfFloat32)

	GetChReturnOfFloat32() chan *ReturnOfFloat32
	PutChReturnOfFloat32(chan *ReturnOfFloat32)
}

type PoolOfByteThenFloat32Impl struct {
	ByteArg           sync.Pool
	Float32Rtn        sync.Pool
	ByteWork          sync.Pool
	Float32Return     sync.Pool
	ChReturnOfFloat32 sync.Pool
}

func (__ *PoolOfByteThenFloat32Impl) GetByteArg() *byte {
	return __.ByteArg.Get().(*byte)
}
func (__ *PoolOfByteThenFloat32Impl) PutByteArg(p *byte) {
	__.ByteArg.Put(p)
}
func (__ *PoolOfByteThenFloat32Impl) GetFloat32Return() *float32 {
	return __.Float32Rtn.Get().(*float32)
}
func (__ *PoolOfByteThenFloat32Impl) PutFloat32Return(p *float32) {
	__.Float32Rtn.Put(p)
}

func (__ *PoolOfByteThenFloat32Impl) GetWorkOfByteThenFloat32() *WorkOfByteThenFloat32 {
	return __.ByteWork.Get().(*WorkOfByteThenFloat32)
}
func (__ *PoolOfByteThenFloat32Impl) PutWorkOfByteThenFloat32(p *WorkOfByteThenFloat32) {
	__.ByteWork.Put(p)
}
func (__ *PoolOfByteThenFloat32Impl) GetReturnOfFloat32() *ReturnOfFloat32 {
	return __.Float32Return.Get().(*ReturnOfFloat32)
}
func (__ *PoolOfByteThenFloat32Impl) PutReturnOfFloat32(p *ReturnOfFloat32) {
	__.Float32Return.Put(p)
}

func (__ *PoolOfByteThenFloat32Impl) GetChReturnOfFloat32() chan *ReturnOfFloat32 {
	return __.ChReturnOfFloat32.Get().(chan *ReturnOfFloat32)
}
func (__ *PoolOfByteThenFloat32Impl) PutChReturnOfFloat32(p chan *ReturnOfFloat32) {
	__.ChReturnOfFloat32.Put(p)
}

func NewPoolOfByteThenFloat32Impl() *PoolOfByteThenFloat32Impl {
	return &PoolOfByteThenFloat32Impl{
		ByteArg: sync.Pool{
			New: func() interface{} {
				return new(byte)
			},
		},
		ByteWork: sync.Pool{
			New: func() interface{} {
				return new(WorkOfByteThenFloat32)
			},
		},
		Float32Rtn: sync.Pool{
			New: func() interface{} {
				return new(float32)
			},
		},
		Float32Return: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfFloat32)
			},
		},
		ChReturnOfFloat32: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfFloat32, 1)
			},
		},
	}
}

type ApiDecouplerOfByteThenFloat32 struct {
	pool PoolOfByteThenFloat32
}

func NewApiDecouplerOfByteThenFloat32() *ApiDecouplerOfByteThenFloat32 {
	return &ApiDecouplerOfByteThenFloat32{
		pool: NewPoolOfByteThenFloat32Impl(),
	}
}

func (__ *ApiDecouplerOfByteThenFloat32) ReturnError(rtn_ch chan<- *ReturnOfFloat32, err error) {
	rtn := __.pool.GetReturnOfFloat32()
	var other float32
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfByteThenFloat32) HandleOfByteThenFloat32(ctx context.Context, req *WorkOfByteThenFloat32, h func(ctx context.Context, arg byte) (float32, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfFloat32()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfByteThenFloat32) DoOfByteThenFloat32(ctx context.Context, worker WorkerOfPushByteThenFloat32, arg byte) (float32, error) {
	// ch := make(chan *ReturnOfFloat32, 1)
	ch := __.pool.GetChReturnOfFloat32()
	defer __.pool.PutChReturnOfFloat32(ch)

	req := __.pool.GetWorkOfByteThenFloat32()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfByteThenFloat32(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfFloat32(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfByteThenFloat32 = func(ctx context.Context, arg byte) (float32, error)

type WorkerOfByteThenFloat32 struct {
	api_syncer *ApiDecouplerOfByteThenFloat32
	handler    WorkHandlerOfByteThenFloat32

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfByteThenFloat32
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfByteThenFloat32(ctx context.Context, h WorkHandlerOfByteThenFloat32, n int) *WorkerOfByteThenFloat32 {
	__ := &WorkerOfByteThenFloat32{
		api_syncer: NewApiDecouplerOfByteThenFloat32(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfByteThenFloat32, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfByteThenFloat32{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfByteThenFloat32(req.Context, req.WorkOfByteThenFloat32, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfByteThenFloat32) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfByteThenFloat32) Push(ctx context.Context, req *WorkOfByteThenFloat32) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfByteThenFloat32)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfByteThenFloat32 = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfByteThenFloat32) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfByteThenFloat32) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfByteThenFloat32) Call(ctx context.Context, arg byte) (float32, error) {
	return __.api_syncer.DoOfByteThenFloat32(ctx, __, arg)
}

type PoolOfByteThenFloat64 interface {
	GetByteArg() *byte
	PutByteArg(*byte)
	GetFloat64Return() *float64
	PutFloat64Return(*float64)

	GetWorkOfByteThenFloat64() *WorkOfByteThenFloat64
	GetReturnOfFloat64() *ReturnOfFloat64
	PutWorkOfByteThenFloat64(*WorkOfByteThenFloat64)
	PutReturnOfFloat64(*ReturnOfFloat64)

	GetChReturnOfFloat64() chan *ReturnOfFloat64
	PutChReturnOfFloat64(chan *ReturnOfFloat64)
}

type PoolOfByteThenFloat64Impl struct {
	ByteArg           sync.Pool
	Float64Rtn        sync.Pool
	ByteWork          sync.Pool
	Float64Return     sync.Pool
	ChReturnOfFloat64 sync.Pool
}

func (__ *PoolOfByteThenFloat64Impl) GetByteArg() *byte {
	return __.ByteArg.Get().(*byte)
}
func (__ *PoolOfByteThenFloat64Impl) PutByteArg(p *byte) {
	__.ByteArg.Put(p)
}
func (__ *PoolOfByteThenFloat64Impl) GetFloat64Return() *float64 {
	return __.Float64Rtn.Get().(*float64)
}
func (__ *PoolOfByteThenFloat64Impl) PutFloat64Return(p *float64) {
	__.Float64Rtn.Put(p)
}

func (__ *PoolOfByteThenFloat64Impl) GetWorkOfByteThenFloat64() *WorkOfByteThenFloat64 {
	return __.ByteWork.Get().(*WorkOfByteThenFloat64)
}
func (__ *PoolOfByteThenFloat64Impl) PutWorkOfByteThenFloat64(p *WorkOfByteThenFloat64) {
	__.ByteWork.Put(p)
}
func (__ *PoolOfByteThenFloat64Impl) GetReturnOfFloat64() *ReturnOfFloat64 {
	return __.Float64Return.Get().(*ReturnOfFloat64)
}
func (__ *PoolOfByteThenFloat64Impl) PutReturnOfFloat64(p *ReturnOfFloat64) {
	__.Float64Return.Put(p)
}

func (__ *PoolOfByteThenFloat64Impl) GetChReturnOfFloat64() chan *ReturnOfFloat64 {
	return __.ChReturnOfFloat64.Get().(chan *ReturnOfFloat64)
}
func (__ *PoolOfByteThenFloat64Impl) PutChReturnOfFloat64(p chan *ReturnOfFloat64) {
	__.ChReturnOfFloat64.Put(p)
}

func NewPoolOfByteThenFloat64Impl() *PoolOfByteThenFloat64Impl {
	return &PoolOfByteThenFloat64Impl{
		ByteArg: sync.Pool{
			New: func() interface{} {
				return new(byte)
			},
		},
		ByteWork: sync.Pool{
			New: func() interface{} {
				return new(WorkOfByteThenFloat64)
			},
		},
		Float64Rtn: sync.Pool{
			New: func() interface{} {
				return new(float64)
			},
		},
		Float64Return: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfFloat64)
			},
		},
		ChReturnOfFloat64: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfFloat64, 1)
			},
		},
	}
}

type ApiDecouplerOfByteThenFloat64 struct {
	pool PoolOfByteThenFloat64
}

func NewApiDecouplerOfByteThenFloat64() *ApiDecouplerOfByteThenFloat64 {
	return &ApiDecouplerOfByteThenFloat64{
		pool: NewPoolOfByteThenFloat64Impl(),
	}
}

func (__ *ApiDecouplerOfByteThenFloat64) ReturnError(rtn_ch chan<- *ReturnOfFloat64, err error) {
	rtn := __.pool.GetReturnOfFloat64()
	var other float64
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfByteThenFloat64) HandleOfByteThenFloat64(ctx context.Context, req *WorkOfByteThenFloat64, h func(ctx context.Context, arg byte) (float64, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfFloat64()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfByteThenFloat64) DoOfByteThenFloat64(ctx context.Context, worker WorkerOfPushByteThenFloat64, arg byte) (float64, error) {
	// ch := make(chan *ReturnOfFloat64, 1)
	ch := __.pool.GetChReturnOfFloat64()
	defer __.pool.PutChReturnOfFloat64(ch)

	req := __.pool.GetWorkOfByteThenFloat64()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfByteThenFloat64(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfFloat64(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfByteThenFloat64 = func(ctx context.Context, arg byte) (float64, error)

type WorkerOfByteThenFloat64 struct {
	api_syncer *ApiDecouplerOfByteThenFloat64
	handler    WorkHandlerOfByteThenFloat64

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfByteThenFloat64
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfByteThenFloat64(ctx context.Context, h WorkHandlerOfByteThenFloat64, n int) *WorkerOfByteThenFloat64 {
	__ := &WorkerOfByteThenFloat64{
		api_syncer: NewApiDecouplerOfByteThenFloat64(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfByteThenFloat64, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfByteThenFloat64{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfByteThenFloat64(req.Context, req.WorkOfByteThenFloat64, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfByteThenFloat64) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfByteThenFloat64) Push(ctx context.Context, req *WorkOfByteThenFloat64) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfByteThenFloat64)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfByteThenFloat64 = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfByteThenFloat64) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfByteThenFloat64) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfByteThenFloat64) Call(ctx context.Context, arg byte) (float64, error) {
	return __.api_syncer.DoOfByteThenFloat64(ctx, __, arg)
}

type PoolOfByteThenInt interface {
	GetByteArg() *byte
	PutByteArg(*byte)
	GetIntReturn() *int
	PutIntReturn(*int)

	GetWorkOfByteThenInt() *WorkOfByteThenInt
	GetReturnOfInt() *ReturnOfInt
	PutWorkOfByteThenInt(*WorkOfByteThenInt)
	PutReturnOfInt(*ReturnOfInt)

	GetChReturnOfInt() chan *ReturnOfInt
	PutChReturnOfInt(chan *ReturnOfInt)
}

type PoolOfByteThenIntImpl struct {
	ByteArg       sync.Pool
	IntRtn        sync.Pool
	ByteWork      sync.Pool
	IntReturn     sync.Pool
	ChReturnOfInt sync.Pool
}

func (__ *PoolOfByteThenIntImpl) GetByteArg() *byte {
	return __.ByteArg.Get().(*byte)
}
func (__ *PoolOfByteThenIntImpl) PutByteArg(p *byte) {
	__.ByteArg.Put(p)
}
func (__ *PoolOfByteThenIntImpl) GetIntReturn() *int {
	return __.IntRtn.Get().(*int)
}
func (__ *PoolOfByteThenIntImpl) PutIntReturn(p *int) {
	__.IntRtn.Put(p)
}

func (__ *PoolOfByteThenIntImpl) GetWorkOfByteThenInt() *WorkOfByteThenInt {
	return __.ByteWork.Get().(*WorkOfByteThenInt)
}
func (__ *PoolOfByteThenIntImpl) PutWorkOfByteThenInt(p *WorkOfByteThenInt) {
	__.ByteWork.Put(p)
}
func (__ *PoolOfByteThenIntImpl) GetReturnOfInt() *ReturnOfInt {
	return __.IntReturn.Get().(*ReturnOfInt)
}
func (__ *PoolOfByteThenIntImpl) PutReturnOfInt(p *ReturnOfInt) {
	__.IntReturn.Put(p)
}

func (__ *PoolOfByteThenIntImpl) GetChReturnOfInt() chan *ReturnOfInt {
	return __.ChReturnOfInt.Get().(chan *ReturnOfInt)
}
func (__ *PoolOfByteThenIntImpl) PutChReturnOfInt(p chan *ReturnOfInt) {
	__.ChReturnOfInt.Put(p)
}

func NewPoolOfByteThenIntImpl() *PoolOfByteThenIntImpl {
	return &PoolOfByteThenIntImpl{
		ByteArg: sync.Pool{
			New: func() interface{} {
				return new(byte)
			},
		},
		ByteWork: sync.Pool{
			New: func() interface{} {
				return new(WorkOfByteThenInt)
			},
		},
		IntRtn: sync.Pool{
			New: func() interface{} {
				return new(int)
			},
		},
		IntReturn: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfInt)
			},
		},
		ChReturnOfInt: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfInt, 1)
			},
		},
	}
}

type ApiDecouplerOfByteThenInt struct {
	pool PoolOfByteThenInt
}

func NewApiDecouplerOfByteThenInt() *ApiDecouplerOfByteThenInt {
	return &ApiDecouplerOfByteThenInt{
		pool: NewPoolOfByteThenIntImpl(),
	}
}

func (__ *ApiDecouplerOfByteThenInt) ReturnError(rtn_ch chan<- *ReturnOfInt, err error) {
	rtn := __.pool.GetReturnOfInt()
	var other int
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfByteThenInt) HandleOfByteThenInt(ctx context.Context, req *WorkOfByteThenInt, h func(ctx context.Context, arg byte) (int, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfInt()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfByteThenInt) DoOfByteThenInt(ctx context.Context, worker WorkerOfPushByteThenInt, arg byte) (int, error) {
	// ch := make(chan *ReturnOfInt, 1)
	ch := __.pool.GetChReturnOfInt()
	defer __.pool.PutChReturnOfInt(ch)

	req := __.pool.GetWorkOfByteThenInt()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfByteThenInt(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfInt(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfByteThenInt = func(ctx context.Context, arg byte) (int, error)

type WorkerOfByteThenInt struct {
	api_syncer *ApiDecouplerOfByteThenInt
	handler    WorkHandlerOfByteThenInt

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfByteThenInt
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfByteThenInt(ctx context.Context, h WorkHandlerOfByteThenInt, n int) *WorkerOfByteThenInt {
	__ := &WorkerOfByteThenInt{
		api_syncer: NewApiDecouplerOfByteThenInt(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfByteThenInt, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfByteThenInt{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfByteThenInt(req.Context, req.WorkOfByteThenInt, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfByteThenInt) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfByteThenInt) Push(ctx context.Context, req *WorkOfByteThenInt) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfByteThenInt)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfByteThenInt = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfByteThenInt) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfByteThenInt) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfByteThenInt) Call(ctx context.Context, arg byte) (int, error) {
	return __.api_syncer.DoOfByteThenInt(ctx, __, arg)
}

type PoolOfByteThenInt16 interface {
	GetByteArg() *byte
	PutByteArg(*byte)
	GetInt16Return() *int16
	PutInt16Return(*int16)

	GetWorkOfByteThenInt16() *WorkOfByteThenInt16
	GetReturnOfInt16() *ReturnOfInt16
	PutWorkOfByteThenInt16(*WorkOfByteThenInt16)
	PutReturnOfInt16(*ReturnOfInt16)

	GetChReturnOfInt16() chan *ReturnOfInt16
	PutChReturnOfInt16(chan *ReturnOfInt16)
}

type PoolOfByteThenInt16Impl struct {
	ByteArg         sync.Pool
	Int16Rtn        sync.Pool
	ByteWork        sync.Pool
	Int16Return     sync.Pool
	ChReturnOfInt16 sync.Pool
}

func (__ *PoolOfByteThenInt16Impl) GetByteArg() *byte {
	return __.ByteArg.Get().(*byte)
}
func (__ *PoolOfByteThenInt16Impl) PutByteArg(p *byte) {
	__.ByteArg.Put(p)
}
func (__ *PoolOfByteThenInt16Impl) GetInt16Return() *int16 {
	return __.Int16Rtn.Get().(*int16)
}
func (__ *PoolOfByteThenInt16Impl) PutInt16Return(p *int16) {
	__.Int16Rtn.Put(p)
}

func (__ *PoolOfByteThenInt16Impl) GetWorkOfByteThenInt16() *WorkOfByteThenInt16 {
	return __.ByteWork.Get().(*WorkOfByteThenInt16)
}
func (__ *PoolOfByteThenInt16Impl) PutWorkOfByteThenInt16(p *WorkOfByteThenInt16) {
	__.ByteWork.Put(p)
}
func (__ *PoolOfByteThenInt16Impl) GetReturnOfInt16() *ReturnOfInt16 {
	return __.Int16Return.Get().(*ReturnOfInt16)
}
func (__ *PoolOfByteThenInt16Impl) PutReturnOfInt16(p *ReturnOfInt16) {
	__.Int16Return.Put(p)
}

func (__ *PoolOfByteThenInt16Impl) GetChReturnOfInt16() chan *ReturnOfInt16 {
	return __.ChReturnOfInt16.Get().(chan *ReturnOfInt16)
}
func (__ *PoolOfByteThenInt16Impl) PutChReturnOfInt16(p chan *ReturnOfInt16) {
	__.ChReturnOfInt16.Put(p)
}

func NewPoolOfByteThenInt16Impl() *PoolOfByteThenInt16Impl {
	return &PoolOfByteThenInt16Impl{
		ByteArg: sync.Pool{
			New: func() interface{} {
				return new(byte)
			},
		},
		ByteWork: sync.Pool{
			New: func() interface{} {
				return new(WorkOfByteThenInt16)
			},
		},
		Int16Rtn: sync.Pool{
			New: func() interface{} {
				return new(int16)
			},
		},
		Int16Return: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfInt16)
			},
		},
		ChReturnOfInt16: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfInt16, 1)
			},
		},
	}
}

type ApiDecouplerOfByteThenInt16 struct {
	pool PoolOfByteThenInt16
}

func NewApiDecouplerOfByteThenInt16() *ApiDecouplerOfByteThenInt16 {
	return &ApiDecouplerOfByteThenInt16{
		pool: NewPoolOfByteThenInt16Impl(),
	}
}

func (__ *ApiDecouplerOfByteThenInt16) ReturnError(rtn_ch chan<- *ReturnOfInt16, err error) {
	rtn := __.pool.GetReturnOfInt16()
	var other int16
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfByteThenInt16) HandleOfByteThenInt16(ctx context.Context, req *WorkOfByteThenInt16, h func(ctx context.Context, arg byte) (int16, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfInt16()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfByteThenInt16) DoOfByteThenInt16(ctx context.Context, worker WorkerOfPushByteThenInt16, arg byte) (int16, error) {
	// ch := make(chan *ReturnOfInt16, 1)
	ch := __.pool.GetChReturnOfInt16()
	defer __.pool.PutChReturnOfInt16(ch)

	req := __.pool.GetWorkOfByteThenInt16()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfByteThenInt16(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfInt16(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfByteThenInt16 = func(ctx context.Context, arg byte) (int16, error)

type WorkerOfByteThenInt16 struct {
	api_syncer *ApiDecouplerOfByteThenInt16
	handler    WorkHandlerOfByteThenInt16

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfByteThenInt16
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfByteThenInt16(ctx context.Context, h WorkHandlerOfByteThenInt16, n int) *WorkerOfByteThenInt16 {
	__ := &WorkerOfByteThenInt16{
		api_syncer: NewApiDecouplerOfByteThenInt16(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfByteThenInt16, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfByteThenInt16{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfByteThenInt16(req.Context, req.WorkOfByteThenInt16, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfByteThenInt16) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfByteThenInt16) Push(ctx context.Context, req *WorkOfByteThenInt16) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfByteThenInt16)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfByteThenInt16 = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfByteThenInt16) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfByteThenInt16) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfByteThenInt16) Call(ctx context.Context, arg byte) (int16, error) {
	return __.api_syncer.DoOfByteThenInt16(ctx, __, arg)
}

type PoolOfByteThenInt32 interface {
	GetByteArg() *byte
	PutByteArg(*byte)
	GetInt32Return() *int32
	PutInt32Return(*int32)

	GetWorkOfByteThenInt32() *WorkOfByteThenInt32
	GetReturnOfInt32() *ReturnOfInt32
	PutWorkOfByteThenInt32(*WorkOfByteThenInt32)
	PutReturnOfInt32(*ReturnOfInt32)

	GetChReturnOfInt32() chan *ReturnOfInt32
	PutChReturnOfInt32(chan *ReturnOfInt32)
}

type PoolOfByteThenInt32Impl struct {
	ByteArg         sync.Pool
	Int32Rtn        sync.Pool
	ByteWork        sync.Pool
	Int32Return     sync.Pool
	ChReturnOfInt32 sync.Pool
}

func (__ *PoolOfByteThenInt32Impl) GetByteArg() *byte {
	return __.ByteArg.Get().(*byte)
}
func (__ *PoolOfByteThenInt32Impl) PutByteArg(p *byte) {
	__.ByteArg.Put(p)
}
func (__ *PoolOfByteThenInt32Impl) GetInt32Return() *int32 {
	return __.Int32Rtn.Get().(*int32)
}
func (__ *PoolOfByteThenInt32Impl) PutInt32Return(p *int32) {
	__.Int32Rtn.Put(p)
}

func (__ *PoolOfByteThenInt32Impl) GetWorkOfByteThenInt32() *WorkOfByteThenInt32 {
	return __.ByteWork.Get().(*WorkOfByteThenInt32)
}
func (__ *PoolOfByteThenInt32Impl) PutWorkOfByteThenInt32(p *WorkOfByteThenInt32) {
	__.ByteWork.Put(p)
}
func (__ *PoolOfByteThenInt32Impl) GetReturnOfInt32() *ReturnOfInt32 {
	return __.Int32Return.Get().(*ReturnOfInt32)
}
func (__ *PoolOfByteThenInt32Impl) PutReturnOfInt32(p *ReturnOfInt32) {
	__.Int32Return.Put(p)
}

func (__ *PoolOfByteThenInt32Impl) GetChReturnOfInt32() chan *ReturnOfInt32 {
	return __.ChReturnOfInt32.Get().(chan *ReturnOfInt32)
}
func (__ *PoolOfByteThenInt32Impl) PutChReturnOfInt32(p chan *ReturnOfInt32) {
	__.ChReturnOfInt32.Put(p)
}

func NewPoolOfByteThenInt32Impl() *PoolOfByteThenInt32Impl {
	return &PoolOfByteThenInt32Impl{
		ByteArg: sync.Pool{
			New: func() interface{} {
				return new(byte)
			},
		},
		ByteWork: sync.Pool{
			New: func() interface{} {
				return new(WorkOfByteThenInt32)
			},
		},
		Int32Rtn: sync.Pool{
			New: func() interface{} {
				return new(int32)
			},
		},
		Int32Return: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfInt32)
			},
		},
		ChReturnOfInt32: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfInt32, 1)
			},
		},
	}
}

type ApiDecouplerOfByteThenInt32 struct {
	pool PoolOfByteThenInt32
}

func NewApiDecouplerOfByteThenInt32() *ApiDecouplerOfByteThenInt32 {
	return &ApiDecouplerOfByteThenInt32{
		pool: NewPoolOfByteThenInt32Impl(),
	}
}

func (__ *ApiDecouplerOfByteThenInt32) ReturnError(rtn_ch chan<- *ReturnOfInt32, err error) {
	rtn := __.pool.GetReturnOfInt32()
	var other int32
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfByteThenInt32) HandleOfByteThenInt32(ctx context.Context, req *WorkOfByteThenInt32, h func(ctx context.Context, arg byte) (int32, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfInt32()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfByteThenInt32) DoOfByteThenInt32(ctx context.Context, worker WorkerOfPushByteThenInt32, arg byte) (int32, error) {
	// ch := make(chan *ReturnOfInt32, 1)
	ch := __.pool.GetChReturnOfInt32()
	defer __.pool.PutChReturnOfInt32(ch)

	req := __.pool.GetWorkOfByteThenInt32()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfByteThenInt32(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfInt32(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfByteThenInt32 = func(ctx context.Context, arg byte) (int32, error)

type WorkerOfByteThenInt32 struct {
	api_syncer *ApiDecouplerOfByteThenInt32
	handler    WorkHandlerOfByteThenInt32

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfByteThenInt32
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfByteThenInt32(ctx context.Context, h WorkHandlerOfByteThenInt32, n int) *WorkerOfByteThenInt32 {
	__ := &WorkerOfByteThenInt32{
		api_syncer: NewApiDecouplerOfByteThenInt32(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfByteThenInt32, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfByteThenInt32{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfByteThenInt32(req.Context, req.WorkOfByteThenInt32, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfByteThenInt32) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfByteThenInt32) Push(ctx context.Context, req *WorkOfByteThenInt32) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfByteThenInt32)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfByteThenInt32 = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfByteThenInt32) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfByteThenInt32) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfByteThenInt32) Call(ctx context.Context, arg byte) (int32, error) {
	return __.api_syncer.DoOfByteThenInt32(ctx, __, arg)
}

type PoolOfByteThenInt64 interface {
	GetByteArg() *byte
	PutByteArg(*byte)
	GetInt64Return() *int64
	PutInt64Return(*int64)

	GetWorkOfByteThenInt64() *WorkOfByteThenInt64
	GetReturnOfInt64() *ReturnOfInt64
	PutWorkOfByteThenInt64(*WorkOfByteThenInt64)
	PutReturnOfInt64(*ReturnOfInt64)

	GetChReturnOfInt64() chan *ReturnOfInt64
	PutChReturnOfInt64(chan *ReturnOfInt64)
}

type PoolOfByteThenInt64Impl struct {
	ByteArg         sync.Pool
	Int64Rtn        sync.Pool
	ByteWork        sync.Pool
	Int64Return     sync.Pool
	ChReturnOfInt64 sync.Pool
}

func (__ *PoolOfByteThenInt64Impl) GetByteArg() *byte {
	return __.ByteArg.Get().(*byte)
}
func (__ *PoolOfByteThenInt64Impl) PutByteArg(p *byte) {
	__.ByteArg.Put(p)
}
func (__ *PoolOfByteThenInt64Impl) GetInt64Return() *int64 {
	return __.Int64Rtn.Get().(*int64)
}
func (__ *PoolOfByteThenInt64Impl) PutInt64Return(p *int64) {
	__.Int64Rtn.Put(p)
}

func (__ *PoolOfByteThenInt64Impl) GetWorkOfByteThenInt64() *WorkOfByteThenInt64 {
	return __.ByteWork.Get().(*WorkOfByteThenInt64)
}
func (__ *PoolOfByteThenInt64Impl) PutWorkOfByteThenInt64(p *WorkOfByteThenInt64) {
	__.ByteWork.Put(p)
}
func (__ *PoolOfByteThenInt64Impl) GetReturnOfInt64() *ReturnOfInt64 {
	return __.Int64Return.Get().(*ReturnOfInt64)
}
func (__ *PoolOfByteThenInt64Impl) PutReturnOfInt64(p *ReturnOfInt64) {
	__.Int64Return.Put(p)
}

func (__ *PoolOfByteThenInt64Impl) GetChReturnOfInt64() chan *ReturnOfInt64 {
	return __.ChReturnOfInt64.Get().(chan *ReturnOfInt64)
}
func (__ *PoolOfByteThenInt64Impl) PutChReturnOfInt64(p chan *ReturnOfInt64) {
	__.ChReturnOfInt64.Put(p)
}

func NewPoolOfByteThenInt64Impl() *PoolOfByteThenInt64Impl {
	return &PoolOfByteThenInt64Impl{
		ByteArg: sync.Pool{
			New: func() interface{} {
				return new(byte)
			},
		},
		ByteWork: sync.Pool{
			New: func() interface{} {
				return new(WorkOfByteThenInt64)
			},
		},
		Int64Rtn: sync.Pool{
			New: func() interface{} {
				return new(int64)
			},
		},
		Int64Return: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfInt64)
			},
		},
		ChReturnOfInt64: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfInt64, 1)
			},
		},
	}
}

type ApiDecouplerOfByteThenInt64 struct {
	pool PoolOfByteThenInt64
}

func NewApiDecouplerOfByteThenInt64() *ApiDecouplerOfByteThenInt64 {
	return &ApiDecouplerOfByteThenInt64{
		pool: NewPoolOfByteThenInt64Impl(),
	}
}

func (__ *ApiDecouplerOfByteThenInt64) ReturnError(rtn_ch chan<- *ReturnOfInt64, err error) {
	rtn := __.pool.GetReturnOfInt64()
	var other int64
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfByteThenInt64) HandleOfByteThenInt64(ctx context.Context, req *WorkOfByteThenInt64, h func(ctx context.Context, arg byte) (int64, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfInt64()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfByteThenInt64) DoOfByteThenInt64(ctx context.Context, worker WorkerOfPushByteThenInt64, arg byte) (int64, error) {
	// ch := make(chan *ReturnOfInt64, 1)
	ch := __.pool.GetChReturnOfInt64()
	defer __.pool.PutChReturnOfInt64(ch)

	req := __.pool.GetWorkOfByteThenInt64()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfByteThenInt64(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfInt64(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfByteThenInt64 = func(ctx context.Context, arg byte) (int64, error)

type WorkerOfByteThenInt64 struct {
	api_syncer *ApiDecouplerOfByteThenInt64
	handler    WorkHandlerOfByteThenInt64

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfByteThenInt64
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfByteThenInt64(ctx context.Context, h WorkHandlerOfByteThenInt64, n int) *WorkerOfByteThenInt64 {
	__ := &WorkerOfByteThenInt64{
		api_syncer: NewApiDecouplerOfByteThenInt64(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfByteThenInt64, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfByteThenInt64{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfByteThenInt64(req.Context, req.WorkOfByteThenInt64, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfByteThenInt64) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfByteThenInt64) Push(ctx context.Context, req *WorkOfByteThenInt64) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfByteThenInt64)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfByteThenInt64 = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfByteThenInt64) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfByteThenInt64) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfByteThenInt64) Call(ctx context.Context, arg byte) (int64, error) {
	return __.api_syncer.DoOfByteThenInt64(ctx, __, arg)
}

type PoolOfByteThenInt8 interface {
	GetByteArg() *byte
	PutByteArg(*byte)
	GetInt8Return() *int8
	PutInt8Return(*int8)

	GetWorkOfByteThenInt8() *WorkOfByteThenInt8
	GetReturnOfInt8() *ReturnOfInt8
	PutWorkOfByteThenInt8(*WorkOfByteThenInt8)
	PutReturnOfInt8(*ReturnOfInt8)

	GetChReturnOfInt8() chan *ReturnOfInt8
	PutChReturnOfInt8(chan *ReturnOfInt8)
}

type PoolOfByteThenInt8Impl struct {
	ByteArg        sync.Pool
	Int8Rtn        sync.Pool
	ByteWork       sync.Pool
	Int8Return     sync.Pool
	ChReturnOfInt8 sync.Pool
}

func (__ *PoolOfByteThenInt8Impl) GetByteArg() *byte {
	return __.ByteArg.Get().(*byte)
}
func (__ *PoolOfByteThenInt8Impl) PutByteArg(p *byte) {
	__.ByteArg.Put(p)
}
func (__ *PoolOfByteThenInt8Impl) GetInt8Return() *int8 {
	return __.Int8Rtn.Get().(*int8)
}
func (__ *PoolOfByteThenInt8Impl) PutInt8Return(p *int8) {
	__.Int8Rtn.Put(p)
}

func (__ *PoolOfByteThenInt8Impl) GetWorkOfByteThenInt8() *WorkOfByteThenInt8 {
	return __.ByteWork.Get().(*WorkOfByteThenInt8)
}
func (__ *PoolOfByteThenInt8Impl) PutWorkOfByteThenInt8(p *WorkOfByteThenInt8) {
	__.ByteWork.Put(p)
}
func (__ *PoolOfByteThenInt8Impl) GetReturnOfInt8() *ReturnOfInt8 {
	return __.Int8Return.Get().(*ReturnOfInt8)
}
func (__ *PoolOfByteThenInt8Impl) PutReturnOfInt8(p *ReturnOfInt8) {
	__.Int8Return.Put(p)
}

func (__ *PoolOfByteThenInt8Impl) GetChReturnOfInt8() chan *ReturnOfInt8 {
	return __.ChReturnOfInt8.Get().(chan *ReturnOfInt8)
}
func (__ *PoolOfByteThenInt8Impl) PutChReturnOfInt8(p chan *ReturnOfInt8) {
	__.ChReturnOfInt8.Put(p)
}

func NewPoolOfByteThenInt8Impl() *PoolOfByteThenInt8Impl {
	return &PoolOfByteThenInt8Impl{
		ByteArg: sync.Pool{
			New: func() interface{} {
				return new(byte)
			},
		},
		ByteWork: sync.Pool{
			New: func() interface{} {
				return new(WorkOfByteThenInt8)
			},
		},
		Int8Rtn: sync.Pool{
			New: func() interface{} {
				return new(int8)
			},
		},
		Int8Return: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfInt8)
			},
		},
		ChReturnOfInt8: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfInt8, 1)
			},
		},
	}
}

type ApiDecouplerOfByteThenInt8 struct {
	pool PoolOfByteThenInt8
}

func NewApiDecouplerOfByteThenInt8() *ApiDecouplerOfByteThenInt8 {
	return &ApiDecouplerOfByteThenInt8{
		pool: NewPoolOfByteThenInt8Impl(),
	}
}

func (__ *ApiDecouplerOfByteThenInt8) ReturnError(rtn_ch chan<- *ReturnOfInt8, err error) {
	rtn := __.pool.GetReturnOfInt8()
	var other int8
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfByteThenInt8) HandleOfByteThenInt8(ctx context.Context, req *WorkOfByteThenInt8, h func(ctx context.Context, arg byte) (int8, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfInt8()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfByteThenInt8) DoOfByteThenInt8(ctx context.Context, worker WorkerOfPushByteThenInt8, arg byte) (int8, error) {
	// ch := make(chan *ReturnOfInt8, 1)
	ch := __.pool.GetChReturnOfInt8()
	defer __.pool.PutChReturnOfInt8(ch)

	req := __.pool.GetWorkOfByteThenInt8()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfByteThenInt8(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfInt8(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfByteThenInt8 = func(ctx context.Context, arg byte) (int8, error)

type WorkerOfByteThenInt8 struct {
	api_syncer *ApiDecouplerOfByteThenInt8
	handler    WorkHandlerOfByteThenInt8

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfByteThenInt8
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfByteThenInt8(ctx context.Context, h WorkHandlerOfByteThenInt8, n int) *WorkerOfByteThenInt8 {
	__ := &WorkerOfByteThenInt8{
		api_syncer: NewApiDecouplerOfByteThenInt8(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfByteThenInt8, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfByteThenInt8{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfByteThenInt8(req.Context, req.WorkOfByteThenInt8, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfByteThenInt8) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfByteThenInt8) Push(ctx context.Context, req *WorkOfByteThenInt8) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfByteThenInt8)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfByteThenInt8 = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfByteThenInt8) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfByteThenInt8) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfByteThenInt8) Call(ctx context.Context, arg byte) (int8, error) {
	return __.api_syncer.DoOfByteThenInt8(ctx, __, arg)
}

type PoolOfByteThenRune interface {
	GetByteArg() *byte
	PutByteArg(*byte)
	GetRuneReturn() *rune
	PutRuneReturn(*rune)

	GetWorkOfByteThenRune() *WorkOfByteThenRune
	GetReturnOfRune() *ReturnOfRune
	PutWorkOfByteThenRune(*WorkOfByteThenRune)
	PutReturnOfRune(*ReturnOfRune)

	GetChReturnOfRune() chan *ReturnOfRune
	PutChReturnOfRune(chan *ReturnOfRune)
}

type PoolOfByteThenRuneImpl struct {
	ByteArg        sync.Pool
	RuneRtn        sync.Pool
	ByteWork       sync.Pool
	RuneReturn     sync.Pool
	ChReturnOfRune sync.Pool
}

func (__ *PoolOfByteThenRuneImpl) GetByteArg() *byte {
	return __.ByteArg.Get().(*byte)
}
func (__ *PoolOfByteThenRuneImpl) PutByteArg(p *byte) {
	__.ByteArg.Put(p)
}
func (__ *PoolOfByteThenRuneImpl) GetRuneReturn() *rune {
	return __.RuneRtn.Get().(*rune)
}
func (__ *PoolOfByteThenRuneImpl) PutRuneReturn(p *rune) {
	__.RuneRtn.Put(p)
}

func (__ *PoolOfByteThenRuneImpl) GetWorkOfByteThenRune() *WorkOfByteThenRune {
	return __.ByteWork.Get().(*WorkOfByteThenRune)
}
func (__ *PoolOfByteThenRuneImpl) PutWorkOfByteThenRune(p *WorkOfByteThenRune) {
	__.ByteWork.Put(p)
}
func (__ *PoolOfByteThenRuneImpl) GetReturnOfRune() *ReturnOfRune {
	return __.RuneReturn.Get().(*ReturnOfRune)
}
func (__ *PoolOfByteThenRuneImpl) PutReturnOfRune(p *ReturnOfRune) {
	__.RuneReturn.Put(p)
}

func (__ *PoolOfByteThenRuneImpl) GetChReturnOfRune() chan *ReturnOfRune {
	return __.ChReturnOfRune.Get().(chan *ReturnOfRune)
}
func (__ *PoolOfByteThenRuneImpl) PutChReturnOfRune(p chan *ReturnOfRune) {
	__.ChReturnOfRune.Put(p)
}

func NewPoolOfByteThenRuneImpl() *PoolOfByteThenRuneImpl {
	return &PoolOfByteThenRuneImpl{
		ByteArg: sync.Pool{
			New: func() interface{} {
				return new(byte)
			},
		},
		ByteWork: sync.Pool{
			New: func() interface{} {
				return new(WorkOfByteThenRune)
			},
		},
		RuneRtn: sync.Pool{
			New: func() interface{} {
				return new(rune)
			},
		},
		RuneReturn: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfRune)
			},
		},
		ChReturnOfRune: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfRune, 1)
			},
		},
	}
}

type ApiDecouplerOfByteThenRune struct {
	pool PoolOfByteThenRune
}

func NewApiDecouplerOfByteThenRune() *ApiDecouplerOfByteThenRune {
	return &ApiDecouplerOfByteThenRune{
		pool: NewPoolOfByteThenRuneImpl(),
	}
}

func (__ *ApiDecouplerOfByteThenRune) ReturnError(rtn_ch chan<- *ReturnOfRune, err error) {
	rtn := __.pool.GetReturnOfRune()
	var other rune
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfByteThenRune) HandleOfByteThenRune(ctx context.Context, req *WorkOfByteThenRune, h func(ctx context.Context, arg byte) (rune, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfRune()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfByteThenRune) DoOfByteThenRune(ctx context.Context, worker WorkerOfPushByteThenRune, arg byte) (rune, error) {
	// ch := make(chan *ReturnOfRune, 1)
	ch := __.pool.GetChReturnOfRune()
	defer __.pool.PutChReturnOfRune(ch)

	req := __.pool.GetWorkOfByteThenRune()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfByteThenRune(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfRune(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfByteThenRune = func(ctx context.Context, arg byte) (rune, error)

type WorkerOfByteThenRune struct {
	api_syncer *ApiDecouplerOfByteThenRune
	handler    WorkHandlerOfByteThenRune

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfByteThenRune
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfByteThenRune(ctx context.Context, h WorkHandlerOfByteThenRune, n int) *WorkerOfByteThenRune {
	__ := &WorkerOfByteThenRune{
		api_syncer: NewApiDecouplerOfByteThenRune(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfByteThenRune, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfByteThenRune{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfByteThenRune(req.Context, req.WorkOfByteThenRune, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfByteThenRune) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfByteThenRune) Push(ctx context.Context, req *WorkOfByteThenRune) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfByteThenRune)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfByteThenRune = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfByteThenRune) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfByteThenRune) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfByteThenRune) Call(ctx context.Context, arg byte) (rune, error) {
	return __.api_syncer.DoOfByteThenRune(ctx, __, arg)
}

type PoolOfByteThenString interface {
	GetByteArg() *byte
	PutByteArg(*byte)
	GetStringReturn() *string
	PutStringReturn(*string)

	GetWorkOfByteThenString() *WorkOfByteThenString
	GetReturnOfString() *ReturnOfString
	PutWorkOfByteThenString(*WorkOfByteThenString)
	PutReturnOfString(*ReturnOfString)

	GetChReturnOfString() chan *ReturnOfString
	PutChReturnOfString(chan *ReturnOfString)
}

type PoolOfByteThenStringImpl struct {
	ByteArg          sync.Pool
	StringRtn        sync.Pool
	ByteWork         sync.Pool
	StringReturn     sync.Pool
	ChReturnOfString sync.Pool
}

func (__ *PoolOfByteThenStringImpl) GetByteArg() *byte {
	return __.ByteArg.Get().(*byte)
}
func (__ *PoolOfByteThenStringImpl) PutByteArg(p *byte) {
	__.ByteArg.Put(p)
}
func (__ *PoolOfByteThenStringImpl) GetStringReturn() *string {
	return __.StringRtn.Get().(*string)
}
func (__ *PoolOfByteThenStringImpl) PutStringReturn(p *string) {
	__.StringRtn.Put(p)
}

func (__ *PoolOfByteThenStringImpl) GetWorkOfByteThenString() *WorkOfByteThenString {
	return __.ByteWork.Get().(*WorkOfByteThenString)
}
func (__ *PoolOfByteThenStringImpl) PutWorkOfByteThenString(p *WorkOfByteThenString) {
	__.ByteWork.Put(p)
}
func (__ *PoolOfByteThenStringImpl) GetReturnOfString() *ReturnOfString {
	return __.StringReturn.Get().(*ReturnOfString)
}
func (__ *PoolOfByteThenStringImpl) PutReturnOfString(p *ReturnOfString) {
	__.StringReturn.Put(p)
}

func (__ *PoolOfByteThenStringImpl) GetChReturnOfString() chan *ReturnOfString {
	return __.ChReturnOfString.Get().(chan *ReturnOfString)
}
func (__ *PoolOfByteThenStringImpl) PutChReturnOfString(p chan *ReturnOfString) {
	__.ChReturnOfString.Put(p)
}

func NewPoolOfByteThenStringImpl() *PoolOfByteThenStringImpl {
	return &PoolOfByteThenStringImpl{
		ByteArg: sync.Pool{
			New: func() interface{} {
				return new(byte)
			},
		},
		ByteWork: sync.Pool{
			New: func() interface{} {
				return new(WorkOfByteThenString)
			},
		},
		StringRtn: sync.Pool{
			New: func() interface{} {
				return new(string)
			},
		},
		StringReturn: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfString)
			},
		},
		ChReturnOfString: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfString, 1)
			},
		},
	}
}

type ApiDecouplerOfByteThenString struct {
	pool PoolOfByteThenString
}

func NewApiDecouplerOfByteThenString() *ApiDecouplerOfByteThenString {
	return &ApiDecouplerOfByteThenString{
		pool: NewPoolOfByteThenStringImpl(),
	}
}

func (__ *ApiDecouplerOfByteThenString) ReturnError(rtn_ch chan<- *ReturnOfString, err error) {
	rtn := __.pool.GetReturnOfString()
	var other string
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfByteThenString) HandleOfByteThenString(ctx context.Context, req *WorkOfByteThenString, h func(ctx context.Context, arg byte) (string, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfString()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfByteThenString) DoOfByteThenString(ctx context.Context, worker WorkerOfPushByteThenString, arg byte) (string, error) {
	// ch := make(chan *ReturnOfString, 1)
	ch := __.pool.GetChReturnOfString()
	defer __.pool.PutChReturnOfString(ch)

	req := __.pool.GetWorkOfByteThenString()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfByteThenString(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfString(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfByteThenString = func(ctx context.Context, arg byte) (string, error)

type WorkerOfByteThenString struct {
	api_syncer *ApiDecouplerOfByteThenString
	handler    WorkHandlerOfByteThenString

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfByteThenString
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfByteThenString(ctx context.Context, h WorkHandlerOfByteThenString, n int) *WorkerOfByteThenString {
	__ := &WorkerOfByteThenString{
		api_syncer: NewApiDecouplerOfByteThenString(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfByteThenString, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfByteThenString{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfByteThenString(req.Context, req.WorkOfByteThenString, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfByteThenString) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfByteThenString) Push(ctx context.Context, req *WorkOfByteThenString) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfByteThenString)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfByteThenString = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfByteThenString) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfByteThenString) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfByteThenString) Call(ctx context.Context, arg byte) (string, error) {
	return __.api_syncer.DoOfByteThenString(ctx, __, arg)
}

type PoolOfByteThenUint interface {
	GetByteArg() *byte
	PutByteArg(*byte)
	GetUintReturn() *uint
	PutUintReturn(*uint)

	GetWorkOfByteThenUint() *WorkOfByteThenUint
	GetReturnOfUint() *ReturnOfUint
	PutWorkOfByteThenUint(*WorkOfByteThenUint)
	PutReturnOfUint(*ReturnOfUint)

	GetChReturnOfUint() chan *ReturnOfUint
	PutChReturnOfUint(chan *ReturnOfUint)
}

type PoolOfByteThenUintImpl struct {
	ByteArg        sync.Pool
	UintRtn        sync.Pool
	ByteWork       sync.Pool
	UintReturn     sync.Pool
	ChReturnOfUint sync.Pool
}

func (__ *PoolOfByteThenUintImpl) GetByteArg() *byte {
	return __.ByteArg.Get().(*byte)
}
func (__ *PoolOfByteThenUintImpl) PutByteArg(p *byte) {
	__.ByteArg.Put(p)
}
func (__ *PoolOfByteThenUintImpl) GetUintReturn() *uint {
	return __.UintRtn.Get().(*uint)
}
func (__ *PoolOfByteThenUintImpl) PutUintReturn(p *uint) {
	__.UintRtn.Put(p)
}

func (__ *PoolOfByteThenUintImpl) GetWorkOfByteThenUint() *WorkOfByteThenUint {
	return __.ByteWork.Get().(*WorkOfByteThenUint)
}
func (__ *PoolOfByteThenUintImpl) PutWorkOfByteThenUint(p *WorkOfByteThenUint) {
	__.ByteWork.Put(p)
}
func (__ *PoolOfByteThenUintImpl) GetReturnOfUint() *ReturnOfUint {
	return __.UintReturn.Get().(*ReturnOfUint)
}
func (__ *PoolOfByteThenUintImpl) PutReturnOfUint(p *ReturnOfUint) {
	__.UintReturn.Put(p)
}

func (__ *PoolOfByteThenUintImpl) GetChReturnOfUint() chan *ReturnOfUint {
	return __.ChReturnOfUint.Get().(chan *ReturnOfUint)
}
func (__ *PoolOfByteThenUintImpl) PutChReturnOfUint(p chan *ReturnOfUint) {
	__.ChReturnOfUint.Put(p)
}

func NewPoolOfByteThenUintImpl() *PoolOfByteThenUintImpl {
	return &PoolOfByteThenUintImpl{
		ByteArg: sync.Pool{
			New: func() interface{} {
				return new(byte)
			},
		},
		ByteWork: sync.Pool{
			New: func() interface{} {
				return new(WorkOfByteThenUint)
			},
		},
		UintRtn: sync.Pool{
			New: func() interface{} {
				return new(uint)
			},
		},
		UintReturn: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfUint)
			},
		},
		ChReturnOfUint: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfUint, 1)
			},
		},
	}
}

type ApiDecouplerOfByteThenUint struct {
	pool PoolOfByteThenUint
}

func NewApiDecouplerOfByteThenUint() *ApiDecouplerOfByteThenUint {
	return &ApiDecouplerOfByteThenUint{
		pool: NewPoolOfByteThenUintImpl(),
	}
}

func (__ *ApiDecouplerOfByteThenUint) ReturnError(rtn_ch chan<- *ReturnOfUint, err error) {
	rtn := __.pool.GetReturnOfUint()
	var other uint
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfByteThenUint) HandleOfByteThenUint(ctx context.Context, req *WorkOfByteThenUint, h func(ctx context.Context, arg byte) (uint, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfUint()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfByteThenUint) DoOfByteThenUint(ctx context.Context, worker WorkerOfPushByteThenUint, arg byte) (uint, error) {
	// ch := make(chan *ReturnOfUint, 1)
	ch := __.pool.GetChReturnOfUint()
	defer __.pool.PutChReturnOfUint(ch)

	req := __.pool.GetWorkOfByteThenUint()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfByteThenUint(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfUint(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfByteThenUint = func(ctx context.Context, arg byte) (uint, error)

type WorkerOfByteThenUint struct {
	api_syncer *ApiDecouplerOfByteThenUint
	handler    WorkHandlerOfByteThenUint

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfByteThenUint
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfByteThenUint(ctx context.Context, h WorkHandlerOfByteThenUint, n int) *WorkerOfByteThenUint {
	__ := &WorkerOfByteThenUint{
		api_syncer: NewApiDecouplerOfByteThenUint(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfByteThenUint, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfByteThenUint{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfByteThenUint(req.Context, req.WorkOfByteThenUint, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfByteThenUint) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfByteThenUint) Push(ctx context.Context, req *WorkOfByteThenUint) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfByteThenUint)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfByteThenUint = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfByteThenUint) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfByteThenUint) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfByteThenUint) Call(ctx context.Context, arg byte) (uint, error) {
	return __.api_syncer.DoOfByteThenUint(ctx, __, arg)
}

type PoolOfByteThenUint16 interface {
	GetByteArg() *byte
	PutByteArg(*byte)
	GetUint16Return() *uint16
	PutUint16Return(*uint16)

	GetWorkOfByteThenUint16() *WorkOfByteThenUint16
	GetReturnOfUint16() *ReturnOfUint16
	PutWorkOfByteThenUint16(*WorkOfByteThenUint16)
	PutReturnOfUint16(*ReturnOfUint16)

	GetChReturnOfUint16() chan *ReturnOfUint16
	PutChReturnOfUint16(chan *ReturnOfUint16)
}

type PoolOfByteThenUint16Impl struct {
	ByteArg          sync.Pool
	Uint16Rtn        sync.Pool
	ByteWork         sync.Pool
	Uint16Return     sync.Pool
	ChReturnOfUint16 sync.Pool
}

func (__ *PoolOfByteThenUint16Impl) GetByteArg() *byte {
	return __.ByteArg.Get().(*byte)
}
func (__ *PoolOfByteThenUint16Impl) PutByteArg(p *byte) {
	__.ByteArg.Put(p)
}
func (__ *PoolOfByteThenUint16Impl) GetUint16Return() *uint16 {
	return __.Uint16Rtn.Get().(*uint16)
}
func (__ *PoolOfByteThenUint16Impl) PutUint16Return(p *uint16) {
	__.Uint16Rtn.Put(p)
}

func (__ *PoolOfByteThenUint16Impl) GetWorkOfByteThenUint16() *WorkOfByteThenUint16 {
	return __.ByteWork.Get().(*WorkOfByteThenUint16)
}
func (__ *PoolOfByteThenUint16Impl) PutWorkOfByteThenUint16(p *WorkOfByteThenUint16) {
	__.ByteWork.Put(p)
}
func (__ *PoolOfByteThenUint16Impl) GetReturnOfUint16() *ReturnOfUint16 {
	return __.Uint16Return.Get().(*ReturnOfUint16)
}
func (__ *PoolOfByteThenUint16Impl) PutReturnOfUint16(p *ReturnOfUint16) {
	__.Uint16Return.Put(p)
}

func (__ *PoolOfByteThenUint16Impl) GetChReturnOfUint16() chan *ReturnOfUint16 {
	return __.ChReturnOfUint16.Get().(chan *ReturnOfUint16)
}
func (__ *PoolOfByteThenUint16Impl) PutChReturnOfUint16(p chan *ReturnOfUint16) {
	__.ChReturnOfUint16.Put(p)
}

func NewPoolOfByteThenUint16Impl() *PoolOfByteThenUint16Impl {
	return &PoolOfByteThenUint16Impl{
		ByteArg: sync.Pool{
			New: func() interface{} {
				return new(byte)
			},
		},
		ByteWork: sync.Pool{
			New: func() interface{} {
				return new(WorkOfByteThenUint16)
			},
		},
		Uint16Rtn: sync.Pool{
			New: func() interface{} {
				return new(uint16)
			},
		},
		Uint16Return: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfUint16)
			},
		},
		ChReturnOfUint16: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfUint16, 1)
			},
		},
	}
}

type ApiDecouplerOfByteThenUint16 struct {
	pool PoolOfByteThenUint16
}

func NewApiDecouplerOfByteThenUint16() *ApiDecouplerOfByteThenUint16 {
	return &ApiDecouplerOfByteThenUint16{
		pool: NewPoolOfByteThenUint16Impl(),
	}
}

func (__ *ApiDecouplerOfByteThenUint16) ReturnError(rtn_ch chan<- *ReturnOfUint16, err error) {
	rtn := __.pool.GetReturnOfUint16()
	var other uint16
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfByteThenUint16) HandleOfByteThenUint16(ctx context.Context, req *WorkOfByteThenUint16, h func(ctx context.Context, arg byte) (uint16, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfUint16()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfByteThenUint16) DoOfByteThenUint16(ctx context.Context, worker WorkerOfPushByteThenUint16, arg byte) (uint16, error) {
	// ch := make(chan *ReturnOfUint16, 1)
	ch := __.pool.GetChReturnOfUint16()
	defer __.pool.PutChReturnOfUint16(ch)

	req := __.pool.GetWorkOfByteThenUint16()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfByteThenUint16(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfUint16(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfByteThenUint16 = func(ctx context.Context, arg byte) (uint16, error)

type WorkerOfByteThenUint16 struct {
	api_syncer *ApiDecouplerOfByteThenUint16
	handler    WorkHandlerOfByteThenUint16

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfByteThenUint16
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfByteThenUint16(ctx context.Context, h WorkHandlerOfByteThenUint16, n int) *WorkerOfByteThenUint16 {
	__ := &WorkerOfByteThenUint16{
		api_syncer: NewApiDecouplerOfByteThenUint16(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfByteThenUint16, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfByteThenUint16{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfByteThenUint16(req.Context, req.WorkOfByteThenUint16, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfByteThenUint16) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfByteThenUint16) Push(ctx context.Context, req *WorkOfByteThenUint16) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfByteThenUint16)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfByteThenUint16 = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfByteThenUint16) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfByteThenUint16) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfByteThenUint16) Call(ctx context.Context, arg byte) (uint16, error) {
	return __.api_syncer.DoOfByteThenUint16(ctx, __, arg)
}

type PoolOfByteThenUint32 interface {
	GetByteArg() *byte
	PutByteArg(*byte)
	GetUint32Return() *uint32
	PutUint32Return(*uint32)

	GetWorkOfByteThenUint32() *WorkOfByteThenUint32
	GetReturnOfUint32() *ReturnOfUint32
	PutWorkOfByteThenUint32(*WorkOfByteThenUint32)
	PutReturnOfUint32(*ReturnOfUint32)

	GetChReturnOfUint32() chan *ReturnOfUint32
	PutChReturnOfUint32(chan *ReturnOfUint32)
}

type PoolOfByteThenUint32Impl struct {
	ByteArg          sync.Pool
	Uint32Rtn        sync.Pool
	ByteWork         sync.Pool
	Uint32Return     sync.Pool
	ChReturnOfUint32 sync.Pool
}

func (__ *PoolOfByteThenUint32Impl) GetByteArg() *byte {
	return __.ByteArg.Get().(*byte)
}
func (__ *PoolOfByteThenUint32Impl) PutByteArg(p *byte) {
	__.ByteArg.Put(p)
}
func (__ *PoolOfByteThenUint32Impl) GetUint32Return() *uint32 {
	return __.Uint32Rtn.Get().(*uint32)
}
func (__ *PoolOfByteThenUint32Impl) PutUint32Return(p *uint32) {
	__.Uint32Rtn.Put(p)
}

func (__ *PoolOfByteThenUint32Impl) GetWorkOfByteThenUint32() *WorkOfByteThenUint32 {
	return __.ByteWork.Get().(*WorkOfByteThenUint32)
}
func (__ *PoolOfByteThenUint32Impl) PutWorkOfByteThenUint32(p *WorkOfByteThenUint32) {
	__.ByteWork.Put(p)
}
func (__ *PoolOfByteThenUint32Impl) GetReturnOfUint32() *ReturnOfUint32 {
	return __.Uint32Return.Get().(*ReturnOfUint32)
}
func (__ *PoolOfByteThenUint32Impl) PutReturnOfUint32(p *ReturnOfUint32) {
	__.Uint32Return.Put(p)
}

func (__ *PoolOfByteThenUint32Impl) GetChReturnOfUint32() chan *ReturnOfUint32 {
	return __.ChReturnOfUint32.Get().(chan *ReturnOfUint32)
}
func (__ *PoolOfByteThenUint32Impl) PutChReturnOfUint32(p chan *ReturnOfUint32) {
	__.ChReturnOfUint32.Put(p)
}

func NewPoolOfByteThenUint32Impl() *PoolOfByteThenUint32Impl {
	return &PoolOfByteThenUint32Impl{
		ByteArg: sync.Pool{
			New: func() interface{} {
				return new(byte)
			},
		},
		ByteWork: sync.Pool{
			New: func() interface{} {
				return new(WorkOfByteThenUint32)
			},
		},
		Uint32Rtn: sync.Pool{
			New: func() interface{} {
				return new(uint32)
			},
		},
		Uint32Return: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfUint32)
			},
		},
		ChReturnOfUint32: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfUint32, 1)
			},
		},
	}
}

type ApiDecouplerOfByteThenUint32 struct {
	pool PoolOfByteThenUint32
}

func NewApiDecouplerOfByteThenUint32() *ApiDecouplerOfByteThenUint32 {
	return &ApiDecouplerOfByteThenUint32{
		pool: NewPoolOfByteThenUint32Impl(),
	}
}

func (__ *ApiDecouplerOfByteThenUint32) ReturnError(rtn_ch chan<- *ReturnOfUint32, err error) {
	rtn := __.pool.GetReturnOfUint32()
	var other uint32
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfByteThenUint32) HandleOfByteThenUint32(ctx context.Context, req *WorkOfByteThenUint32, h func(ctx context.Context, arg byte) (uint32, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfUint32()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfByteThenUint32) DoOfByteThenUint32(ctx context.Context, worker WorkerOfPushByteThenUint32, arg byte) (uint32, error) {
	// ch := make(chan *ReturnOfUint32, 1)
	ch := __.pool.GetChReturnOfUint32()
	defer __.pool.PutChReturnOfUint32(ch)

	req := __.pool.GetWorkOfByteThenUint32()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfByteThenUint32(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfUint32(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfByteThenUint32 = func(ctx context.Context, arg byte) (uint32, error)

type WorkerOfByteThenUint32 struct {
	api_syncer *ApiDecouplerOfByteThenUint32
	handler    WorkHandlerOfByteThenUint32

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfByteThenUint32
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfByteThenUint32(ctx context.Context, h WorkHandlerOfByteThenUint32, n int) *WorkerOfByteThenUint32 {
	__ := &WorkerOfByteThenUint32{
		api_syncer: NewApiDecouplerOfByteThenUint32(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfByteThenUint32, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfByteThenUint32{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfByteThenUint32(req.Context, req.WorkOfByteThenUint32, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfByteThenUint32) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfByteThenUint32) Push(ctx context.Context, req *WorkOfByteThenUint32) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfByteThenUint32)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfByteThenUint32 = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfByteThenUint32) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfByteThenUint32) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfByteThenUint32) Call(ctx context.Context, arg byte) (uint32, error) {
	return __.api_syncer.DoOfByteThenUint32(ctx, __, arg)
}

type PoolOfByteThenUint64 interface {
	GetByteArg() *byte
	PutByteArg(*byte)
	GetUint64Return() *uint64
	PutUint64Return(*uint64)

	GetWorkOfByteThenUint64() *WorkOfByteThenUint64
	GetReturnOfUint64() *ReturnOfUint64
	PutWorkOfByteThenUint64(*WorkOfByteThenUint64)
	PutReturnOfUint64(*ReturnOfUint64)

	GetChReturnOfUint64() chan *ReturnOfUint64
	PutChReturnOfUint64(chan *ReturnOfUint64)
}

type PoolOfByteThenUint64Impl struct {
	ByteArg          sync.Pool
	Uint64Rtn        sync.Pool
	ByteWork         sync.Pool
	Uint64Return     sync.Pool
	ChReturnOfUint64 sync.Pool
}

func (__ *PoolOfByteThenUint64Impl) GetByteArg() *byte {
	return __.ByteArg.Get().(*byte)
}
func (__ *PoolOfByteThenUint64Impl) PutByteArg(p *byte) {
	__.ByteArg.Put(p)
}
func (__ *PoolOfByteThenUint64Impl) GetUint64Return() *uint64 {
	return __.Uint64Rtn.Get().(*uint64)
}
func (__ *PoolOfByteThenUint64Impl) PutUint64Return(p *uint64) {
	__.Uint64Rtn.Put(p)
}

func (__ *PoolOfByteThenUint64Impl) GetWorkOfByteThenUint64() *WorkOfByteThenUint64 {
	return __.ByteWork.Get().(*WorkOfByteThenUint64)
}
func (__ *PoolOfByteThenUint64Impl) PutWorkOfByteThenUint64(p *WorkOfByteThenUint64) {
	__.ByteWork.Put(p)
}
func (__ *PoolOfByteThenUint64Impl) GetReturnOfUint64() *ReturnOfUint64 {
	return __.Uint64Return.Get().(*ReturnOfUint64)
}
func (__ *PoolOfByteThenUint64Impl) PutReturnOfUint64(p *ReturnOfUint64) {
	__.Uint64Return.Put(p)
}

func (__ *PoolOfByteThenUint64Impl) GetChReturnOfUint64() chan *ReturnOfUint64 {
	return __.ChReturnOfUint64.Get().(chan *ReturnOfUint64)
}
func (__ *PoolOfByteThenUint64Impl) PutChReturnOfUint64(p chan *ReturnOfUint64) {
	__.ChReturnOfUint64.Put(p)
}

func NewPoolOfByteThenUint64Impl() *PoolOfByteThenUint64Impl {
	return &PoolOfByteThenUint64Impl{
		ByteArg: sync.Pool{
			New: func() interface{} {
				return new(byte)
			},
		},
		ByteWork: sync.Pool{
			New: func() interface{} {
				return new(WorkOfByteThenUint64)
			},
		},
		Uint64Rtn: sync.Pool{
			New: func() interface{} {
				return new(uint64)
			},
		},
		Uint64Return: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfUint64)
			},
		},
		ChReturnOfUint64: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfUint64, 1)
			},
		},
	}
}

type ApiDecouplerOfByteThenUint64 struct {
	pool PoolOfByteThenUint64
}

func NewApiDecouplerOfByteThenUint64() *ApiDecouplerOfByteThenUint64 {
	return &ApiDecouplerOfByteThenUint64{
		pool: NewPoolOfByteThenUint64Impl(),
	}
}

func (__ *ApiDecouplerOfByteThenUint64) ReturnError(rtn_ch chan<- *ReturnOfUint64, err error) {
	rtn := __.pool.GetReturnOfUint64()
	var other uint64
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfByteThenUint64) HandleOfByteThenUint64(ctx context.Context, req *WorkOfByteThenUint64, h func(ctx context.Context, arg byte) (uint64, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfUint64()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfByteThenUint64) DoOfByteThenUint64(ctx context.Context, worker WorkerOfPushByteThenUint64, arg byte) (uint64, error) {
	// ch := make(chan *ReturnOfUint64, 1)
	ch := __.pool.GetChReturnOfUint64()
	defer __.pool.PutChReturnOfUint64(ch)

	req := __.pool.GetWorkOfByteThenUint64()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfByteThenUint64(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfUint64(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfByteThenUint64 = func(ctx context.Context, arg byte) (uint64, error)

type WorkerOfByteThenUint64 struct {
	api_syncer *ApiDecouplerOfByteThenUint64
	handler    WorkHandlerOfByteThenUint64

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfByteThenUint64
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfByteThenUint64(ctx context.Context, h WorkHandlerOfByteThenUint64, n int) *WorkerOfByteThenUint64 {
	__ := &WorkerOfByteThenUint64{
		api_syncer: NewApiDecouplerOfByteThenUint64(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfByteThenUint64, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfByteThenUint64{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfByteThenUint64(req.Context, req.WorkOfByteThenUint64, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfByteThenUint64) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfByteThenUint64) Push(ctx context.Context, req *WorkOfByteThenUint64) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfByteThenUint64)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfByteThenUint64 = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfByteThenUint64) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfByteThenUint64) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfByteThenUint64) Call(ctx context.Context, arg byte) (uint64, error) {
	return __.api_syncer.DoOfByteThenUint64(ctx, __, arg)
}

type PoolOfByteThenUint8 interface {
	GetByteArg() *byte
	PutByteArg(*byte)
	GetUint8Return() *uint8
	PutUint8Return(*uint8)

	GetWorkOfByteThenUint8() *WorkOfByteThenUint8
	GetReturnOfUint8() *ReturnOfUint8
	PutWorkOfByteThenUint8(*WorkOfByteThenUint8)
	PutReturnOfUint8(*ReturnOfUint8)

	GetChReturnOfUint8() chan *ReturnOfUint8
	PutChReturnOfUint8(chan *ReturnOfUint8)
}

type PoolOfByteThenUint8Impl struct {
	ByteArg         sync.Pool
	Uint8Rtn        sync.Pool
	ByteWork        sync.Pool
	Uint8Return     sync.Pool
	ChReturnOfUint8 sync.Pool
}

func (__ *PoolOfByteThenUint8Impl) GetByteArg() *byte {
	return __.ByteArg.Get().(*byte)
}
func (__ *PoolOfByteThenUint8Impl) PutByteArg(p *byte) {
	__.ByteArg.Put(p)
}
func (__ *PoolOfByteThenUint8Impl) GetUint8Return() *uint8 {
	return __.Uint8Rtn.Get().(*uint8)
}
func (__ *PoolOfByteThenUint8Impl) PutUint8Return(p *uint8) {
	__.Uint8Rtn.Put(p)
}

func (__ *PoolOfByteThenUint8Impl) GetWorkOfByteThenUint8() *WorkOfByteThenUint8 {
	return __.ByteWork.Get().(*WorkOfByteThenUint8)
}
func (__ *PoolOfByteThenUint8Impl) PutWorkOfByteThenUint8(p *WorkOfByteThenUint8) {
	__.ByteWork.Put(p)
}
func (__ *PoolOfByteThenUint8Impl) GetReturnOfUint8() *ReturnOfUint8 {
	return __.Uint8Return.Get().(*ReturnOfUint8)
}
func (__ *PoolOfByteThenUint8Impl) PutReturnOfUint8(p *ReturnOfUint8) {
	__.Uint8Return.Put(p)
}

func (__ *PoolOfByteThenUint8Impl) GetChReturnOfUint8() chan *ReturnOfUint8 {
	return __.ChReturnOfUint8.Get().(chan *ReturnOfUint8)
}
func (__ *PoolOfByteThenUint8Impl) PutChReturnOfUint8(p chan *ReturnOfUint8) {
	__.ChReturnOfUint8.Put(p)
}

func NewPoolOfByteThenUint8Impl() *PoolOfByteThenUint8Impl {
	return &PoolOfByteThenUint8Impl{
		ByteArg: sync.Pool{
			New: func() interface{} {
				return new(byte)
			},
		},
		ByteWork: sync.Pool{
			New: func() interface{} {
				return new(WorkOfByteThenUint8)
			},
		},
		Uint8Rtn: sync.Pool{
			New: func() interface{} {
				return new(uint8)
			},
		},
		Uint8Return: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfUint8)
			},
		},
		ChReturnOfUint8: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfUint8, 1)
			},
		},
	}
}

type ApiDecouplerOfByteThenUint8 struct {
	pool PoolOfByteThenUint8
}

func NewApiDecouplerOfByteThenUint8() *ApiDecouplerOfByteThenUint8 {
	return &ApiDecouplerOfByteThenUint8{
		pool: NewPoolOfByteThenUint8Impl(),
	}
}

func (__ *ApiDecouplerOfByteThenUint8) ReturnError(rtn_ch chan<- *ReturnOfUint8, err error) {
	rtn := __.pool.GetReturnOfUint8()
	var other uint8
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfByteThenUint8) HandleOfByteThenUint8(ctx context.Context, req *WorkOfByteThenUint8, h func(ctx context.Context, arg byte) (uint8, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfUint8()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfByteThenUint8) DoOfByteThenUint8(ctx context.Context, worker WorkerOfPushByteThenUint8, arg byte) (uint8, error) {
	// ch := make(chan *ReturnOfUint8, 1)
	ch := __.pool.GetChReturnOfUint8()
	defer __.pool.PutChReturnOfUint8(ch)

	req := __.pool.GetWorkOfByteThenUint8()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfByteThenUint8(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfUint8(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfByteThenUint8 = func(ctx context.Context, arg byte) (uint8, error)

type WorkerOfByteThenUint8 struct {
	api_syncer *ApiDecouplerOfByteThenUint8
	handler    WorkHandlerOfByteThenUint8

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfByteThenUint8
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfByteThenUint8(ctx context.Context, h WorkHandlerOfByteThenUint8, n int) *WorkerOfByteThenUint8 {
	__ := &WorkerOfByteThenUint8{
		api_syncer: NewApiDecouplerOfByteThenUint8(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfByteThenUint8, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfByteThenUint8{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfByteThenUint8(req.Context, req.WorkOfByteThenUint8, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfByteThenUint8) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfByteThenUint8) Push(ctx context.Context, req *WorkOfByteThenUint8) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfByteThenUint8)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfByteThenUint8 = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfByteThenUint8) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfByteThenUint8) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfByteThenUint8) Call(ctx context.Context, arg byte) (uint8, error) {
	return __.api_syncer.DoOfByteThenUint8(ctx, __, arg)
}

type PoolOfByteThenUintptr interface {
	GetByteArg() *byte
	PutByteArg(*byte)
	GetUintptrReturn() *uintptr
	PutUintptrReturn(*uintptr)

	GetWorkOfByteThenUintptr() *WorkOfByteThenUintptr
	GetReturnOfUintptr() *ReturnOfUintptr
	PutWorkOfByteThenUintptr(*WorkOfByteThenUintptr)
	PutReturnOfUintptr(*ReturnOfUintptr)

	GetChReturnOfUintptr() chan *ReturnOfUintptr
	PutChReturnOfUintptr(chan *ReturnOfUintptr)
}

type PoolOfByteThenUintptrImpl struct {
	ByteArg           sync.Pool
	UintptrRtn        sync.Pool
	ByteWork          sync.Pool
	UintptrReturn     sync.Pool
	ChReturnOfUintptr sync.Pool
}

func (__ *PoolOfByteThenUintptrImpl) GetByteArg() *byte {
	return __.ByteArg.Get().(*byte)
}
func (__ *PoolOfByteThenUintptrImpl) PutByteArg(p *byte) {
	__.ByteArg.Put(p)
}
func (__ *PoolOfByteThenUintptrImpl) GetUintptrReturn() *uintptr {
	return __.UintptrRtn.Get().(*uintptr)
}
func (__ *PoolOfByteThenUintptrImpl) PutUintptrReturn(p *uintptr) {
	__.UintptrRtn.Put(p)
}

func (__ *PoolOfByteThenUintptrImpl) GetWorkOfByteThenUintptr() *WorkOfByteThenUintptr {
	return __.ByteWork.Get().(*WorkOfByteThenUintptr)
}
func (__ *PoolOfByteThenUintptrImpl) PutWorkOfByteThenUintptr(p *WorkOfByteThenUintptr) {
	__.ByteWork.Put(p)
}
func (__ *PoolOfByteThenUintptrImpl) GetReturnOfUintptr() *ReturnOfUintptr {
	return __.UintptrReturn.Get().(*ReturnOfUintptr)
}
func (__ *PoolOfByteThenUintptrImpl) PutReturnOfUintptr(p *ReturnOfUintptr) {
	__.UintptrReturn.Put(p)
}

func (__ *PoolOfByteThenUintptrImpl) GetChReturnOfUintptr() chan *ReturnOfUintptr {
	return __.ChReturnOfUintptr.Get().(chan *ReturnOfUintptr)
}
func (__ *PoolOfByteThenUintptrImpl) PutChReturnOfUintptr(p chan *ReturnOfUintptr) {
	__.ChReturnOfUintptr.Put(p)
}

func NewPoolOfByteThenUintptrImpl() *PoolOfByteThenUintptrImpl {
	return &PoolOfByteThenUintptrImpl{
		ByteArg: sync.Pool{
			New: func() interface{} {
				return new(byte)
			},
		},
		ByteWork: sync.Pool{
			New: func() interface{} {
				return new(WorkOfByteThenUintptr)
			},
		},
		UintptrRtn: sync.Pool{
			New: func() interface{} {
				return new(uintptr)
			},
		},
		UintptrReturn: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfUintptr)
			},
		},
		ChReturnOfUintptr: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfUintptr, 1)
			},
		},
	}
}

type ApiDecouplerOfByteThenUintptr struct {
	pool PoolOfByteThenUintptr
}

func NewApiDecouplerOfByteThenUintptr() *ApiDecouplerOfByteThenUintptr {
	return &ApiDecouplerOfByteThenUintptr{
		pool: NewPoolOfByteThenUintptrImpl(),
	}
}

func (__ *ApiDecouplerOfByteThenUintptr) ReturnError(rtn_ch chan<- *ReturnOfUintptr, err error) {
	rtn := __.pool.GetReturnOfUintptr()
	var other uintptr
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfByteThenUintptr) HandleOfByteThenUintptr(ctx context.Context, req *WorkOfByteThenUintptr, h func(ctx context.Context, arg byte) (uintptr, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfUintptr()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfByteThenUintptr) DoOfByteThenUintptr(ctx context.Context, worker WorkerOfPushByteThenUintptr, arg byte) (uintptr, error) {
	// ch := make(chan *ReturnOfUintptr, 1)
	ch := __.pool.GetChReturnOfUintptr()
	defer __.pool.PutChReturnOfUintptr(ch)

	req := __.pool.GetWorkOfByteThenUintptr()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfByteThenUintptr(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfUintptr(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfByteThenUintptr = func(ctx context.Context, arg byte) (uintptr, error)

type WorkerOfByteThenUintptr struct {
	api_syncer *ApiDecouplerOfByteThenUintptr
	handler    WorkHandlerOfByteThenUintptr

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfByteThenUintptr
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfByteThenUintptr(ctx context.Context, h WorkHandlerOfByteThenUintptr, n int) *WorkerOfByteThenUintptr {
	__ := &WorkerOfByteThenUintptr{
		api_syncer: NewApiDecouplerOfByteThenUintptr(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfByteThenUintptr, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfByteThenUintptr{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfByteThenUintptr(req.Context, req.WorkOfByteThenUintptr, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfByteThenUintptr) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfByteThenUintptr) Push(ctx context.Context, req *WorkOfByteThenUintptr) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfByteThenUintptr)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfByteThenUintptr = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfByteThenUintptr) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfByteThenUintptr) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfByteThenUintptr) Call(ctx context.Context, arg byte) (uintptr, error) {
	return __.api_syncer.DoOfByteThenUintptr(ctx, __, arg)
}

type PoolOfByteThenInterface interface {
	GetByteArg() *byte
	PutByteArg(*byte)
	GetInterfaceReturn() *interface{}
	PutInterfaceReturn(*interface{})

	GetWorkOfByteThenInterface() *WorkOfByteThenInterface
	GetReturnOfInterface() *ReturnOfInterface
	PutWorkOfByteThenInterface(*WorkOfByteThenInterface)
	PutReturnOfInterface(*ReturnOfInterface)

	GetChReturnOfInterface() chan *ReturnOfInterface
	PutChReturnOfInterface(chan *ReturnOfInterface)
}

type PoolOfByteThenInterfaceImpl struct {
	ByteArg             sync.Pool
	InterfaceRtn        sync.Pool
	ByteWork            sync.Pool
	InterfaceReturn     sync.Pool
	ChReturnOfInterface sync.Pool
}

func (__ *PoolOfByteThenInterfaceImpl) GetByteArg() *byte {
	return __.ByteArg.Get().(*byte)
}
func (__ *PoolOfByteThenInterfaceImpl) PutByteArg(p *byte) {
	__.ByteArg.Put(p)
}
func (__ *PoolOfByteThenInterfaceImpl) GetInterfaceReturn() *interface{} {
	return __.InterfaceRtn.Get().(*interface{})
}
func (__ *PoolOfByteThenInterfaceImpl) PutInterfaceReturn(p *interface{}) {
	__.InterfaceRtn.Put(p)
}

func (__ *PoolOfByteThenInterfaceImpl) GetWorkOfByteThenInterface() *WorkOfByteThenInterface {
	return __.ByteWork.Get().(*WorkOfByteThenInterface)
}
func (__ *PoolOfByteThenInterfaceImpl) PutWorkOfByteThenInterface(p *WorkOfByteThenInterface) {
	__.ByteWork.Put(p)
}
func (__ *PoolOfByteThenInterfaceImpl) GetReturnOfInterface() *ReturnOfInterface {
	return __.InterfaceReturn.Get().(*ReturnOfInterface)
}
func (__ *PoolOfByteThenInterfaceImpl) PutReturnOfInterface(p *ReturnOfInterface) {
	__.InterfaceReturn.Put(p)
}

func (__ *PoolOfByteThenInterfaceImpl) GetChReturnOfInterface() chan *ReturnOfInterface {
	return __.ChReturnOfInterface.Get().(chan *ReturnOfInterface)
}
func (__ *PoolOfByteThenInterfaceImpl) PutChReturnOfInterface(p chan *ReturnOfInterface) {
	__.ChReturnOfInterface.Put(p)
}

func NewPoolOfByteThenInterfaceImpl() *PoolOfByteThenInterfaceImpl {
	return &PoolOfByteThenInterfaceImpl{
		ByteArg: sync.Pool{
			New: func() interface{} {
				return new(byte)
			},
		},
		ByteWork: sync.Pool{
			New: func() interface{} {
				return new(WorkOfByteThenInterface)
			},
		},
		InterfaceRtn: sync.Pool{
			New: func() interface{} {
				return new(interface{})
			},
		},
		InterfaceReturn: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfInterface)
			},
		},
		ChReturnOfInterface: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfInterface, 1)
			},
		},
	}
}

type ApiDecouplerOfByteThenInterface struct {
	pool PoolOfByteThenInterface
}

func NewApiDecouplerOfByteThenInterface() *ApiDecouplerOfByteThenInterface {
	return &ApiDecouplerOfByteThenInterface{
		pool: NewPoolOfByteThenInterfaceImpl(),
	}
}

func (__ *ApiDecouplerOfByteThenInterface) ReturnError(rtn_ch chan<- *ReturnOfInterface, err error) {
	rtn := __.pool.GetReturnOfInterface()
	var other interface{}
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfByteThenInterface) HandleOfByteThenInterface(ctx context.Context, req *WorkOfByteThenInterface, h func(ctx context.Context, arg byte) (interface{}, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfInterface()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfByteThenInterface) DoOfByteThenInterface(ctx context.Context, worker WorkerOfPushByteThenInterface, arg byte) (interface{}, error) {
	// ch := make(chan *ReturnOfInterface, 1)
	ch := __.pool.GetChReturnOfInterface()
	defer __.pool.PutChReturnOfInterface(ch)

	req := __.pool.GetWorkOfByteThenInterface()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfByteThenInterface(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfInterface(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfByteThenInterface = func(ctx context.Context, arg byte) (interface{}, error)

type WorkerOfByteThenInterface struct {
	api_syncer *ApiDecouplerOfByteThenInterface
	handler    WorkHandlerOfByteThenInterface

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfByteThenInterface
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfByteThenInterface(ctx context.Context, h WorkHandlerOfByteThenInterface, n int) *WorkerOfByteThenInterface {
	__ := &WorkerOfByteThenInterface{
		api_syncer: NewApiDecouplerOfByteThenInterface(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfByteThenInterface, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfByteThenInterface{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfByteThenInterface(req.Context, req.WorkOfByteThenInterface, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfByteThenInterface) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfByteThenInterface) Push(ctx context.Context, req *WorkOfByteThenInterface) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfByteThenInterface)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfByteThenInterface = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfByteThenInterface) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfByteThenInterface) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfByteThenInterface) Call(ctx context.Context, arg byte) (interface{}, error) {
	return __.api_syncer.DoOfByteThenInterface(ctx, __, arg)
}

type PoolOfByteThenStruct interface {
	GetByteArg() *byte
	PutByteArg(*byte)
	GetStructReturn() *struct{}
	PutStructReturn(*struct{})

	GetWorkOfByteThenStruct() *WorkOfByteThenStruct
	GetReturnOfStruct() *ReturnOfStruct
	PutWorkOfByteThenStruct(*WorkOfByteThenStruct)
	PutReturnOfStruct(*ReturnOfStruct)

	GetChReturnOfStruct() chan *ReturnOfStruct
	PutChReturnOfStruct(chan *ReturnOfStruct)
}

type PoolOfByteThenStructImpl struct {
	ByteArg          sync.Pool
	StructRtn        sync.Pool
	ByteWork         sync.Pool
	StructReturn     sync.Pool
	ChReturnOfStruct sync.Pool
}

func (__ *PoolOfByteThenStructImpl) GetByteArg() *byte {
	return __.ByteArg.Get().(*byte)
}
func (__ *PoolOfByteThenStructImpl) PutByteArg(p *byte) {
	__.ByteArg.Put(p)
}
func (__ *PoolOfByteThenStructImpl) GetStructReturn() *struct{} {
	return __.StructRtn.Get().(*struct{})
}
func (__ *PoolOfByteThenStructImpl) PutStructReturn(p *struct{}) {
	__.StructRtn.Put(p)
}

func (__ *PoolOfByteThenStructImpl) GetWorkOfByteThenStruct() *WorkOfByteThenStruct {
	return __.ByteWork.Get().(*WorkOfByteThenStruct)
}
func (__ *PoolOfByteThenStructImpl) PutWorkOfByteThenStruct(p *WorkOfByteThenStruct) {
	__.ByteWork.Put(p)
}
func (__ *PoolOfByteThenStructImpl) GetReturnOfStruct() *ReturnOfStruct {
	return __.StructReturn.Get().(*ReturnOfStruct)
}
func (__ *PoolOfByteThenStructImpl) PutReturnOfStruct(p *ReturnOfStruct) {
	__.StructReturn.Put(p)
}

func (__ *PoolOfByteThenStructImpl) GetChReturnOfStruct() chan *ReturnOfStruct {
	return __.ChReturnOfStruct.Get().(chan *ReturnOfStruct)
}
func (__ *PoolOfByteThenStructImpl) PutChReturnOfStruct(p chan *ReturnOfStruct) {
	__.ChReturnOfStruct.Put(p)
}

func NewPoolOfByteThenStructImpl() *PoolOfByteThenStructImpl {
	return &PoolOfByteThenStructImpl{
		ByteArg: sync.Pool{
			New: func() interface{} {
				return new(byte)
			},
		},
		ByteWork: sync.Pool{
			New: func() interface{} {
				return new(WorkOfByteThenStruct)
			},
		},
		StructRtn: sync.Pool{
			New: func() interface{} {
				return new(struct{})
			},
		},
		StructReturn: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfStruct)
			},
		},
		ChReturnOfStruct: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfStruct, 1)
			},
		},
	}
}

type ApiDecouplerOfByteThenStruct struct {
	pool PoolOfByteThenStruct
}

func NewApiDecouplerOfByteThenStruct() *ApiDecouplerOfByteThenStruct {
	return &ApiDecouplerOfByteThenStruct{
		pool: NewPoolOfByteThenStructImpl(),
	}
}

func (__ *ApiDecouplerOfByteThenStruct) ReturnError(rtn_ch chan<- *ReturnOfStruct, err error) {
	rtn := __.pool.GetReturnOfStruct()
	var other struct{}
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfByteThenStruct) HandleOfByteThenStruct(ctx context.Context, req *WorkOfByteThenStruct, h func(ctx context.Context, arg byte) (struct{}, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfStruct()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfByteThenStruct) DoOfByteThenStruct(ctx context.Context, worker WorkerOfPushByteThenStruct, arg byte) (struct{}, error) {
	// ch := make(chan *ReturnOfStruct, 1)
	ch := __.pool.GetChReturnOfStruct()
	defer __.pool.PutChReturnOfStruct(ch)

	req := __.pool.GetWorkOfByteThenStruct()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfByteThenStruct(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfStruct(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfByteThenStruct = func(ctx context.Context, arg byte) (struct{}, error)

type WorkerOfByteThenStruct struct {
	api_syncer *ApiDecouplerOfByteThenStruct
	handler    WorkHandlerOfByteThenStruct

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfByteThenStruct
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfByteThenStruct(ctx context.Context, h WorkHandlerOfByteThenStruct, n int) *WorkerOfByteThenStruct {
	__ := &WorkerOfByteThenStruct{
		api_syncer: NewApiDecouplerOfByteThenStruct(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfByteThenStruct, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfByteThenStruct{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfByteThenStruct(req.Context, req.WorkOfByteThenStruct, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfByteThenStruct) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfByteThenStruct) Push(ctx context.Context, req *WorkOfByteThenStruct) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfByteThenStruct)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfByteThenStruct = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfByteThenStruct) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfByteThenStruct) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfByteThenStruct) Call(ctx context.Context, arg byte) (struct{}, error) {
	return __.api_syncer.DoOfByteThenStruct(ctx, __, arg)
}

type PoolOfComplex128ThenBool interface {
	GetComplex128Arg() *complex128
	PutComplex128Arg(*complex128)
	GetBoolReturn() *bool
	PutBoolReturn(*bool)

	GetWorkOfComplex128ThenBool() *WorkOfComplex128ThenBool
	GetReturnOfBool() *ReturnOfBool
	PutWorkOfComplex128ThenBool(*WorkOfComplex128ThenBool)
	PutReturnOfBool(*ReturnOfBool)

	GetChReturnOfBool() chan *ReturnOfBool
	PutChReturnOfBool(chan *ReturnOfBool)
}

type PoolOfComplex128ThenBoolImpl struct {
	Complex128Arg  sync.Pool
	BoolRtn        sync.Pool
	Complex128Work sync.Pool
	BoolReturn     sync.Pool
	ChReturnOfBool sync.Pool
}

func (__ *PoolOfComplex128ThenBoolImpl) GetComplex128Arg() *complex128 {
	return __.Complex128Arg.Get().(*complex128)
}
func (__ *PoolOfComplex128ThenBoolImpl) PutComplex128Arg(p *complex128) {
	__.Complex128Arg.Put(p)
}
func (__ *PoolOfComplex128ThenBoolImpl) GetBoolReturn() *bool {
	return __.BoolRtn.Get().(*bool)
}
func (__ *PoolOfComplex128ThenBoolImpl) PutBoolReturn(p *bool) {
	__.BoolRtn.Put(p)
}

func (__ *PoolOfComplex128ThenBoolImpl) GetWorkOfComplex128ThenBool() *WorkOfComplex128ThenBool {
	return __.Complex128Work.Get().(*WorkOfComplex128ThenBool)
}
func (__ *PoolOfComplex128ThenBoolImpl) PutWorkOfComplex128ThenBool(p *WorkOfComplex128ThenBool) {
	__.Complex128Work.Put(p)
}
func (__ *PoolOfComplex128ThenBoolImpl) GetReturnOfBool() *ReturnOfBool {
	return __.BoolReturn.Get().(*ReturnOfBool)
}
func (__ *PoolOfComplex128ThenBoolImpl) PutReturnOfBool(p *ReturnOfBool) {
	__.BoolReturn.Put(p)
}

func (__ *PoolOfComplex128ThenBoolImpl) GetChReturnOfBool() chan *ReturnOfBool {
	return __.ChReturnOfBool.Get().(chan *ReturnOfBool)
}
func (__ *PoolOfComplex128ThenBoolImpl) PutChReturnOfBool(p chan *ReturnOfBool) {
	__.ChReturnOfBool.Put(p)
}

func NewPoolOfComplex128ThenBoolImpl() *PoolOfComplex128ThenBoolImpl {
	return &PoolOfComplex128ThenBoolImpl{
		Complex128Arg: sync.Pool{
			New: func() interface{} {
				return new(complex128)
			},
		},
		Complex128Work: sync.Pool{
			New: func() interface{} {
				return new(WorkOfComplex128ThenBool)
			},
		},
		BoolRtn: sync.Pool{
			New: func() interface{} {
				return new(bool)
			},
		},
		BoolReturn: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfBool)
			},
		},
		ChReturnOfBool: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfBool, 1)
			},
		},
	}
}

type ApiDecouplerOfComplex128ThenBool struct {
	pool PoolOfComplex128ThenBool
}

func NewApiDecouplerOfComplex128ThenBool() *ApiDecouplerOfComplex128ThenBool {
	return &ApiDecouplerOfComplex128ThenBool{
		pool: NewPoolOfComplex128ThenBoolImpl(),
	}
}

func (__ *ApiDecouplerOfComplex128ThenBool) ReturnError(rtn_ch chan<- *ReturnOfBool, err error) {
	rtn := __.pool.GetReturnOfBool()
	var other bool
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfComplex128ThenBool) HandleOfComplex128ThenBool(ctx context.Context, req *WorkOfComplex128ThenBool, h func(ctx context.Context, arg complex128) (bool, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfBool()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfComplex128ThenBool) DoOfComplex128ThenBool(ctx context.Context, worker WorkerOfPushComplex128ThenBool, arg complex128) (bool, error) {
	// ch := make(chan *ReturnOfBool, 1)
	ch := __.pool.GetChReturnOfBool()
	defer __.pool.PutChReturnOfBool(ch)

	req := __.pool.GetWorkOfComplex128ThenBool()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfComplex128ThenBool(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfBool(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfComplex128ThenBool = func(ctx context.Context, arg complex128) (bool, error)

type WorkerOfComplex128ThenBool struct {
	api_syncer *ApiDecouplerOfComplex128ThenBool
	handler    WorkHandlerOfComplex128ThenBool

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfComplex128ThenBool
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfComplex128ThenBool(ctx context.Context, h WorkHandlerOfComplex128ThenBool, n int) *WorkerOfComplex128ThenBool {
	__ := &WorkerOfComplex128ThenBool{
		api_syncer: NewApiDecouplerOfComplex128ThenBool(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfComplex128ThenBool, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfComplex128ThenBool{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfComplex128ThenBool(req.Context, req.WorkOfComplex128ThenBool, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfComplex128ThenBool) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfComplex128ThenBool) Push(ctx context.Context, req *WorkOfComplex128ThenBool) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfComplex128ThenBool)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfComplex128ThenBool = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfComplex128ThenBool) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfComplex128ThenBool) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfComplex128ThenBool) Call(ctx context.Context, arg complex128) (bool, error) {
	return __.api_syncer.DoOfComplex128ThenBool(ctx, __, arg)
}

type PoolOfComplex128ThenByte interface {
	GetComplex128Arg() *complex128
	PutComplex128Arg(*complex128)
	GetByteReturn() *byte
	PutByteReturn(*byte)

	GetWorkOfComplex128ThenByte() *WorkOfComplex128ThenByte
	GetReturnOfByte() *ReturnOfByte
	PutWorkOfComplex128ThenByte(*WorkOfComplex128ThenByte)
	PutReturnOfByte(*ReturnOfByte)

	GetChReturnOfByte() chan *ReturnOfByte
	PutChReturnOfByte(chan *ReturnOfByte)
}

type PoolOfComplex128ThenByteImpl struct {
	Complex128Arg  sync.Pool
	ByteRtn        sync.Pool
	Complex128Work sync.Pool
	ByteReturn     sync.Pool
	ChReturnOfByte sync.Pool
}

func (__ *PoolOfComplex128ThenByteImpl) GetComplex128Arg() *complex128 {
	return __.Complex128Arg.Get().(*complex128)
}
func (__ *PoolOfComplex128ThenByteImpl) PutComplex128Arg(p *complex128) {
	__.Complex128Arg.Put(p)
}
func (__ *PoolOfComplex128ThenByteImpl) GetByteReturn() *byte {
	return __.ByteRtn.Get().(*byte)
}
func (__ *PoolOfComplex128ThenByteImpl) PutByteReturn(p *byte) {
	__.ByteRtn.Put(p)
}

func (__ *PoolOfComplex128ThenByteImpl) GetWorkOfComplex128ThenByte() *WorkOfComplex128ThenByte {
	return __.Complex128Work.Get().(*WorkOfComplex128ThenByte)
}
func (__ *PoolOfComplex128ThenByteImpl) PutWorkOfComplex128ThenByte(p *WorkOfComplex128ThenByte) {
	__.Complex128Work.Put(p)
}
func (__ *PoolOfComplex128ThenByteImpl) GetReturnOfByte() *ReturnOfByte {
	return __.ByteReturn.Get().(*ReturnOfByte)
}
func (__ *PoolOfComplex128ThenByteImpl) PutReturnOfByte(p *ReturnOfByte) {
	__.ByteReturn.Put(p)
}

func (__ *PoolOfComplex128ThenByteImpl) GetChReturnOfByte() chan *ReturnOfByte {
	return __.ChReturnOfByte.Get().(chan *ReturnOfByte)
}
func (__ *PoolOfComplex128ThenByteImpl) PutChReturnOfByte(p chan *ReturnOfByte) {
	__.ChReturnOfByte.Put(p)
}

func NewPoolOfComplex128ThenByteImpl() *PoolOfComplex128ThenByteImpl {
	return &PoolOfComplex128ThenByteImpl{
		Complex128Arg: sync.Pool{
			New: func() interface{} {
				return new(complex128)
			},
		},
		Complex128Work: sync.Pool{
			New: func() interface{} {
				return new(WorkOfComplex128ThenByte)
			},
		},
		ByteRtn: sync.Pool{
			New: func() interface{} {
				return new(byte)
			},
		},
		ByteReturn: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfByte)
			},
		},
		ChReturnOfByte: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfByte, 1)
			},
		},
	}
}

type ApiDecouplerOfComplex128ThenByte struct {
	pool PoolOfComplex128ThenByte
}

func NewApiDecouplerOfComplex128ThenByte() *ApiDecouplerOfComplex128ThenByte {
	return &ApiDecouplerOfComplex128ThenByte{
		pool: NewPoolOfComplex128ThenByteImpl(),
	}
}

func (__ *ApiDecouplerOfComplex128ThenByte) ReturnError(rtn_ch chan<- *ReturnOfByte, err error) {
	rtn := __.pool.GetReturnOfByte()
	var other byte
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfComplex128ThenByte) HandleOfComplex128ThenByte(ctx context.Context, req *WorkOfComplex128ThenByte, h func(ctx context.Context, arg complex128) (byte, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfByte()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfComplex128ThenByte) DoOfComplex128ThenByte(ctx context.Context, worker WorkerOfPushComplex128ThenByte, arg complex128) (byte, error) {
	// ch := make(chan *ReturnOfByte, 1)
	ch := __.pool.GetChReturnOfByte()
	defer __.pool.PutChReturnOfByte(ch)

	req := __.pool.GetWorkOfComplex128ThenByte()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfComplex128ThenByte(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfByte(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfComplex128ThenByte = func(ctx context.Context, arg complex128) (byte, error)

type WorkerOfComplex128ThenByte struct {
	api_syncer *ApiDecouplerOfComplex128ThenByte
	handler    WorkHandlerOfComplex128ThenByte

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfComplex128ThenByte
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfComplex128ThenByte(ctx context.Context, h WorkHandlerOfComplex128ThenByte, n int) *WorkerOfComplex128ThenByte {
	__ := &WorkerOfComplex128ThenByte{
		api_syncer: NewApiDecouplerOfComplex128ThenByte(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfComplex128ThenByte, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfComplex128ThenByte{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfComplex128ThenByte(req.Context, req.WorkOfComplex128ThenByte, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfComplex128ThenByte) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfComplex128ThenByte) Push(ctx context.Context, req *WorkOfComplex128ThenByte) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfComplex128ThenByte)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfComplex128ThenByte = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfComplex128ThenByte) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfComplex128ThenByte) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfComplex128ThenByte) Call(ctx context.Context, arg complex128) (byte, error) {
	return __.api_syncer.DoOfComplex128ThenByte(ctx, __, arg)
}

type PoolOfComplex128ThenComplex128 interface {
	GetComplex128Arg() *complex128
	PutComplex128Arg(*complex128)
	GetComplex128Return() *complex128
	PutComplex128Return(*complex128)

	GetWorkOfComplex128ThenComplex128() *WorkOfComplex128ThenComplex128
	GetReturnOfComplex128() *ReturnOfComplex128
	PutWorkOfComplex128ThenComplex128(*WorkOfComplex128ThenComplex128)
	PutReturnOfComplex128(*ReturnOfComplex128)

	GetChReturnOfComplex128() chan *ReturnOfComplex128
	PutChReturnOfComplex128(chan *ReturnOfComplex128)
}

type PoolOfComplex128ThenComplex128Impl struct {
	Complex128Arg        sync.Pool
	Complex128Rtn        sync.Pool
	Complex128Work       sync.Pool
	Complex128Return     sync.Pool
	ChReturnOfComplex128 sync.Pool
}

func (__ *PoolOfComplex128ThenComplex128Impl) GetComplex128Arg() *complex128 {
	return __.Complex128Arg.Get().(*complex128)
}
func (__ *PoolOfComplex128ThenComplex128Impl) PutComplex128Arg(p *complex128) {
	__.Complex128Arg.Put(p)
}
func (__ *PoolOfComplex128ThenComplex128Impl) GetComplex128Return() *complex128 {
	return __.Complex128Rtn.Get().(*complex128)
}
func (__ *PoolOfComplex128ThenComplex128Impl) PutComplex128Return(p *complex128) {
	__.Complex128Rtn.Put(p)
}

func (__ *PoolOfComplex128ThenComplex128Impl) GetWorkOfComplex128ThenComplex128() *WorkOfComplex128ThenComplex128 {
	return __.Complex128Work.Get().(*WorkOfComplex128ThenComplex128)
}
func (__ *PoolOfComplex128ThenComplex128Impl) PutWorkOfComplex128ThenComplex128(p *WorkOfComplex128ThenComplex128) {
	__.Complex128Work.Put(p)
}
func (__ *PoolOfComplex128ThenComplex128Impl) GetReturnOfComplex128() *ReturnOfComplex128 {
	return __.Complex128Return.Get().(*ReturnOfComplex128)
}
func (__ *PoolOfComplex128ThenComplex128Impl) PutReturnOfComplex128(p *ReturnOfComplex128) {
	__.Complex128Return.Put(p)
}

func (__ *PoolOfComplex128ThenComplex128Impl) GetChReturnOfComplex128() chan *ReturnOfComplex128 {
	return __.ChReturnOfComplex128.Get().(chan *ReturnOfComplex128)
}
func (__ *PoolOfComplex128ThenComplex128Impl) PutChReturnOfComplex128(p chan *ReturnOfComplex128) {
	__.ChReturnOfComplex128.Put(p)
}

func NewPoolOfComplex128ThenComplex128Impl() *PoolOfComplex128ThenComplex128Impl {
	return &PoolOfComplex128ThenComplex128Impl{
		Complex128Arg: sync.Pool{
			New: func() interface{} {
				return new(complex128)
			},
		},
		Complex128Work: sync.Pool{
			New: func() interface{} {
				return new(WorkOfComplex128ThenComplex128)
			},
		},
		Complex128Rtn: sync.Pool{
			New: func() interface{} {
				return new(complex128)
			},
		},
		Complex128Return: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfComplex128)
			},
		},
		ChReturnOfComplex128: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfComplex128, 1)
			},
		},
	}
}

type ApiDecouplerOfComplex128ThenComplex128 struct {
	pool PoolOfComplex128ThenComplex128
}

func NewApiDecouplerOfComplex128ThenComplex128() *ApiDecouplerOfComplex128ThenComplex128 {
	return &ApiDecouplerOfComplex128ThenComplex128{
		pool: NewPoolOfComplex128ThenComplex128Impl(),
	}
}

func (__ *ApiDecouplerOfComplex128ThenComplex128) ReturnError(rtn_ch chan<- *ReturnOfComplex128, err error) {
	rtn := __.pool.GetReturnOfComplex128()
	var other complex128
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfComplex128ThenComplex128) HandleOfComplex128ThenComplex128(ctx context.Context, req *WorkOfComplex128ThenComplex128, h func(ctx context.Context, arg complex128) (complex128, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfComplex128()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfComplex128ThenComplex128) DoOfComplex128ThenComplex128(ctx context.Context, worker WorkerOfPushComplex128ThenComplex128, arg complex128) (complex128, error) {
	// ch := make(chan *ReturnOfComplex128, 1)
	ch := __.pool.GetChReturnOfComplex128()
	defer __.pool.PutChReturnOfComplex128(ch)

	req := __.pool.GetWorkOfComplex128ThenComplex128()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfComplex128ThenComplex128(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfComplex128(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfComplex128ThenComplex128 = func(ctx context.Context, arg complex128) (complex128, error)

type WorkerOfComplex128ThenComplex128 struct {
	api_syncer *ApiDecouplerOfComplex128ThenComplex128
	handler    WorkHandlerOfComplex128ThenComplex128

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfComplex128ThenComplex128
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfComplex128ThenComplex128(ctx context.Context, h WorkHandlerOfComplex128ThenComplex128, n int) *WorkerOfComplex128ThenComplex128 {
	__ := &WorkerOfComplex128ThenComplex128{
		api_syncer: NewApiDecouplerOfComplex128ThenComplex128(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfComplex128ThenComplex128, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfComplex128ThenComplex128{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfComplex128ThenComplex128(req.Context, req.WorkOfComplex128ThenComplex128, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfComplex128ThenComplex128) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfComplex128ThenComplex128) Push(ctx context.Context, req *WorkOfComplex128ThenComplex128) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfComplex128ThenComplex128)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfComplex128ThenComplex128 = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfComplex128ThenComplex128) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfComplex128ThenComplex128) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfComplex128ThenComplex128) Call(ctx context.Context, arg complex128) (complex128, error) {
	return __.api_syncer.DoOfComplex128ThenComplex128(ctx, __, arg)
}

type PoolOfComplex128ThenComplex64 interface {
	GetComplex128Arg() *complex128
	PutComplex128Arg(*complex128)
	GetComplex64Return() *complex64
	PutComplex64Return(*complex64)

	GetWorkOfComplex128ThenComplex64() *WorkOfComplex128ThenComplex64
	GetReturnOfComplex64() *ReturnOfComplex64
	PutWorkOfComplex128ThenComplex64(*WorkOfComplex128ThenComplex64)
	PutReturnOfComplex64(*ReturnOfComplex64)

	GetChReturnOfComplex64() chan *ReturnOfComplex64
	PutChReturnOfComplex64(chan *ReturnOfComplex64)
}

type PoolOfComplex128ThenComplex64Impl struct {
	Complex128Arg       sync.Pool
	Complex64Rtn        sync.Pool
	Complex128Work      sync.Pool
	Complex64Return     sync.Pool
	ChReturnOfComplex64 sync.Pool
}

func (__ *PoolOfComplex128ThenComplex64Impl) GetComplex128Arg() *complex128 {
	return __.Complex128Arg.Get().(*complex128)
}
func (__ *PoolOfComplex128ThenComplex64Impl) PutComplex128Arg(p *complex128) {
	__.Complex128Arg.Put(p)
}
func (__ *PoolOfComplex128ThenComplex64Impl) GetComplex64Return() *complex64 {
	return __.Complex64Rtn.Get().(*complex64)
}
func (__ *PoolOfComplex128ThenComplex64Impl) PutComplex64Return(p *complex64) {
	__.Complex64Rtn.Put(p)
}

func (__ *PoolOfComplex128ThenComplex64Impl) GetWorkOfComplex128ThenComplex64() *WorkOfComplex128ThenComplex64 {
	return __.Complex128Work.Get().(*WorkOfComplex128ThenComplex64)
}
func (__ *PoolOfComplex128ThenComplex64Impl) PutWorkOfComplex128ThenComplex64(p *WorkOfComplex128ThenComplex64) {
	__.Complex128Work.Put(p)
}
func (__ *PoolOfComplex128ThenComplex64Impl) GetReturnOfComplex64() *ReturnOfComplex64 {
	return __.Complex64Return.Get().(*ReturnOfComplex64)
}
func (__ *PoolOfComplex128ThenComplex64Impl) PutReturnOfComplex64(p *ReturnOfComplex64) {
	__.Complex64Return.Put(p)
}

func (__ *PoolOfComplex128ThenComplex64Impl) GetChReturnOfComplex64() chan *ReturnOfComplex64 {
	return __.ChReturnOfComplex64.Get().(chan *ReturnOfComplex64)
}
func (__ *PoolOfComplex128ThenComplex64Impl) PutChReturnOfComplex64(p chan *ReturnOfComplex64) {
	__.ChReturnOfComplex64.Put(p)
}

func NewPoolOfComplex128ThenComplex64Impl() *PoolOfComplex128ThenComplex64Impl {
	return &PoolOfComplex128ThenComplex64Impl{
		Complex128Arg: sync.Pool{
			New: func() interface{} {
				return new(complex128)
			},
		},
		Complex128Work: sync.Pool{
			New: func() interface{} {
				return new(WorkOfComplex128ThenComplex64)
			},
		},
		Complex64Rtn: sync.Pool{
			New: func() interface{} {
				return new(complex64)
			},
		},
		Complex64Return: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfComplex64)
			},
		},
		ChReturnOfComplex64: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfComplex64, 1)
			},
		},
	}
}

type ApiDecouplerOfComplex128ThenComplex64 struct {
	pool PoolOfComplex128ThenComplex64
}

func NewApiDecouplerOfComplex128ThenComplex64() *ApiDecouplerOfComplex128ThenComplex64 {
	return &ApiDecouplerOfComplex128ThenComplex64{
		pool: NewPoolOfComplex128ThenComplex64Impl(),
	}
}

func (__ *ApiDecouplerOfComplex128ThenComplex64) ReturnError(rtn_ch chan<- *ReturnOfComplex64, err error) {
	rtn := __.pool.GetReturnOfComplex64()
	var other complex64
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfComplex128ThenComplex64) HandleOfComplex128ThenComplex64(ctx context.Context, req *WorkOfComplex128ThenComplex64, h func(ctx context.Context, arg complex128) (complex64, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfComplex64()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfComplex128ThenComplex64) DoOfComplex128ThenComplex64(ctx context.Context, worker WorkerOfPushComplex128ThenComplex64, arg complex128) (complex64, error) {
	// ch := make(chan *ReturnOfComplex64, 1)
	ch := __.pool.GetChReturnOfComplex64()
	defer __.pool.PutChReturnOfComplex64(ch)

	req := __.pool.GetWorkOfComplex128ThenComplex64()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfComplex128ThenComplex64(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfComplex64(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfComplex128ThenComplex64 = func(ctx context.Context, arg complex128) (complex64, error)

type WorkerOfComplex128ThenComplex64 struct {
	api_syncer *ApiDecouplerOfComplex128ThenComplex64
	handler    WorkHandlerOfComplex128ThenComplex64

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfComplex128ThenComplex64
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfComplex128ThenComplex64(ctx context.Context, h WorkHandlerOfComplex128ThenComplex64, n int) *WorkerOfComplex128ThenComplex64 {
	__ := &WorkerOfComplex128ThenComplex64{
		api_syncer: NewApiDecouplerOfComplex128ThenComplex64(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfComplex128ThenComplex64, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfComplex128ThenComplex64{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfComplex128ThenComplex64(req.Context, req.WorkOfComplex128ThenComplex64, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfComplex128ThenComplex64) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfComplex128ThenComplex64) Push(ctx context.Context, req *WorkOfComplex128ThenComplex64) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfComplex128ThenComplex64)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfComplex128ThenComplex64 = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfComplex128ThenComplex64) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfComplex128ThenComplex64) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfComplex128ThenComplex64) Call(ctx context.Context, arg complex128) (complex64, error) {
	return __.api_syncer.DoOfComplex128ThenComplex64(ctx, __, arg)
}

type PoolOfComplex128ThenError interface {
	GetComplex128Arg() *complex128
	PutComplex128Arg(*complex128)
	GetErrorReturn() *error
	PutErrorReturn(*error)

	GetWorkOfComplex128ThenError() *WorkOfComplex128ThenError
	GetReturnOfError() *ReturnOfError
	PutWorkOfComplex128ThenError(*WorkOfComplex128ThenError)
	PutReturnOfError(*ReturnOfError)

	GetChReturnOfError() chan *ReturnOfError
	PutChReturnOfError(chan *ReturnOfError)
}

type PoolOfComplex128ThenErrorImpl struct {
	Complex128Arg   sync.Pool
	ErrorRtn        sync.Pool
	Complex128Work  sync.Pool
	ErrorReturn     sync.Pool
	ChReturnOfError sync.Pool
}

func (__ *PoolOfComplex128ThenErrorImpl) GetComplex128Arg() *complex128 {
	return __.Complex128Arg.Get().(*complex128)
}
func (__ *PoolOfComplex128ThenErrorImpl) PutComplex128Arg(p *complex128) {
	__.Complex128Arg.Put(p)
}
func (__ *PoolOfComplex128ThenErrorImpl) GetErrorReturn() *error {
	return __.ErrorRtn.Get().(*error)
}
func (__ *PoolOfComplex128ThenErrorImpl) PutErrorReturn(p *error) {
	__.ErrorRtn.Put(p)
}

func (__ *PoolOfComplex128ThenErrorImpl) GetWorkOfComplex128ThenError() *WorkOfComplex128ThenError {
	return __.Complex128Work.Get().(*WorkOfComplex128ThenError)
}
func (__ *PoolOfComplex128ThenErrorImpl) PutWorkOfComplex128ThenError(p *WorkOfComplex128ThenError) {
	__.Complex128Work.Put(p)
}
func (__ *PoolOfComplex128ThenErrorImpl) GetReturnOfError() *ReturnOfError {
	return __.ErrorReturn.Get().(*ReturnOfError)
}
func (__ *PoolOfComplex128ThenErrorImpl) PutReturnOfError(p *ReturnOfError) {
	__.ErrorReturn.Put(p)
}

func (__ *PoolOfComplex128ThenErrorImpl) GetChReturnOfError() chan *ReturnOfError {
	return __.ChReturnOfError.Get().(chan *ReturnOfError)
}
func (__ *PoolOfComplex128ThenErrorImpl) PutChReturnOfError(p chan *ReturnOfError) {
	__.ChReturnOfError.Put(p)
}

func NewPoolOfComplex128ThenErrorImpl() *PoolOfComplex128ThenErrorImpl {
	return &PoolOfComplex128ThenErrorImpl{
		Complex128Arg: sync.Pool{
			New: func() interface{} {
				return new(complex128)
			},
		},
		Complex128Work: sync.Pool{
			New: func() interface{} {
				return new(WorkOfComplex128ThenError)
			},
		},
		ErrorRtn: sync.Pool{
			New: func() interface{} {
				return new(error)
			},
		},
		ErrorReturn: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfError)
			},
		},
		ChReturnOfError: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfError, 1)
			},
		},
	}
}

type ApiDecouplerOfComplex128ThenError struct {
	pool PoolOfComplex128ThenError
}

func NewApiDecouplerOfComplex128ThenError() *ApiDecouplerOfComplex128ThenError {
	return &ApiDecouplerOfComplex128ThenError{
		pool: NewPoolOfComplex128ThenErrorImpl(),
	}
}

func (__ *ApiDecouplerOfComplex128ThenError) ReturnError(rtn_ch chan<- *ReturnOfError, err error) {
	rtn := __.pool.GetReturnOfError()
	var other error
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfComplex128ThenError) HandleOfComplex128ThenError(ctx context.Context, req *WorkOfComplex128ThenError, h func(ctx context.Context, arg complex128) (error, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfError()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfComplex128ThenError) DoOfComplex128ThenError(ctx context.Context, worker WorkerOfPushComplex128ThenError, arg complex128) (error, error) {
	// ch := make(chan *ReturnOfError, 1)
	ch := __.pool.GetChReturnOfError()
	defer __.pool.PutChReturnOfError(ch)

	req := __.pool.GetWorkOfComplex128ThenError()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfComplex128ThenError(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfError(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfComplex128ThenError = func(ctx context.Context, arg complex128) (error, error)

type WorkerOfComplex128ThenError struct {
	api_syncer *ApiDecouplerOfComplex128ThenError
	handler    WorkHandlerOfComplex128ThenError

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfComplex128ThenError
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfComplex128ThenError(ctx context.Context, h WorkHandlerOfComplex128ThenError, n int) *WorkerOfComplex128ThenError {
	__ := &WorkerOfComplex128ThenError{
		api_syncer: NewApiDecouplerOfComplex128ThenError(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfComplex128ThenError, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfComplex128ThenError{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfComplex128ThenError(req.Context, req.WorkOfComplex128ThenError, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfComplex128ThenError) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfComplex128ThenError) Push(ctx context.Context, req *WorkOfComplex128ThenError) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfComplex128ThenError)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfComplex128ThenError = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfComplex128ThenError) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfComplex128ThenError) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfComplex128ThenError) Call(ctx context.Context, arg complex128) (error, error) {
	return __.api_syncer.DoOfComplex128ThenError(ctx, __, arg)
}

type PoolOfComplex128ThenFloat32 interface {
	GetComplex128Arg() *complex128
	PutComplex128Arg(*complex128)
	GetFloat32Return() *float32
	PutFloat32Return(*float32)

	GetWorkOfComplex128ThenFloat32() *WorkOfComplex128ThenFloat32
	GetReturnOfFloat32() *ReturnOfFloat32
	PutWorkOfComplex128ThenFloat32(*WorkOfComplex128ThenFloat32)
	PutReturnOfFloat32(*ReturnOfFloat32)

	GetChReturnOfFloat32() chan *ReturnOfFloat32
	PutChReturnOfFloat32(chan *ReturnOfFloat32)
}

type PoolOfComplex128ThenFloat32Impl struct {
	Complex128Arg     sync.Pool
	Float32Rtn        sync.Pool
	Complex128Work    sync.Pool
	Float32Return     sync.Pool
	ChReturnOfFloat32 sync.Pool
}

func (__ *PoolOfComplex128ThenFloat32Impl) GetComplex128Arg() *complex128 {
	return __.Complex128Arg.Get().(*complex128)
}
func (__ *PoolOfComplex128ThenFloat32Impl) PutComplex128Arg(p *complex128) {
	__.Complex128Arg.Put(p)
}
func (__ *PoolOfComplex128ThenFloat32Impl) GetFloat32Return() *float32 {
	return __.Float32Rtn.Get().(*float32)
}
func (__ *PoolOfComplex128ThenFloat32Impl) PutFloat32Return(p *float32) {
	__.Float32Rtn.Put(p)
}

func (__ *PoolOfComplex128ThenFloat32Impl) GetWorkOfComplex128ThenFloat32() *WorkOfComplex128ThenFloat32 {
	return __.Complex128Work.Get().(*WorkOfComplex128ThenFloat32)
}
func (__ *PoolOfComplex128ThenFloat32Impl) PutWorkOfComplex128ThenFloat32(p *WorkOfComplex128ThenFloat32) {
	__.Complex128Work.Put(p)
}
func (__ *PoolOfComplex128ThenFloat32Impl) GetReturnOfFloat32() *ReturnOfFloat32 {
	return __.Float32Return.Get().(*ReturnOfFloat32)
}
func (__ *PoolOfComplex128ThenFloat32Impl) PutReturnOfFloat32(p *ReturnOfFloat32) {
	__.Float32Return.Put(p)
}

func (__ *PoolOfComplex128ThenFloat32Impl) GetChReturnOfFloat32() chan *ReturnOfFloat32 {
	return __.ChReturnOfFloat32.Get().(chan *ReturnOfFloat32)
}
func (__ *PoolOfComplex128ThenFloat32Impl) PutChReturnOfFloat32(p chan *ReturnOfFloat32) {
	__.ChReturnOfFloat32.Put(p)
}

func NewPoolOfComplex128ThenFloat32Impl() *PoolOfComplex128ThenFloat32Impl {
	return &PoolOfComplex128ThenFloat32Impl{
		Complex128Arg: sync.Pool{
			New: func() interface{} {
				return new(complex128)
			},
		},
		Complex128Work: sync.Pool{
			New: func() interface{} {
				return new(WorkOfComplex128ThenFloat32)
			},
		},
		Float32Rtn: sync.Pool{
			New: func() interface{} {
				return new(float32)
			},
		},
		Float32Return: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfFloat32)
			},
		},
		ChReturnOfFloat32: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfFloat32, 1)
			},
		},
	}
}

type ApiDecouplerOfComplex128ThenFloat32 struct {
	pool PoolOfComplex128ThenFloat32
}

func NewApiDecouplerOfComplex128ThenFloat32() *ApiDecouplerOfComplex128ThenFloat32 {
	return &ApiDecouplerOfComplex128ThenFloat32{
		pool: NewPoolOfComplex128ThenFloat32Impl(),
	}
}

func (__ *ApiDecouplerOfComplex128ThenFloat32) ReturnError(rtn_ch chan<- *ReturnOfFloat32, err error) {
	rtn := __.pool.GetReturnOfFloat32()
	var other float32
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfComplex128ThenFloat32) HandleOfComplex128ThenFloat32(ctx context.Context, req *WorkOfComplex128ThenFloat32, h func(ctx context.Context, arg complex128) (float32, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfFloat32()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfComplex128ThenFloat32) DoOfComplex128ThenFloat32(ctx context.Context, worker WorkerOfPushComplex128ThenFloat32, arg complex128) (float32, error) {
	// ch := make(chan *ReturnOfFloat32, 1)
	ch := __.pool.GetChReturnOfFloat32()
	defer __.pool.PutChReturnOfFloat32(ch)

	req := __.pool.GetWorkOfComplex128ThenFloat32()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfComplex128ThenFloat32(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfFloat32(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfComplex128ThenFloat32 = func(ctx context.Context, arg complex128) (float32, error)

type WorkerOfComplex128ThenFloat32 struct {
	api_syncer *ApiDecouplerOfComplex128ThenFloat32
	handler    WorkHandlerOfComplex128ThenFloat32

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfComplex128ThenFloat32
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfComplex128ThenFloat32(ctx context.Context, h WorkHandlerOfComplex128ThenFloat32, n int) *WorkerOfComplex128ThenFloat32 {
	__ := &WorkerOfComplex128ThenFloat32{
		api_syncer: NewApiDecouplerOfComplex128ThenFloat32(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfComplex128ThenFloat32, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfComplex128ThenFloat32{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfComplex128ThenFloat32(req.Context, req.WorkOfComplex128ThenFloat32, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfComplex128ThenFloat32) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfComplex128ThenFloat32) Push(ctx context.Context, req *WorkOfComplex128ThenFloat32) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfComplex128ThenFloat32)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfComplex128ThenFloat32 = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfComplex128ThenFloat32) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfComplex128ThenFloat32) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfComplex128ThenFloat32) Call(ctx context.Context, arg complex128) (float32, error) {
	return __.api_syncer.DoOfComplex128ThenFloat32(ctx, __, arg)
}

type PoolOfComplex128ThenFloat64 interface {
	GetComplex128Arg() *complex128
	PutComplex128Arg(*complex128)
	GetFloat64Return() *float64
	PutFloat64Return(*float64)

	GetWorkOfComplex128ThenFloat64() *WorkOfComplex128ThenFloat64
	GetReturnOfFloat64() *ReturnOfFloat64
	PutWorkOfComplex128ThenFloat64(*WorkOfComplex128ThenFloat64)
	PutReturnOfFloat64(*ReturnOfFloat64)

	GetChReturnOfFloat64() chan *ReturnOfFloat64
	PutChReturnOfFloat64(chan *ReturnOfFloat64)
}

type PoolOfComplex128ThenFloat64Impl struct {
	Complex128Arg     sync.Pool
	Float64Rtn        sync.Pool
	Complex128Work    sync.Pool
	Float64Return     sync.Pool
	ChReturnOfFloat64 sync.Pool
}

func (__ *PoolOfComplex128ThenFloat64Impl) GetComplex128Arg() *complex128 {
	return __.Complex128Arg.Get().(*complex128)
}
func (__ *PoolOfComplex128ThenFloat64Impl) PutComplex128Arg(p *complex128) {
	__.Complex128Arg.Put(p)
}
func (__ *PoolOfComplex128ThenFloat64Impl) GetFloat64Return() *float64 {
	return __.Float64Rtn.Get().(*float64)
}
func (__ *PoolOfComplex128ThenFloat64Impl) PutFloat64Return(p *float64) {
	__.Float64Rtn.Put(p)
}

func (__ *PoolOfComplex128ThenFloat64Impl) GetWorkOfComplex128ThenFloat64() *WorkOfComplex128ThenFloat64 {
	return __.Complex128Work.Get().(*WorkOfComplex128ThenFloat64)
}
func (__ *PoolOfComplex128ThenFloat64Impl) PutWorkOfComplex128ThenFloat64(p *WorkOfComplex128ThenFloat64) {
	__.Complex128Work.Put(p)
}
func (__ *PoolOfComplex128ThenFloat64Impl) GetReturnOfFloat64() *ReturnOfFloat64 {
	return __.Float64Return.Get().(*ReturnOfFloat64)
}
func (__ *PoolOfComplex128ThenFloat64Impl) PutReturnOfFloat64(p *ReturnOfFloat64) {
	__.Float64Return.Put(p)
}

func (__ *PoolOfComplex128ThenFloat64Impl) GetChReturnOfFloat64() chan *ReturnOfFloat64 {
	return __.ChReturnOfFloat64.Get().(chan *ReturnOfFloat64)
}
func (__ *PoolOfComplex128ThenFloat64Impl) PutChReturnOfFloat64(p chan *ReturnOfFloat64) {
	__.ChReturnOfFloat64.Put(p)
}

func NewPoolOfComplex128ThenFloat64Impl() *PoolOfComplex128ThenFloat64Impl {
	return &PoolOfComplex128ThenFloat64Impl{
		Complex128Arg: sync.Pool{
			New: func() interface{} {
				return new(complex128)
			},
		},
		Complex128Work: sync.Pool{
			New: func() interface{} {
				return new(WorkOfComplex128ThenFloat64)
			},
		},
		Float64Rtn: sync.Pool{
			New: func() interface{} {
				return new(float64)
			},
		},
		Float64Return: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfFloat64)
			},
		},
		ChReturnOfFloat64: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfFloat64, 1)
			},
		},
	}
}

type ApiDecouplerOfComplex128ThenFloat64 struct {
	pool PoolOfComplex128ThenFloat64
}

func NewApiDecouplerOfComplex128ThenFloat64() *ApiDecouplerOfComplex128ThenFloat64 {
	return &ApiDecouplerOfComplex128ThenFloat64{
		pool: NewPoolOfComplex128ThenFloat64Impl(),
	}
}

func (__ *ApiDecouplerOfComplex128ThenFloat64) ReturnError(rtn_ch chan<- *ReturnOfFloat64, err error) {
	rtn := __.pool.GetReturnOfFloat64()
	var other float64
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfComplex128ThenFloat64) HandleOfComplex128ThenFloat64(ctx context.Context, req *WorkOfComplex128ThenFloat64, h func(ctx context.Context, arg complex128) (float64, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfFloat64()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfComplex128ThenFloat64) DoOfComplex128ThenFloat64(ctx context.Context, worker WorkerOfPushComplex128ThenFloat64, arg complex128) (float64, error) {
	// ch := make(chan *ReturnOfFloat64, 1)
	ch := __.pool.GetChReturnOfFloat64()
	defer __.pool.PutChReturnOfFloat64(ch)

	req := __.pool.GetWorkOfComplex128ThenFloat64()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfComplex128ThenFloat64(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfFloat64(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfComplex128ThenFloat64 = func(ctx context.Context, arg complex128) (float64, error)

type WorkerOfComplex128ThenFloat64 struct {
	api_syncer *ApiDecouplerOfComplex128ThenFloat64
	handler    WorkHandlerOfComplex128ThenFloat64

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfComplex128ThenFloat64
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfComplex128ThenFloat64(ctx context.Context, h WorkHandlerOfComplex128ThenFloat64, n int) *WorkerOfComplex128ThenFloat64 {
	__ := &WorkerOfComplex128ThenFloat64{
		api_syncer: NewApiDecouplerOfComplex128ThenFloat64(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfComplex128ThenFloat64, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfComplex128ThenFloat64{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfComplex128ThenFloat64(req.Context, req.WorkOfComplex128ThenFloat64, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfComplex128ThenFloat64) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfComplex128ThenFloat64) Push(ctx context.Context, req *WorkOfComplex128ThenFloat64) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfComplex128ThenFloat64)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfComplex128ThenFloat64 = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfComplex128ThenFloat64) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfComplex128ThenFloat64) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfComplex128ThenFloat64) Call(ctx context.Context, arg complex128) (float64, error) {
	return __.api_syncer.DoOfComplex128ThenFloat64(ctx, __, arg)
}

type PoolOfComplex128ThenInt interface {
	GetComplex128Arg() *complex128
	PutComplex128Arg(*complex128)
	GetIntReturn() *int
	PutIntReturn(*int)

	GetWorkOfComplex128ThenInt() *WorkOfComplex128ThenInt
	GetReturnOfInt() *ReturnOfInt
	PutWorkOfComplex128ThenInt(*WorkOfComplex128ThenInt)
	PutReturnOfInt(*ReturnOfInt)

	GetChReturnOfInt() chan *ReturnOfInt
	PutChReturnOfInt(chan *ReturnOfInt)
}

type PoolOfComplex128ThenIntImpl struct {
	Complex128Arg  sync.Pool
	IntRtn         sync.Pool
	Complex128Work sync.Pool
	IntReturn      sync.Pool
	ChReturnOfInt  sync.Pool
}

func (__ *PoolOfComplex128ThenIntImpl) GetComplex128Arg() *complex128 {
	return __.Complex128Arg.Get().(*complex128)
}
func (__ *PoolOfComplex128ThenIntImpl) PutComplex128Arg(p *complex128) {
	__.Complex128Arg.Put(p)
}
func (__ *PoolOfComplex128ThenIntImpl) GetIntReturn() *int {
	return __.IntRtn.Get().(*int)
}
func (__ *PoolOfComplex128ThenIntImpl) PutIntReturn(p *int) {
	__.IntRtn.Put(p)
}

func (__ *PoolOfComplex128ThenIntImpl) GetWorkOfComplex128ThenInt() *WorkOfComplex128ThenInt {
	return __.Complex128Work.Get().(*WorkOfComplex128ThenInt)
}
func (__ *PoolOfComplex128ThenIntImpl) PutWorkOfComplex128ThenInt(p *WorkOfComplex128ThenInt) {
	__.Complex128Work.Put(p)
}
func (__ *PoolOfComplex128ThenIntImpl) GetReturnOfInt() *ReturnOfInt {
	return __.IntReturn.Get().(*ReturnOfInt)
}
func (__ *PoolOfComplex128ThenIntImpl) PutReturnOfInt(p *ReturnOfInt) {
	__.IntReturn.Put(p)
}

func (__ *PoolOfComplex128ThenIntImpl) GetChReturnOfInt() chan *ReturnOfInt {
	return __.ChReturnOfInt.Get().(chan *ReturnOfInt)
}
func (__ *PoolOfComplex128ThenIntImpl) PutChReturnOfInt(p chan *ReturnOfInt) {
	__.ChReturnOfInt.Put(p)
}

func NewPoolOfComplex128ThenIntImpl() *PoolOfComplex128ThenIntImpl {
	return &PoolOfComplex128ThenIntImpl{
		Complex128Arg: sync.Pool{
			New: func() interface{} {
				return new(complex128)
			},
		},
		Complex128Work: sync.Pool{
			New: func() interface{} {
				return new(WorkOfComplex128ThenInt)
			},
		},
		IntRtn: sync.Pool{
			New: func() interface{} {
				return new(int)
			},
		},
		IntReturn: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfInt)
			},
		},
		ChReturnOfInt: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfInt, 1)
			},
		},
	}
}

type ApiDecouplerOfComplex128ThenInt struct {
	pool PoolOfComplex128ThenInt
}

func NewApiDecouplerOfComplex128ThenInt() *ApiDecouplerOfComplex128ThenInt {
	return &ApiDecouplerOfComplex128ThenInt{
		pool: NewPoolOfComplex128ThenIntImpl(),
	}
}

func (__ *ApiDecouplerOfComplex128ThenInt) ReturnError(rtn_ch chan<- *ReturnOfInt, err error) {
	rtn := __.pool.GetReturnOfInt()
	var other int
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfComplex128ThenInt) HandleOfComplex128ThenInt(ctx context.Context, req *WorkOfComplex128ThenInt, h func(ctx context.Context, arg complex128) (int, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfInt()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfComplex128ThenInt) DoOfComplex128ThenInt(ctx context.Context, worker WorkerOfPushComplex128ThenInt, arg complex128) (int, error) {
	// ch := make(chan *ReturnOfInt, 1)
	ch := __.pool.GetChReturnOfInt()
	defer __.pool.PutChReturnOfInt(ch)

	req := __.pool.GetWorkOfComplex128ThenInt()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfComplex128ThenInt(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfInt(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfComplex128ThenInt = func(ctx context.Context, arg complex128) (int, error)

type WorkerOfComplex128ThenInt struct {
	api_syncer *ApiDecouplerOfComplex128ThenInt
	handler    WorkHandlerOfComplex128ThenInt

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfComplex128ThenInt
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfComplex128ThenInt(ctx context.Context, h WorkHandlerOfComplex128ThenInt, n int) *WorkerOfComplex128ThenInt {
	__ := &WorkerOfComplex128ThenInt{
		api_syncer: NewApiDecouplerOfComplex128ThenInt(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfComplex128ThenInt, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfComplex128ThenInt{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfComplex128ThenInt(req.Context, req.WorkOfComplex128ThenInt, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfComplex128ThenInt) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfComplex128ThenInt) Push(ctx context.Context, req *WorkOfComplex128ThenInt) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfComplex128ThenInt)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfComplex128ThenInt = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfComplex128ThenInt) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfComplex128ThenInt) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfComplex128ThenInt) Call(ctx context.Context, arg complex128) (int, error) {
	return __.api_syncer.DoOfComplex128ThenInt(ctx, __, arg)
}

type PoolOfComplex128ThenInt16 interface {
	GetComplex128Arg() *complex128
	PutComplex128Arg(*complex128)
	GetInt16Return() *int16
	PutInt16Return(*int16)

	GetWorkOfComplex128ThenInt16() *WorkOfComplex128ThenInt16
	GetReturnOfInt16() *ReturnOfInt16
	PutWorkOfComplex128ThenInt16(*WorkOfComplex128ThenInt16)
	PutReturnOfInt16(*ReturnOfInt16)

	GetChReturnOfInt16() chan *ReturnOfInt16
	PutChReturnOfInt16(chan *ReturnOfInt16)
}

type PoolOfComplex128ThenInt16Impl struct {
	Complex128Arg   sync.Pool
	Int16Rtn        sync.Pool
	Complex128Work  sync.Pool
	Int16Return     sync.Pool
	ChReturnOfInt16 sync.Pool
}

func (__ *PoolOfComplex128ThenInt16Impl) GetComplex128Arg() *complex128 {
	return __.Complex128Arg.Get().(*complex128)
}
func (__ *PoolOfComplex128ThenInt16Impl) PutComplex128Arg(p *complex128) {
	__.Complex128Arg.Put(p)
}
func (__ *PoolOfComplex128ThenInt16Impl) GetInt16Return() *int16 {
	return __.Int16Rtn.Get().(*int16)
}
func (__ *PoolOfComplex128ThenInt16Impl) PutInt16Return(p *int16) {
	__.Int16Rtn.Put(p)
}

func (__ *PoolOfComplex128ThenInt16Impl) GetWorkOfComplex128ThenInt16() *WorkOfComplex128ThenInt16 {
	return __.Complex128Work.Get().(*WorkOfComplex128ThenInt16)
}
func (__ *PoolOfComplex128ThenInt16Impl) PutWorkOfComplex128ThenInt16(p *WorkOfComplex128ThenInt16) {
	__.Complex128Work.Put(p)
}
func (__ *PoolOfComplex128ThenInt16Impl) GetReturnOfInt16() *ReturnOfInt16 {
	return __.Int16Return.Get().(*ReturnOfInt16)
}
func (__ *PoolOfComplex128ThenInt16Impl) PutReturnOfInt16(p *ReturnOfInt16) {
	__.Int16Return.Put(p)
}

func (__ *PoolOfComplex128ThenInt16Impl) GetChReturnOfInt16() chan *ReturnOfInt16 {
	return __.ChReturnOfInt16.Get().(chan *ReturnOfInt16)
}
func (__ *PoolOfComplex128ThenInt16Impl) PutChReturnOfInt16(p chan *ReturnOfInt16) {
	__.ChReturnOfInt16.Put(p)
}

func NewPoolOfComplex128ThenInt16Impl() *PoolOfComplex128ThenInt16Impl {
	return &PoolOfComplex128ThenInt16Impl{
		Complex128Arg: sync.Pool{
			New: func() interface{} {
				return new(complex128)
			},
		},
		Complex128Work: sync.Pool{
			New: func() interface{} {
				return new(WorkOfComplex128ThenInt16)
			},
		},
		Int16Rtn: sync.Pool{
			New: func() interface{} {
				return new(int16)
			},
		},
		Int16Return: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfInt16)
			},
		},
		ChReturnOfInt16: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfInt16, 1)
			},
		},
	}
}

type ApiDecouplerOfComplex128ThenInt16 struct {
	pool PoolOfComplex128ThenInt16
}

func NewApiDecouplerOfComplex128ThenInt16() *ApiDecouplerOfComplex128ThenInt16 {
	return &ApiDecouplerOfComplex128ThenInt16{
		pool: NewPoolOfComplex128ThenInt16Impl(),
	}
}

func (__ *ApiDecouplerOfComplex128ThenInt16) ReturnError(rtn_ch chan<- *ReturnOfInt16, err error) {
	rtn := __.pool.GetReturnOfInt16()
	var other int16
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfComplex128ThenInt16) HandleOfComplex128ThenInt16(ctx context.Context, req *WorkOfComplex128ThenInt16, h func(ctx context.Context, arg complex128) (int16, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfInt16()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfComplex128ThenInt16) DoOfComplex128ThenInt16(ctx context.Context, worker WorkerOfPushComplex128ThenInt16, arg complex128) (int16, error) {
	// ch := make(chan *ReturnOfInt16, 1)
	ch := __.pool.GetChReturnOfInt16()
	defer __.pool.PutChReturnOfInt16(ch)

	req := __.pool.GetWorkOfComplex128ThenInt16()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfComplex128ThenInt16(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfInt16(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfComplex128ThenInt16 = func(ctx context.Context, arg complex128) (int16, error)

type WorkerOfComplex128ThenInt16 struct {
	api_syncer *ApiDecouplerOfComplex128ThenInt16
	handler    WorkHandlerOfComplex128ThenInt16

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfComplex128ThenInt16
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfComplex128ThenInt16(ctx context.Context, h WorkHandlerOfComplex128ThenInt16, n int) *WorkerOfComplex128ThenInt16 {
	__ := &WorkerOfComplex128ThenInt16{
		api_syncer: NewApiDecouplerOfComplex128ThenInt16(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfComplex128ThenInt16, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfComplex128ThenInt16{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfComplex128ThenInt16(req.Context, req.WorkOfComplex128ThenInt16, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfComplex128ThenInt16) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfComplex128ThenInt16) Push(ctx context.Context, req *WorkOfComplex128ThenInt16) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfComplex128ThenInt16)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfComplex128ThenInt16 = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfComplex128ThenInt16) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfComplex128ThenInt16) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfComplex128ThenInt16) Call(ctx context.Context, arg complex128) (int16, error) {
	return __.api_syncer.DoOfComplex128ThenInt16(ctx, __, arg)
}

type PoolOfComplex128ThenInt32 interface {
	GetComplex128Arg() *complex128
	PutComplex128Arg(*complex128)
	GetInt32Return() *int32
	PutInt32Return(*int32)

	GetWorkOfComplex128ThenInt32() *WorkOfComplex128ThenInt32
	GetReturnOfInt32() *ReturnOfInt32
	PutWorkOfComplex128ThenInt32(*WorkOfComplex128ThenInt32)
	PutReturnOfInt32(*ReturnOfInt32)

	GetChReturnOfInt32() chan *ReturnOfInt32
	PutChReturnOfInt32(chan *ReturnOfInt32)
}

type PoolOfComplex128ThenInt32Impl struct {
	Complex128Arg   sync.Pool
	Int32Rtn        sync.Pool
	Complex128Work  sync.Pool
	Int32Return     sync.Pool
	ChReturnOfInt32 sync.Pool
}

func (__ *PoolOfComplex128ThenInt32Impl) GetComplex128Arg() *complex128 {
	return __.Complex128Arg.Get().(*complex128)
}
func (__ *PoolOfComplex128ThenInt32Impl) PutComplex128Arg(p *complex128) {
	__.Complex128Arg.Put(p)
}
func (__ *PoolOfComplex128ThenInt32Impl) GetInt32Return() *int32 {
	return __.Int32Rtn.Get().(*int32)
}
func (__ *PoolOfComplex128ThenInt32Impl) PutInt32Return(p *int32) {
	__.Int32Rtn.Put(p)
}

func (__ *PoolOfComplex128ThenInt32Impl) GetWorkOfComplex128ThenInt32() *WorkOfComplex128ThenInt32 {
	return __.Complex128Work.Get().(*WorkOfComplex128ThenInt32)
}
func (__ *PoolOfComplex128ThenInt32Impl) PutWorkOfComplex128ThenInt32(p *WorkOfComplex128ThenInt32) {
	__.Complex128Work.Put(p)
}
func (__ *PoolOfComplex128ThenInt32Impl) GetReturnOfInt32() *ReturnOfInt32 {
	return __.Int32Return.Get().(*ReturnOfInt32)
}
func (__ *PoolOfComplex128ThenInt32Impl) PutReturnOfInt32(p *ReturnOfInt32) {
	__.Int32Return.Put(p)
}

func (__ *PoolOfComplex128ThenInt32Impl) GetChReturnOfInt32() chan *ReturnOfInt32 {
	return __.ChReturnOfInt32.Get().(chan *ReturnOfInt32)
}
func (__ *PoolOfComplex128ThenInt32Impl) PutChReturnOfInt32(p chan *ReturnOfInt32) {
	__.ChReturnOfInt32.Put(p)
}

func NewPoolOfComplex128ThenInt32Impl() *PoolOfComplex128ThenInt32Impl {
	return &PoolOfComplex128ThenInt32Impl{
		Complex128Arg: sync.Pool{
			New: func() interface{} {
				return new(complex128)
			},
		},
		Complex128Work: sync.Pool{
			New: func() interface{} {
				return new(WorkOfComplex128ThenInt32)
			},
		},
		Int32Rtn: sync.Pool{
			New: func() interface{} {
				return new(int32)
			},
		},
		Int32Return: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfInt32)
			},
		},
		ChReturnOfInt32: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfInt32, 1)
			},
		},
	}
}

type ApiDecouplerOfComplex128ThenInt32 struct {
	pool PoolOfComplex128ThenInt32
}

func NewApiDecouplerOfComplex128ThenInt32() *ApiDecouplerOfComplex128ThenInt32 {
	return &ApiDecouplerOfComplex128ThenInt32{
		pool: NewPoolOfComplex128ThenInt32Impl(),
	}
}

func (__ *ApiDecouplerOfComplex128ThenInt32) ReturnError(rtn_ch chan<- *ReturnOfInt32, err error) {
	rtn := __.pool.GetReturnOfInt32()
	var other int32
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfComplex128ThenInt32) HandleOfComplex128ThenInt32(ctx context.Context, req *WorkOfComplex128ThenInt32, h func(ctx context.Context, arg complex128) (int32, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfInt32()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfComplex128ThenInt32) DoOfComplex128ThenInt32(ctx context.Context, worker WorkerOfPushComplex128ThenInt32, arg complex128) (int32, error) {
	// ch := make(chan *ReturnOfInt32, 1)
	ch := __.pool.GetChReturnOfInt32()
	defer __.pool.PutChReturnOfInt32(ch)

	req := __.pool.GetWorkOfComplex128ThenInt32()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfComplex128ThenInt32(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfInt32(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfComplex128ThenInt32 = func(ctx context.Context, arg complex128) (int32, error)

type WorkerOfComplex128ThenInt32 struct {
	api_syncer *ApiDecouplerOfComplex128ThenInt32
	handler    WorkHandlerOfComplex128ThenInt32

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfComplex128ThenInt32
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfComplex128ThenInt32(ctx context.Context, h WorkHandlerOfComplex128ThenInt32, n int) *WorkerOfComplex128ThenInt32 {
	__ := &WorkerOfComplex128ThenInt32{
		api_syncer: NewApiDecouplerOfComplex128ThenInt32(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfComplex128ThenInt32, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfComplex128ThenInt32{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfComplex128ThenInt32(req.Context, req.WorkOfComplex128ThenInt32, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfComplex128ThenInt32) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfComplex128ThenInt32) Push(ctx context.Context, req *WorkOfComplex128ThenInt32) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfComplex128ThenInt32)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfComplex128ThenInt32 = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfComplex128ThenInt32) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfComplex128ThenInt32) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfComplex128ThenInt32) Call(ctx context.Context, arg complex128) (int32, error) {
	return __.api_syncer.DoOfComplex128ThenInt32(ctx, __, arg)
}

type PoolOfComplex128ThenInt64 interface {
	GetComplex128Arg() *complex128
	PutComplex128Arg(*complex128)
	GetInt64Return() *int64
	PutInt64Return(*int64)

	GetWorkOfComplex128ThenInt64() *WorkOfComplex128ThenInt64
	GetReturnOfInt64() *ReturnOfInt64
	PutWorkOfComplex128ThenInt64(*WorkOfComplex128ThenInt64)
	PutReturnOfInt64(*ReturnOfInt64)

	GetChReturnOfInt64() chan *ReturnOfInt64
	PutChReturnOfInt64(chan *ReturnOfInt64)
}

type PoolOfComplex128ThenInt64Impl struct {
	Complex128Arg   sync.Pool
	Int64Rtn        sync.Pool
	Complex128Work  sync.Pool
	Int64Return     sync.Pool
	ChReturnOfInt64 sync.Pool
}

func (__ *PoolOfComplex128ThenInt64Impl) GetComplex128Arg() *complex128 {
	return __.Complex128Arg.Get().(*complex128)
}
func (__ *PoolOfComplex128ThenInt64Impl) PutComplex128Arg(p *complex128) {
	__.Complex128Arg.Put(p)
}
func (__ *PoolOfComplex128ThenInt64Impl) GetInt64Return() *int64 {
	return __.Int64Rtn.Get().(*int64)
}
func (__ *PoolOfComplex128ThenInt64Impl) PutInt64Return(p *int64) {
	__.Int64Rtn.Put(p)
}

func (__ *PoolOfComplex128ThenInt64Impl) GetWorkOfComplex128ThenInt64() *WorkOfComplex128ThenInt64 {
	return __.Complex128Work.Get().(*WorkOfComplex128ThenInt64)
}
func (__ *PoolOfComplex128ThenInt64Impl) PutWorkOfComplex128ThenInt64(p *WorkOfComplex128ThenInt64) {
	__.Complex128Work.Put(p)
}
func (__ *PoolOfComplex128ThenInt64Impl) GetReturnOfInt64() *ReturnOfInt64 {
	return __.Int64Return.Get().(*ReturnOfInt64)
}
func (__ *PoolOfComplex128ThenInt64Impl) PutReturnOfInt64(p *ReturnOfInt64) {
	__.Int64Return.Put(p)
}

func (__ *PoolOfComplex128ThenInt64Impl) GetChReturnOfInt64() chan *ReturnOfInt64 {
	return __.ChReturnOfInt64.Get().(chan *ReturnOfInt64)
}
func (__ *PoolOfComplex128ThenInt64Impl) PutChReturnOfInt64(p chan *ReturnOfInt64) {
	__.ChReturnOfInt64.Put(p)
}

func NewPoolOfComplex128ThenInt64Impl() *PoolOfComplex128ThenInt64Impl {
	return &PoolOfComplex128ThenInt64Impl{
		Complex128Arg: sync.Pool{
			New: func() interface{} {
				return new(complex128)
			},
		},
		Complex128Work: sync.Pool{
			New: func() interface{} {
				return new(WorkOfComplex128ThenInt64)
			},
		},
		Int64Rtn: sync.Pool{
			New: func() interface{} {
				return new(int64)
			},
		},
		Int64Return: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfInt64)
			},
		},
		ChReturnOfInt64: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfInt64, 1)
			},
		},
	}
}

type ApiDecouplerOfComplex128ThenInt64 struct {
	pool PoolOfComplex128ThenInt64
}

func NewApiDecouplerOfComplex128ThenInt64() *ApiDecouplerOfComplex128ThenInt64 {
	return &ApiDecouplerOfComplex128ThenInt64{
		pool: NewPoolOfComplex128ThenInt64Impl(),
	}
}

func (__ *ApiDecouplerOfComplex128ThenInt64) ReturnError(rtn_ch chan<- *ReturnOfInt64, err error) {
	rtn := __.pool.GetReturnOfInt64()
	var other int64
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfComplex128ThenInt64) HandleOfComplex128ThenInt64(ctx context.Context, req *WorkOfComplex128ThenInt64, h func(ctx context.Context, arg complex128) (int64, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfInt64()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfComplex128ThenInt64) DoOfComplex128ThenInt64(ctx context.Context, worker WorkerOfPushComplex128ThenInt64, arg complex128) (int64, error) {
	// ch := make(chan *ReturnOfInt64, 1)
	ch := __.pool.GetChReturnOfInt64()
	defer __.pool.PutChReturnOfInt64(ch)

	req := __.pool.GetWorkOfComplex128ThenInt64()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfComplex128ThenInt64(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfInt64(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfComplex128ThenInt64 = func(ctx context.Context, arg complex128) (int64, error)

type WorkerOfComplex128ThenInt64 struct {
	api_syncer *ApiDecouplerOfComplex128ThenInt64
	handler    WorkHandlerOfComplex128ThenInt64

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfComplex128ThenInt64
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfComplex128ThenInt64(ctx context.Context, h WorkHandlerOfComplex128ThenInt64, n int) *WorkerOfComplex128ThenInt64 {
	__ := &WorkerOfComplex128ThenInt64{
		api_syncer: NewApiDecouplerOfComplex128ThenInt64(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfComplex128ThenInt64, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfComplex128ThenInt64{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfComplex128ThenInt64(req.Context, req.WorkOfComplex128ThenInt64, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfComplex128ThenInt64) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfComplex128ThenInt64) Push(ctx context.Context, req *WorkOfComplex128ThenInt64) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfComplex128ThenInt64)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfComplex128ThenInt64 = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfComplex128ThenInt64) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfComplex128ThenInt64) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfComplex128ThenInt64) Call(ctx context.Context, arg complex128) (int64, error) {
	return __.api_syncer.DoOfComplex128ThenInt64(ctx, __, arg)
}

type PoolOfComplex128ThenInt8 interface {
	GetComplex128Arg() *complex128
	PutComplex128Arg(*complex128)
	GetInt8Return() *int8
	PutInt8Return(*int8)

	GetWorkOfComplex128ThenInt8() *WorkOfComplex128ThenInt8
	GetReturnOfInt8() *ReturnOfInt8
	PutWorkOfComplex128ThenInt8(*WorkOfComplex128ThenInt8)
	PutReturnOfInt8(*ReturnOfInt8)

	GetChReturnOfInt8() chan *ReturnOfInt8
	PutChReturnOfInt8(chan *ReturnOfInt8)
}

type PoolOfComplex128ThenInt8Impl struct {
	Complex128Arg  sync.Pool
	Int8Rtn        sync.Pool
	Complex128Work sync.Pool
	Int8Return     sync.Pool
	ChReturnOfInt8 sync.Pool
}

func (__ *PoolOfComplex128ThenInt8Impl) GetComplex128Arg() *complex128 {
	return __.Complex128Arg.Get().(*complex128)
}
func (__ *PoolOfComplex128ThenInt8Impl) PutComplex128Arg(p *complex128) {
	__.Complex128Arg.Put(p)
}
func (__ *PoolOfComplex128ThenInt8Impl) GetInt8Return() *int8 {
	return __.Int8Rtn.Get().(*int8)
}
func (__ *PoolOfComplex128ThenInt8Impl) PutInt8Return(p *int8) {
	__.Int8Rtn.Put(p)
}

func (__ *PoolOfComplex128ThenInt8Impl) GetWorkOfComplex128ThenInt8() *WorkOfComplex128ThenInt8 {
	return __.Complex128Work.Get().(*WorkOfComplex128ThenInt8)
}
func (__ *PoolOfComplex128ThenInt8Impl) PutWorkOfComplex128ThenInt8(p *WorkOfComplex128ThenInt8) {
	__.Complex128Work.Put(p)
}
func (__ *PoolOfComplex128ThenInt8Impl) GetReturnOfInt8() *ReturnOfInt8 {
	return __.Int8Return.Get().(*ReturnOfInt8)
}
func (__ *PoolOfComplex128ThenInt8Impl) PutReturnOfInt8(p *ReturnOfInt8) {
	__.Int8Return.Put(p)
}

func (__ *PoolOfComplex128ThenInt8Impl) GetChReturnOfInt8() chan *ReturnOfInt8 {
	return __.ChReturnOfInt8.Get().(chan *ReturnOfInt8)
}
func (__ *PoolOfComplex128ThenInt8Impl) PutChReturnOfInt8(p chan *ReturnOfInt8) {
	__.ChReturnOfInt8.Put(p)
}

func NewPoolOfComplex128ThenInt8Impl() *PoolOfComplex128ThenInt8Impl {
	return &PoolOfComplex128ThenInt8Impl{
		Complex128Arg: sync.Pool{
			New: func() interface{} {
				return new(complex128)
			},
		},
		Complex128Work: sync.Pool{
			New: func() interface{} {
				return new(WorkOfComplex128ThenInt8)
			},
		},
		Int8Rtn: sync.Pool{
			New: func() interface{} {
				return new(int8)
			},
		},
		Int8Return: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfInt8)
			},
		},
		ChReturnOfInt8: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfInt8, 1)
			},
		},
	}
}

type ApiDecouplerOfComplex128ThenInt8 struct {
	pool PoolOfComplex128ThenInt8
}

func NewApiDecouplerOfComplex128ThenInt8() *ApiDecouplerOfComplex128ThenInt8 {
	return &ApiDecouplerOfComplex128ThenInt8{
		pool: NewPoolOfComplex128ThenInt8Impl(),
	}
}

func (__ *ApiDecouplerOfComplex128ThenInt8) ReturnError(rtn_ch chan<- *ReturnOfInt8, err error) {
	rtn := __.pool.GetReturnOfInt8()
	var other int8
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfComplex128ThenInt8) HandleOfComplex128ThenInt8(ctx context.Context, req *WorkOfComplex128ThenInt8, h func(ctx context.Context, arg complex128) (int8, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfInt8()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfComplex128ThenInt8) DoOfComplex128ThenInt8(ctx context.Context, worker WorkerOfPushComplex128ThenInt8, arg complex128) (int8, error) {
	// ch := make(chan *ReturnOfInt8, 1)
	ch := __.pool.GetChReturnOfInt8()
	defer __.pool.PutChReturnOfInt8(ch)

	req := __.pool.GetWorkOfComplex128ThenInt8()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfComplex128ThenInt8(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfInt8(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfComplex128ThenInt8 = func(ctx context.Context, arg complex128) (int8, error)

type WorkerOfComplex128ThenInt8 struct {
	api_syncer *ApiDecouplerOfComplex128ThenInt8
	handler    WorkHandlerOfComplex128ThenInt8

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfComplex128ThenInt8
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfComplex128ThenInt8(ctx context.Context, h WorkHandlerOfComplex128ThenInt8, n int) *WorkerOfComplex128ThenInt8 {
	__ := &WorkerOfComplex128ThenInt8{
		api_syncer: NewApiDecouplerOfComplex128ThenInt8(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfComplex128ThenInt8, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfComplex128ThenInt8{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfComplex128ThenInt8(req.Context, req.WorkOfComplex128ThenInt8, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfComplex128ThenInt8) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfComplex128ThenInt8) Push(ctx context.Context, req *WorkOfComplex128ThenInt8) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfComplex128ThenInt8)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfComplex128ThenInt8 = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfComplex128ThenInt8) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfComplex128ThenInt8) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfComplex128ThenInt8) Call(ctx context.Context, arg complex128) (int8, error) {
	return __.api_syncer.DoOfComplex128ThenInt8(ctx, __, arg)
}

type PoolOfComplex128ThenRune interface {
	GetComplex128Arg() *complex128
	PutComplex128Arg(*complex128)
	GetRuneReturn() *rune
	PutRuneReturn(*rune)

	GetWorkOfComplex128ThenRune() *WorkOfComplex128ThenRune
	GetReturnOfRune() *ReturnOfRune
	PutWorkOfComplex128ThenRune(*WorkOfComplex128ThenRune)
	PutReturnOfRune(*ReturnOfRune)

	GetChReturnOfRune() chan *ReturnOfRune
	PutChReturnOfRune(chan *ReturnOfRune)
}

type PoolOfComplex128ThenRuneImpl struct {
	Complex128Arg  sync.Pool
	RuneRtn        sync.Pool
	Complex128Work sync.Pool
	RuneReturn     sync.Pool
	ChReturnOfRune sync.Pool
}

func (__ *PoolOfComplex128ThenRuneImpl) GetComplex128Arg() *complex128 {
	return __.Complex128Arg.Get().(*complex128)
}
func (__ *PoolOfComplex128ThenRuneImpl) PutComplex128Arg(p *complex128) {
	__.Complex128Arg.Put(p)
}
func (__ *PoolOfComplex128ThenRuneImpl) GetRuneReturn() *rune {
	return __.RuneRtn.Get().(*rune)
}
func (__ *PoolOfComplex128ThenRuneImpl) PutRuneReturn(p *rune) {
	__.RuneRtn.Put(p)
}

func (__ *PoolOfComplex128ThenRuneImpl) GetWorkOfComplex128ThenRune() *WorkOfComplex128ThenRune {
	return __.Complex128Work.Get().(*WorkOfComplex128ThenRune)
}
func (__ *PoolOfComplex128ThenRuneImpl) PutWorkOfComplex128ThenRune(p *WorkOfComplex128ThenRune) {
	__.Complex128Work.Put(p)
}
func (__ *PoolOfComplex128ThenRuneImpl) GetReturnOfRune() *ReturnOfRune {
	return __.RuneReturn.Get().(*ReturnOfRune)
}
func (__ *PoolOfComplex128ThenRuneImpl) PutReturnOfRune(p *ReturnOfRune) {
	__.RuneReturn.Put(p)
}

func (__ *PoolOfComplex128ThenRuneImpl) GetChReturnOfRune() chan *ReturnOfRune {
	return __.ChReturnOfRune.Get().(chan *ReturnOfRune)
}
func (__ *PoolOfComplex128ThenRuneImpl) PutChReturnOfRune(p chan *ReturnOfRune) {
	__.ChReturnOfRune.Put(p)
}

func NewPoolOfComplex128ThenRuneImpl() *PoolOfComplex128ThenRuneImpl {
	return &PoolOfComplex128ThenRuneImpl{
		Complex128Arg: sync.Pool{
			New: func() interface{} {
				return new(complex128)
			},
		},
		Complex128Work: sync.Pool{
			New: func() interface{} {
				return new(WorkOfComplex128ThenRune)
			},
		},
		RuneRtn: sync.Pool{
			New: func() interface{} {
				return new(rune)
			},
		},
		RuneReturn: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfRune)
			},
		},
		ChReturnOfRune: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfRune, 1)
			},
		},
	}
}

type ApiDecouplerOfComplex128ThenRune struct {
	pool PoolOfComplex128ThenRune
}

func NewApiDecouplerOfComplex128ThenRune() *ApiDecouplerOfComplex128ThenRune {
	return &ApiDecouplerOfComplex128ThenRune{
		pool: NewPoolOfComplex128ThenRuneImpl(),
	}
}

func (__ *ApiDecouplerOfComplex128ThenRune) ReturnError(rtn_ch chan<- *ReturnOfRune, err error) {
	rtn := __.pool.GetReturnOfRune()
	var other rune
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfComplex128ThenRune) HandleOfComplex128ThenRune(ctx context.Context, req *WorkOfComplex128ThenRune, h func(ctx context.Context, arg complex128) (rune, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfRune()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfComplex128ThenRune) DoOfComplex128ThenRune(ctx context.Context, worker WorkerOfPushComplex128ThenRune, arg complex128) (rune, error) {
	// ch := make(chan *ReturnOfRune, 1)
	ch := __.pool.GetChReturnOfRune()
	defer __.pool.PutChReturnOfRune(ch)

	req := __.pool.GetWorkOfComplex128ThenRune()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfComplex128ThenRune(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfRune(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfComplex128ThenRune = func(ctx context.Context, arg complex128) (rune, error)

type WorkerOfComplex128ThenRune struct {
	api_syncer *ApiDecouplerOfComplex128ThenRune
	handler    WorkHandlerOfComplex128ThenRune

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfComplex128ThenRune
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfComplex128ThenRune(ctx context.Context, h WorkHandlerOfComplex128ThenRune, n int) *WorkerOfComplex128ThenRune {
	__ := &WorkerOfComplex128ThenRune{
		api_syncer: NewApiDecouplerOfComplex128ThenRune(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfComplex128ThenRune, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfComplex128ThenRune{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfComplex128ThenRune(req.Context, req.WorkOfComplex128ThenRune, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfComplex128ThenRune) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfComplex128ThenRune) Push(ctx context.Context, req *WorkOfComplex128ThenRune) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfComplex128ThenRune)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfComplex128ThenRune = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfComplex128ThenRune) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfComplex128ThenRune) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfComplex128ThenRune) Call(ctx context.Context, arg complex128) (rune, error) {
	return __.api_syncer.DoOfComplex128ThenRune(ctx, __, arg)
}

type PoolOfComplex128ThenString interface {
	GetComplex128Arg() *complex128
	PutComplex128Arg(*complex128)
	GetStringReturn() *string
	PutStringReturn(*string)

	GetWorkOfComplex128ThenString() *WorkOfComplex128ThenString
	GetReturnOfString() *ReturnOfString
	PutWorkOfComplex128ThenString(*WorkOfComplex128ThenString)
	PutReturnOfString(*ReturnOfString)

	GetChReturnOfString() chan *ReturnOfString
	PutChReturnOfString(chan *ReturnOfString)
}

type PoolOfComplex128ThenStringImpl struct {
	Complex128Arg    sync.Pool
	StringRtn        sync.Pool
	Complex128Work   sync.Pool
	StringReturn     sync.Pool
	ChReturnOfString sync.Pool
}

func (__ *PoolOfComplex128ThenStringImpl) GetComplex128Arg() *complex128 {
	return __.Complex128Arg.Get().(*complex128)
}
func (__ *PoolOfComplex128ThenStringImpl) PutComplex128Arg(p *complex128) {
	__.Complex128Arg.Put(p)
}
func (__ *PoolOfComplex128ThenStringImpl) GetStringReturn() *string {
	return __.StringRtn.Get().(*string)
}
func (__ *PoolOfComplex128ThenStringImpl) PutStringReturn(p *string) {
	__.StringRtn.Put(p)
}

func (__ *PoolOfComplex128ThenStringImpl) GetWorkOfComplex128ThenString() *WorkOfComplex128ThenString {
	return __.Complex128Work.Get().(*WorkOfComplex128ThenString)
}
func (__ *PoolOfComplex128ThenStringImpl) PutWorkOfComplex128ThenString(p *WorkOfComplex128ThenString) {
	__.Complex128Work.Put(p)
}
func (__ *PoolOfComplex128ThenStringImpl) GetReturnOfString() *ReturnOfString {
	return __.StringReturn.Get().(*ReturnOfString)
}
func (__ *PoolOfComplex128ThenStringImpl) PutReturnOfString(p *ReturnOfString) {
	__.StringReturn.Put(p)
}

func (__ *PoolOfComplex128ThenStringImpl) GetChReturnOfString() chan *ReturnOfString {
	return __.ChReturnOfString.Get().(chan *ReturnOfString)
}
func (__ *PoolOfComplex128ThenStringImpl) PutChReturnOfString(p chan *ReturnOfString) {
	__.ChReturnOfString.Put(p)
}

func NewPoolOfComplex128ThenStringImpl() *PoolOfComplex128ThenStringImpl {
	return &PoolOfComplex128ThenStringImpl{
		Complex128Arg: sync.Pool{
			New: func() interface{} {
				return new(complex128)
			},
		},
		Complex128Work: sync.Pool{
			New: func() interface{} {
				return new(WorkOfComplex128ThenString)
			},
		},
		StringRtn: sync.Pool{
			New: func() interface{} {
				return new(string)
			},
		},
		StringReturn: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfString)
			},
		},
		ChReturnOfString: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfString, 1)
			},
		},
	}
}

type ApiDecouplerOfComplex128ThenString struct {
	pool PoolOfComplex128ThenString
}

func NewApiDecouplerOfComplex128ThenString() *ApiDecouplerOfComplex128ThenString {
	return &ApiDecouplerOfComplex128ThenString{
		pool: NewPoolOfComplex128ThenStringImpl(),
	}
}

func (__ *ApiDecouplerOfComplex128ThenString) ReturnError(rtn_ch chan<- *ReturnOfString, err error) {
	rtn := __.pool.GetReturnOfString()
	var other string
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfComplex128ThenString) HandleOfComplex128ThenString(ctx context.Context, req *WorkOfComplex128ThenString, h func(ctx context.Context, arg complex128) (string, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfString()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfComplex128ThenString) DoOfComplex128ThenString(ctx context.Context, worker WorkerOfPushComplex128ThenString, arg complex128) (string, error) {
	// ch := make(chan *ReturnOfString, 1)
	ch := __.pool.GetChReturnOfString()
	defer __.pool.PutChReturnOfString(ch)

	req := __.pool.GetWorkOfComplex128ThenString()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfComplex128ThenString(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfString(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfComplex128ThenString = func(ctx context.Context, arg complex128) (string, error)

type WorkerOfComplex128ThenString struct {
	api_syncer *ApiDecouplerOfComplex128ThenString
	handler    WorkHandlerOfComplex128ThenString

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfComplex128ThenString
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfComplex128ThenString(ctx context.Context, h WorkHandlerOfComplex128ThenString, n int) *WorkerOfComplex128ThenString {
	__ := &WorkerOfComplex128ThenString{
		api_syncer: NewApiDecouplerOfComplex128ThenString(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfComplex128ThenString, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfComplex128ThenString{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfComplex128ThenString(req.Context, req.WorkOfComplex128ThenString, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfComplex128ThenString) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfComplex128ThenString) Push(ctx context.Context, req *WorkOfComplex128ThenString) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfComplex128ThenString)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfComplex128ThenString = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfComplex128ThenString) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfComplex128ThenString) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfComplex128ThenString) Call(ctx context.Context, arg complex128) (string, error) {
	return __.api_syncer.DoOfComplex128ThenString(ctx, __, arg)
}

type PoolOfComplex128ThenUint interface {
	GetComplex128Arg() *complex128
	PutComplex128Arg(*complex128)
	GetUintReturn() *uint
	PutUintReturn(*uint)

	GetWorkOfComplex128ThenUint() *WorkOfComplex128ThenUint
	GetReturnOfUint() *ReturnOfUint
	PutWorkOfComplex128ThenUint(*WorkOfComplex128ThenUint)
	PutReturnOfUint(*ReturnOfUint)

	GetChReturnOfUint() chan *ReturnOfUint
	PutChReturnOfUint(chan *ReturnOfUint)
}

type PoolOfComplex128ThenUintImpl struct {
	Complex128Arg  sync.Pool
	UintRtn        sync.Pool
	Complex128Work sync.Pool
	UintReturn     sync.Pool
	ChReturnOfUint sync.Pool
}

func (__ *PoolOfComplex128ThenUintImpl) GetComplex128Arg() *complex128 {
	return __.Complex128Arg.Get().(*complex128)
}
func (__ *PoolOfComplex128ThenUintImpl) PutComplex128Arg(p *complex128) {
	__.Complex128Arg.Put(p)
}
func (__ *PoolOfComplex128ThenUintImpl) GetUintReturn() *uint {
	return __.UintRtn.Get().(*uint)
}
func (__ *PoolOfComplex128ThenUintImpl) PutUintReturn(p *uint) {
	__.UintRtn.Put(p)
}

func (__ *PoolOfComplex128ThenUintImpl) GetWorkOfComplex128ThenUint() *WorkOfComplex128ThenUint {
	return __.Complex128Work.Get().(*WorkOfComplex128ThenUint)
}
func (__ *PoolOfComplex128ThenUintImpl) PutWorkOfComplex128ThenUint(p *WorkOfComplex128ThenUint) {
	__.Complex128Work.Put(p)
}
func (__ *PoolOfComplex128ThenUintImpl) GetReturnOfUint() *ReturnOfUint {
	return __.UintReturn.Get().(*ReturnOfUint)
}
func (__ *PoolOfComplex128ThenUintImpl) PutReturnOfUint(p *ReturnOfUint) {
	__.UintReturn.Put(p)
}

func (__ *PoolOfComplex128ThenUintImpl) GetChReturnOfUint() chan *ReturnOfUint {
	return __.ChReturnOfUint.Get().(chan *ReturnOfUint)
}
func (__ *PoolOfComplex128ThenUintImpl) PutChReturnOfUint(p chan *ReturnOfUint) {
	__.ChReturnOfUint.Put(p)
}

func NewPoolOfComplex128ThenUintImpl() *PoolOfComplex128ThenUintImpl {
	return &PoolOfComplex128ThenUintImpl{
		Complex128Arg: sync.Pool{
			New: func() interface{} {
				return new(complex128)
			},
		},
		Complex128Work: sync.Pool{
			New: func() interface{} {
				return new(WorkOfComplex128ThenUint)
			},
		},
		UintRtn: sync.Pool{
			New: func() interface{} {
				return new(uint)
			},
		},
		UintReturn: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfUint)
			},
		},
		ChReturnOfUint: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfUint, 1)
			},
		},
	}
}

type ApiDecouplerOfComplex128ThenUint struct {
	pool PoolOfComplex128ThenUint
}

func NewApiDecouplerOfComplex128ThenUint() *ApiDecouplerOfComplex128ThenUint {
	return &ApiDecouplerOfComplex128ThenUint{
		pool: NewPoolOfComplex128ThenUintImpl(),
	}
}

func (__ *ApiDecouplerOfComplex128ThenUint) ReturnError(rtn_ch chan<- *ReturnOfUint, err error) {
	rtn := __.pool.GetReturnOfUint()
	var other uint
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfComplex128ThenUint) HandleOfComplex128ThenUint(ctx context.Context, req *WorkOfComplex128ThenUint, h func(ctx context.Context, arg complex128) (uint, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfUint()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfComplex128ThenUint) DoOfComplex128ThenUint(ctx context.Context, worker WorkerOfPushComplex128ThenUint, arg complex128) (uint, error) {
	// ch := make(chan *ReturnOfUint, 1)
	ch := __.pool.GetChReturnOfUint()
	defer __.pool.PutChReturnOfUint(ch)

	req := __.pool.GetWorkOfComplex128ThenUint()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfComplex128ThenUint(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfUint(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfComplex128ThenUint = func(ctx context.Context, arg complex128) (uint, error)

type WorkerOfComplex128ThenUint struct {
	api_syncer *ApiDecouplerOfComplex128ThenUint
	handler    WorkHandlerOfComplex128ThenUint

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfComplex128ThenUint
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfComplex128ThenUint(ctx context.Context, h WorkHandlerOfComplex128ThenUint, n int) *WorkerOfComplex128ThenUint {
	__ := &WorkerOfComplex128ThenUint{
		api_syncer: NewApiDecouplerOfComplex128ThenUint(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfComplex128ThenUint, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfComplex128ThenUint{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfComplex128ThenUint(req.Context, req.WorkOfComplex128ThenUint, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfComplex128ThenUint) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfComplex128ThenUint) Push(ctx context.Context, req *WorkOfComplex128ThenUint) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfComplex128ThenUint)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfComplex128ThenUint = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfComplex128ThenUint) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfComplex128ThenUint) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfComplex128ThenUint) Call(ctx context.Context, arg complex128) (uint, error) {
	return __.api_syncer.DoOfComplex128ThenUint(ctx, __, arg)
}

type PoolOfComplex128ThenUint16 interface {
	GetComplex128Arg() *complex128
	PutComplex128Arg(*complex128)
	GetUint16Return() *uint16
	PutUint16Return(*uint16)

	GetWorkOfComplex128ThenUint16() *WorkOfComplex128ThenUint16
	GetReturnOfUint16() *ReturnOfUint16
	PutWorkOfComplex128ThenUint16(*WorkOfComplex128ThenUint16)
	PutReturnOfUint16(*ReturnOfUint16)

	GetChReturnOfUint16() chan *ReturnOfUint16
	PutChReturnOfUint16(chan *ReturnOfUint16)
}

type PoolOfComplex128ThenUint16Impl struct {
	Complex128Arg    sync.Pool
	Uint16Rtn        sync.Pool
	Complex128Work   sync.Pool
	Uint16Return     sync.Pool
	ChReturnOfUint16 sync.Pool
}

func (__ *PoolOfComplex128ThenUint16Impl) GetComplex128Arg() *complex128 {
	return __.Complex128Arg.Get().(*complex128)
}
func (__ *PoolOfComplex128ThenUint16Impl) PutComplex128Arg(p *complex128) {
	__.Complex128Arg.Put(p)
}
func (__ *PoolOfComplex128ThenUint16Impl) GetUint16Return() *uint16 {
	return __.Uint16Rtn.Get().(*uint16)
}
func (__ *PoolOfComplex128ThenUint16Impl) PutUint16Return(p *uint16) {
	__.Uint16Rtn.Put(p)
}

func (__ *PoolOfComplex128ThenUint16Impl) GetWorkOfComplex128ThenUint16() *WorkOfComplex128ThenUint16 {
	return __.Complex128Work.Get().(*WorkOfComplex128ThenUint16)
}
func (__ *PoolOfComplex128ThenUint16Impl) PutWorkOfComplex128ThenUint16(p *WorkOfComplex128ThenUint16) {
	__.Complex128Work.Put(p)
}
func (__ *PoolOfComplex128ThenUint16Impl) GetReturnOfUint16() *ReturnOfUint16 {
	return __.Uint16Return.Get().(*ReturnOfUint16)
}
func (__ *PoolOfComplex128ThenUint16Impl) PutReturnOfUint16(p *ReturnOfUint16) {
	__.Uint16Return.Put(p)
}

func (__ *PoolOfComplex128ThenUint16Impl) GetChReturnOfUint16() chan *ReturnOfUint16 {
	return __.ChReturnOfUint16.Get().(chan *ReturnOfUint16)
}
func (__ *PoolOfComplex128ThenUint16Impl) PutChReturnOfUint16(p chan *ReturnOfUint16) {
	__.ChReturnOfUint16.Put(p)
}

func NewPoolOfComplex128ThenUint16Impl() *PoolOfComplex128ThenUint16Impl {
	return &PoolOfComplex128ThenUint16Impl{
		Complex128Arg: sync.Pool{
			New: func() interface{} {
				return new(complex128)
			},
		},
		Complex128Work: sync.Pool{
			New: func() interface{} {
				return new(WorkOfComplex128ThenUint16)
			},
		},
		Uint16Rtn: sync.Pool{
			New: func() interface{} {
				return new(uint16)
			},
		},
		Uint16Return: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfUint16)
			},
		},
		ChReturnOfUint16: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfUint16, 1)
			},
		},
	}
}

type ApiDecouplerOfComplex128ThenUint16 struct {
	pool PoolOfComplex128ThenUint16
}

func NewApiDecouplerOfComplex128ThenUint16() *ApiDecouplerOfComplex128ThenUint16 {
	return &ApiDecouplerOfComplex128ThenUint16{
		pool: NewPoolOfComplex128ThenUint16Impl(),
	}
}

func (__ *ApiDecouplerOfComplex128ThenUint16) ReturnError(rtn_ch chan<- *ReturnOfUint16, err error) {
	rtn := __.pool.GetReturnOfUint16()
	var other uint16
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfComplex128ThenUint16) HandleOfComplex128ThenUint16(ctx context.Context, req *WorkOfComplex128ThenUint16, h func(ctx context.Context, arg complex128) (uint16, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfUint16()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfComplex128ThenUint16) DoOfComplex128ThenUint16(ctx context.Context, worker WorkerOfPushComplex128ThenUint16, arg complex128) (uint16, error) {
	// ch := make(chan *ReturnOfUint16, 1)
	ch := __.pool.GetChReturnOfUint16()
	defer __.pool.PutChReturnOfUint16(ch)

	req := __.pool.GetWorkOfComplex128ThenUint16()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfComplex128ThenUint16(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfUint16(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfComplex128ThenUint16 = func(ctx context.Context, arg complex128) (uint16, error)

type WorkerOfComplex128ThenUint16 struct {
	api_syncer *ApiDecouplerOfComplex128ThenUint16
	handler    WorkHandlerOfComplex128ThenUint16

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfComplex128ThenUint16
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfComplex128ThenUint16(ctx context.Context, h WorkHandlerOfComplex128ThenUint16, n int) *WorkerOfComplex128ThenUint16 {
	__ := &WorkerOfComplex128ThenUint16{
		api_syncer: NewApiDecouplerOfComplex128ThenUint16(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfComplex128ThenUint16, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfComplex128ThenUint16{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfComplex128ThenUint16(req.Context, req.WorkOfComplex128ThenUint16, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfComplex128ThenUint16) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfComplex128ThenUint16) Push(ctx context.Context, req *WorkOfComplex128ThenUint16) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfComplex128ThenUint16)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfComplex128ThenUint16 = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfComplex128ThenUint16) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfComplex128ThenUint16) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfComplex128ThenUint16) Call(ctx context.Context, arg complex128) (uint16, error) {
	return __.api_syncer.DoOfComplex128ThenUint16(ctx, __, arg)
}

type PoolOfComplex128ThenUint32 interface {
	GetComplex128Arg() *complex128
	PutComplex128Arg(*complex128)
	GetUint32Return() *uint32
	PutUint32Return(*uint32)

	GetWorkOfComplex128ThenUint32() *WorkOfComplex128ThenUint32
	GetReturnOfUint32() *ReturnOfUint32
	PutWorkOfComplex128ThenUint32(*WorkOfComplex128ThenUint32)
	PutReturnOfUint32(*ReturnOfUint32)

	GetChReturnOfUint32() chan *ReturnOfUint32
	PutChReturnOfUint32(chan *ReturnOfUint32)
}

type PoolOfComplex128ThenUint32Impl struct {
	Complex128Arg    sync.Pool
	Uint32Rtn        sync.Pool
	Complex128Work   sync.Pool
	Uint32Return     sync.Pool
	ChReturnOfUint32 sync.Pool
}

func (__ *PoolOfComplex128ThenUint32Impl) GetComplex128Arg() *complex128 {
	return __.Complex128Arg.Get().(*complex128)
}
func (__ *PoolOfComplex128ThenUint32Impl) PutComplex128Arg(p *complex128) {
	__.Complex128Arg.Put(p)
}
func (__ *PoolOfComplex128ThenUint32Impl) GetUint32Return() *uint32 {
	return __.Uint32Rtn.Get().(*uint32)
}
func (__ *PoolOfComplex128ThenUint32Impl) PutUint32Return(p *uint32) {
	__.Uint32Rtn.Put(p)
}

func (__ *PoolOfComplex128ThenUint32Impl) GetWorkOfComplex128ThenUint32() *WorkOfComplex128ThenUint32 {
	return __.Complex128Work.Get().(*WorkOfComplex128ThenUint32)
}
func (__ *PoolOfComplex128ThenUint32Impl) PutWorkOfComplex128ThenUint32(p *WorkOfComplex128ThenUint32) {
	__.Complex128Work.Put(p)
}
func (__ *PoolOfComplex128ThenUint32Impl) GetReturnOfUint32() *ReturnOfUint32 {
	return __.Uint32Return.Get().(*ReturnOfUint32)
}
func (__ *PoolOfComplex128ThenUint32Impl) PutReturnOfUint32(p *ReturnOfUint32) {
	__.Uint32Return.Put(p)
}

func (__ *PoolOfComplex128ThenUint32Impl) GetChReturnOfUint32() chan *ReturnOfUint32 {
	return __.ChReturnOfUint32.Get().(chan *ReturnOfUint32)
}
func (__ *PoolOfComplex128ThenUint32Impl) PutChReturnOfUint32(p chan *ReturnOfUint32) {
	__.ChReturnOfUint32.Put(p)
}

func NewPoolOfComplex128ThenUint32Impl() *PoolOfComplex128ThenUint32Impl {
	return &PoolOfComplex128ThenUint32Impl{
		Complex128Arg: sync.Pool{
			New: func() interface{} {
				return new(complex128)
			},
		},
		Complex128Work: sync.Pool{
			New: func() interface{} {
				return new(WorkOfComplex128ThenUint32)
			},
		},
		Uint32Rtn: sync.Pool{
			New: func() interface{} {
				return new(uint32)
			},
		},
		Uint32Return: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfUint32)
			},
		},
		ChReturnOfUint32: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfUint32, 1)
			},
		},
	}
}

type ApiDecouplerOfComplex128ThenUint32 struct {
	pool PoolOfComplex128ThenUint32
}

func NewApiDecouplerOfComplex128ThenUint32() *ApiDecouplerOfComplex128ThenUint32 {
	return &ApiDecouplerOfComplex128ThenUint32{
		pool: NewPoolOfComplex128ThenUint32Impl(),
	}
}

func (__ *ApiDecouplerOfComplex128ThenUint32) ReturnError(rtn_ch chan<- *ReturnOfUint32, err error) {
	rtn := __.pool.GetReturnOfUint32()
	var other uint32
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfComplex128ThenUint32) HandleOfComplex128ThenUint32(ctx context.Context, req *WorkOfComplex128ThenUint32, h func(ctx context.Context, arg complex128) (uint32, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfUint32()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfComplex128ThenUint32) DoOfComplex128ThenUint32(ctx context.Context, worker WorkerOfPushComplex128ThenUint32, arg complex128) (uint32, error) {
	// ch := make(chan *ReturnOfUint32, 1)
	ch := __.pool.GetChReturnOfUint32()
	defer __.pool.PutChReturnOfUint32(ch)

	req := __.pool.GetWorkOfComplex128ThenUint32()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfComplex128ThenUint32(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfUint32(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfComplex128ThenUint32 = func(ctx context.Context, arg complex128) (uint32, error)

type WorkerOfComplex128ThenUint32 struct {
	api_syncer *ApiDecouplerOfComplex128ThenUint32
	handler    WorkHandlerOfComplex128ThenUint32

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfComplex128ThenUint32
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfComplex128ThenUint32(ctx context.Context, h WorkHandlerOfComplex128ThenUint32, n int) *WorkerOfComplex128ThenUint32 {
	__ := &WorkerOfComplex128ThenUint32{
		api_syncer: NewApiDecouplerOfComplex128ThenUint32(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfComplex128ThenUint32, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfComplex128ThenUint32{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfComplex128ThenUint32(req.Context, req.WorkOfComplex128ThenUint32, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfComplex128ThenUint32) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfComplex128ThenUint32) Push(ctx context.Context, req *WorkOfComplex128ThenUint32) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfComplex128ThenUint32)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfComplex128ThenUint32 = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfComplex128ThenUint32) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfComplex128ThenUint32) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfComplex128ThenUint32) Call(ctx context.Context, arg complex128) (uint32, error) {
	return __.api_syncer.DoOfComplex128ThenUint32(ctx, __, arg)
}

type PoolOfComplex128ThenUint64 interface {
	GetComplex128Arg() *complex128
	PutComplex128Arg(*complex128)
	GetUint64Return() *uint64
	PutUint64Return(*uint64)

	GetWorkOfComplex128ThenUint64() *WorkOfComplex128ThenUint64
	GetReturnOfUint64() *ReturnOfUint64
	PutWorkOfComplex128ThenUint64(*WorkOfComplex128ThenUint64)
	PutReturnOfUint64(*ReturnOfUint64)

	GetChReturnOfUint64() chan *ReturnOfUint64
	PutChReturnOfUint64(chan *ReturnOfUint64)
}

type PoolOfComplex128ThenUint64Impl struct {
	Complex128Arg    sync.Pool
	Uint64Rtn        sync.Pool
	Complex128Work   sync.Pool
	Uint64Return     sync.Pool
	ChReturnOfUint64 sync.Pool
}

func (__ *PoolOfComplex128ThenUint64Impl) GetComplex128Arg() *complex128 {
	return __.Complex128Arg.Get().(*complex128)
}
func (__ *PoolOfComplex128ThenUint64Impl) PutComplex128Arg(p *complex128) {
	__.Complex128Arg.Put(p)
}
func (__ *PoolOfComplex128ThenUint64Impl) GetUint64Return() *uint64 {
	return __.Uint64Rtn.Get().(*uint64)
}
func (__ *PoolOfComplex128ThenUint64Impl) PutUint64Return(p *uint64) {
	__.Uint64Rtn.Put(p)
}

func (__ *PoolOfComplex128ThenUint64Impl) GetWorkOfComplex128ThenUint64() *WorkOfComplex128ThenUint64 {
	return __.Complex128Work.Get().(*WorkOfComplex128ThenUint64)
}
func (__ *PoolOfComplex128ThenUint64Impl) PutWorkOfComplex128ThenUint64(p *WorkOfComplex128ThenUint64) {
	__.Complex128Work.Put(p)
}
func (__ *PoolOfComplex128ThenUint64Impl) GetReturnOfUint64() *ReturnOfUint64 {
	return __.Uint64Return.Get().(*ReturnOfUint64)
}
func (__ *PoolOfComplex128ThenUint64Impl) PutReturnOfUint64(p *ReturnOfUint64) {
	__.Uint64Return.Put(p)
}

func (__ *PoolOfComplex128ThenUint64Impl) GetChReturnOfUint64() chan *ReturnOfUint64 {
	return __.ChReturnOfUint64.Get().(chan *ReturnOfUint64)
}
func (__ *PoolOfComplex128ThenUint64Impl) PutChReturnOfUint64(p chan *ReturnOfUint64) {
	__.ChReturnOfUint64.Put(p)
}

func NewPoolOfComplex128ThenUint64Impl() *PoolOfComplex128ThenUint64Impl {
	return &PoolOfComplex128ThenUint64Impl{
		Complex128Arg: sync.Pool{
			New: func() interface{} {
				return new(complex128)
			},
		},
		Complex128Work: sync.Pool{
			New: func() interface{} {
				return new(WorkOfComplex128ThenUint64)
			},
		},
		Uint64Rtn: sync.Pool{
			New: func() interface{} {
				return new(uint64)
			},
		},
		Uint64Return: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfUint64)
			},
		},
		ChReturnOfUint64: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfUint64, 1)
			},
		},
	}
}

type ApiDecouplerOfComplex128ThenUint64 struct {
	pool PoolOfComplex128ThenUint64
}

func NewApiDecouplerOfComplex128ThenUint64() *ApiDecouplerOfComplex128ThenUint64 {
	return &ApiDecouplerOfComplex128ThenUint64{
		pool: NewPoolOfComplex128ThenUint64Impl(),
	}
}

func (__ *ApiDecouplerOfComplex128ThenUint64) ReturnError(rtn_ch chan<- *ReturnOfUint64, err error) {
	rtn := __.pool.GetReturnOfUint64()
	var other uint64
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfComplex128ThenUint64) HandleOfComplex128ThenUint64(ctx context.Context, req *WorkOfComplex128ThenUint64, h func(ctx context.Context, arg complex128) (uint64, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfUint64()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfComplex128ThenUint64) DoOfComplex128ThenUint64(ctx context.Context, worker WorkerOfPushComplex128ThenUint64, arg complex128) (uint64, error) {
	// ch := make(chan *ReturnOfUint64, 1)
	ch := __.pool.GetChReturnOfUint64()
	defer __.pool.PutChReturnOfUint64(ch)

	req := __.pool.GetWorkOfComplex128ThenUint64()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfComplex128ThenUint64(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfUint64(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfComplex128ThenUint64 = func(ctx context.Context, arg complex128) (uint64, error)

type WorkerOfComplex128ThenUint64 struct {
	api_syncer *ApiDecouplerOfComplex128ThenUint64
	handler    WorkHandlerOfComplex128ThenUint64

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfComplex128ThenUint64
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfComplex128ThenUint64(ctx context.Context, h WorkHandlerOfComplex128ThenUint64, n int) *WorkerOfComplex128ThenUint64 {
	__ := &WorkerOfComplex128ThenUint64{
		api_syncer: NewApiDecouplerOfComplex128ThenUint64(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfComplex128ThenUint64, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfComplex128ThenUint64{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfComplex128ThenUint64(req.Context, req.WorkOfComplex128ThenUint64, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfComplex128ThenUint64) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfComplex128ThenUint64) Push(ctx context.Context, req *WorkOfComplex128ThenUint64) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfComplex128ThenUint64)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfComplex128ThenUint64 = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfComplex128ThenUint64) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfComplex128ThenUint64) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfComplex128ThenUint64) Call(ctx context.Context, arg complex128) (uint64, error) {
	return __.api_syncer.DoOfComplex128ThenUint64(ctx, __, arg)
}

type PoolOfComplex128ThenUint8 interface {
	GetComplex128Arg() *complex128
	PutComplex128Arg(*complex128)
	GetUint8Return() *uint8
	PutUint8Return(*uint8)

	GetWorkOfComplex128ThenUint8() *WorkOfComplex128ThenUint8
	GetReturnOfUint8() *ReturnOfUint8
	PutWorkOfComplex128ThenUint8(*WorkOfComplex128ThenUint8)
	PutReturnOfUint8(*ReturnOfUint8)

	GetChReturnOfUint8() chan *ReturnOfUint8
	PutChReturnOfUint8(chan *ReturnOfUint8)
}

type PoolOfComplex128ThenUint8Impl struct {
	Complex128Arg   sync.Pool
	Uint8Rtn        sync.Pool
	Complex128Work  sync.Pool
	Uint8Return     sync.Pool
	ChReturnOfUint8 sync.Pool
}

func (__ *PoolOfComplex128ThenUint8Impl) GetComplex128Arg() *complex128 {
	return __.Complex128Arg.Get().(*complex128)
}
func (__ *PoolOfComplex128ThenUint8Impl) PutComplex128Arg(p *complex128) {
	__.Complex128Arg.Put(p)
}
func (__ *PoolOfComplex128ThenUint8Impl) GetUint8Return() *uint8 {
	return __.Uint8Rtn.Get().(*uint8)
}
func (__ *PoolOfComplex128ThenUint8Impl) PutUint8Return(p *uint8) {
	__.Uint8Rtn.Put(p)
}

func (__ *PoolOfComplex128ThenUint8Impl) GetWorkOfComplex128ThenUint8() *WorkOfComplex128ThenUint8 {
	return __.Complex128Work.Get().(*WorkOfComplex128ThenUint8)
}
func (__ *PoolOfComplex128ThenUint8Impl) PutWorkOfComplex128ThenUint8(p *WorkOfComplex128ThenUint8) {
	__.Complex128Work.Put(p)
}
func (__ *PoolOfComplex128ThenUint8Impl) GetReturnOfUint8() *ReturnOfUint8 {
	return __.Uint8Return.Get().(*ReturnOfUint8)
}
func (__ *PoolOfComplex128ThenUint8Impl) PutReturnOfUint8(p *ReturnOfUint8) {
	__.Uint8Return.Put(p)
}

func (__ *PoolOfComplex128ThenUint8Impl) GetChReturnOfUint8() chan *ReturnOfUint8 {
	return __.ChReturnOfUint8.Get().(chan *ReturnOfUint8)
}
func (__ *PoolOfComplex128ThenUint8Impl) PutChReturnOfUint8(p chan *ReturnOfUint8) {
	__.ChReturnOfUint8.Put(p)
}

func NewPoolOfComplex128ThenUint8Impl() *PoolOfComplex128ThenUint8Impl {
	return &PoolOfComplex128ThenUint8Impl{
		Complex128Arg: sync.Pool{
			New: func() interface{} {
				return new(complex128)
			},
		},
		Complex128Work: sync.Pool{
			New: func() interface{} {
				return new(WorkOfComplex128ThenUint8)
			},
		},
		Uint8Rtn: sync.Pool{
			New: func() interface{} {
				return new(uint8)
			},
		},
		Uint8Return: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfUint8)
			},
		},
		ChReturnOfUint8: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfUint8, 1)
			},
		},
	}
}

type ApiDecouplerOfComplex128ThenUint8 struct {
	pool PoolOfComplex128ThenUint8
}

func NewApiDecouplerOfComplex128ThenUint8() *ApiDecouplerOfComplex128ThenUint8 {
	return &ApiDecouplerOfComplex128ThenUint8{
		pool: NewPoolOfComplex128ThenUint8Impl(),
	}
}

func (__ *ApiDecouplerOfComplex128ThenUint8) ReturnError(rtn_ch chan<- *ReturnOfUint8, err error) {
	rtn := __.pool.GetReturnOfUint8()
	var other uint8
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfComplex128ThenUint8) HandleOfComplex128ThenUint8(ctx context.Context, req *WorkOfComplex128ThenUint8, h func(ctx context.Context, arg complex128) (uint8, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfUint8()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfComplex128ThenUint8) DoOfComplex128ThenUint8(ctx context.Context, worker WorkerOfPushComplex128ThenUint8, arg complex128) (uint8, error) {
	// ch := make(chan *ReturnOfUint8, 1)
	ch := __.pool.GetChReturnOfUint8()
	defer __.pool.PutChReturnOfUint8(ch)

	req := __.pool.GetWorkOfComplex128ThenUint8()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfComplex128ThenUint8(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfUint8(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfComplex128ThenUint8 = func(ctx context.Context, arg complex128) (uint8, error)

type WorkerOfComplex128ThenUint8 struct {
	api_syncer *ApiDecouplerOfComplex128ThenUint8
	handler    WorkHandlerOfComplex128ThenUint8

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfComplex128ThenUint8
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfComplex128ThenUint8(ctx context.Context, h WorkHandlerOfComplex128ThenUint8, n int) *WorkerOfComplex128ThenUint8 {
	__ := &WorkerOfComplex128ThenUint8{
		api_syncer: NewApiDecouplerOfComplex128ThenUint8(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfComplex128ThenUint8, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfComplex128ThenUint8{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfComplex128ThenUint8(req.Context, req.WorkOfComplex128ThenUint8, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfComplex128ThenUint8) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfComplex128ThenUint8) Push(ctx context.Context, req *WorkOfComplex128ThenUint8) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfComplex128ThenUint8)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfComplex128ThenUint8 = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfComplex128ThenUint8) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfComplex128ThenUint8) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfComplex128ThenUint8) Call(ctx context.Context, arg complex128) (uint8, error) {
	return __.api_syncer.DoOfComplex128ThenUint8(ctx, __, arg)
}

type PoolOfComplex128ThenUintptr interface {
	GetComplex128Arg() *complex128
	PutComplex128Arg(*complex128)
	GetUintptrReturn() *uintptr
	PutUintptrReturn(*uintptr)

	GetWorkOfComplex128ThenUintptr() *WorkOfComplex128ThenUintptr
	GetReturnOfUintptr() *ReturnOfUintptr
	PutWorkOfComplex128ThenUintptr(*WorkOfComplex128ThenUintptr)
	PutReturnOfUintptr(*ReturnOfUintptr)

	GetChReturnOfUintptr() chan *ReturnOfUintptr
	PutChReturnOfUintptr(chan *ReturnOfUintptr)
}

type PoolOfComplex128ThenUintptrImpl struct {
	Complex128Arg     sync.Pool
	UintptrRtn        sync.Pool
	Complex128Work    sync.Pool
	UintptrReturn     sync.Pool
	ChReturnOfUintptr sync.Pool
}

func (__ *PoolOfComplex128ThenUintptrImpl) GetComplex128Arg() *complex128 {
	return __.Complex128Arg.Get().(*complex128)
}
func (__ *PoolOfComplex128ThenUintptrImpl) PutComplex128Arg(p *complex128) {
	__.Complex128Arg.Put(p)
}
func (__ *PoolOfComplex128ThenUintptrImpl) GetUintptrReturn() *uintptr {
	return __.UintptrRtn.Get().(*uintptr)
}
func (__ *PoolOfComplex128ThenUintptrImpl) PutUintptrReturn(p *uintptr) {
	__.UintptrRtn.Put(p)
}

func (__ *PoolOfComplex128ThenUintptrImpl) GetWorkOfComplex128ThenUintptr() *WorkOfComplex128ThenUintptr {
	return __.Complex128Work.Get().(*WorkOfComplex128ThenUintptr)
}
func (__ *PoolOfComplex128ThenUintptrImpl) PutWorkOfComplex128ThenUintptr(p *WorkOfComplex128ThenUintptr) {
	__.Complex128Work.Put(p)
}
func (__ *PoolOfComplex128ThenUintptrImpl) GetReturnOfUintptr() *ReturnOfUintptr {
	return __.UintptrReturn.Get().(*ReturnOfUintptr)
}
func (__ *PoolOfComplex128ThenUintptrImpl) PutReturnOfUintptr(p *ReturnOfUintptr) {
	__.UintptrReturn.Put(p)
}

func (__ *PoolOfComplex128ThenUintptrImpl) GetChReturnOfUintptr() chan *ReturnOfUintptr {
	return __.ChReturnOfUintptr.Get().(chan *ReturnOfUintptr)
}
func (__ *PoolOfComplex128ThenUintptrImpl) PutChReturnOfUintptr(p chan *ReturnOfUintptr) {
	__.ChReturnOfUintptr.Put(p)
}

func NewPoolOfComplex128ThenUintptrImpl() *PoolOfComplex128ThenUintptrImpl {
	return &PoolOfComplex128ThenUintptrImpl{
		Complex128Arg: sync.Pool{
			New: func() interface{} {
				return new(complex128)
			},
		},
		Complex128Work: sync.Pool{
			New: func() interface{} {
				return new(WorkOfComplex128ThenUintptr)
			},
		},
		UintptrRtn: sync.Pool{
			New: func() interface{} {
				return new(uintptr)
			},
		},
		UintptrReturn: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfUintptr)
			},
		},
		ChReturnOfUintptr: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfUintptr, 1)
			},
		},
	}
}

type ApiDecouplerOfComplex128ThenUintptr struct {
	pool PoolOfComplex128ThenUintptr
}

func NewApiDecouplerOfComplex128ThenUintptr() *ApiDecouplerOfComplex128ThenUintptr {
	return &ApiDecouplerOfComplex128ThenUintptr{
		pool: NewPoolOfComplex128ThenUintptrImpl(),
	}
}

func (__ *ApiDecouplerOfComplex128ThenUintptr) ReturnError(rtn_ch chan<- *ReturnOfUintptr, err error) {
	rtn := __.pool.GetReturnOfUintptr()
	var other uintptr
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfComplex128ThenUintptr) HandleOfComplex128ThenUintptr(ctx context.Context, req *WorkOfComplex128ThenUintptr, h func(ctx context.Context, arg complex128) (uintptr, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfUintptr()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfComplex128ThenUintptr) DoOfComplex128ThenUintptr(ctx context.Context, worker WorkerOfPushComplex128ThenUintptr, arg complex128) (uintptr, error) {
	// ch := make(chan *ReturnOfUintptr, 1)
	ch := __.pool.GetChReturnOfUintptr()
	defer __.pool.PutChReturnOfUintptr(ch)

	req := __.pool.GetWorkOfComplex128ThenUintptr()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfComplex128ThenUintptr(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfUintptr(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfComplex128ThenUintptr = func(ctx context.Context, arg complex128) (uintptr, error)

type WorkerOfComplex128ThenUintptr struct {
	api_syncer *ApiDecouplerOfComplex128ThenUintptr
	handler    WorkHandlerOfComplex128ThenUintptr

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfComplex128ThenUintptr
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfComplex128ThenUintptr(ctx context.Context, h WorkHandlerOfComplex128ThenUintptr, n int) *WorkerOfComplex128ThenUintptr {
	__ := &WorkerOfComplex128ThenUintptr{
		api_syncer: NewApiDecouplerOfComplex128ThenUintptr(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfComplex128ThenUintptr, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfComplex128ThenUintptr{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfComplex128ThenUintptr(req.Context, req.WorkOfComplex128ThenUintptr, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfComplex128ThenUintptr) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfComplex128ThenUintptr) Push(ctx context.Context, req *WorkOfComplex128ThenUintptr) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfComplex128ThenUintptr)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfComplex128ThenUintptr = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfComplex128ThenUintptr) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfComplex128ThenUintptr) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfComplex128ThenUintptr) Call(ctx context.Context, arg complex128) (uintptr, error) {
	return __.api_syncer.DoOfComplex128ThenUintptr(ctx, __, arg)
}

type PoolOfComplex128ThenInterface interface {
	GetComplex128Arg() *complex128
	PutComplex128Arg(*complex128)
	GetInterfaceReturn() *interface{}
	PutInterfaceReturn(*interface{})

	GetWorkOfComplex128ThenInterface() *WorkOfComplex128ThenInterface
	GetReturnOfInterface() *ReturnOfInterface
	PutWorkOfComplex128ThenInterface(*WorkOfComplex128ThenInterface)
	PutReturnOfInterface(*ReturnOfInterface)

	GetChReturnOfInterface() chan *ReturnOfInterface
	PutChReturnOfInterface(chan *ReturnOfInterface)
}

type PoolOfComplex128ThenInterfaceImpl struct {
	Complex128Arg       sync.Pool
	InterfaceRtn        sync.Pool
	Complex128Work      sync.Pool
	InterfaceReturn     sync.Pool
	ChReturnOfInterface sync.Pool
}

func (__ *PoolOfComplex128ThenInterfaceImpl) GetComplex128Arg() *complex128 {
	return __.Complex128Arg.Get().(*complex128)
}
func (__ *PoolOfComplex128ThenInterfaceImpl) PutComplex128Arg(p *complex128) {
	__.Complex128Arg.Put(p)
}
func (__ *PoolOfComplex128ThenInterfaceImpl) GetInterfaceReturn() *interface{} {
	return __.InterfaceRtn.Get().(*interface{})
}
func (__ *PoolOfComplex128ThenInterfaceImpl) PutInterfaceReturn(p *interface{}) {
	__.InterfaceRtn.Put(p)
}

func (__ *PoolOfComplex128ThenInterfaceImpl) GetWorkOfComplex128ThenInterface() *WorkOfComplex128ThenInterface {
	return __.Complex128Work.Get().(*WorkOfComplex128ThenInterface)
}
func (__ *PoolOfComplex128ThenInterfaceImpl) PutWorkOfComplex128ThenInterface(p *WorkOfComplex128ThenInterface) {
	__.Complex128Work.Put(p)
}
func (__ *PoolOfComplex128ThenInterfaceImpl) GetReturnOfInterface() *ReturnOfInterface {
	return __.InterfaceReturn.Get().(*ReturnOfInterface)
}
func (__ *PoolOfComplex128ThenInterfaceImpl) PutReturnOfInterface(p *ReturnOfInterface) {
	__.InterfaceReturn.Put(p)
}

func (__ *PoolOfComplex128ThenInterfaceImpl) GetChReturnOfInterface() chan *ReturnOfInterface {
	return __.ChReturnOfInterface.Get().(chan *ReturnOfInterface)
}
func (__ *PoolOfComplex128ThenInterfaceImpl) PutChReturnOfInterface(p chan *ReturnOfInterface) {
	__.ChReturnOfInterface.Put(p)
}

func NewPoolOfComplex128ThenInterfaceImpl() *PoolOfComplex128ThenInterfaceImpl {
	return &PoolOfComplex128ThenInterfaceImpl{
		Complex128Arg: sync.Pool{
			New: func() interface{} {
				return new(complex128)
			},
		},
		Complex128Work: sync.Pool{
			New: func() interface{} {
				return new(WorkOfComplex128ThenInterface)
			},
		},
		InterfaceRtn: sync.Pool{
			New: func() interface{} {
				return new(interface{})
			},
		},
		InterfaceReturn: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfInterface)
			},
		},
		ChReturnOfInterface: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfInterface, 1)
			},
		},
	}
}

type ApiDecouplerOfComplex128ThenInterface struct {
	pool PoolOfComplex128ThenInterface
}

func NewApiDecouplerOfComplex128ThenInterface() *ApiDecouplerOfComplex128ThenInterface {
	return &ApiDecouplerOfComplex128ThenInterface{
		pool: NewPoolOfComplex128ThenInterfaceImpl(),
	}
}

func (__ *ApiDecouplerOfComplex128ThenInterface) ReturnError(rtn_ch chan<- *ReturnOfInterface, err error) {
	rtn := __.pool.GetReturnOfInterface()
	var other interface{}
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfComplex128ThenInterface) HandleOfComplex128ThenInterface(ctx context.Context, req *WorkOfComplex128ThenInterface, h func(ctx context.Context, arg complex128) (interface{}, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfInterface()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfComplex128ThenInterface) DoOfComplex128ThenInterface(ctx context.Context, worker WorkerOfPushComplex128ThenInterface, arg complex128) (interface{}, error) {
	// ch := make(chan *ReturnOfInterface, 1)
	ch := __.pool.GetChReturnOfInterface()
	defer __.pool.PutChReturnOfInterface(ch)

	req := __.pool.GetWorkOfComplex128ThenInterface()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfComplex128ThenInterface(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfInterface(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfComplex128ThenInterface = func(ctx context.Context, arg complex128) (interface{}, error)

type WorkerOfComplex128ThenInterface struct {
	api_syncer *ApiDecouplerOfComplex128ThenInterface
	handler    WorkHandlerOfComplex128ThenInterface

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfComplex128ThenInterface
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfComplex128ThenInterface(ctx context.Context, h WorkHandlerOfComplex128ThenInterface, n int) *WorkerOfComplex128ThenInterface {
	__ := &WorkerOfComplex128ThenInterface{
		api_syncer: NewApiDecouplerOfComplex128ThenInterface(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfComplex128ThenInterface, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfComplex128ThenInterface{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfComplex128ThenInterface(req.Context, req.WorkOfComplex128ThenInterface, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfComplex128ThenInterface) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfComplex128ThenInterface) Push(ctx context.Context, req *WorkOfComplex128ThenInterface) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfComplex128ThenInterface)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfComplex128ThenInterface = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfComplex128ThenInterface) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfComplex128ThenInterface) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfComplex128ThenInterface) Call(ctx context.Context, arg complex128) (interface{}, error) {
	return __.api_syncer.DoOfComplex128ThenInterface(ctx, __, arg)
}

type PoolOfComplex128ThenStruct interface {
	GetComplex128Arg() *complex128
	PutComplex128Arg(*complex128)
	GetStructReturn() *struct{}
	PutStructReturn(*struct{})

	GetWorkOfComplex128ThenStruct() *WorkOfComplex128ThenStruct
	GetReturnOfStruct() *ReturnOfStruct
	PutWorkOfComplex128ThenStruct(*WorkOfComplex128ThenStruct)
	PutReturnOfStruct(*ReturnOfStruct)

	GetChReturnOfStruct() chan *ReturnOfStruct
	PutChReturnOfStruct(chan *ReturnOfStruct)
}

type PoolOfComplex128ThenStructImpl struct {
	Complex128Arg    sync.Pool
	StructRtn        sync.Pool
	Complex128Work   sync.Pool
	StructReturn     sync.Pool
	ChReturnOfStruct sync.Pool
}

func (__ *PoolOfComplex128ThenStructImpl) GetComplex128Arg() *complex128 {
	return __.Complex128Arg.Get().(*complex128)
}
func (__ *PoolOfComplex128ThenStructImpl) PutComplex128Arg(p *complex128) {
	__.Complex128Arg.Put(p)
}
func (__ *PoolOfComplex128ThenStructImpl) GetStructReturn() *struct{} {
	return __.StructRtn.Get().(*struct{})
}
func (__ *PoolOfComplex128ThenStructImpl) PutStructReturn(p *struct{}) {
	__.StructRtn.Put(p)
}

func (__ *PoolOfComplex128ThenStructImpl) GetWorkOfComplex128ThenStruct() *WorkOfComplex128ThenStruct {
	return __.Complex128Work.Get().(*WorkOfComplex128ThenStruct)
}
func (__ *PoolOfComplex128ThenStructImpl) PutWorkOfComplex128ThenStruct(p *WorkOfComplex128ThenStruct) {
	__.Complex128Work.Put(p)
}
func (__ *PoolOfComplex128ThenStructImpl) GetReturnOfStruct() *ReturnOfStruct {
	return __.StructReturn.Get().(*ReturnOfStruct)
}
func (__ *PoolOfComplex128ThenStructImpl) PutReturnOfStruct(p *ReturnOfStruct) {
	__.StructReturn.Put(p)
}

func (__ *PoolOfComplex128ThenStructImpl) GetChReturnOfStruct() chan *ReturnOfStruct {
	return __.ChReturnOfStruct.Get().(chan *ReturnOfStruct)
}
func (__ *PoolOfComplex128ThenStructImpl) PutChReturnOfStruct(p chan *ReturnOfStruct) {
	__.ChReturnOfStruct.Put(p)
}

func NewPoolOfComplex128ThenStructImpl() *PoolOfComplex128ThenStructImpl {
	return &PoolOfComplex128ThenStructImpl{
		Complex128Arg: sync.Pool{
			New: func() interface{} {
				return new(complex128)
			},
		},
		Complex128Work: sync.Pool{
			New: func() interface{} {
				return new(WorkOfComplex128ThenStruct)
			},
		},
		StructRtn: sync.Pool{
			New: func() interface{} {
				return new(struct{})
			},
		},
		StructReturn: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfStruct)
			},
		},
		ChReturnOfStruct: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfStruct, 1)
			},
		},
	}
}

type ApiDecouplerOfComplex128ThenStruct struct {
	pool PoolOfComplex128ThenStruct
}

func NewApiDecouplerOfComplex128ThenStruct() *ApiDecouplerOfComplex128ThenStruct {
	return &ApiDecouplerOfComplex128ThenStruct{
		pool: NewPoolOfComplex128ThenStructImpl(),
	}
}

func (__ *ApiDecouplerOfComplex128ThenStruct) ReturnError(rtn_ch chan<- *ReturnOfStruct, err error) {
	rtn := __.pool.GetReturnOfStruct()
	var other struct{}
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfComplex128ThenStruct) HandleOfComplex128ThenStruct(ctx context.Context, req *WorkOfComplex128ThenStruct, h func(ctx context.Context, arg complex128) (struct{}, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfStruct()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfComplex128ThenStruct) DoOfComplex128ThenStruct(ctx context.Context, worker WorkerOfPushComplex128ThenStruct, arg complex128) (struct{}, error) {
	// ch := make(chan *ReturnOfStruct, 1)
	ch := __.pool.GetChReturnOfStruct()
	defer __.pool.PutChReturnOfStruct(ch)

	req := __.pool.GetWorkOfComplex128ThenStruct()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfComplex128ThenStruct(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfStruct(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfComplex128ThenStruct = func(ctx context.Context, arg complex128) (struct{}, error)

type WorkerOfComplex128ThenStruct struct {
	api_syncer *ApiDecouplerOfComplex128ThenStruct
	handler    WorkHandlerOfComplex128ThenStruct

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfComplex128ThenStruct
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfComplex128ThenStruct(ctx context.Context, h WorkHandlerOfComplex128ThenStruct, n int) *WorkerOfComplex128ThenStruct {
	__ := &WorkerOfComplex128ThenStruct{
		api_syncer: NewApiDecouplerOfComplex128ThenStruct(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfComplex128ThenStruct, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfComplex128ThenStruct{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfComplex128ThenStruct(req.Context, req.WorkOfComplex128ThenStruct, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfComplex128ThenStruct) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfComplex128ThenStruct) Push(ctx context.Context, req *WorkOfComplex128ThenStruct) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfComplex128ThenStruct)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfComplex128ThenStruct = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfComplex128ThenStruct) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfComplex128ThenStruct) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfComplex128ThenStruct) Call(ctx context.Context, arg complex128) (struct{}, error) {
	return __.api_syncer.DoOfComplex128ThenStruct(ctx, __, arg)
}

type PoolOfComplex64ThenBool interface {
	GetComplex64Arg() *complex64
	PutComplex64Arg(*complex64)
	GetBoolReturn() *bool
	PutBoolReturn(*bool)

	GetWorkOfComplex64ThenBool() *WorkOfComplex64ThenBool
	GetReturnOfBool() *ReturnOfBool
	PutWorkOfComplex64ThenBool(*WorkOfComplex64ThenBool)
	PutReturnOfBool(*ReturnOfBool)

	GetChReturnOfBool() chan *ReturnOfBool
	PutChReturnOfBool(chan *ReturnOfBool)
}

type PoolOfComplex64ThenBoolImpl struct {
	Complex64Arg   sync.Pool
	BoolRtn        sync.Pool
	Complex64Work  sync.Pool
	BoolReturn     sync.Pool
	ChReturnOfBool sync.Pool
}

func (__ *PoolOfComplex64ThenBoolImpl) GetComplex64Arg() *complex64 {
	return __.Complex64Arg.Get().(*complex64)
}
func (__ *PoolOfComplex64ThenBoolImpl) PutComplex64Arg(p *complex64) {
	__.Complex64Arg.Put(p)
}
func (__ *PoolOfComplex64ThenBoolImpl) GetBoolReturn() *bool {
	return __.BoolRtn.Get().(*bool)
}
func (__ *PoolOfComplex64ThenBoolImpl) PutBoolReturn(p *bool) {
	__.BoolRtn.Put(p)
}

func (__ *PoolOfComplex64ThenBoolImpl) GetWorkOfComplex64ThenBool() *WorkOfComplex64ThenBool {
	return __.Complex64Work.Get().(*WorkOfComplex64ThenBool)
}
func (__ *PoolOfComplex64ThenBoolImpl) PutWorkOfComplex64ThenBool(p *WorkOfComplex64ThenBool) {
	__.Complex64Work.Put(p)
}
func (__ *PoolOfComplex64ThenBoolImpl) GetReturnOfBool() *ReturnOfBool {
	return __.BoolReturn.Get().(*ReturnOfBool)
}
func (__ *PoolOfComplex64ThenBoolImpl) PutReturnOfBool(p *ReturnOfBool) {
	__.BoolReturn.Put(p)
}

func (__ *PoolOfComplex64ThenBoolImpl) GetChReturnOfBool() chan *ReturnOfBool {
	return __.ChReturnOfBool.Get().(chan *ReturnOfBool)
}
func (__ *PoolOfComplex64ThenBoolImpl) PutChReturnOfBool(p chan *ReturnOfBool) {
	__.ChReturnOfBool.Put(p)
}

func NewPoolOfComplex64ThenBoolImpl() *PoolOfComplex64ThenBoolImpl {
	return &PoolOfComplex64ThenBoolImpl{
		Complex64Arg: sync.Pool{
			New: func() interface{} {
				return new(complex64)
			},
		},
		Complex64Work: sync.Pool{
			New: func() interface{} {
				return new(WorkOfComplex64ThenBool)
			},
		},
		BoolRtn: sync.Pool{
			New: func() interface{} {
				return new(bool)
			},
		},
		BoolReturn: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfBool)
			},
		},
		ChReturnOfBool: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfBool, 1)
			},
		},
	}
}

type ApiDecouplerOfComplex64ThenBool struct {
	pool PoolOfComplex64ThenBool
}

func NewApiDecouplerOfComplex64ThenBool() *ApiDecouplerOfComplex64ThenBool {
	return &ApiDecouplerOfComplex64ThenBool{
		pool: NewPoolOfComplex64ThenBoolImpl(),
	}
}

func (__ *ApiDecouplerOfComplex64ThenBool) ReturnError(rtn_ch chan<- *ReturnOfBool, err error) {
	rtn := __.pool.GetReturnOfBool()
	var other bool
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfComplex64ThenBool) HandleOfComplex64ThenBool(ctx context.Context, req *WorkOfComplex64ThenBool, h func(ctx context.Context, arg complex64) (bool, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfBool()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfComplex64ThenBool) DoOfComplex64ThenBool(ctx context.Context, worker WorkerOfPushComplex64ThenBool, arg complex64) (bool, error) {
	// ch := make(chan *ReturnOfBool, 1)
	ch := __.pool.GetChReturnOfBool()
	defer __.pool.PutChReturnOfBool(ch)

	req := __.pool.GetWorkOfComplex64ThenBool()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfComplex64ThenBool(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfBool(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfComplex64ThenBool = func(ctx context.Context, arg complex64) (bool, error)

type WorkerOfComplex64ThenBool struct {
	api_syncer *ApiDecouplerOfComplex64ThenBool
	handler    WorkHandlerOfComplex64ThenBool

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfComplex64ThenBool
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfComplex64ThenBool(ctx context.Context, h WorkHandlerOfComplex64ThenBool, n int) *WorkerOfComplex64ThenBool {
	__ := &WorkerOfComplex64ThenBool{
		api_syncer: NewApiDecouplerOfComplex64ThenBool(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfComplex64ThenBool, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfComplex64ThenBool{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfComplex64ThenBool(req.Context, req.WorkOfComplex64ThenBool, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfComplex64ThenBool) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfComplex64ThenBool) Push(ctx context.Context, req *WorkOfComplex64ThenBool) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfComplex64ThenBool)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfComplex64ThenBool = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfComplex64ThenBool) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfComplex64ThenBool) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfComplex64ThenBool) Call(ctx context.Context, arg complex64) (bool, error) {
	return __.api_syncer.DoOfComplex64ThenBool(ctx, __, arg)
}

type PoolOfComplex64ThenByte interface {
	GetComplex64Arg() *complex64
	PutComplex64Arg(*complex64)
	GetByteReturn() *byte
	PutByteReturn(*byte)

	GetWorkOfComplex64ThenByte() *WorkOfComplex64ThenByte
	GetReturnOfByte() *ReturnOfByte
	PutWorkOfComplex64ThenByte(*WorkOfComplex64ThenByte)
	PutReturnOfByte(*ReturnOfByte)

	GetChReturnOfByte() chan *ReturnOfByte
	PutChReturnOfByte(chan *ReturnOfByte)
}

type PoolOfComplex64ThenByteImpl struct {
	Complex64Arg   sync.Pool
	ByteRtn        sync.Pool
	Complex64Work  sync.Pool
	ByteReturn     sync.Pool
	ChReturnOfByte sync.Pool
}

func (__ *PoolOfComplex64ThenByteImpl) GetComplex64Arg() *complex64 {
	return __.Complex64Arg.Get().(*complex64)
}
func (__ *PoolOfComplex64ThenByteImpl) PutComplex64Arg(p *complex64) {
	__.Complex64Arg.Put(p)
}
func (__ *PoolOfComplex64ThenByteImpl) GetByteReturn() *byte {
	return __.ByteRtn.Get().(*byte)
}
func (__ *PoolOfComplex64ThenByteImpl) PutByteReturn(p *byte) {
	__.ByteRtn.Put(p)
}

func (__ *PoolOfComplex64ThenByteImpl) GetWorkOfComplex64ThenByte() *WorkOfComplex64ThenByte {
	return __.Complex64Work.Get().(*WorkOfComplex64ThenByte)
}
func (__ *PoolOfComplex64ThenByteImpl) PutWorkOfComplex64ThenByte(p *WorkOfComplex64ThenByte) {
	__.Complex64Work.Put(p)
}
func (__ *PoolOfComplex64ThenByteImpl) GetReturnOfByte() *ReturnOfByte {
	return __.ByteReturn.Get().(*ReturnOfByte)
}
func (__ *PoolOfComplex64ThenByteImpl) PutReturnOfByte(p *ReturnOfByte) {
	__.ByteReturn.Put(p)
}

func (__ *PoolOfComplex64ThenByteImpl) GetChReturnOfByte() chan *ReturnOfByte {
	return __.ChReturnOfByte.Get().(chan *ReturnOfByte)
}
func (__ *PoolOfComplex64ThenByteImpl) PutChReturnOfByte(p chan *ReturnOfByte) {
	__.ChReturnOfByte.Put(p)
}

func NewPoolOfComplex64ThenByteImpl() *PoolOfComplex64ThenByteImpl {
	return &PoolOfComplex64ThenByteImpl{
		Complex64Arg: sync.Pool{
			New: func() interface{} {
				return new(complex64)
			},
		},
		Complex64Work: sync.Pool{
			New: func() interface{} {
				return new(WorkOfComplex64ThenByte)
			},
		},
		ByteRtn: sync.Pool{
			New: func() interface{} {
				return new(byte)
			},
		},
		ByteReturn: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfByte)
			},
		},
		ChReturnOfByte: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfByte, 1)
			},
		},
	}
}

type ApiDecouplerOfComplex64ThenByte struct {
	pool PoolOfComplex64ThenByte
}

func NewApiDecouplerOfComplex64ThenByte() *ApiDecouplerOfComplex64ThenByte {
	return &ApiDecouplerOfComplex64ThenByte{
		pool: NewPoolOfComplex64ThenByteImpl(),
	}
}

func (__ *ApiDecouplerOfComplex64ThenByte) ReturnError(rtn_ch chan<- *ReturnOfByte, err error) {
	rtn := __.pool.GetReturnOfByte()
	var other byte
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfComplex64ThenByte) HandleOfComplex64ThenByte(ctx context.Context, req *WorkOfComplex64ThenByte, h func(ctx context.Context, arg complex64) (byte, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfByte()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfComplex64ThenByte) DoOfComplex64ThenByte(ctx context.Context, worker WorkerOfPushComplex64ThenByte, arg complex64) (byte, error) {
	// ch := make(chan *ReturnOfByte, 1)
	ch := __.pool.GetChReturnOfByte()
	defer __.pool.PutChReturnOfByte(ch)

	req := __.pool.GetWorkOfComplex64ThenByte()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfComplex64ThenByte(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfByte(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfComplex64ThenByte = func(ctx context.Context, arg complex64) (byte, error)

type WorkerOfComplex64ThenByte struct {
	api_syncer *ApiDecouplerOfComplex64ThenByte
	handler    WorkHandlerOfComplex64ThenByte

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfComplex64ThenByte
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfComplex64ThenByte(ctx context.Context, h WorkHandlerOfComplex64ThenByte, n int) *WorkerOfComplex64ThenByte {
	__ := &WorkerOfComplex64ThenByte{
		api_syncer: NewApiDecouplerOfComplex64ThenByte(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfComplex64ThenByte, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfComplex64ThenByte{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfComplex64ThenByte(req.Context, req.WorkOfComplex64ThenByte, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfComplex64ThenByte) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfComplex64ThenByte) Push(ctx context.Context, req *WorkOfComplex64ThenByte) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfComplex64ThenByte)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfComplex64ThenByte = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfComplex64ThenByte) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfComplex64ThenByte) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfComplex64ThenByte) Call(ctx context.Context, arg complex64) (byte, error) {
	return __.api_syncer.DoOfComplex64ThenByte(ctx, __, arg)
}

type PoolOfComplex64ThenComplex128 interface {
	GetComplex64Arg() *complex64
	PutComplex64Arg(*complex64)
	GetComplex128Return() *complex128
	PutComplex128Return(*complex128)

	GetWorkOfComplex64ThenComplex128() *WorkOfComplex64ThenComplex128
	GetReturnOfComplex128() *ReturnOfComplex128
	PutWorkOfComplex64ThenComplex128(*WorkOfComplex64ThenComplex128)
	PutReturnOfComplex128(*ReturnOfComplex128)

	GetChReturnOfComplex128() chan *ReturnOfComplex128
	PutChReturnOfComplex128(chan *ReturnOfComplex128)
}

type PoolOfComplex64ThenComplex128Impl struct {
	Complex64Arg         sync.Pool
	Complex128Rtn        sync.Pool
	Complex64Work        sync.Pool
	Complex128Return     sync.Pool
	ChReturnOfComplex128 sync.Pool
}

func (__ *PoolOfComplex64ThenComplex128Impl) GetComplex64Arg() *complex64 {
	return __.Complex64Arg.Get().(*complex64)
}
func (__ *PoolOfComplex64ThenComplex128Impl) PutComplex64Arg(p *complex64) {
	__.Complex64Arg.Put(p)
}
func (__ *PoolOfComplex64ThenComplex128Impl) GetComplex128Return() *complex128 {
	return __.Complex128Rtn.Get().(*complex128)
}
func (__ *PoolOfComplex64ThenComplex128Impl) PutComplex128Return(p *complex128) {
	__.Complex128Rtn.Put(p)
}

func (__ *PoolOfComplex64ThenComplex128Impl) GetWorkOfComplex64ThenComplex128() *WorkOfComplex64ThenComplex128 {
	return __.Complex64Work.Get().(*WorkOfComplex64ThenComplex128)
}
func (__ *PoolOfComplex64ThenComplex128Impl) PutWorkOfComplex64ThenComplex128(p *WorkOfComplex64ThenComplex128) {
	__.Complex64Work.Put(p)
}
func (__ *PoolOfComplex64ThenComplex128Impl) GetReturnOfComplex128() *ReturnOfComplex128 {
	return __.Complex128Return.Get().(*ReturnOfComplex128)
}
func (__ *PoolOfComplex64ThenComplex128Impl) PutReturnOfComplex128(p *ReturnOfComplex128) {
	__.Complex128Return.Put(p)
}

func (__ *PoolOfComplex64ThenComplex128Impl) GetChReturnOfComplex128() chan *ReturnOfComplex128 {
	return __.ChReturnOfComplex128.Get().(chan *ReturnOfComplex128)
}
func (__ *PoolOfComplex64ThenComplex128Impl) PutChReturnOfComplex128(p chan *ReturnOfComplex128) {
	__.ChReturnOfComplex128.Put(p)
}

func NewPoolOfComplex64ThenComplex128Impl() *PoolOfComplex64ThenComplex128Impl {
	return &PoolOfComplex64ThenComplex128Impl{
		Complex64Arg: sync.Pool{
			New: func() interface{} {
				return new(complex64)
			},
		},
		Complex64Work: sync.Pool{
			New: func() interface{} {
				return new(WorkOfComplex64ThenComplex128)
			},
		},
		Complex128Rtn: sync.Pool{
			New: func() interface{} {
				return new(complex128)
			},
		},
		Complex128Return: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfComplex128)
			},
		},
		ChReturnOfComplex128: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfComplex128, 1)
			},
		},
	}
}

type ApiDecouplerOfComplex64ThenComplex128 struct {
	pool PoolOfComplex64ThenComplex128
}

func NewApiDecouplerOfComplex64ThenComplex128() *ApiDecouplerOfComplex64ThenComplex128 {
	return &ApiDecouplerOfComplex64ThenComplex128{
		pool: NewPoolOfComplex64ThenComplex128Impl(),
	}
}

func (__ *ApiDecouplerOfComplex64ThenComplex128) ReturnError(rtn_ch chan<- *ReturnOfComplex128, err error) {
	rtn := __.pool.GetReturnOfComplex128()
	var other complex128
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfComplex64ThenComplex128) HandleOfComplex64ThenComplex128(ctx context.Context, req *WorkOfComplex64ThenComplex128, h func(ctx context.Context, arg complex64) (complex128, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfComplex128()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfComplex64ThenComplex128) DoOfComplex64ThenComplex128(ctx context.Context, worker WorkerOfPushComplex64ThenComplex128, arg complex64) (complex128, error) {
	// ch := make(chan *ReturnOfComplex128, 1)
	ch := __.pool.GetChReturnOfComplex128()
	defer __.pool.PutChReturnOfComplex128(ch)

	req := __.pool.GetWorkOfComplex64ThenComplex128()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfComplex64ThenComplex128(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfComplex128(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfComplex64ThenComplex128 = func(ctx context.Context, arg complex64) (complex128, error)

type WorkerOfComplex64ThenComplex128 struct {
	api_syncer *ApiDecouplerOfComplex64ThenComplex128
	handler    WorkHandlerOfComplex64ThenComplex128

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfComplex64ThenComplex128
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfComplex64ThenComplex128(ctx context.Context, h WorkHandlerOfComplex64ThenComplex128, n int) *WorkerOfComplex64ThenComplex128 {
	__ := &WorkerOfComplex64ThenComplex128{
		api_syncer: NewApiDecouplerOfComplex64ThenComplex128(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfComplex64ThenComplex128, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfComplex64ThenComplex128{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfComplex64ThenComplex128(req.Context, req.WorkOfComplex64ThenComplex128, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfComplex64ThenComplex128) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfComplex64ThenComplex128) Push(ctx context.Context, req *WorkOfComplex64ThenComplex128) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfComplex64ThenComplex128)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfComplex64ThenComplex128 = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfComplex64ThenComplex128) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfComplex64ThenComplex128) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfComplex64ThenComplex128) Call(ctx context.Context, arg complex64) (complex128, error) {
	return __.api_syncer.DoOfComplex64ThenComplex128(ctx, __, arg)
}

type PoolOfComplex64ThenComplex64 interface {
	GetComplex64Arg() *complex64
	PutComplex64Arg(*complex64)
	GetComplex64Return() *complex64
	PutComplex64Return(*complex64)

	GetWorkOfComplex64ThenComplex64() *WorkOfComplex64ThenComplex64
	GetReturnOfComplex64() *ReturnOfComplex64
	PutWorkOfComplex64ThenComplex64(*WorkOfComplex64ThenComplex64)
	PutReturnOfComplex64(*ReturnOfComplex64)

	GetChReturnOfComplex64() chan *ReturnOfComplex64
	PutChReturnOfComplex64(chan *ReturnOfComplex64)
}

type PoolOfComplex64ThenComplex64Impl struct {
	Complex64Arg        sync.Pool
	Complex64Rtn        sync.Pool
	Complex64Work       sync.Pool
	Complex64Return     sync.Pool
	ChReturnOfComplex64 sync.Pool
}

func (__ *PoolOfComplex64ThenComplex64Impl) GetComplex64Arg() *complex64 {
	return __.Complex64Arg.Get().(*complex64)
}
func (__ *PoolOfComplex64ThenComplex64Impl) PutComplex64Arg(p *complex64) {
	__.Complex64Arg.Put(p)
}
func (__ *PoolOfComplex64ThenComplex64Impl) GetComplex64Return() *complex64 {
	return __.Complex64Rtn.Get().(*complex64)
}
func (__ *PoolOfComplex64ThenComplex64Impl) PutComplex64Return(p *complex64) {
	__.Complex64Rtn.Put(p)
}

func (__ *PoolOfComplex64ThenComplex64Impl) GetWorkOfComplex64ThenComplex64() *WorkOfComplex64ThenComplex64 {
	return __.Complex64Work.Get().(*WorkOfComplex64ThenComplex64)
}
func (__ *PoolOfComplex64ThenComplex64Impl) PutWorkOfComplex64ThenComplex64(p *WorkOfComplex64ThenComplex64) {
	__.Complex64Work.Put(p)
}
func (__ *PoolOfComplex64ThenComplex64Impl) GetReturnOfComplex64() *ReturnOfComplex64 {
	return __.Complex64Return.Get().(*ReturnOfComplex64)
}
func (__ *PoolOfComplex64ThenComplex64Impl) PutReturnOfComplex64(p *ReturnOfComplex64) {
	__.Complex64Return.Put(p)
}

func (__ *PoolOfComplex64ThenComplex64Impl) GetChReturnOfComplex64() chan *ReturnOfComplex64 {
	return __.ChReturnOfComplex64.Get().(chan *ReturnOfComplex64)
}
func (__ *PoolOfComplex64ThenComplex64Impl) PutChReturnOfComplex64(p chan *ReturnOfComplex64) {
	__.ChReturnOfComplex64.Put(p)
}

func NewPoolOfComplex64ThenComplex64Impl() *PoolOfComplex64ThenComplex64Impl {
	return &PoolOfComplex64ThenComplex64Impl{
		Complex64Arg: sync.Pool{
			New: func() interface{} {
				return new(complex64)
			},
		},
		Complex64Work: sync.Pool{
			New: func() interface{} {
				return new(WorkOfComplex64ThenComplex64)
			},
		},
		Complex64Rtn: sync.Pool{
			New: func() interface{} {
				return new(complex64)
			},
		},
		Complex64Return: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfComplex64)
			},
		},
		ChReturnOfComplex64: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfComplex64, 1)
			},
		},
	}
}

type ApiDecouplerOfComplex64ThenComplex64 struct {
	pool PoolOfComplex64ThenComplex64
}

func NewApiDecouplerOfComplex64ThenComplex64() *ApiDecouplerOfComplex64ThenComplex64 {
	return &ApiDecouplerOfComplex64ThenComplex64{
		pool: NewPoolOfComplex64ThenComplex64Impl(),
	}
}

func (__ *ApiDecouplerOfComplex64ThenComplex64) ReturnError(rtn_ch chan<- *ReturnOfComplex64, err error) {
	rtn := __.pool.GetReturnOfComplex64()
	var other complex64
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfComplex64ThenComplex64) HandleOfComplex64ThenComplex64(ctx context.Context, req *WorkOfComplex64ThenComplex64, h func(ctx context.Context, arg complex64) (complex64, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfComplex64()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfComplex64ThenComplex64) DoOfComplex64ThenComplex64(ctx context.Context, worker WorkerOfPushComplex64ThenComplex64, arg complex64) (complex64, error) {
	// ch := make(chan *ReturnOfComplex64, 1)
	ch := __.pool.GetChReturnOfComplex64()
	defer __.pool.PutChReturnOfComplex64(ch)

	req := __.pool.GetWorkOfComplex64ThenComplex64()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfComplex64ThenComplex64(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfComplex64(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfComplex64ThenComplex64 = func(ctx context.Context, arg complex64) (complex64, error)

type WorkerOfComplex64ThenComplex64 struct {
	api_syncer *ApiDecouplerOfComplex64ThenComplex64
	handler    WorkHandlerOfComplex64ThenComplex64

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfComplex64ThenComplex64
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfComplex64ThenComplex64(ctx context.Context, h WorkHandlerOfComplex64ThenComplex64, n int) *WorkerOfComplex64ThenComplex64 {
	__ := &WorkerOfComplex64ThenComplex64{
		api_syncer: NewApiDecouplerOfComplex64ThenComplex64(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfComplex64ThenComplex64, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfComplex64ThenComplex64{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfComplex64ThenComplex64(req.Context, req.WorkOfComplex64ThenComplex64, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfComplex64ThenComplex64) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfComplex64ThenComplex64) Push(ctx context.Context, req *WorkOfComplex64ThenComplex64) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfComplex64ThenComplex64)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfComplex64ThenComplex64 = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfComplex64ThenComplex64) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfComplex64ThenComplex64) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfComplex64ThenComplex64) Call(ctx context.Context, arg complex64) (complex64, error) {
	return __.api_syncer.DoOfComplex64ThenComplex64(ctx, __, arg)
}

type PoolOfComplex64ThenError interface {
	GetComplex64Arg() *complex64
	PutComplex64Arg(*complex64)
	GetErrorReturn() *error
	PutErrorReturn(*error)

	GetWorkOfComplex64ThenError() *WorkOfComplex64ThenError
	GetReturnOfError() *ReturnOfError
	PutWorkOfComplex64ThenError(*WorkOfComplex64ThenError)
	PutReturnOfError(*ReturnOfError)

	GetChReturnOfError() chan *ReturnOfError
	PutChReturnOfError(chan *ReturnOfError)
}

type PoolOfComplex64ThenErrorImpl struct {
	Complex64Arg    sync.Pool
	ErrorRtn        sync.Pool
	Complex64Work   sync.Pool
	ErrorReturn     sync.Pool
	ChReturnOfError sync.Pool
}

func (__ *PoolOfComplex64ThenErrorImpl) GetComplex64Arg() *complex64 {
	return __.Complex64Arg.Get().(*complex64)
}
func (__ *PoolOfComplex64ThenErrorImpl) PutComplex64Arg(p *complex64) {
	__.Complex64Arg.Put(p)
}
func (__ *PoolOfComplex64ThenErrorImpl) GetErrorReturn() *error {
	return __.ErrorRtn.Get().(*error)
}
func (__ *PoolOfComplex64ThenErrorImpl) PutErrorReturn(p *error) {
	__.ErrorRtn.Put(p)
}

func (__ *PoolOfComplex64ThenErrorImpl) GetWorkOfComplex64ThenError() *WorkOfComplex64ThenError {
	return __.Complex64Work.Get().(*WorkOfComplex64ThenError)
}
func (__ *PoolOfComplex64ThenErrorImpl) PutWorkOfComplex64ThenError(p *WorkOfComplex64ThenError) {
	__.Complex64Work.Put(p)
}
func (__ *PoolOfComplex64ThenErrorImpl) GetReturnOfError() *ReturnOfError {
	return __.ErrorReturn.Get().(*ReturnOfError)
}
func (__ *PoolOfComplex64ThenErrorImpl) PutReturnOfError(p *ReturnOfError) {
	__.ErrorReturn.Put(p)
}

func (__ *PoolOfComplex64ThenErrorImpl) GetChReturnOfError() chan *ReturnOfError {
	return __.ChReturnOfError.Get().(chan *ReturnOfError)
}
func (__ *PoolOfComplex64ThenErrorImpl) PutChReturnOfError(p chan *ReturnOfError) {
	__.ChReturnOfError.Put(p)
}

func NewPoolOfComplex64ThenErrorImpl() *PoolOfComplex64ThenErrorImpl {
	return &PoolOfComplex64ThenErrorImpl{
		Complex64Arg: sync.Pool{
			New: func() interface{} {
				return new(complex64)
			},
		},
		Complex64Work: sync.Pool{
			New: func() interface{} {
				return new(WorkOfComplex64ThenError)
			},
		},
		ErrorRtn: sync.Pool{
			New: func() interface{} {
				return new(error)
			},
		},
		ErrorReturn: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfError)
			},
		},
		ChReturnOfError: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfError, 1)
			},
		},
	}
}

type ApiDecouplerOfComplex64ThenError struct {
	pool PoolOfComplex64ThenError
}

func NewApiDecouplerOfComplex64ThenError() *ApiDecouplerOfComplex64ThenError {
	return &ApiDecouplerOfComplex64ThenError{
		pool: NewPoolOfComplex64ThenErrorImpl(),
	}
}

func (__ *ApiDecouplerOfComplex64ThenError) ReturnError(rtn_ch chan<- *ReturnOfError, err error) {
	rtn := __.pool.GetReturnOfError()
	var other error
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfComplex64ThenError) HandleOfComplex64ThenError(ctx context.Context, req *WorkOfComplex64ThenError, h func(ctx context.Context, arg complex64) (error, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfError()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfComplex64ThenError) DoOfComplex64ThenError(ctx context.Context, worker WorkerOfPushComplex64ThenError, arg complex64) (error, error) {
	// ch := make(chan *ReturnOfError, 1)
	ch := __.pool.GetChReturnOfError()
	defer __.pool.PutChReturnOfError(ch)

	req := __.pool.GetWorkOfComplex64ThenError()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfComplex64ThenError(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfError(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfComplex64ThenError = func(ctx context.Context, arg complex64) (error, error)

type WorkerOfComplex64ThenError struct {
	api_syncer *ApiDecouplerOfComplex64ThenError
	handler    WorkHandlerOfComplex64ThenError

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfComplex64ThenError
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfComplex64ThenError(ctx context.Context, h WorkHandlerOfComplex64ThenError, n int) *WorkerOfComplex64ThenError {
	__ := &WorkerOfComplex64ThenError{
		api_syncer: NewApiDecouplerOfComplex64ThenError(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfComplex64ThenError, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfComplex64ThenError{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfComplex64ThenError(req.Context, req.WorkOfComplex64ThenError, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfComplex64ThenError) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfComplex64ThenError) Push(ctx context.Context, req *WorkOfComplex64ThenError) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfComplex64ThenError)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfComplex64ThenError = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfComplex64ThenError) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfComplex64ThenError) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfComplex64ThenError) Call(ctx context.Context, arg complex64) (error, error) {
	return __.api_syncer.DoOfComplex64ThenError(ctx, __, arg)
}

type PoolOfComplex64ThenFloat32 interface {
	GetComplex64Arg() *complex64
	PutComplex64Arg(*complex64)
	GetFloat32Return() *float32
	PutFloat32Return(*float32)

	GetWorkOfComplex64ThenFloat32() *WorkOfComplex64ThenFloat32
	GetReturnOfFloat32() *ReturnOfFloat32
	PutWorkOfComplex64ThenFloat32(*WorkOfComplex64ThenFloat32)
	PutReturnOfFloat32(*ReturnOfFloat32)

	GetChReturnOfFloat32() chan *ReturnOfFloat32
	PutChReturnOfFloat32(chan *ReturnOfFloat32)
}

type PoolOfComplex64ThenFloat32Impl struct {
	Complex64Arg      sync.Pool
	Float32Rtn        sync.Pool
	Complex64Work     sync.Pool
	Float32Return     sync.Pool
	ChReturnOfFloat32 sync.Pool
}

func (__ *PoolOfComplex64ThenFloat32Impl) GetComplex64Arg() *complex64 {
	return __.Complex64Arg.Get().(*complex64)
}
func (__ *PoolOfComplex64ThenFloat32Impl) PutComplex64Arg(p *complex64) {
	__.Complex64Arg.Put(p)
}
func (__ *PoolOfComplex64ThenFloat32Impl) GetFloat32Return() *float32 {
	return __.Float32Rtn.Get().(*float32)
}
func (__ *PoolOfComplex64ThenFloat32Impl) PutFloat32Return(p *float32) {
	__.Float32Rtn.Put(p)
}

func (__ *PoolOfComplex64ThenFloat32Impl) GetWorkOfComplex64ThenFloat32() *WorkOfComplex64ThenFloat32 {
	return __.Complex64Work.Get().(*WorkOfComplex64ThenFloat32)
}
func (__ *PoolOfComplex64ThenFloat32Impl) PutWorkOfComplex64ThenFloat32(p *WorkOfComplex64ThenFloat32) {
	__.Complex64Work.Put(p)
}
func (__ *PoolOfComplex64ThenFloat32Impl) GetReturnOfFloat32() *ReturnOfFloat32 {
	return __.Float32Return.Get().(*ReturnOfFloat32)
}
func (__ *PoolOfComplex64ThenFloat32Impl) PutReturnOfFloat32(p *ReturnOfFloat32) {
	__.Float32Return.Put(p)
}

func (__ *PoolOfComplex64ThenFloat32Impl) GetChReturnOfFloat32() chan *ReturnOfFloat32 {
	return __.ChReturnOfFloat32.Get().(chan *ReturnOfFloat32)
}
func (__ *PoolOfComplex64ThenFloat32Impl) PutChReturnOfFloat32(p chan *ReturnOfFloat32) {
	__.ChReturnOfFloat32.Put(p)
}

func NewPoolOfComplex64ThenFloat32Impl() *PoolOfComplex64ThenFloat32Impl {
	return &PoolOfComplex64ThenFloat32Impl{
		Complex64Arg: sync.Pool{
			New: func() interface{} {
				return new(complex64)
			},
		},
		Complex64Work: sync.Pool{
			New: func() interface{} {
				return new(WorkOfComplex64ThenFloat32)
			},
		},
		Float32Rtn: sync.Pool{
			New: func() interface{} {
				return new(float32)
			},
		},
		Float32Return: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfFloat32)
			},
		},
		ChReturnOfFloat32: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfFloat32, 1)
			},
		},
	}
}

type ApiDecouplerOfComplex64ThenFloat32 struct {
	pool PoolOfComplex64ThenFloat32
}

func NewApiDecouplerOfComplex64ThenFloat32() *ApiDecouplerOfComplex64ThenFloat32 {
	return &ApiDecouplerOfComplex64ThenFloat32{
		pool: NewPoolOfComplex64ThenFloat32Impl(),
	}
}

func (__ *ApiDecouplerOfComplex64ThenFloat32) ReturnError(rtn_ch chan<- *ReturnOfFloat32, err error) {
	rtn := __.pool.GetReturnOfFloat32()
	var other float32
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfComplex64ThenFloat32) HandleOfComplex64ThenFloat32(ctx context.Context, req *WorkOfComplex64ThenFloat32, h func(ctx context.Context, arg complex64) (float32, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfFloat32()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfComplex64ThenFloat32) DoOfComplex64ThenFloat32(ctx context.Context, worker WorkerOfPushComplex64ThenFloat32, arg complex64) (float32, error) {
	// ch := make(chan *ReturnOfFloat32, 1)
	ch := __.pool.GetChReturnOfFloat32()
	defer __.pool.PutChReturnOfFloat32(ch)

	req := __.pool.GetWorkOfComplex64ThenFloat32()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfComplex64ThenFloat32(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfFloat32(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfComplex64ThenFloat32 = func(ctx context.Context, arg complex64) (float32, error)

type WorkerOfComplex64ThenFloat32 struct {
	api_syncer *ApiDecouplerOfComplex64ThenFloat32
	handler    WorkHandlerOfComplex64ThenFloat32

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfComplex64ThenFloat32
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfComplex64ThenFloat32(ctx context.Context, h WorkHandlerOfComplex64ThenFloat32, n int) *WorkerOfComplex64ThenFloat32 {
	__ := &WorkerOfComplex64ThenFloat32{
		api_syncer: NewApiDecouplerOfComplex64ThenFloat32(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfComplex64ThenFloat32, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfComplex64ThenFloat32{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfComplex64ThenFloat32(req.Context, req.WorkOfComplex64ThenFloat32, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfComplex64ThenFloat32) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfComplex64ThenFloat32) Push(ctx context.Context, req *WorkOfComplex64ThenFloat32) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfComplex64ThenFloat32)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfComplex64ThenFloat32 = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfComplex64ThenFloat32) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfComplex64ThenFloat32) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfComplex64ThenFloat32) Call(ctx context.Context, arg complex64) (float32, error) {
	return __.api_syncer.DoOfComplex64ThenFloat32(ctx, __, arg)
}

type PoolOfComplex64ThenFloat64 interface {
	GetComplex64Arg() *complex64
	PutComplex64Arg(*complex64)
	GetFloat64Return() *float64
	PutFloat64Return(*float64)

	GetWorkOfComplex64ThenFloat64() *WorkOfComplex64ThenFloat64
	GetReturnOfFloat64() *ReturnOfFloat64
	PutWorkOfComplex64ThenFloat64(*WorkOfComplex64ThenFloat64)
	PutReturnOfFloat64(*ReturnOfFloat64)

	GetChReturnOfFloat64() chan *ReturnOfFloat64
	PutChReturnOfFloat64(chan *ReturnOfFloat64)
}

type PoolOfComplex64ThenFloat64Impl struct {
	Complex64Arg      sync.Pool
	Float64Rtn        sync.Pool
	Complex64Work     sync.Pool
	Float64Return     sync.Pool
	ChReturnOfFloat64 sync.Pool
}

func (__ *PoolOfComplex64ThenFloat64Impl) GetComplex64Arg() *complex64 {
	return __.Complex64Arg.Get().(*complex64)
}
func (__ *PoolOfComplex64ThenFloat64Impl) PutComplex64Arg(p *complex64) {
	__.Complex64Arg.Put(p)
}
func (__ *PoolOfComplex64ThenFloat64Impl) GetFloat64Return() *float64 {
	return __.Float64Rtn.Get().(*float64)
}
func (__ *PoolOfComplex64ThenFloat64Impl) PutFloat64Return(p *float64) {
	__.Float64Rtn.Put(p)
}

func (__ *PoolOfComplex64ThenFloat64Impl) GetWorkOfComplex64ThenFloat64() *WorkOfComplex64ThenFloat64 {
	return __.Complex64Work.Get().(*WorkOfComplex64ThenFloat64)
}
func (__ *PoolOfComplex64ThenFloat64Impl) PutWorkOfComplex64ThenFloat64(p *WorkOfComplex64ThenFloat64) {
	__.Complex64Work.Put(p)
}
func (__ *PoolOfComplex64ThenFloat64Impl) GetReturnOfFloat64() *ReturnOfFloat64 {
	return __.Float64Return.Get().(*ReturnOfFloat64)
}
func (__ *PoolOfComplex64ThenFloat64Impl) PutReturnOfFloat64(p *ReturnOfFloat64) {
	__.Float64Return.Put(p)
}

func (__ *PoolOfComplex64ThenFloat64Impl) GetChReturnOfFloat64() chan *ReturnOfFloat64 {
	return __.ChReturnOfFloat64.Get().(chan *ReturnOfFloat64)
}
func (__ *PoolOfComplex64ThenFloat64Impl) PutChReturnOfFloat64(p chan *ReturnOfFloat64) {
	__.ChReturnOfFloat64.Put(p)
}

func NewPoolOfComplex64ThenFloat64Impl() *PoolOfComplex64ThenFloat64Impl {
	return &PoolOfComplex64ThenFloat64Impl{
		Complex64Arg: sync.Pool{
			New: func() interface{} {
				return new(complex64)
			},
		},
		Complex64Work: sync.Pool{
			New: func() interface{} {
				return new(WorkOfComplex64ThenFloat64)
			},
		},
		Float64Rtn: sync.Pool{
			New: func() interface{} {
				return new(float64)
			},
		},
		Float64Return: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfFloat64)
			},
		},
		ChReturnOfFloat64: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfFloat64, 1)
			},
		},
	}
}

type ApiDecouplerOfComplex64ThenFloat64 struct {
	pool PoolOfComplex64ThenFloat64
}

func NewApiDecouplerOfComplex64ThenFloat64() *ApiDecouplerOfComplex64ThenFloat64 {
	return &ApiDecouplerOfComplex64ThenFloat64{
		pool: NewPoolOfComplex64ThenFloat64Impl(),
	}
}

func (__ *ApiDecouplerOfComplex64ThenFloat64) ReturnError(rtn_ch chan<- *ReturnOfFloat64, err error) {
	rtn := __.pool.GetReturnOfFloat64()
	var other float64
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfComplex64ThenFloat64) HandleOfComplex64ThenFloat64(ctx context.Context, req *WorkOfComplex64ThenFloat64, h func(ctx context.Context, arg complex64) (float64, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfFloat64()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfComplex64ThenFloat64) DoOfComplex64ThenFloat64(ctx context.Context, worker WorkerOfPushComplex64ThenFloat64, arg complex64) (float64, error) {
	// ch := make(chan *ReturnOfFloat64, 1)
	ch := __.pool.GetChReturnOfFloat64()
	defer __.pool.PutChReturnOfFloat64(ch)

	req := __.pool.GetWorkOfComplex64ThenFloat64()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfComplex64ThenFloat64(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfFloat64(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfComplex64ThenFloat64 = func(ctx context.Context, arg complex64) (float64, error)

type WorkerOfComplex64ThenFloat64 struct {
	api_syncer *ApiDecouplerOfComplex64ThenFloat64
	handler    WorkHandlerOfComplex64ThenFloat64

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfComplex64ThenFloat64
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfComplex64ThenFloat64(ctx context.Context, h WorkHandlerOfComplex64ThenFloat64, n int) *WorkerOfComplex64ThenFloat64 {
	__ := &WorkerOfComplex64ThenFloat64{
		api_syncer: NewApiDecouplerOfComplex64ThenFloat64(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfComplex64ThenFloat64, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfComplex64ThenFloat64{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfComplex64ThenFloat64(req.Context, req.WorkOfComplex64ThenFloat64, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfComplex64ThenFloat64) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfComplex64ThenFloat64) Push(ctx context.Context, req *WorkOfComplex64ThenFloat64) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfComplex64ThenFloat64)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfComplex64ThenFloat64 = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfComplex64ThenFloat64) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfComplex64ThenFloat64) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfComplex64ThenFloat64) Call(ctx context.Context, arg complex64) (float64, error) {
	return __.api_syncer.DoOfComplex64ThenFloat64(ctx, __, arg)
}

type PoolOfComplex64ThenInt interface {
	GetComplex64Arg() *complex64
	PutComplex64Arg(*complex64)
	GetIntReturn() *int
	PutIntReturn(*int)

	GetWorkOfComplex64ThenInt() *WorkOfComplex64ThenInt
	GetReturnOfInt() *ReturnOfInt
	PutWorkOfComplex64ThenInt(*WorkOfComplex64ThenInt)
	PutReturnOfInt(*ReturnOfInt)

	GetChReturnOfInt() chan *ReturnOfInt
	PutChReturnOfInt(chan *ReturnOfInt)
}

type PoolOfComplex64ThenIntImpl struct {
	Complex64Arg  sync.Pool
	IntRtn        sync.Pool
	Complex64Work sync.Pool
	IntReturn     sync.Pool
	ChReturnOfInt sync.Pool
}

func (__ *PoolOfComplex64ThenIntImpl) GetComplex64Arg() *complex64 {
	return __.Complex64Arg.Get().(*complex64)
}
func (__ *PoolOfComplex64ThenIntImpl) PutComplex64Arg(p *complex64) {
	__.Complex64Arg.Put(p)
}
func (__ *PoolOfComplex64ThenIntImpl) GetIntReturn() *int {
	return __.IntRtn.Get().(*int)
}
func (__ *PoolOfComplex64ThenIntImpl) PutIntReturn(p *int) {
	__.IntRtn.Put(p)
}

func (__ *PoolOfComplex64ThenIntImpl) GetWorkOfComplex64ThenInt() *WorkOfComplex64ThenInt {
	return __.Complex64Work.Get().(*WorkOfComplex64ThenInt)
}
func (__ *PoolOfComplex64ThenIntImpl) PutWorkOfComplex64ThenInt(p *WorkOfComplex64ThenInt) {
	__.Complex64Work.Put(p)
}
func (__ *PoolOfComplex64ThenIntImpl) GetReturnOfInt() *ReturnOfInt {
	return __.IntReturn.Get().(*ReturnOfInt)
}
func (__ *PoolOfComplex64ThenIntImpl) PutReturnOfInt(p *ReturnOfInt) {
	__.IntReturn.Put(p)
}

func (__ *PoolOfComplex64ThenIntImpl) GetChReturnOfInt() chan *ReturnOfInt {
	return __.ChReturnOfInt.Get().(chan *ReturnOfInt)
}
func (__ *PoolOfComplex64ThenIntImpl) PutChReturnOfInt(p chan *ReturnOfInt) {
	__.ChReturnOfInt.Put(p)
}

func NewPoolOfComplex64ThenIntImpl() *PoolOfComplex64ThenIntImpl {
	return &PoolOfComplex64ThenIntImpl{
		Complex64Arg: sync.Pool{
			New: func() interface{} {
				return new(complex64)
			},
		},
		Complex64Work: sync.Pool{
			New: func() interface{} {
				return new(WorkOfComplex64ThenInt)
			},
		},
		IntRtn: sync.Pool{
			New: func() interface{} {
				return new(int)
			},
		},
		IntReturn: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfInt)
			},
		},
		ChReturnOfInt: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfInt, 1)
			},
		},
	}
}

type ApiDecouplerOfComplex64ThenInt struct {
	pool PoolOfComplex64ThenInt
}

func NewApiDecouplerOfComplex64ThenInt() *ApiDecouplerOfComplex64ThenInt {
	return &ApiDecouplerOfComplex64ThenInt{
		pool: NewPoolOfComplex64ThenIntImpl(),
	}
}

func (__ *ApiDecouplerOfComplex64ThenInt) ReturnError(rtn_ch chan<- *ReturnOfInt, err error) {
	rtn := __.pool.GetReturnOfInt()
	var other int
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfComplex64ThenInt) HandleOfComplex64ThenInt(ctx context.Context, req *WorkOfComplex64ThenInt, h func(ctx context.Context, arg complex64) (int, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfInt()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfComplex64ThenInt) DoOfComplex64ThenInt(ctx context.Context, worker WorkerOfPushComplex64ThenInt, arg complex64) (int, error) {
	// ch := make(chan *ReturnOfInt, 1)
	ch := __.pool.GetChReturnOfInt()
	defer __.pool.PutChReturnOfInt(ch)

	req := __.pool.GetWorkOfComplex64ThenInt()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfComplex64ThenInt(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfInt(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfComplex64ThenInt = func(ctx context.Context, arg complex64) (int, error)

type WorkerOfComplex64ThenInt struct {
	api_syncer *ApiDecouplerOfComplex64ThenInt
	handler    WorkHandlerOfComplex64ThenInt

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfComplex64ThenInt
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfComplex64ThenInt(ctx context.Context, h WorkHandlerOfComplex64ThenInt, n int) *WorkerOfComplex64ThenInt {
	__ := &WorkerOfComplex64ThenInt{
		api_syncer: NewApiDecouplerOfComplex64ThenInt(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfComplex64ThenInt, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfComplex64ThenInt{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfComplex64ThenInt(req.Context, req.WorkOfComplex64ThenInt, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfComplex64ThenInt) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfComplex64ThenInt) Push(ctx context.Context, req *WorkOfComplex64ThenInt) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfComplex64ThenInt)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfComplex64ThenInt = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfComplex64ThenInt) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfComplex64ThenInt) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfComplex64ThenInt) Call(ctx context.Context, arg complex64) (int, error) {
	return __.api_syncer.DoOfComplex64ThenInt(ctx, __, arg)
}

type PoolOfComplex64ThenInt16 interface {
	GetComplex64Arg() *complex64
	PutComplex64Arg(*complex64)
	GetInt16Return() *int16
	PutInt16Return(*int16)

	GetWorkOfComplex64ThenInt16() *WorkOfComplex64ThenInt16
	GetReturnOfInt16() *ReturnOfInt16
	PutWorkOfComplex64ThenInt16(*WorkOfComplex64ThenInt16)
	PutReturnOfInt16(*ReturnOfInt16)

	GetChReturnOfInt16() chan *ReturnOfInt16
	PutChReturnOfInt16(chan *ReturnOfInt16)
}

type PoolOfComplex64ThenInt16Impl struct {
	Complex64Arg    sync.Pool
	Int16Rtn        sync.Pool
	Complex64Work   sync.Pool
	Int16Return     sync.Pool
	ChReturnOfInt16 sync.Pool
}

func (__ *PoolOfComplex64ThenInt16Impl) GetComplex64Arg() *complex64 {
	return __.Complex64Arg.Get().(*complex64)
}
func (__ *PoolOfComplex64ThenInt16Impl) PutComplex64Arg(p *complex64) {
	__.Complex64Arg.Put(p)
}
func (__ *PoolOfComplex64ThenInt16Impl) GetInt16Return() *int16 {
	return __.Int16Rtn.Get().(*int16)
}
func (__ *PoolOfComplex64ThenInt16Impl) PutInt16Return(p *int16) {
	__.Int16Rtn.Put(p)
}

func (__ *PoolOfComplex64ThenInt16Impl) GetWorkOfComplex64ThenInt16() *WorkOfComplex64ThenInt16 {
	return __.Complex64Work.Get().(*WorkOfComplex64ThenInt16)
}
func (__ *PoolOfComplex64ThenInt16Impl) PutWorkOfComplex64ThenInt16(p *WorkOfComplex64ThenInt16) {
	__.Complex64Work.Put(p)
}
func (__ *PoolOfComplex64ThenInt16Impl) GetReturnOfInt16() *ReturnOfInt16 {
	return __.Int16Return.Get().(*ReturnOfInt16)
}
func (__ *PoolOfComplex64ThenInt16Impl) PutReturnOfInt16(p *ReturnOfInt16) {
	__.Int16Return.Put(p)
}

func (__ *PoolOfComplex64ThenInt16Impl) GetChReturnOfInt16() chan *ReturnOfInt16 {
	return __.ChReturnOfInt16.Get().(chan *ReturnOfInt16)
}
func (__ *PoolOfComplex64ThenInt16Impl) PutChReturnOfInt16(p chan *ReturnOfInt16) {
	__.ChReturnOfInt16.Put(p)
}

func NewPoolOfComplex64ThenInt16Impl() *PoolOfComplex64ThenInt16Impl {
	return &PoolOfComplex64ThenInt16Impl{
		Complex64Arg: sync.Pool{
			New: func() interface{} {
				return new(complex64)
			},
		},
		Complex64Work: sync.Pool{
			New: func() interface{} {
				return new(WorkOfComplex64ThenInt16)
			},
		},
		Int16Rtn: sync.Pool{
			New: func() interface{} {
				return new(int16)
			},
		},
		Int16Return: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfInt16)
			},
		},
		ChReturnOfInt16: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfInt16, 1)
			},
		},
	}
}

type ApiDecouplerOfComplex64ThenInt16 struct {
	pool PoolOfComplex64ThenInt16
}

func NewApiDecouplerOfComplex64ThenInt16() *ApiDecouplerOfComplex64ThenInt16 {
	return &ApiDecouplerOfComplex64ThenInt16{
		pool: NewPoolOfComplex64ThenInt16Impl(),
	}
}

func (__ *ApiDecouplerOfComplex64ThenInt16) ReturnError(rtn_ch chan<- *ReturnOfInt16, err error) {
	rtn := __.pool.GetReturnOfInt16()
	var other int16
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfComplex64ThenInt16) HandleOfComplex64ThenInt16(ctx context.Context, req *WorkOfComplex64ThenInt16, h func(ctx context.Context, arg complex64) (int16, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfInt16()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfComplex64ThenInt16) DoOfComplex64ThenInt16(ctx context.Context, worker WorkerOfPushComplex64ThenInt16, arg complex64) (int16, error) {
	// ch := make(chan *ReturnOfInt16, 1)
	ch := __.pool.GetChReturnOfInt16()
	defer __.pool.PutChReturnOfInt16(ch)

	req := __.pool.GetWorkOfComplex64ThenInt16()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfComplex64ThenInt16(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfInt16(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfComplex64ThenInt16 = func(ctx context.Context, arg complex64) (int16, error)

type WorkerOfComplex64ThenInt16 struct {
	api_syncer *ApiDecouplerOfComplex64ThenInt16
	handler    WorkHandlerOfComplex64ThenInt16

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfComplex64ThenInt16
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfComplex64ThenInt16(ctx context.Context, h WorkHandlerOfComplex64ThenInt16, n int) *WorkerOfComplex64ThenInt16 {
	__ := &WorkerOfComplex64ThenInt16{
		api_syncer: NewApiDecouplerOfComplex64ThenInt16(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfComplex64ThenInt16, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfComplex64ThenInt16{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfComplex64ThenInt16(req.Context, req.WorkOfComplex64ThenInt16, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfComplex64ThenInt16) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfComplex64ThenInt16) Push(ctx context.Context, req *WorkOfComplex64ThenInt16) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfComplex64ThenInt16)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfComplex64ThenInt16 = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfComplex64ThenInt16) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfComplex64ThenInt16) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfComplex64ThenInt16) Call(ctx context.Context, arg complex64) (int16, error) {
	return __.api_syncer.DoOfComplex64ThenInt16(ctx, __, arg)
}

type PoolOfComplex64ThenInt32 interface {
	GetComplex64Arg() *complex64
	PutComplex64Arg(*complex64)
	GetInt32Return() *int32
	PutInt32Return(*int32)

	GetWorkOfComplex64ThenInt32() *WorkOfComplex64ThenInt32
	GetReturnOfInt32() *ReturnOfInt32
	PutWorkOfComplex64ThenInt32(*WorkOfComplex64ThenInt32)
	PutReturnOfInt32(*ReturnOfInt32)

	GetChReturnOfInt32() chan *ReturnOfInt32
	PutChReturnOfInt32(chan *ReturnOfInt32)
}

type PoolOfComplex64ThenInt32Impl struct {
	Complex64Arg    sync.Pool
	Int32Rtn        sync.Pool
	Complex64Work   sync.Pool
	Int32Return     sync.Pool
	ChReturnOfInt32 sync.Pool
}

func (__ *PoolOfComplex64ThenInt32Impl) GetComplex64Arg() *complex64 {
	return __.Complex64Arg.Get().(*complex64)
}
func (__ *PoolOfComplex64ThenInt32Impl) PutComplex64Arg(p *complex64) {
	__.Complex64Arg.Put(p)
}
func (__ *PoolOfComplex64ThenInt32Impl) GetInt32Return() *int32 {
	return __.Int32Rtn.Get().(*int32)
}
func (__ *PoolOfComplex64ThenInt32Impl) PutInt32Return(p *int32) {
	__.Int32Rtn.Put(p)
}

func (__ *PoolOfComplex64ThenInt32Impl) GetWorkOfComplex64ThenInt32() *WorkOfComplex64ThenInt32 {
	return __.Complex64Work.Get().(*WorkOfComplex64ThenInt32)
}
func (__ *PoolOfComplex64ThenInt32Impl) PutWorkOfComplex64ThenInt32(p *WorkOfComplex64ThenInt32) {
	__.Complex64Work.Put(p)
}
func (__ *PoolOfComplex64ThenInt32Impl) GetReturnOfInt32() *ReturnOfInt32 {
	return __.Int32Return.Get().(*ReturnOfInt32)
}
func (__ *PoolOfComplex64ThenInt32Impl) PutReturnOfInt32(p *ReturnOfInt32) {
	__.Int32Return.Put(p)
}

func (__ *PoolOfComplex64ThenInt32Impl) GetChReturnOfInt32() chan *ReturnOfInt32 {
	return __.ChReturnOfInt32.Get().(chan *ReturnOfInt32)
}
func (__ *PoolOfComplex64ThenInt32Impl) PutChReturnOfInt32(p chan *ReturnOfInt32) {
	__.ChReturnOfInt32.Put(p)
}

func NewPoolOfComplex64ThenInt32Impl() *PoolOfComplex64ThenInt32Impl {
	return &PoolOfComplex64ThenInt32Impl{
		Complex64Arg: sync.Pool{
			New: func() interface{} {
				return new(complex64)
			},
		},
		Complex64Work: sync.Pool{
			New: func() interface{} {
				return new(WorkOfComplex64ThenInt32)
			},
		},
		Int32Rtn: sync.Pool{
			New: func() interface{} {
				return new(int32)
			},
		},
		Int32Return: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfInt32)
			},
		},
		ChReturnOfInt32: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfInt32, 1)
			},
		},
	}
}

type ApiDecouplerOfComplex64ThenInt32 struct {
	pool PoolOfComplex64ThenInt32
}

func NewApiDecouplerOfComplex64ThenInt32() *ApiDecouplerOfComplex64ThenInt32 {
	return &ApiDecouplerOfComplex64ThenInt32{
		pool: NewPoolOfComplex64ThenInt32Impl(),
	}
}

func (__ *ApiDecouplerOfComplex64ThenInt32) ReturnError(rtn_ch chan<- *ReturnOfInt32, err error) {
	rtn := __.pool.GetReturnOfInt32()
	var other int32
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfComplex64ThenInt32) HandleOfComplex64ThenInt32(ctx context.Context, req *WorkOfComplex64ThenInt32, h func(ctx context.Context, arg complex64) (int32, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfInt32()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfComplex64ThenInt32) DoOfComplex64ThenInt32(ctx context.Context, worker WorkerOfPushComplex64ThenInt32, arg complex64) (int32, error) {
	// ch := make(chan *ReturnOfInt32, 1)
	ch := __.pool.GetChReturnOfInt32()
	defer __.pool.PutChReturnOfInt32(ch)

	req := __.pool.GetWorkOfComplex64ThenInt32()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfComplex64ThenInt32(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfInt32(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfComplex64ThenInt32 = func(ctx context.Context, arg complex64) (int32, error)

type WorkerOfComplex64ThenInt32 struct {
	api_syncer *ApiDecouplerOfComplex64ThenInt32
	handler    WorkHandlerOfComplex64ThenInt32

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfComplex64ThenInt32
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfComplex64ThenInt32(ctx context.Context, h WorkHandlerOfComplex64ThenInt32, n int) *WorkerOfComplex64ThenInt32 {
	__ := &WorkerOfComplex64ThenInt32{
		api_syncer: NewApiDecouplerOfComplex64ThenInt32(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfComplex64ThenInt32, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfComplex64ThenInt32{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfComplex64ThenInt32(req.Context, req.WorkOfComplex64ThenInt32, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfComplex64ThenInt32) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfComplex64ThenInt32) Push(ctx context.Context, req *WorkOfComplex64ThenInt32) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfComplex64ThenInt32)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfComplex64ThenInt32 = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfComplex64ThenInt32) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfComplex64ThenInt32) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfComplex64ThenInt32) Call(ctx context.Context, arg complex64) (int32, error) {
	return __.api_syncer.DoOfComplex64ThenInt32(ctx, __, arg)
}

type PoolOfComplex64ThenInt64 interface {
	GetComplex64Arg() *complex64
	PutComplex64Arg(*complex64)
	GetInt64Return() *int64
	PutInt64Return(*int64)

	GetWorkOfComplex64ThenInt64() *WorkOfComplex64ThenInt64
	GetReturnOfInt64() *ReturnOfInt64
	PutWorkOfComplex64ThenInt64(*WorkOfComplex64ThenInt64)
	PutReturnOfInt64(*ReturnOfInt64)

	GetChReturnOfInt64() chan *ReturnOfInt64
	PutChReturnOfInt64(chan *ReturnOfInt64)
}

type PoolOfComplex64ThenInt64Impl struct {
	Complex64Arg    sync.Pool
	Int64Rtn        sync.Pool
	Complex64Work   sync.Pool
	Int64Return     sync.Pool
	ChReturnOfInt64 sync.Pool
}

func (__ *PoolOfComplex64ThenInt64Impl) GetComplex64Arg() *complex64 {
	return __.Complex64Arg.Get().(*complex64)
}
func (__ *PoolOfComplex64ThenInt64Impl) PutComplex64Arg(p *complex64) {
	__.Complex64Arg.Put(p)
}
func (__ *PoolOfComplex64ThenInt64Impl) GetInt64Return() *int64 {
	return __.Int64Rtn.Get().(*int64)
}
func (__ *PoolOfComplex64ThenInt64Impl) PutInt64Return(p *int64) {
	__.Int64Rtn.Put(p)
}

func (__ *PoolOfComplex64ThenInt64Impl) GetWorkOfComplex64ThenInt64() *WorkOfComplex64ThenInt64 {
	return __.Complex64Work.Get().(*WorkOfComplex64ThenInt64)
}
func (__ *PoolOfComplex64ThenInt64Impl) PutWorkOfComplex64ThenInt64(p *WorkOfComplex64ThenInt64) {
	__.Complex64Work.Put(p)
}
func (__ *PoolOfComplex64ThenInt64Impl) GetReturnOfInt64() *ReturnOfInt64 {
	return __.Int64Return.Get().(*ReturnOfInt64)
}
func (__ *PoolOfComplex64ThenInt64Impl) PutReturnOfInt64(p *ReturnOfInt64) {
	__.Int64Return.Put(p)
}

func (__ *PoolOfComplex64ThenInt64Impl) GetChReturnOfInt64() chan *ReturnOfInt64 {
	return __.ChReturnOfInt64.Get().(chan *ReturnOfInt64)
}
func (__ *PoolOfComplex64ThenInt64Impl) PutChReturnOfInt64(p chan *ReturnOfInt64) {
	__.ChReturnOfInt64.Put(p)
}

func NewPoolOfComplex64ThenInt64Impl() *PoolOfComplex64ThenInt64Impl {
	return &PoolOfComplex64ThenInt64Impl{
		Complex64Arg: sync.Pool{
			New: func() interface{} {
				return new(complex64)
			},
		},
		Complex64Work: sync.Pool{
			New: func() interface{} {
				return new(WorkOfComplex64ThenInt64)
			},
		},
		Int64Rtn: sync.Pool{
			New: func() interface{} {
				return new(int64)
			},
		},
		Int64Return: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfInt64)
			},
		},
		ChReturnOfInt64: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfInt64, 1)
			},
		},
	}
}

type ApiDecouplerOfComplex64ThenInt64 struct {
	pool PoolOfComplex64ThenInt64
}

func NewApiDecouplerOfComplex64ThenInt64() *ApiDecouplerOfComplex64ThenInt64 {
	return &ApiDecouplerOfComplex64ThenInt64{
		pool: NewPoolOfComplex64ThenInt64Impl(),
	}
}

func (__ *ApiDecouplerOfComplex64ThenInt64) ReturnError(rtn_ch chan<- *ReturnOfInt64, err error) {
	rtn := __.pool.GetReturnOfInt64()
	var other int64
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfComplex64ThenInt64) HandleOfComplex64ThenInt64(ctx context.Context, req *WorkOfComplex64ThenInt64, h func(ctx context.Context, arg complex64) (int64, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfInt64()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfComplex64ThenInt64) DoOfComplex64ThenInt64(ctx context.Context, worker WorkerOfPushComplex64ThenInt64, arg complex64) (int64, error) {
	// ch := make(chan *ReturnOfInt64, 1)
	ch := __.pool.GetChReturnOfInt64()
	defer __.pool.PutChReturnOfInt64(ch)

	req := __.pool.GetWorkOfComplex64ThenInt64()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfComplex64ThenInt64(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfInt64(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfComplex64ThenInt64 = func(ctx context.Context, arg complex64) (int64, error)

type WorkerOfComplex64ThenInt64 struct {
	api_syncer *ApiDecouplerOfComplex64ThenInt64
	handler    WorkHandlerOfComplex64ThenInt64

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfComplex64ThenInt64
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfComplex64ThenInt64(ctx context.Context, h WorkHandlerOfComplex64ThenInt64, n int) *WorkerOfComplex64ThenInt64 {
	__ := &WorkerOfComplex64ThenInt64{
		api_syncer: NewApiDecouplerOfComplex64ThenInt64(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfComplex64ThenInt64, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfComplex64ThenInt64{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfComplex64ThenInt64(req.Context, req.WorkOfComplex64ThenInt64, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfComplex64ThenInt64) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfComplex64ThenInt64) Push(ctx context.Context, req *WorkOfComplex64ThenInt64) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfComplex64ThenInt64)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfComplex64ThenInt64 = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfComplex64ThenInt64) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfComplex64ThenInt64) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfComplex64ThenInt64) Call(ctx context.Context, arg complex64) (int64, error) {
	return __.api_syncer.DoOfComplex64ThenInt64(ctx, __, arg)
}

type PoolOfComplex64ThenInt8 interface {
	GetComplex64Arg() *complex64
	PutComplex64Arg(*complex64)
	GetInt8Return() *int8
	PutInt8Return(*int8)

	GetWorkOfComplex64ThenInt8() *WorkOfComplex64ThenInt8
	GetReturnOfInt8() *ReturnOfInt8
	PutWorkOfComplex64ThenInt8(*WorkOfComplex64ThenInt8)
	PutReturnOfInt8(*ReturnOfInt8)

	GetChReturnOfInt8() chan *ReturnOfInt8
	PutChReturnOfInt8(chan *ReturnOfInt8)
}

type PoolOfComplex64ThenInt8Impl struct {
	Complex64Arg   sync.Pool
	Int8Rtn        sync.Pool
	Complex64Work  sync.Pool
	Int8Return     sync.Pool
	ChReturnOfInt8 sync.Pool
}

func (__ *PoolOfComplex64ThenInt8Impl) GetComplex64Arg() *complex64 {
	return __.Complex64Arg.Get().(*complex64)
}
func (__ *PoolOfComplex64ThenInt8Impl) PutComplex64Arg(p *complex64) {
	__.Complex64Arg.Put(p)
}
func (__ *PoolOfComplex64ThenInt8Impl) GetInt8Return() *int8 {
	return __.Int8Rtn.Get().(*int8)
}
func (__ *PoolOfComplex64ThenInt8Impl) PutInt8Return(p *int8) {
	__.Int8Rtn.Put(p)
}

func (__ *PoolOfComplex64ThenInt8Impl) GetWorkOfComplex64ThenInt8() *WorkOfComplex64ThenInt8 {
	return __.Complex64Work.Get().(*WorkOfComplex64ThenInt8)
}
func (__ *PoolOfComplex64ThenInt8Impl) PutWorkOfComplex64ThenInt8(p *WorkOfComplex64ThenInt8) {
	__.Complex64Work.Put(p)
}
func (__ *PoolOfComplex64ThenInt8Impl) GetReturnOfInt8() *ReturnOfInt8 {
	return __.Int8Return.Get().(*ReturnOfInt8)
}
func (__ *PoolOfComplex64ThenInt8Impl) PutReturnOfInt8(p *ReturnOfInt8) {
	__.Int8Return.Put(p)
}

func (__ *PoolOfComplex64ThenInt8Impl) GetChReturnOfInt8() chan *ReturnOfInt8 {
	return __.ChReturnOfInt8.Get().(chan *ReturnOfInt8)
}
func (__ *PoolOfComplex64ThenInt8Impl) PutChReturnOfInt8(p chan *ReturnOfInt8) {
	__.ChReturnOfInt8.Put(p)
}

func NewPoolOfComplex64ThenInt8Impl() *PoolOfComplex64ThenInt8Impl {
	return &PoolOfComplex64ThenInt8Impl{
		Complex64Arg: sync.Pool{
			New: func() interface{} {
				return new(complex64)
			},
		},
		Complex64Work: sync.Pool{
			New: func() interface{} {
				return new(WorkOfComplex64ThenInt8)
			},
		},
		Int8Rtn: sync.Pool{
			New: func() interface{} {
				return new(int8)
			},
		},
		Int8Return: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfInt8)
			},
		},
		ChReturnOfInt8: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfInt8, 1)
			},
		},
	}
}

type ApiDecouplerOfComplex64ThenInt8 struct {
	pool PoolOfComplex64ThenInt8
}

func NewApiDecouplerOfComplex64ThenInt8() *ApiDecouplerOfComplex64ThenInt8 {
	return &ApiDecouplerOfComplex64ThenInt8{
		pool: NewPoolOfComplex64ThenInt8Impl(),
	}
}

func (__ *ApiDecouplerOfComplex64ThenInt8) ReturnError(rtn_ch chan<- *ReturnOfInt8, err error) {
	rtn := __.pool.GetReturnOfInt8()
	var other int8
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfComplex64ThenInt8) HandleOfComplex64ThenInt8(ctx context.Context, req *WorkOfComplex64ThenInt8, h func(ctx context.Context, arg complex64) (int8, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfInt8()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfComplex64ThenInt8) DoOfComplex64ThenInt8(ctx context.Context, worker WorkerOfPushComplex64ThenInt8, arg complex64) (int8, error) {
	// ch := make(chan *ReturnOfInt8, 1)
	ch := __.pool.GetChReturnOfInt8()
	defer __.pool.PutChReturnOfInt8(ch)

	req := __.pool.GetWorkOfComplex64ThenInt8()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfComplex64ThenInt8(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfInt8(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfComplex64ThenInt8 = func(ctx context.Context, arg complex64) (int8, error)

type WorkerOfComplex64ThenInt8 struct {
	api_syncer *ApiDecouplerOfComplex64ThenInt8
	handler    WorkHandlerOfComplex64ThenInt8

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfComplex64ThenInt8
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfComplex64ThenInt8(ctx context.Context, h WorkHandlerOfComplex64ThenInt8, n int) *WorkerOfComplex64ThenInt8 {
	__ := &WorkerOfComplex64ThenInt8{
		api_syncer: NewApiDecouplerOfComplex64ThenInt8(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfComplex64ThenInt8, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfComplex64ThenInt8{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfComplex64ThenInt8(req.Context, req.WorkOfComplex64ThenInt8, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfComplex64ThenInt8) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfComplex64ThenInt8) Push(ctx context.Context, req *WorkOfComplex64ThenInt8) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfComplex64ThenInt8)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfComplex64ThenInt8 = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfComplex64ThenInt8) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfComplex64ThenInt8) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfComplex64ThenInt8) Call(ctx context.Context, arg complex64) (int8, error) {
	return __.api_syncer.DoOfComplex64ThenInt8(ctx, __, arg)
}

type PoolOfComplex64ThenRune interface {
	GetComplex64Arg() *complex64
	PutComplex64Arg(*complex64)
	GetRuneReturn() *rune
	PutRuneReturn(*rune)

	GetWorkOfComplex64ThenRune() *WorkOfComplex64ThenRune
	GetReturnOfRune() *ReturnOfRune
	PutWorkOfComplex64ThenRune(*WorkOfComplex64ThenRune)
	PutReturnOfRune(*ReturnOfRune)

	GetChReturnOfRune() chan *ReturnOfRune
	PutChReturnOfRune(chan *ReturnOfRune)
}

type PoolOfComplex64ThenRuneImpl struct {
	Complex64Arg   sync.Pool
	RuneRtn        sync.Pool
	Complex64Work  sync.Pool
	RuneReturn     sync.Pool
	ChReturnOfRune sync.Pool
}

func (__ *PoolOfComplex64ThenRuneImpl) GetComplex64Arg() *complex64 {
	return __.Complex64Arg.Get().(*complex64)
}
func (__ *PoolOfComplex64ThenRuneImpl) PutComplex64Arg(p *complex64) {
	__.Complex64Arg.Put(p)
}
func (__ *PoolOfComplex64ThenRuneImpl) GetRuneReturn() *rune {
	return __.RuneRtn.Get().(*rune)
}
func (__ *PoolOfComplex64ThenRuneImpl) PutRuneReturn(p *rune) {
	__.RuneRtn.Put(p)
}

func (__ *PoolOfComplex64ThenRuneImpl) GetWorkOfComplex64ThenRune() *WorkOfComplex64ThenRune {
	return __.Complex64Work.Get().(*WorkOfComplex64ThenRune)
}
func (__ *PoolOfComplex64ThenRuneImpl) PutWorkOfComplex64ThenRune(p *WorkOfComplex64ThenRune) {
	__.Complex64Work.Put(p)
}
func (__ *PoolOfComplex64ThenRuneImpl) GetReturnOfRune() *ReturnOfRune {
	return __.RuneReturn.Get().(*ReturnOfRune)
}
func (__ *PoolOfComplex64ThenRuneImpl) PutReturnOfRune(p *ReturnOfRune) {
	__.RuneReturn.Put(p)
}

func (__ *PoolOfComplex64ThenRuneImpl) GetChReturnOfRune() chan *ReturnOfRune {
	return __.ChReturnOfRune.Get().(chan *ReturnOfRune)
}
func (__ *PoolOfComplex64ThenRuneImpl) PutChReturnOfRune(p chan *ReturnOfRune) {
	__.ChReturnOfRune.Put(p)
}

func NewPoolOfComplex64ThenRuneImpl() *PoolOfComplex64ThenRuneImpl {
	return &PoolOfComplex64ThenRuneImpl{
		Complex64Arg: sync.Pool{
			New: func() interface{} {
				return new(complex64)
			},
		},
		Complex64Work: sync.Pool{
			New: func() interface{} {
				return new(WorkOfComplex64ThenRune)
			},
		},
		RuneRtn: sync.Pool{
			New: func() interface{} {
				return new(rune)
			},
		},
		RuneReturn: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfRune)
			},
		},
		ChReturnOfRune: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfRune, 1)
			},
		},
	}
}

type ApiDecouplerOfComplex64ThenRune struct {
	pool PoolOfComplex64ThenRune
}

func NewApiDecouplerOfComplex64ThenRune() *ApiDecouplerOfComplex64ThenRune {
	return &ApiDecouplerOfComplex64ThenRune{
		pool: NewPoolOfComplex64ThenRuneImpl(),
	}
}

func (__ *ApiDecouplerOfComplex64ThenRune) ReturnError(rtn_ch chan<- *ReturnOfRune, err error) {
	rtn := __.pool.GetReturnOfRune()
	var other rune
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfComplex64ThenRune) HandleOfComplex64ThenRune(ctx context.Context, req *WorkOfComplex64ThenRune, h func(ctx context.Context, arg complex64) (rune, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfRune()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfComplex64ThenRune) DoOfComplex64ThenRune(ctx context.Context, worker WorkerOfPushComplex64ThenRune, arg complex64) (rune, error) {
	// ch := make(chan *ReturnOfRune, 1)
	ch := __.pool.GetChReturnOfRune()
	defer __.pool.PutChReturnOfRune(ch)

	req := __.pool.GetWorkOfComplex64ThenRune()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfComplex64ThenRune(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfRune(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfComplex64ThenRune = func(ctx context.Context, arg complex64) (rune, error)

type WorkerOfComplex64ThenRune struct {
	api_syncer *ApiDecouplerOfComplex64ThenRune
	handler    WorkHandlerOfComplex64ThenRune

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfComplex64ThenRune
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfComplex64ThenRune(ctx context.Context, h WorkHandlerOfComplex64ThenRune, n int) *WorkerOfComplex64ThenRune {
	__ := &WorkerOfComplex64ThenRune{
		api_syncer: NewApiDecouplerOfComplex64ThenRune(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfComplex64ThenRune, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfComplex64ThenRune{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfComplex64ThenRune(req.Context, req.WorkOfComplex64ThenRune, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfComplex64ThenRune) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfComplex64ThenRune) Push(ctx context.Context, req *WorkOfComplex64ThenRune) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfComplex64ThenRune)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfComplex64ThenRune = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfComplex64ThenRune) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfComplex64ThenRune) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfComplex64ThenRune) Call(ctx context.Context, arg complex64) (rune, error) {
	return __.api_syncer.DoOfComplex64ThenRune(ctx, __, arg)
}

type PoolOfComplex64ThenString interface {
	GetComplex64Arg() *complex64
	PutComplex64Arg(*complex64)
	GetStringReturn() *string
	PutStringReturn(*string)

	GetWorkOfComplex64ThenString() *WorkOfComplex64ThenString
	GetReturnOfString() *ReturnOfString
	PutWorkOfComplex64ThenString(*WorkOfComplex64ThenString)
	PutReturnOfString(*ReturnOfString)

	GetChReturnOfString() chan *ReturnOfString
	PutChReturnOfString(chan *ReturnOfString)
}

type PoolOfComplex64ThenStringImpl struct {
	Complex64Arg     sync.Pool
	StringRtn        sync.Pool
	Complex64Work    sync.Pool
	StringReturn     sync.Pool
	ChReturnOfString sync.Pool
}

func (__ *PoolOfComplex64ThenStringImpl) GetComplex64Arg() *complex64 {
	return __.Complex64Arg.Get().(*complex64)
}
func (__ *PoolOfComplex64ThenStringImpl) PutComplex64Arg(p *complex64) {
	__.Complex64Arg.Put(p)
}
func (__ *PoolOfComplex64ThenStringImpl) GetStringReturn() *string {
	return __.StringRtn.Get().(*string)
}
func (__ *PoolOfComplex64ThenStringImpl) PutStringReturn(p *string) {
	__.StringRtn.Put(p)
}

func (__ *PoolOfComplex64ThenStringImpl) GetWorkOfComplex64ThenString() *WorkOfComplex64ThenString {
	return __.Complex64Work.Get().(*WorkOfComplex64ThenString)
}
func (__ *PoolOfComplex64ThenStringImpl) PutWorkOfComplex64ThenString(p *WorkOfComplex64ThenString) {
	__.Complex64Work.Put(p)
}
func (__ *PoolOfComplex64ThenStringImpl) GetReturnOfString() *ReturnOfString {
	return __.StringReturn.Get().(*ReturnOfString)
}
func (__ *PoolOfComplex64ThenStringImpl) PutReturnOfString(p *ReturnOfString) {
	__.StringReturn.Put(p)
}

func (__ *PoolOfComplex64ThenStringImpl) GetChReturnOfString() chan *ReturnOfString {
	return __.ChReturnOfString.Get().(chan *ReturnOfString)
}
func (__ *PoolOfComplex64ThenStringImpl) PutChReturnOfString(p chan *ReturnOfString) {
	__.ChReturnOfString.Put(p)
}

func NewPoolOfComplex64ThenStringImpl() *PoolOfComplex64ThenStringImpl {
	return &PoolOfComplex64ThenStringImpl{
		Complex64Arg: sync.Pool{
			New: func() interface{} {
				return new(complex64)
			},
		},
		Complex64Work: sync.Pool{
			New: func() interface{} {
				return new(WorkOfComplex64ThenString)
			},
		},
		StringRtn: sync.Pool{
			New: func() interface{} {
				return new(string)
			},
		},
		StringReturn: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfString)
			},
		},
		ChReturnOfString: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfString, 1)
			},
		},
	}
}

type ApiDecouplerOfComplex64ThenString struct {
	pool PoolOfComplex64ThenString
}

func NewApiDecouplerOfComplex64ThenString() *ApiDecouplerOfComplex64ThenString {
	return &ApiDecouplerOfComplex64ThenString{
		pool: NewPoolOfComplex64ThenStringImpl(),
	}
}

func (__ *ApiDecouplerOfComplex64ThenString) ReturnError(rtn_ch chan<- *ReturnOfString, err error) {
	rtn := __.pool.GetReturnOfString()
	var other string
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfComplex64ThenString) HandleOfComplex64ThenString(ctx context.Context, req *WorkOfComplex64ThenString, h func(ctx context.Context, arg complex64) (string, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfString()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfComplex64ThenString) DoOfComplex64ThenString(ctx context.Context, worker WorkerOfPushComplex64ThenString, arg complex64) (string, error) {
	// ch := make(chan *ReturnOfString, 1)
	ch := __.pool.GetChReturnOfString()
	defer __.pool.PutChReturnOfString(ch)

	req := __.pool.GetWorkOfComplex64ThenString()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfComplex64ThenString(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfString(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfComplex64ThenString = func(ctx context.Context, arg complex64) (string, error)

type WorkerOfComplex64ThenString struct {
	api_syncer *ApiDecouplerOfComplex64ThenString
	handler    WorkHandlerOfComplex64ThenString

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfComplex64ThenString
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfComplex64ThenString(ctx context.Context, h WorkHandlerOfComplex64ThenString, n int) *WorkerOfComplex64ThenString {
	__ := &WorkerOfComplex64ThenString{
		api_syncer: NewApiDecouplerOfComplex64ThenString(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfComplex64ThenString, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfComplex64ThenString{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfComplex64ThenString(req.Context, req.WorkOfComplex64ThenString, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfComplex64ThenString) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfComplex64ThenString) Push(ctx context.Context, req *WorkOfComplex64ThenString) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfComplex64ThenString)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfComplex64ThenString = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfComplex64ThenString) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfComplex64ThenString) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfComplex64ThenString) Call(ctx context.Context, arg complex64) (string, error) {
	return __.api_syncer.DoOfComplex64ThenString(ctx, __, arg)
}

type PoolOfComplex64ThenUint interface {
	GetComplex64Arg() *complex64
	PutComplex64Arg(*complex64)
	GetUintReturn() *uint
	PutUintReturn(*uint)

	GetWorkOfComplex64ThenUint() *WorkOfComplex64ThenUint
	GetReturnOfUint() *ReturnOfUint
	PutWorkOfComplex64ThenUint(*WorkOfComplex64ThenUint)
	PutReturnOfUint(*ReturnOfUint)

	GetChReturnOfUint() chan *ReturnOfUint
	PutChReturnOfUint(chan *ReturnOfUint)
}

type PoolOfComplex64ThenUintImpl struct {
	Complex64Arg   sync.Pool
	UintRtn        sync.Pool
	Complex64Work  sync.Pool
	UintReturn     sync.Pool
	ChReturnOfUint sync.Pool
}

func (__ *PoolOfComplex64ThenUintImpl) GetComplex64Arg() *complex64 {
	return __.Complex64Arg.Get().(*complex64)
}
func (__ *PoolOfComplex64ThenUintImpl) PutComplex64Arg(p *complex64) {
	__.Complex64Arg.Put(p)
}
func (__ *PoolOfComplex64ThenUintImpl) GetUintReturn() *uint {
	return __.UintRtn.Get().(*uint)
}
func (__ *PoolOfComplex64ThenUintImpl) PutUintReturn(p *uint) {
	__.UintRtn.Put(p)
}

func (__ *PoolOfComplex64ThenUintImpl) GetWorkOfComplex64ThenUint() *WorkOfComplex64ThenUint {
	return __.Complex64Work.Get().(*WorkOfComplex64ThenUint)
}
func (__ *PoolOfComplex64ThenUintImpl) PutWorkOfComplex64ThenUint(p *WorkOfComplex64ThenUint) {
	__.Complex64Work.Put(p)
}
func (__ *PoolOfComplex64ThenUintImpl) GetReturnOfUint() *ReturnOfUint {
	return __.UintReturn.Get().(*ReturnOfUint)
}
func (__ *PoolOfComplex64ThenUintImpl) PutReturnOfUint(p *ReturnOfUint) {
	__.UintReturn.Put(p)
}

func (__ *PoolOfComplex64ThenUintImpl) GetChReturnOfUint() chan *ReturnOfUint {
	return __.ChReturnOfUint.Get().(chan *ReturnOfUint)
}
func (__ *PoolOfComplex64ThenUintImpl) PutChReturnOfUint(p chan *ReturnOfUint) {
	__.ChReturnOfUint.Put(p)
}

func NewPoolOfComplex64ThenUintImpl() *PoolOfComplex64ThenUintImpl {
	return &PoolOfComplex64ThenUintImpl{
		Complex64Arg: sync.Pool{
			New: func() interface{} {
				return new(complex64)
			},
		},
		Complex64Work: sync.Pool{
			New: func() interface{} {
				return new(WorkOfComplex64ThenUint)
			},
		},
		UintRtn: sync.Pool{
			New: func() interface{} {
				return new(uint)
			},
		},
		UintReturn: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfUint)
			},
		},
		ChReturnOfUint: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfUint, 1)
			},
		},
	}
}

type ApiDecouplerOfComplex64ThenUint struct {
	pool PoolOfComplex64ThenUint
}

func NewApiDecouplerOfComplex64ThenUint() *ApiDecouplerOfComplex64ThenUint {
	return &ApiDecouplerOfComplex64ThenUint{
		pool: NewPoolOfComplex64ThenUintImpl(),
	}
}

func (__ *ApiDecouplerOfComplex64ThenUint) ReturnError(rtn_ch chan<- *ReturnOfUint, err error) {
	rtn := __.pool.GetReturnOfUint()
	var other uint
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfComplex64ThenUint) HandleOfComplex64ThenUint(ctx context.Context, req *WorkOfComplex64ThenUint, h func(ctx context.Context, arg complex64) (uint, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfUint()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfComplex64ThenUint) DoOfComplex64ThenUint(ctx context.Context, worker WorkerOfPushComplex64ThenUint, arg complex64) (uint, error) {
	// ch := make(chan *ReturnOfUint, 1)
	ch := __.pool.GetChReturnOfUint()
	defer __.pool.PutChReturnOfUint(ch)

	req := __.pool.GetWorkOfComplex64ThenUint()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfComplex64ThenUint(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfUint(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfComplex64ThenUint = func(ctx context.Context, arg complex64) (uint, error)

type WorkerOfComplex64ThenUint struct {
	api_syncer *ApiDecouplerOfComplex64ThenUint
	handler    WorkHandlerOfComplex64ThenUint

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfComplex64ThenUint
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfComplex64ThenUint(ctx context.Context, h WorkHandlerOfComplex64ThenUint, n int) *WorkerOfComplex64ThenUint {
	__ := &WorkerOfComplex64ThenUint{
		api_syncer: NewApiDecouplerOfComplex64ThenUint(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfComplex64ThenUint, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfComplex64ThenUint{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfComplex64ThenUint(req.Context, req.WorkOfComplex64ThenUint, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfComplex64ThenUint) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfComplex64ThenUint) Push(ctx context.Context, req *WorkOfComplex64ThenUint) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfComplex64ThenUint)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfComplex64ThenUint = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfComplex64ThenUint) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfComplex64ThenUint) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfComplex64ThenUint) Call(ctx context.Context, arg complex64) (uint, error) {
	return __.api_syncer.DoOfComplex64ThenUint(ctx, __, arg)
}

type PoolOfComplex64ThenUint16 interface {
	GetComplex64Arg() *complex64
	PutComplex64Arg(*complex64)
	GetUint16Return() *uint16
	PutUint16Return(*uint16)

	GetWorkOfComplex64ThenUint16() *WorkOfComplex64ThenUint16
	GetReturnOfUint16() *ReturnOfUint16
	PutWorkOfComplex64ThenUint16(*WorkOfComplex64ThenUint16)
	PutReturnOfUint16(*ReturnOfUint16)

	GetChReturnOfUint16() chan *ReturnOfUint16
	PutChReturnOfUint16(chan *ReturnOfUint16)
}

type PoolOfComplex64ThenUint16Impl struct {
	Complex64Arg     sync.Pool
	Uint16Rtn        sync.Pool
	Complex64Work    sync.Pool
	Uint16Return     sync.Pool
	ChReturnOfUint16 sync.Pool
}

func (__ *PoolOfComplex64ThenUint16Impl) GetComplex64Arg() *complex64 {
	return __.Complex64Arg.Get().(*complex64)
}
func (__ *PoolOfComplex64ThenUint16Impl) PutComplex64Arg(p *complex64) {
	__.Complex64Arg.Put(p)
}
func (__ *PoolOfComplex64ThenUint16Impl) GetUint16Return() *uint16 {
	return __.Uint16Rtn.Get().(*uint16)
}
func (__ *PoolOfComplex64ThenUint16Impl) PutUint16Return(p *uint16) {
	__.Uint16Rtn.Put(p)
}

func (__ *PoolOfComplex64ThenUint16Impl) GetWorkOfComplex64ThenUint16() *WorkOfComplex64ThenUint16 {
	return __.Complex64Work.Get().(*WorkOfComplex64ThenUint16)
}
func (__ *PoolOfComplex64ThenUint16Impl) PutWorkOfComplex64ThenUint16(p *WorkOfComplex64ThenUint16) {
	__.Complex64Work.Put(p)
}
func (__ *PoolOfComplex64ThenUint16Impl) GetReturnOfUint16() *ReturnOfUint16 {
	return __.Uint16Return.Get().(*ReturnOfUint16)
}
func (__ *PoolOfComplex64ThenUint16Impl) PutReturnOfUint16(p *ReturnOfUint16) {
	__.Uint16Return.Put(p)
}

func (__ *PoolOfComplex64ThenUint16Impl) GetChReturnOfUint16() chan *ReturnOfUint16 {
	return __.ChReturnOfUint16.Get().(chan *ReturnOfUint16)
}
func (__ *PoolOfComplex64ThenUint16Impl) PutChReturnOfUint16(p chan *ReturnOfUint16) {
	__.ChReturnOfUint16.Put(p)
}

func NewPoolOfComplex64ThenUint16Impl() *PoolOfComplex64ThenUint16Impl {
	return &PoolOfComplex64ThenUint16Impl{
		Complex64Arg: sync.Pool{
			New: func() interface{} {
				return new(complex64)
			},
		},
		Complex64Work: sync.Pool{
			New: func() interface{} {
				return new(WorkOfComplex64ThenUint16)
			},
		},
		Uint16Rtn: sync.Pool{
			New: func() interface{} {
				return new(uint16)
			},
		},
		Uint16Return: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfUint16)
			},
		},
		ChReturnOfUint16: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfUint16, 1)
			},
		},
	}
}

type ApiDecouplerOfComplex64ThenUint16 struct {
	pool PoolOfComplex64ThenUint16
}

func NewApiDecouplerOfComplex64ThenUint16() *ApiDecouplerOfComplex64ThenUint16 {
	return &ApiDecouplerOfComplex64ThenUint16{
		pool: NewPoolOfComplex64ThenUint16Impl(),
	}
}

func (__ *ApiDecouplerOfComplex64ThenUint16) ReturnError(rtn_ch chan<- *ReturnOfUint16, err error) {
	rtn := __.pool.GetReturnOfUint16()
	var other uint16
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfComplex64ThenUint16) HandleOfComplex64ThenUint16(ctx context.Context, req *WorkOfComplex64ThenUint16, h func(ctx context.Context, arg complex64) (uint16, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfUint16()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfComplex64ThenUint16) DoOfComplex64ThenUint16(ctx context.Context, worker WorkerOfPushComplex64ThenUint16, arg complex64) (uint16, error) {
	// ch := make(chan *ReturnOfUint16, 1)
	ch := __.pool.GetChReturnOfUint16()
	defer __.pool.PutChReturnOfUint16(ch)

	req := __.pool.GetWorkOfComplex64ThenUint16()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfComplex64ThenUint16(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfUint16(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfComplex64ThenUint16 = func(ctx context.Context, arg complex64) (uint16, error)

type WorkerOfComplex64ThenUint16 struct {
	api_syncer *ApiDecouplerOfComplex64ThenUint16
	handler    WorkHandlerOfComplex64ThenUint16

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfComplex64ThenUint16
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfComplex64ThenUint16(ctx context.Context, h WorkHandlerOfComplex64ThenUint16, n int) *WorkerOfComplex64ThenUint16 {
	__ := &WorkerOfComplex64ThenUint16{
		api_syncer: NewApiDecouplerOfComplex64ThenUint16(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfComplex64ThenUint16, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfComplex64ThenUint16{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfComplex64ThenUint16(req.Context, req.WorkOfComplex64ThenUint16, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfComplex64ThenUint16) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfComplex64ThenUint16) Push(ctx context.Context, req *WorkOfComplex64ThenUint16) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfComplex64ThenUint16)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfComplex64ThenUint16 = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfComplex64ThenUint16) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfComplex64ThenUint16) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfComplex64ThenUint16) Call(ctx context.Context, arg complex64) (uint16, error) {
	return __.api_syncer.DoOfComplex64ThenUint16(ctx, __, arg)
}

type PoolOfComplex64ThenUint32 interface {
	GetComplex64Arg() *complex64
	PutComplex64Arg(*complex64)
	GetUint32Return() *uint32
	PutUint32Return(*uint32)

	GetWorkOfComplex64ThenUint32() *WorkOfComplex64ThenUint32
	GetReturnOfUint32() *ReturnOfUint32
	PutWorkOfComplex64ThenUint32(*WorkOfComplex64ThenUint32)
	PutReturnOfUint32(*ReturnOfUint32)

	GetChReturnOfUint32() chan *ReturnOfUint32
	PutChReturnOfUint32(chan *ReturnOfUint32)
}

type PoolOfComplex64ThenUint32Impl struct {
	Complex64Arg     sync.Pool
	Uint32Rtn        sync.Pool
	Complex64Work    sync.Pool
	Uint32Return     sync.Pool
	ChReturnOfUint32 sync.Pool
}

func (__ *PoolOfComplex64ThenUint32Impl) GetComplex64Arg() *complex64 {
	return __.Complex64Arg.Get().(*complex64)
}
func (__ *PoolOfComplex64ThenUint32Impl) PutComplex64Arg(p *complex64) {
	__.Complex64Arg.Put(p)
}
func (__ *PoolOfComplex64ThenUint32Impl) GetUint32Return() *uint32 {
	return __.Uint32Rtn.Get().(*uint32)
}
func (__ *PoolOfComplex64ThenUint32Impl) PutUint32Return(p *uint32) {
	__.Uint32Rtn.Put(p)
}

func (__ *PoolOfComplex64ThenUint32Impl) GetWorkOfComplex64ThenUint32() *WorkOfComplex64ThenUint32 {
	return __.Complex64Work.Get().(*WorkOfComplex64ThenUint32)
}
func (__ *PoolOfComplex64ThenUint32Impl) PutWorkOfComplex64ThenUint32(p *WorkOfComplex64ThenUint32) {
	__.Complex64Work.Put(p)
}
func (__ *PoolOfComplex64ThenUint32Impl) GetReturnOfUint32() *ReturnOfUint32 {
	return __.Uint32Return.Get().(*ReturnOfUint32)
}
func (__ *PoolOfComplex64ThenUint32Impl) PutReturnOfUint32(p *ReturnOfUint32) {
	__.Uint32Return.Put(p)
}

func (__ *PoolOfComplex64ThenUint32Impl) GetChReturnOfUint32() chan *ReturnOfUint32 {
	return __.ChReturnOfUint32.Get().(chan *ReturnOfUint32)
}
func (__ *PoolOfComplex64ThenUint32Impl) PutChReturnOfUint32(p chan *ReturnOfUint32) {
	__.ChReturnOfUint32.Put(p)
}

func NewPoolOfComplex64ThenUint32Impl() *PoolOfComplex64ThenUint32Impl {
	return &PoolOfComplex64ThenUint32Impl{
		Complex64Arg: sync.Pool{
			New: func() interface{} {
				return new(complex64)
			},
		},
		Complex64Work: sync.Pool{
			New: func() interface{} {
				return new(WorkOfComplex64ThenUint32)
			},
		},
		Uint32Rtn: sync.Pool{
			New: func() interface{} {
				return new(uint32)
			},
		},
		Uint32Return: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfUint32)
			},
		},
		ChReturnOfUint32: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfUint32, 1)
			},
		},
	}
}

type ApiDecouplerOfComplex64ThenUint32 struct {
	pool PoolOfComplex64ThenUint32
}

func NewApiDecouplerOfComplex64ThenUint32() *ApiDecouplerOfComplex64ThenUint32 {
	return &ApiDecouplerOfComplex64ThenUint32{
		pool: NewPoolOfComplex64ThenUint32Impl(),
	}
}

func (__ *ApiDecouplerOfComplex64ThenUint32) ReturnError(rtn_ch chan<- *ReturnOfUint32, err error) {
	rtn := __.pool.GetReturnOfUint32()
	var other uint32
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfComplex64ThenUint32) HandleOfComplex64ThenUint32(ctx context.Context, req *WorkOfComplex64ThenUint32, h func(ctx context.Context, arg complex64) (uint32, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfUint32()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfComplex64ThenUint32) DoOfComplex64ThenUint32(ctx context.Context, worker WorkerOfPushComplex64ThenUint32, arg complex64) (uint32, error) {
	// ch := make(chan *ReturnOfUint32, 1)
	ch := __.pool.GetChReturnOfUint32()
	defer __.pool.PutChReturnOfUint32(ch)

	req := __.pool.GetWorkOfComplex64ThenUint32()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfComplex64ThenUint32(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfUint32(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfComplex64ThenUint32 = func(ctx context.Context, arg complex64) (uint32, error)

type WorkerOfComplex64ThenUint32 struct {
	api_syncer *ApiDecouplerOfComplex64ThenUint32
	handler    WorkHandlerOfComplex64ThenUint32

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfComplex64ThenUint32
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfComplex64ThenUint32(ctx context.Context, h WorkHandlerOfComplex64ThenUint32, n int) *WorkerOfComplex64ThenUint32 {
	__ := &WorkerOfComplex64ThenUint32{
		api_syncer: NewApiDecouplerOfComplex64ThenUint32(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfComplex64ThenUint32, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfComplex64ThenUint32{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfComplex64ThenUint32(req.Context, req.WorkOfComplex64ThenUint32, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfComplex64ThenUint32) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfComplex64ThenUint32) Push(ctx context.Context, req *WorkOfComplex64ThenUint32) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfComplex64ThenUint32)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfComplex64ThenUint32 = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfComplex64ThenUint32) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfComplex64ThenUint32) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfComplex64ThenUint32) Call(ctx context.Context, arg complex64) (uint32, error) {
	return __.api_syncer.DoOfComplex64ThenUint32(ctx, __, arg)
}

type PoolOfComplex64ThenUint64 interface {
	GetComplex64Arg() *complex64
	PutComplex64Arg(*complex64)
	GetUint64Return() *uint64
	PutUint64Return(*uint64)

	GetWorkOfComplex64ThenUint64() *WorkOfComplex64ThenUint64
	GetReturnOfUint64() *ReturnOfUint64
	PutWorkOfComplex64ThenUint64(*WorkOfComplex64ThenUint64)
	PutReturnOfUint64(*ReturnOfUint64)

	GetChReturnOfUint64() chan *ReturnOfUint64
	PutChReturnOfUint64(chan *ReturnOfUint64)
}

type PoolOfComplex64ThenUint64Impl struct {
	Complex64Arg     sync.Pool
	Uint64Rtn        sync.Pool
	Complex64Work    sync.Pool
	Uint64Return     sync.Pool
	ChReturnOfUint64 sync.Pool
}

func (__ *PoolOfComplex64ThenUint64Impl) GetComplex64Arg() *complex64 {
	return __.Complex64Arg.Get().(*complex64)
}
func (__ *PoolOfComplex64ThenUint64Impl) PutComplex64Arg(p *complex64) {
	__.Complex64Arg.Put(p)
}
func (__ *PoolOfComplex64ThenUint64Impl) GetUint64Return() *uint64 {
	return __.Uint64Rtn.Get().(*uint64)
}
func (__ *PoolOfComplex64ThenUint64Impl) PutUint64Return(p *uint64) {
	__.Uint64Rtn.Put(p)
}

func (__ *PoolOfComplex64ThenUint64Impl) GetWorkOfComplex64ThenUint64() *WorkOfComplex64ThenUint64 {
	return __.Complex64Work.Get().(*WorkOfComplex64ThenUint64)
}
func (__ *PoolOfComplex64ThenUint64Impl) PutWorkOfComplex64ThenUint64(p *WorkOfComplex64ThenUint64) {
	__.Complex64Work.Put(p)
}
func (__ *PoolOfComplex64ThenUint64Impl) GetReturnOfUint64() *ReturnOfUint64 {
	return __.Uint64Return.Get().(*ReturnOfUint64)
}
func (__ *PoolOfComplex64ThenUint64Impl) PutReturnOfUint64(p *ReturnOfUint64) {
	__.Uint64Return.Put(p)
}

func (__ *PoolOfComplex64ThenUint64Impl) GetChReturnOfUint64() chan *ReturnOfUint64 {
	return __.ChReturnOfUint64.Get().(chan *ReturnOfUint64)
}
func (__ *PoolOfComplex64ThenUint64Impl) PutChReturnOfUint64(p chan *ReturnOfUint64) {
	__.ChReturnOfUint64.Put(p)
}

func NewPoolOfComplex64ThenUint64Impl() *PoolOfComplex64ThenUint64Impl {
	return &PoolOfComplex64ThenUint64Impl{
		Complex64Arg: sync.Pool{
			New: func() interface{} {
				return new(complex64)
			},
		},
		Complex64Work: sync.Pool{
			New: func() interface{} {
				return new(WorkOfComplex64ThenUint64)
			},
		},
		Uint64Rtn: sync.Pool{
			New: func() interface{} {
				return new(uint64)
			},
		},
		Uint64Return: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfUint64)
			},
		},
		ChReturnOfUint64: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfUint64, 1)
			},
		},
	}
}

type ApiDecouplerOfComplex64ThenUint64 struct {
	pool PoolOfComplex64ThenUint64
}

func NewApiDecouplerOfComplex64ThenUint64() *ApiDecouplerOfComplex64ThenUint64 {
	return &ApiDecouplerOfComplex64ThenUint64{
		pool: NewPoolOfComplex64ThenUint64Impl(),
	}
}

func (__ *ApiDecouplerOfComplex64ThenUint64) ReturnError(rtn_ch chan<- *ReturnOfUint64, err error) {
	rtn := __.pool.GetReturnOfUint64()
	var other uint64
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfComplex64ThenUint64) HandleOfComplex64ThenUint64(ctx context.Context, req *WorkOfComplex64ThenUint64, h func(ctx context.Context, arg complex64) (uint64, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfUint64()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfComplex64ThenUint64) DoOfComplex64ThenUint64(ctx context.Context, worker WorkerOfPushComplex64ThenUint64, arg complex64) (uint64, error) {
	// ch := make(chan *ReturnOfUint64, 1)
	ch := __.pool.GetChReturnOfUint64()
	defer __.pool.PutChReturnOfUint64(ch)

	req := __.pool.GetWorkOfComplex64ThenUint64()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfComplex64ThenUint64(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfUint64(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfComplex64ThenUint64 = func(ctx context.Context, arg complex64) (uint64, error)

type WorkerOfComplex64ThenUint64 struct {
	api_syncer *ApiDecouplerOfComplex64ThenUint64
	handler    WorkHandlerOfComplex64ThenUint64

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfComplex64ThenUint64
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfComplex64ThenUint64(ctx context.Context, h WorkHandlerOfComplex64ThenUint64, n int) *WorkerOfComplex64ThenUint64 {
	__ := &WorkerOfComplex64ThenUint64{
		api_syncer: NewApiDecouplerOfComplex64ThenUint64(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfComplex64ThenUint64, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfComplex64ThenUint64{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfComplex64ThenUint64(req.Context, req.WorkOfComplex64ThenUint64, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfComplex64ThenUint64) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfComplex64ThenUint64) Push(ctx context.Context, req *WorkOfComplex64ThenUint64) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfComplex64ThenUint64)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfComplex64ThenUint64 = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfComplex64ThenUint64) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfComplex64ThenUint64) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfComplex64ThenUint64) Call(ctx context.Context, arg complex64) (uint64, error) {
	return __.api_syncer.DoOfComplex64ThenUint64(ctx, __, arg)
}

type PoolOfComplex64ThenUint8 interface {
	GetComplex64Arg() *complex64
	PutComplex64Arg(*complex64)
	GetUint8Return() *uint8
	PutUint8Return(*uint8)

	GetWorkOfComplex64ThenUint8() *WorkOfComplex64ThenUint8
	GetReturnOfUint8() *ReturnOfUint8
	PutWorkOfComplex64ThenUint8(*WorkOfComplex64ThenUint8)
	PutReturnOfUint8(*ReturnOfUint8)

	GetChReturnOfUint8() chan *ReturnOfUint8
	PutChReturnOfUint8(chan *ReturnOfUint8)
}

type PoolOfComplex64ThenUint8Impl struct {
	Complex64Arg    sync.Pool
	Uint8Rtn        sync.Pool
	Complex64Work   sync.Pool
	Uint8Return     sync.Pool
	ChReturnOfUint8 sync.Pool
}

func (__ *PoolOfComplex64ThenUint8Impl) GetComplex64Arg() *complex64 {
	return __.Complex64Arg.Get().(*complex64)
}
func (__ *PoolOfComplex64ThenUint8Impl) PutComplex64Arg(p *complex64) {
	__.Complex64Arg.Put(p)
}
func (__ *PoolOfComplex64ThenUint8Impl) GetUint8Return() *uint8 {
	return __.Uint8Rtn.Get().(*uint8)
}
func (__ *PoolOfComplex64ThenUint8Impl) PutUint8Return(p *uint8) {
	__.Uint8Rtn.Put(p)
}

func (__ *PoolOfComplex64ThenUint8Impl) GetWorkOfComplex64ThenUint8() *WorkOfComplex64ThenUint8 {
	return __.Complex64Work.Get().(*WorkOfComplex64ThenUint8)
}
func (__ *PoolOfComplex64ThenUint8Impl) PutWorkOfComplex64ThenUint8(p *WorkOfComplex64ThenUint8) {
	__.Complex64Work.Put(p)
}
func (__ *PoolOfComplex64ThenUint8Impl) GetReturnOfUint8() *ReturnOfUint8 {
	return __.Uint8Return.Get().(*ReturnOfUint8)
}
func (__ *PoolOfComplex64ThenUint8Impl) PutReturnOfUint8(p *ReturnOfUint8) {
	__.Uint8Return.Put(p)
}

func (__ *PoolOfComplex64ThenUint8Impl) GetChReturnOfUint8() chan *ReturnOfUint8 {
	return __.ChReturnOfUint8.Get().(chan *ReturnOfUint8)
}
func (__ *PoolOfComplex64ThenUint8Impl) PutChReturnOfUint8(p chan *ReturnOfUint8) {
	__.ChReturnOfUint8.Put(p)
}

func NewPoolOfComplex64ThenUint8Impl() *PoolOfComplex64ThenUint8Impl {
	return &PoolOfComplex64ThenUint8Impl{
		Complex64Arg: sync.Pool{
			New: func() interface{} {
				return new(complex64)
			},
		},
		Complex64Work: sync.Pool{
			New: func() interface{} {
				return new(WorkOfComplex64ThenUint8)
			},
		},
		Uint8Rtn: sync.Pool{
			New: func() interface{} {
				return new(uint8)
			},
		},
		Uint8Return: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfUint8)
			},
		},
		ChReturnOfUint8: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfUint8, 1)
			},
		},
	}
}

type ApiDecouplerOfComplex64ThenUint8 struct {
	pool PoolOfComplex64ThenUint8
}

func NewApiDecouplerOfComplex64ThenUint8() *ApiDecouplerOfComplex64ThenUint8 {
	return &ApiDecouplerOfComplex64ThenUint8{
		pool: NewPoolOfComplex64ThenUint8Impl(),
	}
}

func (__ *ApiDecouplerOfComplex64ThenUint8) ReturnError(rtn_ch chan<- *ReturnOfUint8, err error) {
	rtn := __.pool.GetReturnOfUint8()
	var other uint8
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfComplex64ThenUint8) HandleOfComplex64ThenUint8(ctx context.Context, req *WorkOfComplex64ThenUint8, h func(ctx context.Context, arg complex64) (uint8, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfUint8()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfComplex64ThenUint8) DoOfComplex64ThenUint8(ctx context.Context, worker WorkerOfPushComplex64ThenUint8, arg complex64) (uint8, error) {
	// ch := make(chan *ReturnOfUint8, 1)
	ch := __.pool.GetChReturnOfUint8()
	defer __.pool.PutChReturnOfUint8(ch)

	req := __.pool.GetWorkOfComplex64ThenUint8()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfComplex64ThenUint8(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfUint8(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfComplex64ThenUint8 = func(ctx context.Context, arg complex64) (uint8, error)

type WorkerOfComplex64ThenUint8 struct {
	api_syncer *ApiDecouplerOfComplex64ThenUint8
	handler    WorkHandlerOfComplex64ThenUint8

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfComplex64ThenUint8
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfComplex64ThenUint8(ctx context.Context, h WorkHandlerOfComplex64ThenUint8, n int) *WorkerOfComplex64ThenUint8 {
	__ := &WorkerOfComplex64ThenUint8{
		api_syncer: NewApiDecouplerOfComplex64ThenUint8(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfComplex64ThenUint8, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfComplex64ThenUint8{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfComplex64ThenUint8(req.Context, req.WorkOfComplex64ThenUint8, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfComplex64ThenUint8) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfComplex64ThenUint8) Push(ctx context.Context, req *WorkOfComplex64ThenUint8) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfComplex64ThenUint8)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfComplex64ThenUint8 = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfComplex64ThenUint8) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfComplex64ThenUint8) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfComplex64ThenUint8) Call(ctx context.Context, arg complex64) (uint8, error) {
	return __.api_syncer.DoOfComplex64ThenUint8(ctx, __, arg)
}

type PoolOfComplex64ThenUintptr interface {
	GetComplex64Arg() *complex64
	PutComplex64Arg(*complex64)
	GetUintptrReturn() *uintptr
	PutUintptrReturn(*uintptr)

	GetWorkOfComplex64ThenUintptr() *WorkOfComplex64ThenUintptr
	GetReturnOfUintptr() *ReturnOfUintptr
	PutWorkOfComplex64ThenUintptr(*WorkOfComplex64ThenUintptr)
	PutReturnOfUintptr(*ReturnOfUintptr)

	GetChReturnOfUintptr() chan *ReturnOfUintptr
	PutChReturnOfUintptr(chan *ReturnOfUintptr)
}

type PoolOfComplex64ThenUintptrImpl struct {
	Complex64Arg      sync.Pool
	UintptrRtn        sync.Pool
	Complex64Work     sync.Pool
	UintptrReturn     sync.Pool
	ChReturnOfUintptr sync.Pool
}

func (__ *PoolOfComplex64ThenUintptrImpl) GetComplex64Arg() *complex64 {
	return __.Complex64Arg.Get().(*complex64)
}
func (__ *PoolOfComplex64ThenUintptrImpl) PutComplex64Arg(p *complex64) {
	__.Complex64Arg.Put(p)
}
func (__ *PoolOfComplex64ThenUintptrImpl) GetUintptrReturn() *uintptr {
	return __.UintptrRtn.Get().(*uintptr)
}
func (__ *PoolOfComplex64ThenUintptrImpl) PutUintptrReturn(p *uintptr) {
	__.UintptrRtn.Put(p)
}

func (__ *PoolOfComplex64ThenUintptrImpl) GetWorkOfComplex64ThenUintptr() *WorkOfComplex64ThenUintptr {
	return __.Complex64Work.Get().(*WorkOfComplex64ThenUintptr)
}
func (__ *PoolOfComplex64ThenUintptrImpl) PutWorkOfComplex64ThenUintptr(p *WorkOfComplex64ThenUintptr) {
	__.Complex64Work.Put(p)
}
func (__ *PoolOfComplex64ThenUintptrImpl) GetReturnOfUintptr() *ReturnOfUintptr {
	return __.UintptrReturn.Get().(*ReturnOfUintptr)
}
func (__ *PoolOfComplex64ThenUintptrImpl) PutReturnOfUintptr(p *ReturnOfUintptr) {
	__.UintptrReturn.Put(p)
}

func (__ *PoolOfComplex64ThenUintptrImpl) GetChReturnOfUintptr() chan *ReturnOfUintptr {
	return __.ChReturnOfUintptr.Get().(chan *ReturnOfUintptr)
}
func (__ *PoolOfComplex64ThenUintptrImpl) PutChReturnOfUintptr(p chan *ReturnOfUintptr) {
	__.ChReturnOfUintptr.Put(p)
}

func NewPoolOfComplex64ThenUintptrImpl() *PoolOfComplex64ThenUintptrImpl {
	return &PoolOfComplex64ThenUintptrImpl{
		Complex64Arg: sync.Pool{
			New: func() interface{} {
				return new(complex64)
			},
		},
		Complex64Work: sync.Pool{
			New: func() interface{} {
				return new(WorkOfComplex64ThenUintptr)
			},
		},
		UintptrRtn: sync.Pool{
			New: func() interface{} {
				return new(uintptr)
			},
		},
		UintptrReturn: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfUintptr)
			},
		},
		ChReturnOfUintptr: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfUintptr, 1)
			},
		},
	}
}

type ApiDecouplerOfComplex64ThenUintptr struct {
	pool PoolOfComplex64ThenUintptr
}

func NewApiDecouplerOfComplex64ThenUintptr() *ApiDecouplerOfComplex64ThenUintptr {
	return &ApiDecouplerOfComplex64ThenUintptr{
		pool: NewPoolOfComplex64ThenUintptrImpl(),
	}
}

func (__ *ApiDecouplerOfComplex64ThenUintptr) ReturnError(rtn_ch chan<- *ReturnOfUintptr, err error) {
	rtn := __.pool.GetReturnOfUintptr()
	var other uintptr
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfComplex64ThenUintptr) HandleOfComplex64ThenUintptr(ctx context.Context, req *WorkOfComplex64ThenUintptr, h func(ctx context.Context, arg complex64) (uintptr, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfUintptr()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfComplex64ThenUintptr) DoOfComplex64ThenUintptr(ctx context.Context, worker WorkerOfPushComplex64ThenUintptr, arg complex64) (uintptr, error) {
	// ch := make(chan *ReturnOfUintptr, 1)
	ch := __.pool.GetChReturnOfUintptr()
	defer __.pool.PutChReturnOfUintptr(ch)

	req := __.pool.GetWorkOfComplex64ThenUintptr()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfComplex64ThenUintptr(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfUintptr(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfComplex64ThenUintptr = func(ctx context.Context, arg complex64) (uintptr, error)

type WorkerOfComplex64ThenUintptr struct {
	api_syncer *ApiDecouplerOfComplex64ThenUintptr
	handler    WorkHandlerOfComplex64ThenUintptr

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfComplex64ThenUintptr
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfComplex64ThenUintptr(ctx context.Context, h WorkHandlerOfComplex64ThenUintptr, n int) *WorkerOfComplex64ThenUintptr {
	__ := &WorkerOfComplex64ThenUintptr{
		api_syncer: NewApiDecouplerOfComplex64ThenUintptr(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfComplex64ThenUintptr, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfComplex64ThenUintptr{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfComplex64ThenUintptr(req.Context, req.WorkOfComplex64ThenUintptr, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfComplex64ThenUintptr) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfComplex64ThenUintptr) Push(ctx context.Context, req *WorkOfComplex64ThenUintptr) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfComplex64ThenUintptr)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfComplex64ThenUintptr = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfComplex64ThenUintptr) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfComplex64ThenUintptr) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfComplex64ThenUintptr) Call(ctx context.Context, arg complex64) (uintptr, error) {
	return __.api_syncer.DoOfComplex64ThenUintptr(ctx, __, arg)
}

type PoolOfComplex64ThenInterface interface {
	GetComplex64Arg() *complex64
	PutComplex64Arg(*complex64)
	GetInterfaceReturn() *interface{}
	PutInterfaceReturn(*interface{})

	GetWorkOfComplex64ThenInterface() *WorkOfComplex64ThenInterface
	GetReturnOfInterface() *ReturnOfInterface
	PutWorkOfComplex64ThenInterface(*WorkOfComplex64ThenInterface)
	PutReturnOfInterface(*ReturnOfInterface)

	GetChReturnOfInterface() chan *ReturnOfInterface
	PutChReturnOfInterface(chan *ReturnOfInterface)
}

type PoolOfComplex64ThenInterfaceImpl struct {
	Complex64Arg        sync.Pool
	InterfaceRtn        sync.Pool
	Complex64Work       sync.Pool
	InterfaceReturn     sync.Pool
	ChReturnOfInterface sync.Pool
}

func (__ *PoolOfComplex64ThenInterfaceImpl) GetComplex64Arg() *complex64 {
	return __.Complex64Arg.Get().(*complex64)
}
func (__ *PoolOfComplex64ThenInterfaceImpl) PutComplex64Arg(p *complex64) {
	__.Complex64Arg.Put(p)
}
func (__ *PoolOfComplex64ThenInterfaceImpl) GetInterfaceReturn() *interface{} {
	return __.InterfaceRtn.Get().(*interface{})
}
func (__ *PoolOfComplex64ThenInterfaceImpl) PutInterfaceReturn(p *interface{}) {
	__.InterfaceRtn.Put(p)
}

func (__ *PoolOfComplex64ThenInterfaceImpl) GetWorkOfComplex64ThenInterface() *WorkOfComplex64ThenInterface {
	return __.Complex64Work.Get().(*WorkOfComplex64ThenInterface)
}
func (__ *PoolOfComplex64ThenInterfaceImpl) PutWorkOfComplex64ThenInterface(p *WorkOfComplex64ThenInterface) {
	__.Complex64Work.Put(p)
}
func (__ *PoolOfComplex64ThenInterfaceImpl) GetReturnOfInterface() *ReturnOfInterface {
	return __.InterfaceReturn.Get().(*ReturnOfInterface)
}
func (__ *PoolOfComplex64ThenInterfaceImpl) PutReturnOfInterface(p *ReturnOfInterface) {
	__.InterfaceReturn.Put(p)
}

func (__ *PoolOfComplex64ThenInterfaceImpl) GetChReturnOfInterface() chan *ReturnOfInterface {
	return __.ChReturnOfInterface.Get().(chan *ReturnOfInterface)
}
func (__ *PoolOfComplex64ThenInterfaceImpl) PutChReturnOfInterface(p chan *ReturnOfInterface) {
	__.ChReturnOfInterface.Put(p)
}

func NewPoolOfComplex64ThenInterfaceImpl() *PoolOfComplex64ThenInterfaceImpl {
	return &PoolOfComplex64ThenInterfaceImpl{
		Complex64Arg: sync.Pool{
			New: func() interface{} {
				return new(complex64)
			},
		},
		Complex64Work: sync.Pool{
			New: func() interface{} {
				return new(WorkOfComplex64ThenInterface)
			},
		},
		InterfaceRtn: sync.Pool{
			New: func() interface{} {
				return new(interface{})
			},
		},
		InterfaceReturn: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfInterface)
			},
		},
		ChReturnOfInterface: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfInterface, 1)
			},
		},
	}
}

type ApiDecouplerOfComplex64ThenInterface struct {
	pool PoolOfComplex64ThenInterface
}

func NewApiDecouplerOfComplex64ThenInterface() *ApiDecouplerOfComplex64ThenInterface {
	return &ApiDecouplerOfComplex64ThenInterface{
		pool: NewPoolOfComplex64ThenInterfaceImpl(),
	}
}

func (__ *ApiDecouplerOfComplex64ThenInterface) ReturnError(rtn_ch chan<- *ReturnOfInterface, err error) {
	rtn := __.pool.GetReturnOfInterface()
	var other interface{}
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfComplex64ThenInterface) HandleOfComplex64ThenInterface(ctx context.Context, req *WorkOfComplex64ThenInterface, h func(ctx context.Context, arg complex64) (interface{}, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfInterface()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfComplex64ThenInterface) DoOfComplex64ThenInterface(ctx context.Context, worker WorkerOfPushComplex64ThenInterface, arg complex64) (interface{}, error) {
	// ch := make(chan *ReturnOfInterface, 1)
	ch := __.pool.GetChReturnOfInterface()
	defer __.pool.PutChReturnOfInterface(ch)

	req := __.pool.GetWorkOfComplex64ThenInterface()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfComplex64ThenInterface(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfInterface(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfComplex64ThenInterface = func(ctx context.Context, arg complex64) (interface{}, error)

type WorkerOfComplex64ThenInterface struct {
	api_syncer *ApiDecouplerOfComplex64ThenInterface
	handler    WorkHandlerOfComplex64ThenInterface

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfComplex64ThenInterface
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfComplex64ThenInterface(ctx context.Context, h WorkHandlerOfComplex64ThenInterface, n int) *WorkerOfComplex64ThenInterface {
	__ := &WorkerOfComplex64ThenInterface{
		api_syncer: NewApiDecouplerOfComplex64ThenInterface(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfComplex64ThenInterface, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfComplex64ThenInterface{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfComplex64ThenInterface(req.Context, req.WorkOfComplex64ThenInterface, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfComplex64ThenInterface) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfComplex64ThenInterface) Push(ctx context.Context, req *WorkOfComplex64ThenInterface) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfComplex64ThenInterface)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfComplex64ThenInterface = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfComplex64ThenInterface) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfComplex64ThenInterface) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfComplex64ThenInterface) Call(ctx context.Context, arg complex64) (interface{}, error) {
	return __.api_syncer.DoOfComplex64ThenInterface(ctx, __, arg)
}

type PoolOfComplex64ThenStruct interface {
	GetComplex64Arg() *complex64
	PutComplex64Arg(*complex64)
	GetStructReturn() *struct{}
	PutStructReturn(*struct{})

	GetWorkOfComplex64ThenStruct() *WorkOfComplex64ThenStruct
	GetReturnOfStruct() *ReturnOfStruct
	PutWorkOfComplex64ThenStruct(*WorkOfComplex64ThenStruct)
	PutReturnOfStruct(*ReturnOfStruct)

	GetChReturnOfStruct() chan *ReturnOfStruct
	PutChReturnOfStruct(chan *ReturnOfStruct)
}

type PoolOfComplex64ThenStructImpl struct {
	Complex64Arg     sync.Pool
	StructRtn        sync.Pool
	Complex64Work    sync.Pool
	StructReturn     sync.Pool
	ChReturnOfStruct sync.Pool
}

func (__ *PoolOfComplex64ThenStructImpl) GetComplex64Arg() *complex64 {
	return __.Complex64Arg.Get().(*complex64)
}
func (__ *PoolOfComplex64ThenStructImpl) PutComplex64Arg(p *complex64) {
	__.Complex64Arg.Put(p)
}
func (__ *PoolOfComplex64ThenStructImpl) GetStructReturn() *struct{} {
	return __.StructRtn.Get().(*struct{})
}
func (__ *PoolOfComplex64ThenStructImpl) PutStructReturn(p *struct{}) {
	__.StructRtn.Put(p)
}

func (__ *PoolOfComplex64ThenStructImpl) GetWorkOfComplex64ThenStruct() *WorkOfComplex64ThenStruct {
	return __.Complex64Work.Get().(*WorkOfComplex64ThenStruct)
}
func (__ *PoolOfComplex64ThenStructImpl) PutWorkOfComplex64ThenStruct(p *WorkOfComplex64ThenStruct) {
	__.Complex64Work.Put(p)
}
func (__ *PoolOfComplex64ThenStructImpl) GetReturnOfStruct() *ReturnOfStruct {
	return __.StructReturn.Get().(*ReturnOfStruct)
}
func (__ *PoolOfComplex64ThenStructImpl) PutReturnOfStruct(p *ReturnOfStruct) {
	__.StructReturn.Put(p)
}

func (__ *PoolOfComplex64ThenStructImpl) GetChReturnOfStruct() chan *ReturnOfStruct {
	return __.ChReturnOfStruct.Get().(chan *ReturnOfStruct)
}
func (__ *PoolOfComplex64ThenStructImpl) PutChReturnOfStruct(p chan *ReturnOfStruct) {
	__.ChReturnOfStruct.Put(p)
}

func NewPoolOfComplex64ThenStructImpl() *PoolOfComplex64ThenStructImpl {
	return &PoolOfComplex64ThenStructImpl{
		Complex64Arg: sync.Pool{
			New: func() interface{} {
				return new(complex64)
			},
		},
		Complex64Work: sync.Pool{
			New: func() interface{} {
				return new(WorkOfComplex64ThenStruct)
			},
		},
		StructRtn: sync.Pool{
			New: func() interface{} {
				return new(struct{})
			},
		},
		StructReturn: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfStruct)
			},
		},
		ChReturnOfStruct: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfStruct, 1)
			},
		},
	}
}

type ApiDecouplerOfComplex64ThenStruct struct {
	pool PoolOfComplex64ThenStruct
}

func NewApiDecouplerOfComplex64ThenStruct() *ApiDecouplerOfComplex64ThenStruct {
	return &ApiDecouplerOfComplex64ThenStruct{
		pool: NewPoolOfComplex64ThenStructImpl(),
	}
}

func (__ *ApiDecouplerOfComplex64ThenStruct) ReturnError(rtn_ch chan<- *ReturnOfStruct, err error) {
	rtn := __.pool.GetReturnOfStruct()
	var other struct{}
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfComplex64ThenStruct) HandleOfComplex64ThenStruct(ctx context.Context, req *WorkOfComplex64ThenStruct, h func(ctx context.Context, arg complex64) (struct{}, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfStruct()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfComplex64ThenStruct) DoOfComplex64ThenStruct(ctx context.Context, worker WorkerOfPushComplex64ThenStruct, arg complex64) (struct{}, error) {
	// ch := make(chan *ReturnOfStruct, 1)
	ch := __.pool.GetChReturnOfStruct()
	defer __.pool.PutChReturnOfStruct(ch)

	req := __.pool.GetWorkOfComplex64ThenStruct()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfComplex64ThenStruct(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfStruct(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfComplex64ThenStruct = func(ctx context.Context, arg complex64) (struct{}, error)

type WorkerOfComplex64ThenStruct struct {
	api_syncer *ApiDecouplerOfComplex64ThenStruct
	handler    WorkHandlerOfComplex64ThenStruct

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfComplex64ThenStruct
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfComplex64ThenStruct(ctx context.Context, h WorkHandlerOfComplex64ThenStruct, n int) *WorkerOfComplex64ThenStruct {
	__ := &WorkerOfComplex64ThenStruct{
		api_syncer: NewApiDecouplerOfComplex64ThenStruct(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfComplex64ThenStruct, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfComplex64ThenStruct{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfComplex64ThenStruct(req.Context, req.WorkOfComplex64ThenStruct, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfComplex64ThenStruct) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfComplex64ThenStruct) Push(ctx context.Context, req *WorkOfComplex64ThenStruct) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfComplex64ThenStruct)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfComplex64ThenStruct = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfComplex64ThenStruct) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfComplex64ThenStruct) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfComplex64ThenStruct) Call(ctx context.Context, arg complex64) (struct{}, error) {
	return __.api_syncer.DoOfComplex64ThenStruct(ctx, __, arg)
}

type PoolOfErrorThenBool interface {
	GetErrorArg() *error
	PutErrorArg(*error)
	GetBoolReturn() *bool
	PutBoolReturn(*bool)

	GetWorkOfErrorThenBool() *WorkOfErrorThenBool
	GetReturnOfBool() *ReturnOfBool
	PutWorkOfErrorThenBool(*WorkOfErrorThenBool)
	PutReturnOfBool(*ReturnOfBool)

	GetChReturnOfBool() chan *ReturnOfBool
	PutChReturnOfBool(chan *ReturnOfBool)
}

type PoolOfErrorThenBoolImpl struct {
	ErrorArg       sync.Pool
	BoolRtn        sync.Pool
	ErrorWork      sync.Pool
	BoolReturn     sync.Pool
	ChReturnOfBool sync.Pool
}

func (__ *PoolOfErrorThenBoolImpl) GetErrorArg() *error {
	return __.ErrorArg.Get().(*error)
}
func (__ *PoolOfErrorThenBoolImpl) PutErrorArg(p *error) {
	__.ErrorArg.Put(p)
}
func (__ *PoolOfErrorThenBoolImpl) GetBoolReturn() *bool {
	return __.BoolRtn.Get().(*bool)
}
func (__ *PoolOfErrorThenBoolImpl) PutBoolReturn(p *bool) {
	__.BoolRtn.Put(p)
}

func (__ *PoolOfErrorThenBoolImpl) GetWorkOfErrorThenBool() *WorkOfErrorThenBool {
	return __.ErrorWork.Get().(*WorkOfErrorThenBool)
}
func (__ *PoolOfErrorThenBoolImpl) PutWorkOfErrorThenBool(p *WorkOfErrorThenBool) {
	__.ErrorWork.Put(p)
}
func (__ *PoolOfErrorThenBoolImpl) GetReturnOfBool() *ReturnOfBool {
	return __.BoolReturn.Get().(*ReturnOfBool)
}
func (__ *PoolOfErrorThenBoolImpl) PutReturnOfBool(p *ReturnOfBool) {
	__.BoolReturn.Put(p)
}

func (__ *PoolOfErrorThenBoolImpl) GetChReturnOfBool() chan *ReturnOfBool {
	return __.ChReturnOfBool.Get().(chan *ReturnOfBool)
}
func (__ *PoolOfErrorThenBoolImpl) PutChReturnOfBool(p chan *ReturnOfBool) {
	__.ChReturnOfBool.Put(p)
}

func NewPoolOfErrorThenBoolImpl() *PoolOfErrorThenBoolImpl {
	return &PoolOfErrorThenBoolImpl{
		ErrorArg: sync.Pool{
			New: func() interface{} {
				return new(error)
			},
		},
		ErrorWork: sync.Pool{
			New: func() interface{} {
				return new(WorkOfErrorThenBool)
			},
		},
		BoolRtn: sync.Pool{
			New: func() interface{} {
				return new(bool)
			},
		},
		BoolReturn: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfBool)
			},
		},
		ChReturnOfBool: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfBool, 1)
			},
		},
	}
}

type ApiDecouplerOfErrorThenBool struct {
	pool PoolOfErrorThenBool
}

func NewApiDecouplerOfErrorThenBool() *ApiDecouplerOfErrorThenBool {
	return &ApiDecouplerOfErrorThenBool{
		pool: NewPoolOfErrorThenBoolImpl(),
	}
}

func (__ *ApiDecouplerOfErrorThenBool) ReturnError(rtn_ch chan<- *ReturnOfBool, err error) {
	rtn := __.pool.GetReturnOfBool()
	var other bool
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfErrorThenBool) HandleOfErrorThenBool(ctx context.Context, req *WorkOfErrorThenBool, h func(ctx context.Context, arg error) (bool, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfBool()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfErrorThenBool) DoOfErrorThenBool(ctx context.Context, worker WorkerOfPushErrorThenBool, arg error) (bool, error) {
	// ch := make(chan *ReturnOfBool, 1)
	ch := __.pool.GetChReturnOfBool()
	defer __.pool.PutChReturnOfBool(ch)

	req := __.pool.GetWorkOfErrorThenBool()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfErrorThenBool(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfBool(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfErrorThenBool = func(ctx context.Context, arg error) (bool, error)

type WorkerOfErrorThenBool struct {
	api_syncer *ApiDecouplerOfErrorThenBool
	handler    WorkHandlerOfErrorThenBool

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfErrorThenBool
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfErrorThenBool(ctx context.Context, h WorkHandlerOfErrorThenBool, n int) *WorkerOfErrorThenBool {
	__ := &WorkerOfErrorThenBool{
		api_syncer: NewApiDecouplerOfErrorThenBool(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfErrorThenBool, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfErrorThenBool{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfErrorThenBool(req.Context, req.WorkOfErrorThenBool, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfErrorThenBool) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfErrorThenBool) Push(ctx context.Context, req *WorkOfErrorThenBool) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfErrorThenBool)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfErrorThenBool = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfErrorThenBool) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfErrorThenBool) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfErrorThenBool) Call(ctx context.Context, arg error) (bool, error) {
	return __.api_syncer.DoOfErrorThenBool(ctx, __, arg)
}

type PoolOfErrorThenByte interface {
	GetErrorArg() *error
	PutErrorArg(*error)
	GetByteReturn() *byte
	PutByteReturn(*byte)

	GetWorkOfErrorThenByte() *WorkOfErrorThenByte
	GetReturnOfByte() *ReturnOfByte
	PutWorkOfErrorThenByte(*WorkOfErrorThenByte)
	PutReturnOfByte(*ReturnOfByte)

	GetChReturnOfByte() chan *ReturnOfByte
	PutChReturnOfByte(chan *ReturnOfByte)
}

type PoolOfErrorThenByteImpl struct {
	ErrorArg       sync.Pool
	ByteRtn        sync.Pool
	ErrorWork      sync.Pool
	ByteReturn     sync.Pool
	ChReturnOfByte sync.Pool
}

func (__ *PoolOfErrorThenByteImpl) GetErrorArg() *error {
	return __.ErrorArg.Get().(*error)
}
func (__ *PoolOfErrorThenByteImpl) PutErrorArg(p *error) {
	__.ErrorArg.Put(p)
}
func (__ *PoolOfErrorThenByteImpl) GetByteReturn() *byte {
	return __.ByteRtn.Get().(*byte)
}
func (__ *PoolOfErrorThenByteImpl) PutByteReturn(p *byte) {
	__.ByteRtn.Put(p)
}

func (__ *PoolOfErrorThenByteImpl) GetWorkOfErrorThenByte() *WorkOfErrorThenByte {
	return __.ErrorWork.Get().(*WorkOfErrorThenByte)
}
func (__ *PoolOfErrorThenByteImpl) PutWorkOfErrorThenByte(p *WorkOfErrorThenByte) {
	__.ErrorWork.Put(p)
}
func (__ *PoolOfErrorThenByteImpl) GetReturnOfByte() *ReturnOfByte {
	return __.ByteReturn.Get().(*ReturnOfByte)
}
func (__ *PoolOfErrorThenByteImpl) PutReturnOfByte(p *ReturnOfByte) {
	__.ByteReturn.Put(p)
}

func (__ *PoolOfErrorThenByteImpl) GetChReturnOfByte() chan *ReturnOfByte {
	return __.ChReturnOfByte.Get().(chan *ReturnOfByte)
}
func (__ *PoolOfErrorThenByteImpl) PutChReturnOfByte(p chan *ReturnOfByte) {
	__.ChReturnOfByte.Put(p)
}

func NewPoolOfErrorThenByteImpl() *PoolOfErrorThenByteImpl {
	return &PoolOfErrorThenByteImpl{
		ErrorArg: sync.Pool{
			New: func() interface{} {
				return new(error)
			},
		},
		ErrorWork: sync.Pool{
			New: func() interface{} {
				return new(WorkOfErrorThenByte)
			},
		},
		ByteRtn: sync.Pool{
			New: func() interface{} {
				return new(byte)
			},
		},
		ByteReturn: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfByte)
			},
		},
		ChReturnOfByte: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfByte, 1)
			},
		},
	}
}

type ApiDecouplerOfErrorThenByte struct {
	pool PoolOfErrorThenByte
}

func NewApiDecouplerOfErrorThenByte() *ApiDecouplerOfErrorThenByte {
	return &ApiDecouplerOfErrorThenByte{
		pool: NewPoolOfErrorThenByteImpl(),
	}
}

func (__ *ApiDecouplerOfErrorThenByte) ReturnError(rtn_ch chan<- *ReturnOfByte, err error) {
	rtn := __.pool.GetReturnOfByte()
	var other byte
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfErrorThenByte) HandleOfErrorThenByte(ctx context.Context, req *WorkOfErrorThenByte, h func(ctx context.Context, arg error) (byte, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfByte()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfErrorThenByte) DoOfErrorThenByte(ctx context.Context, worker WorkerOfPushErrorThenByte, arg error) (byte, error) {
	// ch := make(chan *ReturnOfByte, 1)
	ch := __.pool.GetChReturnOfByte()
	defer __.pool.PutChReturnOfByte(ch)

	req := __.pool.GetWorkOfErrorThenByte()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfErrorThenByte(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfByte(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfErrorThenByte = func(ctx context.Context, arg error) (byte, error)

type WorkerOfErrorThenByte struct {
	api_syncer *ApiDecouplerOfErrorThenByte
	handler    WorkHandlerOfErrorThenByte

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfErrorThenByte
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfErrorThenByte(ctx context.Context, h WorkHandlerOfErrorThenByte, n int) *WorkerOfErrorThenByte {
	__ := &WorkerOfErrorThenByte{
		api_syncer: NewApiDecouplerOfErrorThenByte(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfErrorThenByte, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfErrorThenByte{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfErrorThenByte(req.Context, req.WorkOfErrorThenByte, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfErrorThenByte) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfErrorThenByte) Push(ctx context.Context, req *WorkOfErrorThenByte) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfErrorThenByte)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfErrorThenByte = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfErrorThenByte) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfErrorThenByte) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfErrorThenByte) Call(ctx context.Context, arg error) (byte, error) {
	return __.api_syncer.DoOfErrorThenByte(ctx, __, arg)
}

type PoolOfErrorThenComplex128 interface {
	GetErrorArg() *error
	PutErrorArg(*error)
	GetComplex128Return() *complex128
	PutComplex128Return(*complex128)

	GetWorkOfErrorThenComplex128() *WorkOfErrorThenComplex128
	GetReturnOfComplex128() *ReturnOfComplex128
	PutWorkOfErrorThenComplex128(*WorkOfErrorThenComplex128)
	PutReturnOfComplex128(*ReturnOfComplex128)

	GetChReturnOfComplex128() chan *ReturnOfComplex128
	PutChReturnOfComplex128(chan *ReturnOfComplex128)
}

type PoolOfErrorThenComplex128Impl struct {
	ErrorArg             sync.Pool
	Complex128Rtn        sync.Pool
	ErrorWork            sync.Pool
	Complex128Return     sync.Pool
	ChReturnOfComplex128 sync.Pool
}

func (__ *PoolOfErrorThenComplex128Impl) GetErrorArg() *error {
	return __.ErrorArg.Get().(*error)
}
func (__ *PoolOfErrorThenComplex128Impl) PutErrorArg(p *error) {
	__.ErrorArg.Put(p)
}
func (__ *PoolOfErrorThenComplex128Impl) GetComplex128Return() *complex128 {
	return __.Complex128Rtn.Get().(*complex128)
}
func (__ *PoolOfErrorThenComplex128Impl) PutComplex128Return(p *complex128) {
	__.Complex128Rtn.Put(p)
}

func (__ *PoolOfErrorThenComplex128Impl) GetWorkOfErrorThenComplex128() *WorkOfErrorThenComplex128 {
	return __.ErrorWork.Get().(*WorkOfErrorThenComplex128)
}
func (__ *PoolOfErrorThenComplex128Impl) PutWorkOfErrorThenComplex128(p *WorkOfErrorThenComplex128) {
	__.ErrorWork.Put(p)
}
func (__ *PoolOfErrorThenComplex128Impl) GetReturnOfComplex128() *ReturnOfComplex128 {
	return __.Complex128Return.Get().(*ReturnOfComplex128)
}
func (__ *PoolOfErrorThenComplex128Impl) PutReturnOfComplex128(p *ReturnOfComplex128) {
	__.Complex128Return.Put(p)
}

func (__ *PoolOfErrorThenComplex128Impl) GetChReturnOfComplex128() chan *ReturnOfComplex128 {
	return __.ChReturnOfComplex128.Get().(chan *ReturnOfComplex128)
}
func (__ *PoolOfErrorThenComplex128Impl) PutChReturnOfComplex128(p chan *ReturnOfComplex128) {
	__.ChReturnOfComplex128.Put(p)
}

func NewPoolOfErrorThenComplex128Impl() *PoolOfErrorThenComplex128Impl {
	return &PoolOfErrorThenComplex128Impl{
		ErrorArg: sync.Pool{
			New: func() interface{} {
				return new(error)
			},
		},
		ErrorWork: sync.Pool{
			New: func() interface{} {
				return new(WorkOfErrorThenComplex128)
			},
		},
		Complex128Rtn: sync.Pool{
			New: func() interface{} {
				return new(complex128)
			},
		},
		Complex128Return: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfComplex128)
			},
		},
		ChReturnOfComplex128: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfComplex128, 1)
			},
		},
	}
}

type ApiDecouplerOfErrorThenComplex128 struct {
	pool PoolOfErrorThenComplex128
}

func NewApiDecouplerOfErrorThenComplex128() *ApiDecouplerOfErrorThenComplex128 {
	return &ApiDecouplerOfErrorThenComplex128{
		pool: NewPoolOfErrorThenComplex128Impl(),
	}
}

func (__ *ApiDecouplerOfErrorThenComplex128) ReturnError(rtn_ch chan<- *ReturnOfComplex128, err error) {
	rtn := __.pool.GetReturnOfComplex128()
	var other complex128
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfErrorThenComplex128) HandleOfErrorThenComplex128(ctx context.Context, req *WorkOfErrorThenComplex128, h func(ctx context.Context, arg error) (complex128, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfComplex128()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfErrorThenComplex128) DoOfErrorThenComplex128(ctx context.Context, worker WorkerOfPushErrorThenComplex128, arg error) (complex128, error) {
	// ch := make(chan *ReturnOfComplex128, 1)
	ch := __.pool.GetChReturnOfComplex128()
	defer __.pool.PutChReturnOfComplex128(ch)

	req := __.pool.GetWorkOfErrorThenComplex128()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfErrorThenComplex128(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfComplex128(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfErrorThenComplex128 = func(ctx context.Context, arg error) (complex128, error)

type WorkerOfErrorThenComplex128 struct {
	api_syncer *ApiDecouplerOfErrorThenComplex128
	handler    WorkHandlerOfErrorThenComplex128

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfErrorThenComplex128
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfErrorThenComplex128(ctx context.Context, h WorkHandlerOfErrorThenComplex128, n int) *WorkerOfErrorThenComplex128 {
	__ := &WorkerOfErrorThenComplex128{
		api_syncer: NewApiDecouplerOfErrorThenComplex128(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfErrorThenComplex128, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfErrorThenComplex128{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfErrorThenComplex128(req.Context, req.WorkOfErrorThenComplex128, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfErrorThenComplex128) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfErrorThenComplex128) Push(ctx context.Context, req *WorkOfErrorThenComplex128) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfErrorThenComplex128)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfErrorThenComplex128 = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfErrorThenComplex128) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfErrorThenComplex128) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfErrorThenComplex128) Call(ctx context.Context, arg error) (complex128, error) {
	return __.api_syncer.DoOfErrorThenComplex128(ctx, __, arg)
}

type PoolOfErrorThenComplex64 interface {
	GetErrorArg() *error
	PutErrorArg(*error)
	GetComplex64Return() *complex64
	PutComplex64Return(*complex64)

	GetWorkOfErrorThenComplex64() *WorkOfErrorThenComplex64
	GetReturnOfComplex64() *ReturnOfComplex64
	PutWorkOfErrorThenComplex64(*WorkOfErrorThenComplex64)
	PutReturnOfComplex64(*ReturnOfComplex64)

	GetChReturnOfComplex64() chan *ReturnOfComplex64
	PutChReturnOfComplex64(chan *ReturnOfComplex64)
}

type PoolOfErrorThenComplex64Impl struct {
	ErrorArg            sync.Pool
	Complex64Rtn        sync.Pool
	ErrorWork           sync.Pool
	Complex64Return     sync.Pool
	ChReturnOfComplex64 sync.Pool
}

func (__ *PoolOfErrorThenComplex64Impl) GetErrorArg() *error {
	return __.ErrorArg.Get().(*error)
}
func (__ *PoolOfErrorThenComplex64Impl) PutErrorArg(p *error) {
	__.ErrorArg.Put(p)
}
func (__ *PoolOfErrorThenComplex64Impl) GetComplex64Return() *complex64 {
	return __.Complex64Rtn.Get().(*complex64)
}
func (__ *PoolOfErrorThenComplex64Impl) PutComplex64Return(p *complex64) {
	__.Complex64Rtn.Put(p)
}

func (__ *PoolOfErrorThenComplex64Impl) GetWorkOfErrorThenComplex64() *WorkOfErrorThenComplex64 {
	return __.ErrorWork.Get().(*WorkOfErrorThenComplex64)
}
func (__ *PoolOfErrorThenComplex64Impl) PutWorkOfErrorThenComplex64(p *WorkOfErrorThenComplex64) {
	__.ErrorWork.Put(p)
}
func (__ *PoolOfErrorThenComplex64Impl) GetReturnOfComplex64() *ReturnOfComplex64 {
	return __.Complex64Return.Get().(*ReturnOfComplex64)
}
func (__ *PoolOfErrorThenComplex64Impl) PutReturnOfComplex64(p *ReturnOfComplex64) {
	__.Complex64Return.Put(p)
}

func (__ *PoolOfErrorThenComplex64Impl) GetChReturnOfComplex64() chan *ReturnOfComplex64 {
	return __.ChReturnOfComplex64.Get().(chan *ReturnOfComplex64)
}
func (__ *PoolOfErrorThenComplex64Impl) PutChReturnOfComplex64(p chan *ReturnOfComplex64) {
	__.ChReturnOfComplex64.Put(p)
}

func NewPoolOfErrorThenComplex64Impl() *PoolOfErrorThenComplex64Impl {
	return &PoolOfErrorThenComplex64Impl{
		ErrorArg: sync.Pool{
			New: func() interface{} {
				return new(error)
			},
		},
		ErrorWork: sync.Pool{
			New: func() interface{} {
				return new(WorkOfErrorThenComplex64)
			},
		},
		Complex64Rtn: sync.Pool{
			New: func() interface{} {
				return new(complex64)
			},
		},
		Complex64Return: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfComplex64)
			},
		},
		ChReturnOfComplex64: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfComplex64, 1)
			},
		},
	}
}

type ApiDecouplerOfErrorThenComplex64 struct {
	pool PoolOfErrorThenComplex64
}

func NewApiDecouplerOfErrorThenComplex64() *ApiDecouplerOfErrorThenComplex64 {
	return &ApiDecouplerOfErrorThenComplex64{
		pool: NewPoolOfErrorThenComplex64Impl(),
	}
}

func (__ *ApiDecouplerOfErrorThenComplex64) ReturnError(rtn_ch chan<- *ReturnOfComplex64, err error) {
	rtn := __.pool.GetReturnOfComplex64()
	var other complex64
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfErrorThenComplex64) HandleOfErrorThenComplex64(ctx context.Context, req *WorkOfErrorThenComplex64, h func(ctx context.Context, arg error) (complex64, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfComplex64()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfErrorThenComplex64) DoOfErrorThenComplex64(ctx context.Context, worker WorkerOfPushErrorThenComplex64, arg error) (complex64, error) {
	// ch := make(chan *ReturnOfComplex64, 1)
	ch := __.pool.GetChReturnOfComplex64()
	defer __.pool.PutChReturnOfComplex64(ch)

	req := __.pool.GetWorkOfErrorThenComplex64()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfErrorThenComplex64(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfComplex64(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfErrorThenComplex64 = func(ctx context.Context, arg error) (complex64, error)

type WorkerOfErrorThenComplex64 struct {
	api_syncer *ApiDecouplerOfErrorThenComplex64
	handler    WorkHandlerOfErrorThenComplex64

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfErrorThenComplex64
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfErrorThenComplex64(ctx context.Context, h WorkHandlerOfErrorThenComplex64, n int) *WorkerOfErrorThenComplex64 {
	__ := &WorkerOfErrorThenComplex64{
		api_syncer: NewApiDecouplerOfErrorThenComplex64(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfErrorThenComplex64, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfErrorThenComplex64{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfErrorThenComplex64(req.Context, req.WorkOfErrorThenComplex64, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfErrorThenComplex64) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfErrorThenComplex64) Push(ctx context.Context, req *WorkOfErrorThenComplex64) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfErrorThenComplex64)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfErrorThenComplex64 = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfErrorThenComplex64) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfErrorThenComplex64) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfErrorThenComplex64) Call(ctx context.Context, arg error) (complex64, error) {
	return __.api_syncer.DoOfErrorThenComplex64(ctx, __, arg)
}

type PoolOfErrorThenError interface {
	GetErrorArg() *error
	PutErrorArg(*error)
	GetErrorReturn() *error
	PutErrorReturn(*error)

	GetWorkOfErrorThenError() *WorkOfErrorThenError
	GetReturnOfError() *ReturnOfError
	PutWorkOfErrorThenError(*WorkOfErrorThenError)
	PutReturnOfError(*ReturnOfError)

	GetChReturnOfError() chan *ReturnOfError
	PutChReturnOfError(chan *ReturnOfError)
}

type PoolOfErrorThenErrorImpl struct {
	ErrorArg        sync.Pool
	ErrorRtn        sync.Pool
	ErrorWork       sync.Pool
	ErrorReturn     sync.Pool
	ChReturnOfError sync.Pool
}

func (__ *PoolOfErrorThenErrorImpl) GetErrorArg() *error {
	return __.ErrorArg.Get().(*error)
}
func (__ *PoolOfErrorThenErrorImpl) PutErrorArg(p *error) {
	__.ErrorArg.Put(p)
}
func (__ *PoolOfErrorThenErrorImpl) GetErrorReturn() *error {
	return __.ErrorRtn.Get().(*error)
}
func (__ *PoolOfErrorThenErrorImpl) PutErrorReturn(p *error) {
	__.ErrorRtn.Put(p)
}

func (__ *PoolOfErrorThenErrorImpl) GetWorkOfErrorThenError() *WorkOfErrorThenError {
	return __.ErrorWork.Get().(*WorkOfErrorThenError)
}
func (__ *PoolOfErrorThenErrorImpl) PutWorkOfErrorThenError(p *WorkOfErrorThenError) {
	__.ErrorWork.Put(p)
}
func (__ *PoolOfErrorThenErrorImpl) GetReturnOfError() *ReturnOfError {
	return __.ErrorReturn.Get().(*ReturnOfError)
}
func (__ *PoolOfErrorThenErrorImpl) PutReturnOfError(p *ReturnOfError) {
	__.ErrorReturn.Put(p)
}

func (__ *PoolOfErrorThenErrorImpl) GetChReturnOfError() chan *ReturnOfError {
	return __.ChReturnOfError.Get().(chan *ReturnOfError)
}
func (__ *PoolOfErrorThenErrorImpl) PutChReturnOfError(p chan *ReturnOfError) {
	__.ChReturnOfError.Put(p)
}

func NewPoolOfErrorThenErrorImpl() *PoolOfErrorThenErrorImpl {
	return &PoolOfErrorThenErrorImpl{
		ErrorArg: sync.Pool{
			New: func() interface{} {
				return new(error)
			},
		},
		ErrorWork: sync.Pool{
			New: func() interface{} {
				return new(WorkOfErrorThenError)
			},
		},
		ErrorRtn: sync.Pool{
			New: func() interface{} {
				return new(error)
			},
		},
		ErrorReturn: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfError)
			},
		},
		ChReturnOfError: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfError, 1)
			},
		},
	}
}

type ApiDecouplerOfErrorThenError struct {
	pool PoolOfErrorThenError
}

func NewApiDecouplerOfErrorThenError() *ApiDecouplerOfErrorThenError {
	return &ApiDecouplerOfErrorThenError{
		pool: NewPoolOfErrorThenErrorImpl(),
	}
}

func (__ *ApiDecouplerOfErrorThenError) ReturnError(rtn_ch chan<- *ReturnOfError, err error) {
	rtn := __.pool.GetReturnOfError()
	var other error
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfErrorThenError) HandleOfErrorThenError(ctx context.Context, req *WorkOfErrorThenError, h func(ctx context.Context, arg error) (error, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfError()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfErrorThenError) DoOfErrorThenError(ctx context.Context, worker WorkerOfPushErrorThenError, arg error) (error, error) {
	// ch := make(chan *ReturnOfError, 1)
	ch := __.pool.GetChReturnOfError()
	defer __.pool.PutChReturnOfError(ch)

	req := __.pool.GetWorkOfErrorThenError()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfErrorThenError(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfError(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfErrorThenError = func(ctx context.Context, arg error) (error, error)

type WorkerOfErrorThenError struct {
	api_syncer *ApiDecouplerOfErrorThenError
	handler    WorkHandlerOfErrorThenError

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfErrorThenError
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfErrorThenError(ctx context.Context, h WorkHandlerOfErrorThenError, n int) *WorkerOfErrorThenError {
	__ := &WorkerOfErrorThenError{
		api_syncer: NewApiDecouplerOfErrorThenError(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfErrorThenError, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfErrorThenError{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfErrorThenError(req.Context, req.WorkOfErrorThenError, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfErrorThenError) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfErrorThenError) Push(ctx context.Context, req *WorkOfErrorThenError) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfErrorThenError)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfErrorThenError = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfErrorThenError) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfErrorThenError) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfErrorThenError) Call(ctx context.Context, arg error) (error, error) {
	return __.api_syncer.DoOfErrorThenError(ctx, __, arg)
}

type PoolOfErrorThenFloat32 interface {
	GetErrorArg() *error
	PutErrorArg(*error)
	GetFloat32Return() *float32
	PutFloat32Return(*float32)

	GetWorkOfErrorThenFloat32() *WorkOfErrorThenFloat32
	GetReturnOfFloat32() *ReturnOfFloat32
	PutWorkOfErrorThenFloat32(*WorkOfErrorThenFloat32)
	PutReturnOfFloat32(*ReturnOfFloat32)

	GetChReturnOfFloat32() chan *ReturnOfFloat32
	PutChReturnOfFloat32(chan *ReturnOfFloat32)
}

type PoolOfErrorThenFloat32Impl struct {
	ErrorArg          sync.Pool
	Float32Rtn        sync.Pool
	ErrorWork         sync.Pool
	Float32Return     sync.Pool
	ChReturnOfFloat32 sync.Pool
}

func (__ *PoolOfErrorThenFloat32Impl) GetErrorArg() *error {
	return __.ErrorArg.Get().(*error)
}
func (__ *PoolOfErrorThenFloat32Impl) PutErrorArg(p *error) {
	__.ErrorArg.Put(p)
}
func (__ *PoolOfErrorThenFloat32Impl) GetFloat32Return() *float32 {
	return __.Float32Rtn.Get().(*float32)
}
func (__ *PoolOfErrorThenFloat32Impl) PutFloat32Return(p *float32) {
	__.Float32Rtn.Put(p)
}

func (__ *PoolOfErrorThenFloat32Impl) GetWorkOfErrorThenFloat32() *WorkOfErrorThenFloat32 {
	return __.ErrorWork.Get().(*WorkOfErrorThenFloat32)
}
func (__ *PoolOfErrorThenFloat32Impl) PutWorkOfErrorThenFloat32(p *WorkOfErrorThenFloat32) {
	__.ErrorWork.Put(p)
}
func (__ *PoolOfErrorThenFloat32Impl) GetReturnOfFloat32() *ReturnOfFloat32 {
	return __.Float32Return.Get().(*ReturnOfFloat32)
}
func (__ *PoolOfErrorThenFloat32Impl) PutReturnOfFloat32(p *ReturnOfFloat32) {
	__.Float32Return.Put(p)
}

func (__ *PoolOfErrorThenFloat32Impl) GetChReturnOfFloat32() chan *ReturnOfFloat32 {
	return __.ChReturnOfFloat32.Get().(chan *ReturnOfFloat32)
}
func (__ *PoolOfErrorThenFloat32Impl) PutChReturnOfFloat32(p chan *ReturnOfFloat32) {
	__.ChReturnOfFloat32.Put(p)
}

func NewPoolOfErrorThenFloat32Impl() *PoolOfErrorThenFloat32Impl {
	return &PoolOfErrorThenFloat32Impl{
		ErrorArg: sync.Pool{
			New: func() interface{} {
				return new(error)
			},
		},
		ErrorWork: sync.Pool{
			New: func() interface{} {
				return new(WorkOfErrorThenFloat32)
			},
		},
		Float32Rtn: sync.Pool{
			New: func() interface{} {
				return new(float32)
			},
		},
		Float32Return: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfFloat32)
			},
		},
		ChReturnOfFloat32: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfFloat32, 1)
			},
		},
	}
}

type ApiDecouplerOfErrorThenFloat32 struct {
	pool PoolOfErrorThenFloat32
}

func NewApiDecouplerOfErrorThenFloat32() *ApiDecouplerOfErrorThenFloat32 {
	return &ApiDecouplerOfErrorThenFloat32{
		pool: NewPoolOfErrorThenFloat32Impl(),
	}
}

func (__ *ApiDecouplerOfErrorThenFloat32) ReturnError(rtn_ch chan<- *ReturnOfFloat32, err error) {
	rtn := __.pool.GetReturnOfFloat32()
	var other float32
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfErrorThenFloat32) HandleOfErrorThenFloat32(ctx context.Context, req *WorkOfErrorThenFloat32, h func(ctx context.Context, arg error) (float32, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfFloat32()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfErrorThenFloat32) DoOfErrorThenFloat32(ctx context.Context, worker WorkerOfPushErrorThenFloat32, arg error) (float32, error) {
	// ch := make(chan *ReturnOfFloat32, 1)
	ch := __.pool.GetChReturnOfFloat32()
	defer __.pool.PutChReturnOfFloat32(ch)

	req := __.pool.GetWorkOfErrorThenFloat32()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfErrorThenFloat32(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfFloat32(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfErrorThenFloat32 = func(ctx context.Context, arg error) (float32, error)

type WorkerOfErrorThenFloat32 struct {
	api_syncer *ApiDecouplerOfErrorThenFloat32
	handler    WorkHandlerOfErrorThenFloat32

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfErrorThenFloat32
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfErrorThenFloat32(ctx context.Context, h WorkHandlerOfErrorThenFloat32, n int) *WorkerOfErrorThenFloat32 {
	__ := &WorkerOfErrorThenFloat32{
		api_syncer: NewApiDecouplerOfErrorThenFloat32(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfErrorThenFloat32, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfErrorThenFloat32{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfErrorThenFloat32(req.Context, req.WorkOfErrorThenFloat32, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfErrorThenFloat32) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfErrorThenFloat32) Push(ctx context.Context, req *WorkOfErrorThenFloat32) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfErrorThenFloat32)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfErrorThenFloat32 = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfErrorThenFloat32) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfErrorThenFloat32) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfErrorThenFloat32) Call(ctx context.Context, arg error) (float32, error) {
	return __.api_syncer.DoOfErrorThenFloat32(ctx, __, arg)
}

type PoolOfErrorThenFloat64 interface {
	GetErrorArg() *error
	PutErrorArg(*error)
	GetFloat64Return() *float64
	PutFloat64Return(*float64)

	GetWorkOfErrorThenFloat64() *WorkOfErrorThenFloat64
	GetReturnOfFloat64() *ReturnOfFloat64
	PutWorkOfErrorThenFloat64(*WorkOfErrorThenFloat64)
	PutReturnOfFloat64(*ReturnOfFloat64)

	GetChReturnOfFloat64() chan *ReturnOfFloat64
	PutChReturnOfFloat64(chan *ReturnOfFloat64)
}

type PoolOfErrorThenFloat64Impl struct {
	ErrorArg          sync.Pool
	Float64Rtn        sync.Pool
	ErrorWork         sync.Pool
	Float64Return     sync.Pool
	ChReturnOfFloat64 sync.Pool
}

func (__ *PoolOfErrorThenFloat64Impl) GetErrorArg() *error {
	return __.ErrorArg.Get().(*error)
}
func (__ *PoolOfErrorThenFloat64Impl) PutErrorArg(p *error) {
	__.ErrorArg.Put(p)
}
func (__ *PoolOfErrorThenFloat64Impl) GetFloat64Return() *float64 {
	return __.Float64Rtn.Get().(*float64)
}
func (__ *PoolOfErrorThenFloat64Impl) PutFloat64Return(p *float64) {
	__.Float64Rtn.Put(p)
}

func (__ *PoolOfErrorThenFloat64Impl) GetWorkOfErrorThenFloat64() *WorkOfErrorThenFloat64 {
	return __.ErrorWork.Get().(*WorkOfErrorThenFloat64)
}
func (__ *PoolOfErrorThenFloat64Impl) PutWorkOfErrorThenFloat64(p *WorkOfErrorThenFloat64) {
	__.ErrorWork.Put(p)
}
func (__ *PoolOfErrorThenFloat64Impl) GetReturnOfFloat64() *ReturnOfFloat64 {
	return __.Float64Return.Get().(*ReturnOfFloat64)
}
func (__ *PoolOfErrorThenFloat64Impl) PutReturnOfFloat64(p *ReturnOfFloat64) {
	__.Float64Return.Put(p)
}

func (__ *PoolOfErrorThenFloat64Impl) GetChReturnOfFloat64() chan *ReturnOfFloat64 {
	return __.ChReturnOfFloat64.Get().(chan *ReturnOfFloat64)
}
func (__ *PoolOfErrorThenFloat64Impl) PutChReturnOfFloat64(p chan *ReturnOfFloat64) {
	__.ChReturnOfFloat64.Put(p)
}

func NewPoolOfErrorThenFloat64Impl() *PoolOfErrorThenFloat64Impl {
	return &PoolOfErrorThenFloat64Impl{
		ErrorArg: sync.Pool{
			New: func() interface{} {
				return new(error)
			},
		},
		ErrorWork: sync.Pool{
			New: func() interface{} {
				return new(WorkOfErrorThenFloat64)
			},
		},
		Float64Rtn: sync.Pool{
			New: func() interface{} {
				return new(float64)
			},
		},
		Float64Return: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfFloat64)
			},
		},
		ChReturnOfFloat64: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfFloat64, 1)
			},
		},
	}
}

type ApiDecouplerOfErrorThenFloat64 struct {
	pool PoolOfErrorThenFloat64
}

func NewApiDecouplerOfErrorThenFloat64() *ApiDecouplerOfErrorThenFloat64 {
	return &ApiDecouplerOfErrorThenFloat64{
		pool: NewPoolOfErrorThenFloat64Impl(),
	}
}

func (__ *ApiDecouplerOfErrorThenFloat64) ReturnError(rtn_ch chan<- *ReturnOfFloat64, err error) {
	rtn := __.pool.GetReturnOfFloat64()
	var other float64
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfErrorThenFloat64) HandleOfErrorThenFloat64(ctx context.Context, req *WorkOfErrorThenFloat64, h func(ctx context.Context, arg error) (float64, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfFloat64()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfErrorThenFloat64) DoOfErrorThenFloat64(ctx context.Context, worker WorkerOfPushErrorThenFloat64, arg error) (float64, error) {
	// ch := make(chan *ReturnOfFloat64, 1)
	ch := __.pool.GetChReturnOfFloat64()
	defer __.pool.PutChReturnOfFloat64(ch)

	req := __.pool.GetWorkOfErrorThenFloat64()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfErrorThenFloat64(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfFloat64(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfErrorThenFloat64 = func(ctx context.Context, arg error) (float64, error)

type WorkerOfErrorThenFloat64 struct {
	api_syncer *ApiDecouplerOfErrorThenFloat64
	handler    WorkHandlerOfErrorThenFloat64

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfErrorThenFloat64
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfErrorThenFloat64(ctx context.Context, h WorkHandlerOfErrorThenFloat64, n int) *WorkerOfErrorThenFloat64 {
	__ := &WorkerOfErrorThenFloat64{
		api_syncer: NewApiDecouplerOfErrorThenFloat64(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfErrorThenFloat64, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfErrorThenFloat64{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfErrorThenFloat64(req.Context, req.WorkOfErrorThenFloat64, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfErrorThenFloat64) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfErrorThenFloat64) Push(ctx context.Context, req *WorkOfErrorThenFloat64) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfErrorThenFloat64)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfErrorThenFloat64 = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfErrorThenFloat64) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfErrorThenFloat64) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfErrorThenFloat64) Call(ctx context.Context, arg error) (float64, error) {
	return __.api_syncer.DoOfErrorThenFloat64(ctx, __, arg)
}

type PoolOfErrorThenInt interface {
	GetErrorArg() *error
	PutErrorArg(*error)
	GetIntReturn() *int
	PutIntReturn(*int)

	GetWorkOfErrorThenInt() *WorkOfErrorThenInt
	GetReturnOfInt() *ReturnOfInt
	PutWorkOfErrorThenInt(*WorkOfErrorThenInt)
	PutReturnOfInt(*ReturnOfInt)

	GetChReturnOfInt() chan *ReturnOfInt
	PutChReturnOfInt(chan *ReturnOfInt)
}

type PoolOfErrorThenIntImpl struct {
	ErrorArg      sync.Pool
	IntRtn        sync.Pool
	ErrorWork     sync.Pool
	IntReturn     sync.Pool
	ChReturnOfInt sync.Pool
}

func (__ *PoolOfErrorThenIntImpl) GetErrorArg() *error {
	return __.ErrorArg.Get().(*error)
}
func (__ *PoolOfErrorThenIntImpl) PutErrorArg(p *error) {
	__.ErrorArg.Put(p)
}
func (__ *PoolOfErrorThenIntImpl) GetIntReturn() *int {
	return __.IntRtn.Get().(*int)
}
func (__ *PoolOfErrorThenIntImpl) PutIntReturn(p *int) {
	__.IntRtn.Put(p)
}

func (__ *PoolOfErrorThenIntImpl) GetWorkOfErrorThenInt() *WorkOfErrorThenInt {
	return __.ErrorWork.Get().(*WorkOfErrorThenInt)
}
func (__ *PoolOfErrorThenIntImpl) PutWorkOfErrorThenInt(p *WorkOfErrorThenInt) {
	__.ErrorWork.Put(p)
}
func (__ *PoolOfErrorThenIntImpl) GetReturnOfInt() *ReturnOfInt {
	return __.IntReturn.Get().(*ReturnOfInt)
}
func (__ *PoolOfErrorThenIntImpl) PutReturnOfInt(p *ReturnOfInt) {
	__.IntReturn.Put(p)
}

func (__ *PoolOfErrorThenIntImpl) GetChReturnOfInt() chan *ReturnOfInt {
	return __.ChReturnOfInt.Get().(chan *ReturnOfInt)
}
func (__ *PoolOfErrorThenIntImpl) PutChReturnOfInt(p chan *ReturnOfInt) {
	__.ChReturnOfInt.Put(p)
}

func NewPoolOfErrorThenIntImpl() *PoolOfErrorThenIntImpl {
	return &PoolOfErrorThenIntImpl{
		ErrorArg: sync.Pool{
			New: func() interface{} {
				return new(error)
			},
		},
		ErrorWork: sync.Pool{
			New: func() interface{} {
				return new(WorkOfErrorThenInt)
			},
		},
		IntRtn: sync.Pool{
			New: func() interface{} {
				return new(int)
			},
		},
		IntReturn: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfInt)
			},
		},
		ChReturnOfInt: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfInt, 1)
			},
		},
	}
}

type ApiDecouplerOfErrorThenInt struct {
	pool PoolOfErrorThenInt
}

func NewApiDecouplerOfErrorThenInt() *ApiDecouplerOfErrorThenInt {
	return &ApiDecouplerOfErrorThenInt{
		pool: NewPoolOfErrorThenIntImpl(),
	}
}

func (__ *ApiDecouplerOfErrorThenInt) ReturnError(rtn_ch chan<- *ReturnOfInt, err error) {
	rtn := __.pool.GetReturnOfInt()
	var other int
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfErrorThenInt) HandleOfErrorThenInt(ctx context.Context, req *WorkOfErrorThenInt, h func(ctx context.Context, arg error) (int, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfInt()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfErrorThenInt) DoOfErrorThenInt(ctx context.Context, worker WorkerOfPushErrorThenInt, arg error) (int, error) {
	// ch := make(chan *ReturnOfInt, 1)
	ch := __.pool.GetChReturnOfInt()
	defer __.pool.PutChReturnOfInt(ch)

	req := __.pool.GetWorkOfErrorThenInt()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfErrorThenInt(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfInt(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfErrorThenInt = func(ctx context.Context, arg error) (int, error)

type WorkerOfErrorThenInt struct {
	api_syncer *ApiDecouplerOfErrorThenInt
	handler    WorkHandlerOfErrorThenInt

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfErrorThenInt
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfErrorThenInt(ctx context.Context, h WorkHandlerOfErrorThenInt, n int) *WorkerOfErrorThenInt {
	__ := &WorkerOfErrorThenInt{
		api_syncer: NewApiDecouplerOfErrorThenInt(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfErrorThenInt, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfErrorThenInt{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfErrorThenInt(req.Context, req.WorkOfErrorThenInt, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfErrorThenInt) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfErrorThenInt) Push(ctx context.Context, req *WorkOfErrorThenInt) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfErrorThenInt)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfErrorThenInt = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfErrorThenInt) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfErrorThenInt) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfErrorThenInt) Call(ctx context.Context, arg error) (int, error) {
	return __.api_syncer.DoOfErrorThenInt(ctx, __, arg)
}

type PoolOfErrorThenInt16 interface {
	GetErrorArg() *error
	PutErrorArg(*error)
	GetInt16Return() *int16
	PutInt16Return(*int16)

	GetWorkOfErrorThenInt16() *WorkOfErrorThenInt16
	GetReturnOfInt16() *ReturnOfInt16
	PutWorkOfErrorThenInt16(*WorkOfErrorThenInt16)
	PutReturnOfInt16(*ReturnOfInt16)

	GetChReturnOfInt16() chan *ReturnOfInt16
	PutChReturnOfInt16(chan *ReturnOfInt16)
}

type PoolOfErrorThenInt16Impl struct {
	ErrorArg        sync.Pool
	Int16Rtn        sync.Pool
	ErrorWork       sync.Pool
	Int16Return     sync.Pool
	ChReturnOfInt16 sync.Pool
}

func (__ *PoolOfErrorThenInt16Impl) GetErrorArg() *error {
	return __.ErrorArg.Get().(*error)
}
func (__ *PoolOfErrorThenInt16Impl) PutErrorArg(p *error) {
	__.ErrorArg.Put(p)
}
func (__ *PoolOfErrorThenInt16Impl) GetInt16Return() *int16 {
	return __.Int16Rtn.Get().(*int16)
}
func (__ *PoolOfErrorThenInt16Impl) PutInt16Return(p *int16) {
	__.Int16Rtn.Put(p)
}

func (__ *PoolOfErrorThenInt16Impl) GetWorkOfErrorThenInt16() *WorkOfErrorThenInt16 {
	return __.ErrorWork.Get().(*WorkOfErrorThenInt16)
}
func (__ *PoolOfErrorThenInt16Impl) PutWorkOfErrorThenInt16(p *WorkOfErrorThenInt16) {
	__.ErrorWork.Put(p)
}
func (__ *PoolOfErrorThenInt16Impl) GetReturnOfInt16() *ReturnOfInt16 {
	return __.Int16Return.Get().(*ReturnOfInt16)
}
func (__ *PoolOfErrorThenInt16Impl) PutReturnOfInt16(p *ReturnOfInt16) {
	__.Int16Return.Put(p)
}

func (__ *PoolOfErrorThenInt16Impl) GetChReturnOfInt16() chan *ReturnOfInt16 {
	return __.ChReturnOfInt16.Get().(chan *ReturnOfInt16)
}
func (__ *PoolOfErrorThenInt16Impl) PutChReturnOfInt16(p chan *ReturnOfInt16) {
	__.ChReturnOfInt16.Put(p)
}

func NewPoolOfErrorThenInt16Impl() *PoolOfErrorThenInt16Impl {
	return &PoolOfErrorThenInt16Impl{
		ErrorArg: sync.Pool{
			New: func() interface{} {
				return new(error)
			},
		},
		ErrorWork: sync.Pool{
			New: func() interface{} {
				return new(WorkOfErrorThenInt16)
			},
		},
		Int16Rtn: sync.Pool{
			New: func() interface{} {
				return new(int16)
			},
		},
		Int16Return: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfInt16)
			},
		},
		ChReturnOfInt16: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfInt16, 1)
			},
		},
	}
}

type ApiDecouplerOfErrorThenInt16 struct {
	pool PoolOfErrorThenInt16
}

func NewApiDecouplerOfErrorThenInt16() *ApiDecouplerOfErrorThenInt16 {
	return &ApiDecouplerOfErrorThenInt16{
		pool: NewPoolOfErrorThenInt16Impl(),
	}
}

func (__ *ApiDecouplerOfErrorThenInt16) ReturnError(rtn_ch chan<- *ReturnOfInt16, err error) {
	rtn := __.pool.GetReturnOfInt16()
	var other int16
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfErrorThenInt16) HandleOfErrorThenInt16(ctx context.Context, req *WorkOfErrorThenInt16, h func(ctx context.Context, arg error) (int16, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfInt16()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfErrorThenInt16) DoOfErrorThenInt16(ctx context.Context, worker WorkerOfPushErrorThenInt16, arg error) (int16, error) {
	// ch := make(chan *ReturnOfInt16, 1)
	ch := __.pool.GetChReturnOfInt16()
	defer __.pool.PutChReturnOfInt16(ch)

	req := __.pool.GetWorkOfErrorThenInt16()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfErrorThenInt16(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfInt16(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfErrorThenInt16 = func(ctx context.Context, arg error) (int16, error)

type WorkerOfErrorThenInt16 struct {
	api_syncer *ApiDecouplerOfErrorThenInt16
	handler    WorkHandlerOfErrorThenInt16

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfErrorThenInt16
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfErrorThenInt16(ctx context.Context, h WorkHandlerOfErrorThenInt16, n int) *WorkerOfErrorThenInt16 {
	__ := &WorkerOfErrorThenInt16{
		api_syncer: NewApiDecouplerOfErrorThenInt16(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfErrorThenInt16, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfErrorThenInt16{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfErrorThenInt16(req.Context, req.WorkOfErrorThenInt16, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfErrorThenInt16) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfErrorThenInt16) Push(ctx context.Context, req *WorkOfErrorThenInt16) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfErrorThenInt16)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfErrorThenInt16 = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfErrorThenInt16) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfErrorThenInt16) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfErrorThenInt16) Call(ctx context.Context, arg error) (int16, error) {
	return __.api_syncer.DoOfErrorThenInt16(ctx, __, arg)
}

type PoolOfErrorThenInt32 interface {
	GetErrorArg() *error
	PutErrorArg(*error)
	GetInt32Return() *int32
	PutInt32Return(*int32)

	GetWorkOfErrorThenInt32() *WorkOfErrorThenInt32
	GetReturnOfInt32() *ReturnOfInt32
	PutWorkOfErrorThenInt32(*WorkOfErrorThenInt32)
	PutReturnOfInt32(*ReturnOfInt32)

	GetChReturnOfInt32() chan *ReturnOfInt32
	PutChReturnOfInt32(chan *ReturnOfInt32)
}

type PoolOfErrorThenInt32Impl struct {
	ErrorArg        sync.Pool
	Int32Rtn        sync.Pool
	ErrorWork       sync.Pool
	Int32Return     sync.Pool
	ChReturnOfInt32 sync.Pool
}

func (__ *PoolOfErrorThenInt32Impl) GetErrorArg() *error {
	return __.ErrorArg.Get().(*error)
}
func (__ *PoolOfErrorThenInt32Impl) PutErrorArg(p *error) {
	__.ErrorArg.Put(p)
}
func (__ *PoolOfErrorThenInt32Impl) GetInt32Return() *int32 {
	return __.Int32Rtn.Get().(*int32)
}
func (__ *PoolOfErrorThenInt32Impl) PutInt32Return(p *int32) {
	__.Int32Rtn.Put(p)
}

func (__ *PoolOfErrorThenInt32Impl) GetWorkOfErrorThenInt32() *WorkOfErrorThenInt32 {
	return __.ErrorWork.Get().(*WorkOfErrorThenInt32)
}
func (__ *PoolOfErrorThenInt32Impl) PutWorkOfErrorThenInt32(p *WorkOfErrorThenInt32) {
	__.ErrorWork.Put(p)
}
func (__ *PoolOfErrorThenInt32Impl) GetReturnOfInt32() *ReturnOfInt32 {
	return __.Int32Return.Get().(*ReturnOfInt32)
}
func (__ *PoolOfErrorThenInt32Impl) PutReturnOfInt32(p *ReturnOfInt32) {
	__.Int32Return.Put(p)
}

func (__ *PoolOfErrorThenInt32Impl) GetChReturnOfInt32() chan *ReturnOfInt32 {
	return __.ChReturnOfInt32.Get().(chan *ReturnOfInt32)
}
func (__ *PoolOfErrorThenInt32Impl) PutChReturnOfInt32(p chan *ReturnOfInt32) {
	__.ChReturnOfInt32.Put(p)
}

func NewPoolOfErrorThenInt32Impl() *PoolOfErrorThenInt32Impl {
	return &PoolOfErrorThenInt32Impl{
		ErrorArg: sync.Pool{
			New: func() interface{} {
				return new(error)
			},
		},
		ErrorWork: sync.Pool{
			New: func() interface{} {
				return new(WorkOfErrorThenInt32)
			},
		},
		Int32Rtn: sync.Pool{
			New: func() interface{} {
				return new(int32)
			},
		},
		Int32Return: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfInt32)
			},
		},
		ChReturnOfInt32: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfInt32, 1)
			},
		},
	}
}

type ApiDecouplerOfErrorThenInt32 struct {
	pool PoolOfErrorThenInt32
}

func NewApiDecouplerOfErrorThenInt32() *ApiDecouplerOfErrorThenInt32 {
	return &ApiDecouplerOfErrorThenInt32{
		pool: NewPoolOfErrorThenInt32Impl(),
	}
}

func (__ *ApiDecouplerOfErrorThenInt32) ReturnError(rtn_ch chan<- *ReturnOfInt32, err error) {
	rtn := __.pool.GetReturnOfInt32()
	var other int32
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfErrorThenInt32) HandleOfErrorThenInt32(ctx context.Context, req *WorkOfErrorThenInt32, h func(ctx context.Context, arg error) (int32, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfInt32()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfErrorThenInt32) DoOfErrorThenInt32(ctx context.Context, worker WorkerOfPushErrorThenInt32, arg error) (int32, error) {
	// ch := make(chan *ReturnOfInt32, 1)
	ch := __.pool.GetChReturnOfInt32()
	defer __.pool.PutChReturnOfInt32(ch)

	req := __.pool.GetWorkOfErrorThenInt32()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfErrorThenInt32(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfInt32(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfErrorThenInt32 = func(ctx context.Context, arg error) (int32, error)

type WorkerOfErrorThenInt32 struct {
	api_syncer *ApiDecouplerOfErrorThenInt32
	handler    WorkHandlerOfErrorThenInt32

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfErrorThenInt32
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfErrorThenInt32(ctx context.Context, h WorkHandlerOfErrorThenInt32, n int) *WorkerOfErrorThenInt32 {
	__ := &WorkerOfErrorThenInt32{
		api_syncer: NewApiDecouplerOfErrorThenInt32(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfErrorThenInt32, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfErrorThenInt32{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfErrorThenInt32(req.Context, req.WorkOfErrorThenInt32, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfErrorThenInt32) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfErrorThenInt32) Push(ctx context.Context, req *WorkOfErrorThenInt32) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfErrorThenInt32)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfErrorThenInt32 = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfErrorThenInt32) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfErrorThenInt32) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfErrorThenInt32) Call(ctx context.Context, arg error) (int32, error) {
	return __.api_syncer.DoOfErrorThenInt32(ctx, __, arg)
}

type PoolOfErrorThenInt64 interface {
	GetErrorArg() *error
	PutErrorArg(*error)
	GetInt64Return() *int64
	PutInt64Return(*int64)

	GetWorkOfErrorThenInt64() *WorkOfErrorThenInt64
	GetReturnOfInt64() *ReturnOfInt64
	PutWorkOfErrorThenInt64(*WorkOfErrorThenInt64)
	PutReturnOfInt64(*ReturnOfInt64)

	GetChReturnOfInt64() chan *ReturnOfInt64
	PutChReturnOfInt64(chan *ReturnOfInt64)
}

type PoolOfErrorThenInt64Impl struct {
	ErrorArg        sync.Pool
	Int64Rtn        sync.Pool
	ErrorWork       sync.Pool
	Int64Return     sync.Pool
	ChReturnOfInt64 sync.Pool
}

func (__ *PoolOfErrorThenInt64Impl) GetErrorArg() *error {
	return __.ErrorArg.Get().(*error)
}
func (__ *PoolOfErrorThenInt64Impl) PutErrorArg(p *error) {
	__.ErrorArg.Put(p)
}
func (__ *PoolOfErrorThenInt64Impl) GetInt64Return() *int64 {
	return __.Int64Rtn.Get().(*int64)
}
func (__ *PoolOfErrorThenInt64Impl) PutInt64Return(p *int64) {
	__.Int64Rtn.Put(p)
}

func (__ *PoolOfErrorThenInt64Impl) GetWorkOfErrorThenInt64() *WorkOfErrorThenInt64 {
	return __.ErrorWork.Get().(*WorkOfErrorThenInt64)
}
func (__ *PoolOfErrorThenInt64Impl) PutWorkOfErrorThenInt64(p *WorkOfErrorThenInt64) {
	__.ErrorWork.Put(p)
}
func (__ *PoolOfErrorThenInt64Impl) GetReturnOfInt64() *ReturnOfInt64 {
	return __.Int64Return.Get().(*ReturnOfInt64)
}
func (__ *PoolOfErrorThenInt64Impl) PutReturnOfInt64(p *ReturnOfInt64) {
	__.Int64Return.Put(p)
}

func (__ *PoolOfErrorThenInt64Impl) GetChReturnOfInt64() chan *ReturnOfInt64 {
	return __.ChReturnOfInt64.Get().(chan *ReturnOfInt64)
}
func (__ *PoolOfErrorThenInt64Impl) PutChReturnOfInt64(p chan *ReturnOfInt64) {
	__.ChReturnOfInt64.Put(p)
}

func NewPoolOfErrorThenInt64Impl() *PoolOfErrorThenInt64Impl {
	return &PoolOfErrorThenInt64Impl{
		ErrorArg: sync.Pool{
			New: func() interface{} {
				return new(error)
			},
		},
		ErrorWork: sync.Pool{
			New: func() interface{} {
				return new(WorkOfErrorThenInt64)
			},
		},
		Int64Rtn: sync.Pool{
			New: func() interface{} {
				return new(int64)
			},
		},
		Int64Return: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfInt64)
			},
		},
		ChReturnOfInt64: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfInt64, 1)
			},
		},
	}
}

type ApiDecouplerOfErrorThenInt64 struct {
	pool PoolOfErrorThenInt64
}

func NewApiDecouplerOfErrorThenInt64() *ApiDecouplerOfErrorThenInt64 {
	return &ApiDecouplerOfErrorThenInt64{
		pool: NewPoolOfErrorThenInt64Impl(),
	}
}

func (__ *ApiDecouplerOfErrorThenInt64) ReturnError(rtn_ch chan<- *ReturnOfInt64, err error) {
	rtn := __.pool.GetReturnOfInt64()
	var other int64
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfErrorThenInt64) HandleOfErrorThenInt64(ctx context.Context, req *WorkOfErrorThenInt64, h func(ctx context.Context, arg error) (int64, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfInt64()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfErrorThenInt64) DoOfErrorThenInt64(ctx context.Context, worker WorkerOfPushErrorThenInt64, arg error) (int64, error) {
	// ch := make(chan *ReturnOfInt64, 1)
	ch := __.pool.GetChReturnOfInt64()
	defer __.pool.PutChReturnOfInt64(ch)

	req := __.pool.GetWorkOfErrorThenInt64()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfErrorThenInt64(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfInt64(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfErrorThenInt64 = func(ctx context.Context, arg error) (int64, error)

type WorkerOfErrorThenInt64 struct {
	api_syncer *ApiDecouplerOfErrorThenInt64
	handler    WorkHandlerOfErrorThenInt64

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfErrorThenInt64
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfErrorThenInt64(ctx context.Context, h WorkHandlerOfErrorThenInt64, n int) *WorkerOfErrorThenInt64 {
	__ := &WorkerOfErrorThenInt64{
		api_syncer: NewApiDecouplerOfErrorThenInt64(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfErrorThenInt64, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfErrorThenInt64{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfErrorThenInt64(req.Context, req.WorkOfErrorThenInt64, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfErrorThenInt64) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfErrorThenInt64) Push(ctx context.Context, req *WorkOfErrorThenInt64) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfErrorThenInt64)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfErrorThenInt64 = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfErrorThenInt64) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfErrorThenInt64) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfErrorThenInt64) Call(ctx context.Context, arg error) (int64, error) {
	return __.api_syncer.DoOfErrorThenInt64(ctx, __, arg)
}

type PoolOfErrorThenInt8 interface {
	GetErrorArg() *error
	PutErrorArg(*error)
	GetInt8Return() *int8
	PutInt8Return(*int8)

	GetWorkOfErrorThenInt8() *WorkOfErrorThenInt8
	GetReturnOfInt8() *ReturnOfInt8
	PutWorkOfErrorThenInt8(*WorkOfErrorThenInt8)
	PutReturnOfInt8(*ReturnOfInt8)

	GetChReturnOfInt8() chan *ReturnOfInt8
	PutChReturnOfInt8(chan *ReturnOfInt8)
}

type PoolOfErrorThenInt8Impl struct {
	ErrorArg       sync.Pool
	Int8Rtn        sync.Pool
	ErrorWork      sync.Pool
	Int8Return     sync.Pool
	ChReturnOfInt8 sync.Pool
}

func (__ *PoolOfErrorThenInt8Impl) GetErrorArg() *error {
	return __.ErrorArg.Get().(*error)
}
func (__ *PoolOfErrorThenInt8Impl) PutErrorArg(p *error) {
	__.ErrorArg.Put(p)
}
func (__ *PoolOfErrorThenInt8Impl) GetInt8Return() *int8 {
	return __.Int8Rtn.Get().(*int8)
}
func (__ *PoolOfErrorThenInt8Impl) PutInt8Return(p *int8) {
	__.Int8Rtn.Put(p)
}

func (__ *PoolOfErrorThenInt8Impl) GetWorkOfErrorThenInt8() *WorkOfErrorThenInt8 {
	return __.ErrorWork.Get().(*WorkOfErrorThenInt8)
}
func (__ *PoolOfErrorThenInt8Impl) PutWorkOfErrorThenInt8(p *WorkOfErrorThenInt8) {
	__.ErrorWork.Put(p)
}
func (__ *PoolOfErrorThenInt8Impl) GetReturnOfInt8() *ReturnOfInt8 {
	return __.Int8Return.Get().(*ReturnOfInt8)
}
func (__ *PoolOfErrorThenInt8Impl) PutReturnOfInt8(p *ReturnOfInt8) {
	__.Int8Return.Put(p)
}

func (__ *PoolOfErrorThenInt8Impl) GetChReturnOfInt8() chan *ReturnOfInt8 {
	return __.ChReturnOfInt8.Get().(chan *ReturnOfInt8)
}
func (__ *PoolOfErrorThenInt8Impl) PutChReturnOfInt8(p chan *ReturnOfInt8) {
	__.ChReturnOfInt8.Put(p)
}

func NewPoolOfErrorThenInt8Impl() *PoolOfErrorThenInt8Impl {
	return &PoolOfErrorThenInt8Impl{
		ErrorArg: sync.Pool{
			New: func() interface{} {
				return new(error)
			},
		},
		ErrorWork: sync.Pool{
			New: func() interface{} {
				return new(WorkOfErrorThenInt8)
			},
		},
		Int8Rtn: sync.Pool{
			New: func() interface{} {
				return new(int8)
			},
		},
		Int8Return: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfInt8)
			},
		},
		ChReturnOfInt8: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfInt8, 1)
			},
		},
	}
}

type ApiDecouplerOfErrorThenInt8 struct {
	pool PoolOfErrorThenInt8
}

func NewApiDecouplerOfErrorThenInt8() *ApiDecouplerOfErrorThenInt8 {
	return &ApiDecouplerOfErrorThenInt8{
		pool: NewPoolOfErrorThenInt8Impl(),
	}
}

func (__ *ApiDecouplerOfErrorThenInt8) ReturnError(rtn_ch chan<- *ReturnOfInt8, err error) {
	rtn := __.pool.GetReturnOfInt8()
	var other int8
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfErrorThenInt8) HandleOfErrorThenInt8(ctx context.Context, req *WorkOfErrorThenInt8, h func(ctx context.Context, arg error) (int8, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfInt8()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfErrorThenInt8) DoOfErrorThenInt8(ctx context.Context, worker WorkerOfPushErrorThenInt8, arg error) (int8, error) {
	// ch := make(chan *ReturnOfInt8, 1)
	ch := __.pool.GetChReturnOfInt8()
	defer __.pool.PutChReturnOfInt8(ch)

	req := __.pool.GetWorkOfErrorThenInt8()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfErrorThenInt8(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfInt8(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfErrorThenInt8 = func(ctx context.Context, arg error) (int8, error)

type WorkerOfErrorThenInt8 struct {
	api_syncer *ApiDecouplerOfErrorThenInt8
	handler    WorkHandlerOfErrorThenInt8

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfErrorThenInt8
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfErrorThenInt8(ctx context.Context, h WorkHandlerOfErrorThenInt8, n int) *WorkerOfErrorThenInt8 {
	__ := &WorkerOfErrorThenInt8{
		api_syncer: NewApiDecouplerOfErrorThenInt8(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfErrorThenInt8, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfErrorThenInt8{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfErrorThenInt8(req.Context, req.WorkOfErrorThenInt8, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfErrorThenInt8) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfErrorThenInt8) Push(ctx context.Context, req *WorkOfErrorThenInt8) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfErrorThenInt8)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfErrorThenInt8 = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfErrorThenInt8) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfErrorThenInt8) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfErrorThenInt8) Call(ctx context.Context, arg error) (int8, error) {
	return __.api_syncer.DoOfErrorThenInt8(ctx, __, arg)
}

type PoolOfErrorThenRune interface {
	GetErrorArg() *error
	PutErrorArg(*error)
	GetRuneReturn() *rune
	PutRuneReturn(*rune)

	GetWorkOfErrorThenRune() *WorkOfErrorThenRune
	GetReturnOfRune() *ReturnOfRune
	PutWorkOfErrorThenRune(*WorkOfErrorThenRune)
	PutReturnOfRune(*ReturnOfRune)

	GetChReturnOfRune() chan *ReturnOfRune
	PutChReturnOfRune(chan *ReturnOfRune)
}

type PoolOfErrorThenRuneImpl struct {
	ErrorArg       sync.Pool
	RuneRtn        sync.Pool
	ErrorWork      sync.Pool
	RuneReturn     sync.Pool
	ChReturnOfRune sync.Pool
}

func (__ *PoolOfErrorThenRuneImpl) GetErrorArg() *error {
	return __.ErrorArg.Get().(*error)
}
func (__ *PoolOfErrorThenRuneImpl) PutErrorArg(p *error) {
	__.ErrorArg.Put(p)
}
func (__ *PoolOfErrorThenRuneImpl) GetRuneReturn() *rune {
	return __.RuneRtn.Get().(*rune)
}
func (__ *PoolOfErrorThenRuneImpl) PutRuneReturn(p *rune) {
	__.RuneRtn.Put(p)
}

func (__ *PoolOfErrorThenRuneImpl) GetWorkOfErrorThenRune() *WorkOfErrorThenRune {
	return __.ErrorWork.Get().(*WorkOfErrorThenRune)
}
func (__ *PoolOfErrorThenRuneImpl) PutWorkOfErrorThenRune(p *WorkOfErrorThenRune) {
	__.ErrorWork.Put(p)
}
func (__ *PoolOfErrorThenRuneImpl) GetReturnOfRune() *ReturnOfRune {
	return __.RuneReturn.Get().(*ReturnOfRune)
}
func (__ *PoolOfErrorThenRuneImpl) PutReturnOfRune(p *ReturnOfRune) {
	__.RuneReturn.Put(p)
}

func (__ *PoolOfErrorThenRuneImpl) GetChReturnOfRune() chan *ReturnOfRune {
	return __.ChReturnOfRune.Get().(chan *ReturnOfRune)
}
func (__ *PoolOfErrorThenRuneImpl) PutChReturnOfRune(p chan *ReturnOfRune) {
	__.ChReturnOfRune.Put(p)
}

func NewPoolOfErrorThenRuneImpl() *PoolOfErrorThenRuneImpl {
	return &PoolOfErrorThenRuneImpl{
		ErrorArg: sync.Pool{
			New: func() interface{} {
				return new(error)
			},
		},
		ErrorWork: sync.Pool{
			New: func() interface{} {
				return new(WorkOfErrorThenRune)
			},
		},
		RuneRtn: sync.Pool{
			New: func() interface{} {
				return new(rune)
			},
		},
		RuneReturn: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfRune)
			},
		},
		ChReturnOfRune: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfRune, 1)
			},
		},
	}
}

type ApiDecouplerOfErrorThenRune struct {
	pool PoolOfErrorThenRune
}

func NewApiDecouplerOfErrorThenRune() *ApiDecouplerOfErrorThenRune {
	return &ApiDecouplerOfErrorThenRune{
		pool: NewPoolOfErrorThenRuneImpl(),
	}
}

func (__ *ApiDecouplerOfErrorThenRune) ReturnError(rtn_ch chan<- *ReturnOfRune, err error) {
	rtn := __.pool.GetReturnOfRune()
	var other rune
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfErrorThenRune) HandleOfErrorThenRune(ctx context.Context, req *WorkOfErrorThenRune, h func(ctx context.Context, arg error) (rune, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfRune()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfErrorThenRune) DoOfErrorThenRune(ctx context.Context, worker WorkerOfPushErrorThenRune, arg error) (rune, error) {
	// ch := make(chan *ReturnOfRune, 1)
	ch := __.pool.GetChReturnOfRune()
	defer __.pool.PutChReturnOfRune(ch)

	req := __.pool.GetWorkOfErrorThenRune()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfErrorThenRune(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfRune(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfErrorThenRune = func(ctx context.Context, arg error) (rune, error)

type WorkerOfErrorThenRune struct {
	api_syncer *ApiDecouplerOfErrorThenRune
	handler    WorkHandlerOfErrorThenRune

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfErrorThenRune
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfErrorThenRune(ctx context.Context, h WorkHandlerOfErrorThenRune, n int) *WorkerOfErrorThenRune {
	__ := &WorkerOfErrorThenRune{
		api_syncer: NewApiDecouplerOfErrorThenRune(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfErrorThenRune, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfErrorThenRune{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfErrorThenRune(req.Context, req.WorkOfErrorThenRune, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfErrorThenRune) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfErrorThenRune) Push(ctx context.Context, req *WorkOfErrorThenRune) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfErrorThenRune)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfErrorThenRune = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfErrorThenRune) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfErrorThenRune) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfErrorThenRune) Call(ctx context.Context, arg error) (rune, error) {
	return __.api_syncer.DoOfErrorThenRune(ctx, __, arg)
}

type PoolOfErrorThenString interface {
	GetErrorArg() *error
	PutErrorArg(*error)
	GetStringReturn() *string
	PutStringReturn(*string)

	GetWorkOfErrorThenString() *WorkOfErrorThenString
	GetReturnOfString() *ReturnOfString
	PutWorkOfErrorThenString(*WorkOfErrorThenString)
	PutReturnOfString(*ReturnOfString)

	GetChReturnOfString() chan *ReturnOfString
	PutChReturnOfString(chan *ReturnOfString)
}

type PoolOfErrorThenStringImpl struct {
	ErrorArg         sync.Pool
	StringRtn        sync.Pool
	ErrorWork        sync.Pool
	StringReturn     sync.Pool
	ChReturnOfString sync.Pool
}

func (__ *PoolOfErrorThenStringImpl) GetErrorArg() *error {
	return __.ErrorArg.Get().(*error)
}
func (__ *PoolOfErrorThenStringImpl) PutErrorArg(p *error) {
	__.ErrorArg.Put(p)
}
func (__ *PoolOfErrorThenStringImpl) GetStringReturn() *string {
	return __.StringRtn.Get().(*string)
}
func (__ *PoolOfErrorThenStringImpl) PutStringReturn(p *string) {
	__.StringRtn.Put(p)
}

func (__ *PoolOfErrorThenStringImpl) GetWorkOfErrorThenString() *WorkOfErrorThenString {
	return __.ErrorWork.Get().(*WorkOfErrorThenString)
}
func (__ *PoolOfErrorThenStringImpl) PutWorkOfErrorThenString(p *WorkOfErrorThenString) {
	__.ErrorWork.Put(p)
}
func (__ *PoolOfErrorThenStringImpl) GetReturnOfString() *ReturnOfString {
	return __.StringReturn.Get().(*ReturnOfString)
}
func (__ *PoolOfErrorThenStringImpl) PutReturnOfString(p *ReturnOfString) {
	__.StringReturn.Put(p)
}

func (__ *PoolOfErrorThenStringImpl) GetChReturnOfString() chan *ReturnOfString {
	return __.ChReturnOfString.Get().(chan *ReturnOfString)
}
func (__ *PoolOfErrorThenStringImpl) PutChReturnOfString(p chan *ReturnOfString) {
	__.ChReturnOfString.Put(p)
}

func NewPoolOfErrorThenStringImpl() *PoolOfErrorThenStringImpl {
	return &PoolOfErrorThenStringImpl{
		ErrorArg: sync.Pool{
			New: func() interface{} {
				return new(error)
			},
		},
		ErrorWork: sync.Pool{
			New: func() interface{} {
				return new(WorkOfErrorThenString)
			},
		},
		StringRtn: sync.Pool{
			New: func() interface{} {
				return new(string)
			},
		},
		StringReturn: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfString)
			},
		},
		ChReturnOfString: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfString, 1)
			},
		},
	}
}

type ApiDecouplerOfErrorThenString struct {
	pool PoolOfErrorThenString
}

func NewApiDecouplerOfErrorThenString() *ApiDecouplerOfErrorThenString {
	return &ApiDecouplerOfErrorThenString{
		pool: NewPoolOfErrorThenStringImpl(),
	}
}

func (__ *ApiDecouplerOfErrorThenString) ReturnError(rtn_ch chan<- *ReturnOfString, err error) {
	rtn := __.pool.GetReturnOfString()
	var other string
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfErrorThenString) HandleOfErrorThenString(ctx context.Context, req *WorkOfErrorThenString, h func(ctx context.Context, arg error) (string, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfString()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfErrorThenString) DoOfErrorThenString(ctx context.Context, worker WorkerOfPushErrorThenString, arg error) (string, error) {
	// ch := make(chan *ReturnOfString, 1)
	ch := __.pool.GetChReturnOfString()
	defer __.pool.PutChReturnOfString(ch)

	req := __.pool.GetWorkOfErrorThenString()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfErrorThenString(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfString(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfErrorThenString = func(ctx context.Context, arg error) (string, error)

type WorkerOfErrorThenString struct {
	api_syncer *ApiDecouplerOfErrorThenString
	handler    WorkHandlerOfErrorThenString

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfErrorThenString
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfErrorThenString(ctx context.Context, h WorkHandlerOfErrorThenString, n int) *WorkerOfErrorThenString {
	__ := &WorkerOfErrorThenString{
		api_syncer: NewApiDecouplerOfErrorThenString(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfErrorThenString, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfErrorThenString{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfErrorThenString(req.Context, req.WorkOfErrorThenString, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfErrorThenString) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfErrorThenString) Push(ctx context.Context, req *WorkOfErrorThenString) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfErrorThenString)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfErrorThenString = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfErrorThenString) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfErrorThenString) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfErrorThenString) Call(ctx context.Context, arg error) (string, error) {
	return __.api_syncer.DoOfErrorThenString(ctx, __, arg)
}

type PoolOfErrorThenUint interface {
	GetErrorArg() *error
	PutErrorArg(*error)
	GetUintReturn() *uint
	PutUintReturn(*uint)

	GetWorkOfErrorThenUint() *WorkOfErrorThenUint
	GetReturnOfUint() *ReturnOfUint
	PutWorkOfErrorThenUint(*WorkOfErrorThenUint)
	PutReturnOfUint(*ReturnOfUint)

	GetChReturnOfUint() chan *ReturnOfUint
	PutChReturnOfUint(chan *ReturnOfUint)
}

type PoolOfErrorThenUintImpl struct {
	ErrorArg       sync.Pool
	UintRtn        sync.Pool
	ErrorWork      sync.Pool
	UintReturn     sync.Pool
	ChReturnOfUint sync.Pool
}

func (__ *PoolOfErrorThenUintImpl) GetErrorArg() *error {
	return __.ErrorArg.Get().(*error)
}
func (__ *PoolOfErrorThenUintImpl) PutErrorArg(p *error) {
	__.ErrorArg.Put(p)
}
func (__ *PoolOfErrorThenUintImpl) GetUintReturn() *uint {
	return __.UintRtn.Get().(*uint)
}
func (__ *PoolOfErrorThenUintImpl) PutUintReturn(p *uint) {
	__.UintRtn.Put(p)
}

func (__ *PoolOfErrorThenUintImpl) GetWorkOfErrorThenUint() *WorkOfErrorThenUint {
	return __.ErrorWork.Get().(*WorkOfErrorThenUint)
}
func (__ *PoolOfErrorThenUintImpl) PutWorkOfErrorThenUint(p *WorkOfErrorThenUint) {
	__.ErrorWork.Put(p)
}
func (__ *PoolOfErrorThenUintImpl) GetReturnOfUint() *ReturnOfUint {
	return __.UintReturn.Get().(*ReturnOfUint)
}
func (__ *PoolOfErrorThenUintImpl) PutReturnOfUint(p *ReturnOfUint) {
	__.UintReturn.Put(p)
}

func (__ *PoolOfErrorThenUintImpl) GetChReturnOfUint() chan *ReturnOfUint {
	return __.ChReturnOfUint.Get().(chan *ReturnOfUint)
}
func (__ *PoolOfErrorThenUintImpl) PutChReturnOfUint(p chan *ReturnOfUint) {
	__.ChReturnOfUint.Put(p)
}

func NewPoolOfErrorThenUintImpl() *PoolOfErrorThenUintImpl {
	return &PoolOfErrorThenUintImpl{
		ErrorArg: sync.Pool{
			New: func() interface{} {
				return new(error)
			},
		},
		ErrorWork: sync.Pool{
			New: func() interface{} {
				return new(WorkOfErrorThenUint)
			},
		},
		UintRtn: sync.Pool{
			New: func() interface{} {
				return new(uint)
			},
		},
		UintReturn: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfUint)
			},
		},
		ChReturnOfUint: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfUint, 1)
			},
		},
	}
}

type ApiDecouplerOfErrorThenUint struct {
	pool PoolOfErrorThenUint
}

func NewApiDecouplerOfErrorThenUint() *ApiDecouplerOfErrorThenUint {
	return &ApiDecouplerOfErrorThenUint{
		pool: NewPoolOfErrorThenUintImpl(),
	}
}

func (__ *ApiDecouplerOfErrorThenUint) ReturnError(rtn_ch chan<- *ReturnOfUint, err error) {
	rtn := __.pool.GetReturnOfUint()
	var other uint
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfErrorThenUint) HandleOfErrorThenUint(ctx context.Context, req *WorkOfErrorThenUint, h func(ctx context.Context, arg error) (uint, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfUint()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfErrorThenUint) DoOfErrorThenUint(ctx context.Context, worker WorkerOfPushErrorThenUint, arg error) (uint, error) {
	// ch := make(chan *ReturnOfUint, 1)
	ch := __.pool.GetChReturnOfUint()
	defer __.pool.PutChReturnOfUint(ch)

	req := __.pool.GetWorkOfErrorThenUint()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfErrorThenUint(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfUint(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfErrorThenUint = func(ctx context.Context, arg error) (uint, error)

type WorkerOfErrorThenUint struct {
	api_syncer *ApiDecouplerOfErrorThenUint
	handler    WorkHandlerOfErrorThenUint

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfErrorThenUint
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfErrorThenUint(ctx context.Context, h WorkHandlerOfErrorThenUint, n int) *WorkerOfErrorThenUint {
	__ := &WorkerOfErrorThenUint{
		api_syncer: NewApiDecouplerOfErrorThenUint(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfErrorThenUint, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfErrorThenUint{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfErrorThenUint(req.Context, req.WorkOfErrorThenUint, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfErrorThenUint) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfErrorThenUint) Push(ctx context.Context, req *WorkOfErrorThenUint) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfErrorThenUint)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfErrorThenUint = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfErrorThenUint) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfErrorThenUint) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfErrorThenUint) Call(ctx context.Context, arg error) (uint, error) {
	return __.api_syncer.DoOfErrorThenUint(ctx, __, arg)
}

type PoolOfErrorThenUint16 interface {
	GetErrorArg() *error
	PutErrorArg(*error)
	GetUint16Return() *uint16
	PutUint16Return(*uint16)

	GetWorkOfErrorThenUint16() *WorkOfErrorThenUint16
	GetReturnOfUint16() *ReturnOfUint16
	PutWorkOfErrorThenUint16(*WorkOfErrorThenUint16)
	PutReturnOfUint16(*ReturnOfUint16)

	GetChReturnOfUint16() chan *ReturnOfUint16
	PutChReturnOfUint16(chan *ReturnOfUint16)
}

type PoolOfErrorThenUint16Impl struct {
	ErrorArg         sync.Pool
	Uint16Rtn        sync.Pool
	ErrorWork        sync.Pool
	Uint16Return     sync.Pool
	ChReturnOfUint16 sync.Pool
}

func (__ *PoolOfErrorThenUint16Impl) GetErrorArg() *error {
	return __.ErrorArg.Get().(*error)
}
func (__ *PoolOfErrorThenUint16Impl) PutErrorArg(p *error) {
	__.ErrorArg.Put(p)
}
func (__ *PoolOfErrorThenUint16Impl) GetUint16Return() *uint16 {
	return __.Uint16Rtn.Get().(*uint16)
}
func (__ *PoolOfErrorThenUint16Impl) PutUint16Return(p *uint16) {
	__.Uint16Rtn.Put(p)
}

func (__ *PoolOfErrorThenUint16Impl) GetWorkOfErrorThenUint16() *WorkOfErrorThenUint16 {
	return __.ErrorWork.Get().(*WorkOfErrorThenUint16)
}
func (__ *PoolOfErrorThenUint16Impl) PutWorkOfErrorThenUint16(p *WorkOfErrorThenUint16) {
	__.ErrorWork.Put(p)
}
func (__ *PoolOfErrorThenUint16Impl) GetReturnOfUint16() *ReturnOfUint16 {
	return __.Uint16Return.Get().(*ReturnOfUint16)
}
func (__ *PoolOfErrorThenUint16Impl) PutReturnOfUint16(p *ReturnOfUint16) {
	__.Uint16Return.Put(p)
}

func (__ *PoolOfErrorThenUint16Impl) GetChReturnOfUint16() chan *ReturnOfUint16 {
	return __.ChReturnOfUint16.Get().(chan *ReturnOfUint16)
}
func (__ *PoolOfErrorThenUint16Impl) PutChReturnOfUint16(p chan *ReturnOfUint16) {
	__.ChReturnOfUint16.Put(p)
}

func NewPoolOfErrorThenUint16Impl() *PoolOfErrorThenUint16Impl {
	return &PoolOfErrorThenUint16Impl{
		ErrorArg: sync.Pool{
			New: func() interface{} {
				return new(error)
			},
		},
		ErrorWork: sync.Pool{
			New: func() interface{} {
				return new(WorkOfErrorThenUint16)
			},
		},
		Uint16Rtn: sync.Pool{
			New: func() interface{} {
				return new(uint16)
			},
		},
		Uint16Return: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfUint16)
			},
		},
		ChReturnOfUint16: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfUint16, 1)
			},
		},
	}
}

type ApiDecouplerOfErrorThenUint16 struct {
	pool PoolOfErrorThenUint16
}

func NewApiDecouplerOfErrorThenUint16() *ApiDecouplerOfErrorThenUint16 {
	return &ApiDecouplerOfErrorThenUint16{
		pool: NewPoolOfErrorThenUint16Impl(),
	}
}

func (__ *ApiDecouplerOfErrorThenUint16) ReturnError(rtn_ch chan<- *ReturnOfUint16, err error) {
	rtn := __.pool.GetReturnOfUint16()
	var other uint16
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfErrorThenUint16) HandleOfErrorThenUint16(ctx context.Context, req *WorkOfErrorThenUint16, h func(ctx context.Context, arg error) (uint16, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfUint16()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfErrorThenUint16) DoOfErrorThenUint16(ctx context.Context, worker WorkerOfPushErrorThenUint16, arg error) (uint16, error) {
	// ch := make(chan *ReturnOfUint16, 1)
	ch := __.pool.GetChReturnOfUint16()
	defer __.pool.PutChReturnOfUint16(ch)

	req := __.pool.GetWorkOfErrorThenUint16()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfErrorThenUint16(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfUint16(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfErrorThenUint16 = func(ctx context.Context, arg error) (uint16, error)

type WorkerOfErrorThenUint16 struct {
	api_syncer *ApiDecouplerOfErrorThenUint16
	handler    WorkHandlerOfErrorThenUint16

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfErrorThenUint16
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfErrorThenUint16(ctx context.Context, h WorkHandlerOfErrorThenUint16, n int) *WorkerOfErrorThenUint16 {
	__ := &WorkerOfErrorThenUint16{
		api_syncer: NewApiDecouplerOfErrorThenUint16(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfErrorThenUint16, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfErrorThenUint16{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfErrorThenUint16(req.Context, req.WorkOfErrorThenUint16, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfErrorThenUint16) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfErrorThenUint16) Push(ctx context.Context, req *WorkOfErrorThenUint16) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfErrorThenUint16)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfErrorThenUint16 = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfErrorThenUint16) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfErrorThenUint16) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfErrorThenUint16) Call(ctx context.Context, arg error) (uint16, error) {
	return __.api_syncer.DoOfErrorThenUint16(ctx, __, arg)
}

type PoolOfErrorThenUint32 interface {
	GetErrorArg() *error
	PutErrorArg(*error)
	GetUint32Return() *uint32
	PutUint32Return(*uint32)

	GetWorkOfErrorThenUint32() *WorkOfErrorThenUint32
	GetReturnOfUint32() *ReturnOfUint32
	PutWorkOfErrorThenUint32(*WorkOfErrorThenUint32)
	PutReturnOfUint32(*ReturnOfUint32)

	GetChReturnOfUint32() chan *ReturnOfUint32
	PutChReturnOfUint32(chan *ReturnOfUint32)
}

type PoolOfErrorThenUint32Impl struct {
	ErrorArg         sync.Pool
	Uint32Rtn        sync.Pool
	ErrorWork        sync.Pool
	Uint32Return     sync.Pool
	ChReturnOfUint32 sync.Pool
}

func (__ *PoolOfErrorThenUint32Impl) GetErrorArg() *error {
	return __.ErrorArg.Get().(*error)
}
func (__ *PoolOfErrorThenUint32Impl) PutErrorArg(p *error) {
	__.ErrorArg.Put(p)
}
func (__ *PoolOfErrorThenUint32Impl) GetUint32Return() *uint32 {
	return __.Uint32Rtn.Get().(*uint32)
}
func (__ *PoolOfErrorThenUint32Impl) PutUint32Return(p *uint32) {
	__.Uint32Rtn.Put(p)
}

func (__ *PoolOfErrorThenUint32Impl) GetWorkOfErrorThenUint32() *WorkOfErrorThenUint32 {
	return __.ErrorWork.Get().(*WorkOfErrorThenUint32)
}
func (__ *PoolOfErrorThenUint32Impl) PutWorkOfErrorThenUint32(p *WorkOfErrorThenUint32) {
	__.ErrorWork.Put(p)
}
func (__ *PoolOfErrorThenUint32Impl) GetReturnOfUint32() *ReturnOfUint32 {
	return __.Uint32Return.Get().(*ReturnOfUint32)
}
func (__ *PoolOfErrorThenUint32Impl) PutReturnOfUint32(p *ReturnOfUint32) {
	__.Uint32Return.Put(p)
}

func (__ *PoolOfErrorThenUint32Impl) GetChReturnOfUint32() chan *ReturnOfUint32 {
	return __.ChReturnOfUint32.Get().(chan *ReturnOfUint32)
}
func (__ *PoolOfErrorThenUint32Impl) PutChReturnOfUint32(p chan *ReturnOfUint32) {
	__.ChReturnOfUint32.Put(p)
}

func NewPoolOfErrorThenUint32Impl() *PoolOfErrorThenUint32Impl {
	return &PoolOfErrorThenUint32Impl{
		ErrorArg: sync.Pool{
			New: func() interface{} {
				return new(error)
			},
		},
		ErrorWork: sync.Pool{
			New: func() interface{} {
				return new(WorkOfErrorThenUint32)
			},
		},
		Uint32Rtn: sync.Pool{
			New: func() interface{} {
				return new(uint32)
			},
		},
		Uint32Return: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfUint32)
			},
		},
		ChReturnOfUint32: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfUint32, 1)
			},
		},
	}
}

type ApiDecouplerOfErrorThenUint32 struct {
	pool PoolOfErrorThenUint32
}

func NewApiDecouplerOfErrorThenUint32() *ApiDecouplerOfErrorThenUint32 {
	return &ApiDecouplerOfErrorThenUint32{
		pool: NewPoolOfErrorThenUint32Impl(),
	}
}

func (__ *ApiDecouplerOfErrorThenUint32) ReturnError(rtn_ch chan<- *ReturnOfUint32, err error) {
	rtn := __.pool.GetReturnOfUint32()
	var other uint32
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfErrorThenUint32) HandleOfErrorThenUint32(ctx context.Context, req *WorkOfErrorThenUint32, h func(ctx context.Context, arg error) (uint32, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfUint32()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfErrorThenUint32) DoOfErrorThenUint32(ctx context.Context, worker WorkerOfPushErrorThenUint32, arg error) (uint32, error) {
	// ch := make(chan *ReturnOfUint32, 1)
	ch := __.pool.GetChReturnOfUint32()
	defer __.pool.PutChReturnOfUint32(ch)

	req := __.pool.GetWorkOfErrorThenUint32()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfErrorThenUint32(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfUint32(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfErrorThenUint32 = func(ctx context.Context, arg error) (uint32, error)

type WorkerOfErrorThenUint32 struct {
	api_syncer *ApiDecouplerOfErrorThenUint32
	handler    WorkHandlerOfErrorThenUint32

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfErrorThenUint32
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfErrorThenUint32(ctx context.Context, h WorkHandlerOfErrorThenUint32, n int) *WorkerOfErrorThenUint32 {
	__ := &WorkerOfErrorThenUint32{
		api_syncer: NewApiDecouplerOfErrorThenUint32(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfErrorThenUint32, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfErrorThenUint32{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfErrorThenUint32(req.Context, req.WorkOfErrorThenUint32, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfErrorThenUint32) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfErrorThenUint32) Push(ctx context.Context, req *WorkOfErrorThenUint32) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfErrorThenUint32)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfErrorThenUint32 = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfErrorThenUint32) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfErrorThenUint32) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfErrorThenUint32) Call(ctx context.Context, arg error) (uint32, error) {
	return __.api_syncer.DoOfErrorThenUint32(ctx, __, arg)
}

type PoolOfErrorThenUint64 interface {
	GetErrorArg() *error
	PutErrorArg(*error)
	GetUint64Return() *uint64
	PutUint64Return(*uint64)

	GetWorkOfErrorThenUint64() *WorkOfErrorThenUint64
	GetReturnOfUint64() *ReturnOfUint64
	PutWorkOfErrorThenUint64(*WorkOfErrorThenUint64)
	PutReturnOfUint64(*ReturnOfUint64)

	GetChReturnOfUint64() chan *ReturnOfUint64
	PutChReturnOfUint64(chan *ReturnOfUint64)
}

type PoolOfErrorThenUint64Impl struct {
	ErrorArg         sync.Pool
	Uint64Rtn        sync.Pool
	ErrorWork        sync.Pool
	Uint64Return     sync.Pool
	ChReturnOfUint64 sync.Pool
}

func (__ *PoolOfErrorThenUint64Impl) GetErrorArg() *error {
	return __.ErrorArg.Get().(*error)
}
func (__ *PoolOfErrorThenUint64Impl) PutErrorArg(p *error) {
	__.ErrorArg.Put(p)
}
func (__ *PoolOfErrorThenUint64Impl) GetUint64Return() *uint64 {
	return __.Uint64Rtn.Get().(*uint64)
}
func (__ *PoolOfErrorThenUint64Impl) PutUint64Return(p *uint64) {
	__.Uint64Rtn.Put(p)
}

func (__ *PoolOfErrorThenUint64Impl) GetWorkOfErrorThenUint64() *WorkOfErrorThenUint64 {
	return __.ErrorWork.Get().(*WorkOfErrorThenUint64)
}
func (__ *PoolOfErrorThenUint64Impl) PutWorkOfErrorThenUint64(p *WorkOfErrorThenUint64) {
	__.ErrorWork.Put(p)
}
func (__ *PoolOfErrorThenUint64Impl) GetReturnOfUint64() *ReturnOfUint64 {
	return __.Uint64Return.Get().(*ReturnOfUint64)
}
func (__ *PoolOfErrorThenUint64Impl) PutReturnOfUint64(p *ReturnOfUint64) {
	__.Uint64Return.Put(p)
}

func (__ *PoolOfErrorThenUint64Impl) GetChReturnOfUint64() chan *ReturnOfUint64 {
	return __.ChReturnOfUint64.Get().(chan *ReturnOfUint64)
}
func (__ *PoolOfErrorThenUint64Impl) PutChReturnOfUint64(p chan *ReturnOfUint64) {
	__.ChReturnOfUint64.Put(p)
}

func NewPoolOfErrorThenUint64Impl() *PoolOfErrorThenUint64Impl {
	return &PoolOfErrorThenUint64Impl{
		ErrorArg: sync.Pool{
			New: func() interface{} {
				return new(error)
			},
		},
		ErrorWork: sync.Pool{
			New: func() interface{} {
				return new(WorkOfErrorThenUint64)
			},
		},
		Uint64Rtn: sync.Pool{
			New: func() interface{} {
				return new(uint64)
			},
		},
		Uint64Return: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfUint64)
			},
		},
		ChReturnOfUint64: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfUint64, 1)
			},
		},
	}
}

type ApiDecouplerOfErrorThenUint64 struct {
	pool PoolOfErrorThenUint64
}

func NewApiDecouplerOfErrorThenUint64() *ApiDecouplerOfErrorThenUint64 {
	return &ApiDecouplerOfErrorThenUint64{
		pool: NewPoolOfErrorThenUint64Impl(),
	}
}

func (__ *ApiDecouplerOfErrorThenUint64) ReturnError(rtn_ch chan<- *ReturnOfUint64, err error) {
	rtn := __.pool.GetReturnOfUint64()
	var other uint64
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfErrorThenUint64) HandleOfErrorThenUint64(ctx context.Context, req *WorkOfErrorThenUint64, h func(ctx context.Context, arg error) (uint64, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfUint64()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfErrorThenUint64) DoOfErrorThenUint64(ctx context.Context, worker WorkerOfPushErrorThenUint64, arg error) (uint64, error) {
	// ch := make(chan *ReturnOfUint64, 1)
	ch := __.pool.GetChReturnOfUint64()
	defer __.pool.PutChReturnOfUint64(ch)

	req := __.pool.GetWorkOfErrorThenUint64()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfErrorThenUint64(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfUint64(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfErrorThenUint64 = func(ctx context.Context, arg error) (uint64, error)

type WorkerOfErrorThenUint64 struct {
	api_syncer *ApiDecouplerOfErrorThenUint64
	handler    WorkHandlerOfErrorThenUint64

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfErrorThenUint64
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfErrorThenUint64(ctx context.Context, h WorkHandlerOfErrorThenUint64, n int) *WorkerOfErrorThenUint64 {
	__ := &WorkerOfErrorThenUint64{
		api_syncer: NewApiDecouplerOfErrorThenUint64(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfErrorThenUint64, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfErrorThenUint64{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfErrorThenUint64(req.Context, req.WorkOfErrorThenUint64, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfErrorThenUint64) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfErrorThenUint64) Push(ctx context.Context, req *WorkOfErrorThenUint64) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfErrorThenUint64)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfErrorThenUint64 = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfErrorThenUint64) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfErrorThenUint64) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfErrorThenUint64) Call(ctx context.Context, arg error) (uint64, error) {
	return __.api_syncer.DoOfErrorThenUint64(ctx, __, arg)
}

type PoolOfErrorThenUint8 interface {
	GetErrorArg() *error
	PutErrorArg(*error)
	GetUint8Return() *uint8
	PutUint8Return(*uint8)

	GetWorkOfErrorThenUint8() *WorkOfErrorThenUint8
	GetReturnOfUint8() *ReturnOfUint8
	PutWorkOfErrorThenUint8(*WorkOfErrorThenUint8)
	PutReturnOfUint8(*ReturnOfUint8)

	GetChReturnOfUint8() chan *ReturnOfUint8
	PutChReturnOfUint8(chan *ReturnOfUint8)
}

type PoolOfErrorThenUint8Impl struct {
	ErrorArg        sync.Pool
	Uint8Rtn        sync.Pool
	ErrorWork       sync.Pool
	Uint8Return     sync.Pool
	ChReturnOfUint8 sync.Pool
}

func (__ *PoolOfErrorThenUint8Impl) GetErrorArg() *error {
	return __.ErrorArg.Get().(*error)
}
func (__ *PoolOfErrorThenUint8Impl) PutErrorArg(p *error) {
	__.ErrorArg.Put(p)
}
func (__ *PoolOfErrorThenUint8Impl) GetUint8Return() *uint8 {
	return __.Uint8Rtn.Get().(*uint8)
}
func (__ *PoolOfErrorThenUint8Impl) PutUint8Return(p *uint8) {
	__.Uint8Rtn.Put(p)
}

func (__ *PoolOfErrorThenUint8Impl) GetWorkOfErrorThenUint8() *WorkOfErrorThenUint8 {
	return __.ErrorWork.Get().(*WorkOfErrorThenUint8)
}
func (__ *PoolOfErrorThenUint8Impl) PutWorkOfErrorThenUint8(p *WorkOfErrorThenUint8) {
	__.ErrorWork.Put(p)
}
func (__ *PoolOfErrorThenUint8Impl) GetReturnOfUint8() *ReturnOfUint8 {
	return __.Uint8Return.Get().(*ReturnOfUint8)
}
func (__ *PoolOfErrorThenUint8Impl) PutReturnOfUint8(p *ReturnOfUint8) {
	__.Uint8Return.Put(p)
}

func (__ *PoolOfErrorThenUint8Impl) GetChReturnOfUint8() chan *ReturnOfUint8 {
	return __.ChReturnOfUint8.Get().(chan *ReturnOfUint8)
}
func (__ *PoolOfErrorThenUint8Impl) PutChReturnOfUint8(p chan *ReturnOfUint8) {
	__.ChReturnOfUint8.Put(p)
}

func NewPoolOfErrorThenUint8Impl() *PoolOfErrorThenUint8Impl {
	return &PoolOfErrorThenUint8Impl{
		ErrorArg: sync.Pool{
			New: func() interface{} {
				return new(error)
			},
		},
		ErrorWork: sync.Pool{
			New: func() interface{} {
				return new(WorkOfErrorThenUint8)
			},
		},
		Uint8Rtn: sync.Pool{
			New: func() interface{} {
				return new(uint8)
			},
		},
		Uint8Return: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfUint8)
			},
		},
		ChReturnOfUint8: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfUint8, 1)
			},
		},
	}
}

type ApiDecouplerOfErrorThenUint8 struct {
	pool PoolOfErrorThenUint8
}

func NewApiDecouplerOfErrorThenUint8() *ApiDecouplerOfErrorThenUint8 {
	return &ApiDecouplerOfErrorThenUint8{
		pool: NewPoolOfErrorThenUint8Impl(),
	}
}

func (__ *ApiDecouplerOfErrorThenUint8) ReturnError(rtn_ch chan<- *ReturnOfUint8, err error) {
	rtn := __.pool.GetReturnOfUint8()
	var other uint8
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfErrorThenUint8) HandleOfErrorThenUint8(ctx context.Context, req *WorkOfErrorThenUint8, h func(ctx context.Context, arg error) (uint8, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfUint8()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfErrorThenUint8) DoOfErrorThenUint8(ctx context.Context, worker WorkerOfPushErrorThenUint8, arg error) (uint8, error) {
	// ch := make(chan *ReturnOfUint8, 1)
	ch := __.pool.GetChReturnOfUint8()
	defer __.pool.PutChReturnOfUint8(ch)

	req := __.pool.GetWorkOfErrorThenUint8()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfErrorThenUint8(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfUint8(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfErrorThenUint8 = func(ctx context.Context, arg error) (uint8, error)

type WorkerOfErrorThenUint8 struct {
	api_syncer *ApiDecouplerOfErrorThenUint8
	handler    WorkHandlerOfErrorThenUint8

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfErrorThenUint8
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfErrorThenUint8(ctx context.Context, h WorkHandlerOfErrorThenUint8, n int) *WorkerOfErrorThenUint8 {
	__ := &WorkerOfErrorThenUint8{
		api_syncer: NewApiDecouplerOfErrorThenUint8(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfErrorThenUint8, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfErrorThenUint8{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfErrorThenUint8(req.Context, req.WorkOfErrorThenUint8, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfErrorThenUint8) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfErrorThenUint8) Push(ctx context.Context, req *WorkOfErrorThenUint8) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfErrorThenUint8)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfErrorThenUint8 = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfErrorThenUint8) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfErrorThenUint8) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfErrorThenUint8) Call(ctx context.Context, arg error) (uint8, error) {
	return __.api_syncer.DoOfErrorThenUint8(ctx, __, arg)
}

type PoolOfErrorThenUintptr interface {
	GetErrorArg() *error
	PutErrorArg(*error)
	GetUintptrReturn() *uintptr
	PutUintptrReturn(*uintptr)

	GetWorkOfErrorThenUintptr() *WorkOfErrorThenUintptr
	GetReturnOfUintptr() *ReturnOfUintptr
	PutWorkOfErrorThenUintptr(*WorkOfErrorThenUintptr)
	PutReturnOfUintptr(*ReturnOfUintptr)

	GetChReturnOfUintptr() chan *ReturnOfUintptr
	PutChReturnOfUintptr(chan *ReturnOfUintptr)
}

type PoolOfErrorThenUintptrImpl struct {
	ErrorArg          sync.Pool
	UintptrRtn        sync.Pool
	ErrorWork         sync.Pool
	UintptrReturn     sync.Pool
	ChReturnOfUintptr sync.Pool
}

func (__ *PoolOfErrorThenUintptrImpl) GetErrorArg() *error {
	return __.ErrorArg.Get().(*error)
}
func (__ *PoolOfErrorThenUintptrImpl) PutErrorArg(p *error) {
	__.ErrorArg.Put(p)
}
func (__ *PoolOfErrorThenUintptrImpl) GetUintptrReturn() *uintptr {
	return __.UintptrRtn.Get().(*uintptr)
}
func (__ *PoolOfErrorThenUintptrImpl) PutUintptrReturn(p *uintptr) {
	__.UintptrRtn.Put(p)
}

func (__ *PoolOfErrorThenUintptrImpl) GetWorkOfErrorThenUintptr() *WorkOfErrorThenUintptr {
	return __.ErrorWork.Get().(*WorkOfErrorThenUintptr)
}
func (__ *PoolOfErrorThenUintptrImpl) PutWorkOfErrorThenUintptr(p *WorkOfErrorThenUintptr) {
	__.ErrorWork.Put(p)
}
func (__ *PoolOfErrorThenUintptrImpl) GetReturnOfUintptr() *ReturnOfUintptr {
	return __.UintptrReturn.Get().(*ReturnOfUintptr)
}
func (__ *PoolOfErrorThenUintptrImpl) PutReturnOfUintptr(p *ReturnOfUintptr) {
	__.UintptrReturn.Put(p)
}

func (__ *PoolOfErrorThenUintptrImpl) GetChReturnOfUintptr() chan *ReturnOfUintptr {
	return __.ChReturnOfUintptr.Get().(chan *ReturnOfUintptr)
}
func (__ *PoolOfErrorThenUintptrImpl) PutChReturnOfUintptr(p chan *ReturnOfUintptr) {
	__.ChReturnOfUintptr.Put(p)
}

func NewPoolOfErrorThenUintptrImpl() *PoolOfErrorThenUintptrImpl {
	return &PoolOfErrorThenUintptrImpl{
		ErrorArg: sync.Pool{
			New: func() interface{} {
				return new(error)
			},
		},
		ErrorWork: sync.Pool{
			New: func() interface{} {
				return new(WorkOfErrorThenUintptr)
			},
		},
		UintptrRtn: sync.Pool{
			New: func() interface{} {
				return new(uintptr)
			},
		},
		UintptrReturn: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfUintptr)
			},
		},
		ChReturnOfUintptr: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfUintptr, 1)
			},
		},
	}
}

type ApiDecouplerOfErrorThenUintptr struct {
	pool PoolOfErrorThenUintptr
}

func NewApiDecouplerOfErrorThenUintptr() *ApiDecouplerOfErrorThenUintptr {
	return &ApiDecouplerOfErrorThenUintptr{
		pool: NewPoolOfErrorThenUintptrImpl(),
	}
}

func (__ *ApiDecouplerOfErrorThenUintptr) ReturnError(rtn_ch chan<- *ReturnOfUintptr, err error) {
	rtn := __.pool.GetReturnOfUintptr()
	var other uintptr
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfErrorThenUintptr) HandleOfErrorThenUintptr(ctx context.Context, req *WorkOfErrorThenUintptr, h func(ctx context.Context, arg error) (uintptr, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfUintptr()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfErrorThenUintptr) DoOfErrorThenUintptr(ctx context.Context, worker WorkerOfPushErrorThenUintptr, arg error) (uintptr, error) {
	// ch := make(chan *ReturnOfUintptr, 1)
	ch := __.pool.GetChReturnOfUintptr()
	defer __.pool.PutChReturnOfUintptr(ch)

	req := __.pool.GetWorkOfErrorThenUintptr()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfErrorThenUintptr(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfUintptr(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfErrorThenUintptr = func(ctx context.Context, arg error) (uintptr, error)

type WorkerOfErrorThenUintptr struct {
	api_syncer *ApiDecouplerOfErrorThenUintptr
	handler    WorkHandlerOfErrorThenUintptr

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfErrorThenUintptr
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfErrorThenUintptr(ctx context.Context, h WorkHandlerOfErrorThenUintptr, n int) *WorkerOfErrorThenUintptr {
	__ := &WorkerOfErrorThenUintptr{
		api_syncer: NewApiDecouplerOfErrorThenUintptr(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfErrorThenUintptr, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfErrorThenUintptr{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfErrorThenUintptr(req.Context, req.WorkOfErrorThenUintptr, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfErrorThenUintptr) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfErrorThenUintptr) Push(ctx context.Context, req *WorkOfErrorThenUintptr) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfErrorThenUintptr)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfErrorThenUintptr = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfErrorThenUintptr) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfErrorThenUintptr) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfErrorThenUintptr) Call(ctx context.Context, arg error) (uintptr, error) {
	return __.api_syncer.DoOfErrorThenUintptr(ctx, __, arg)
}

type PoolOfErrorThenInterface interface {
	GetErrorArg() *error
	PutErrorArg(*error)
	GetInterfaceReturn() *interface{}
	PutInterfaceReturn(*interface{})

	GetWorkOfErrorThenInterface() *WorkOfErrorThenInterface
	GetReturnOfInterface() *ReturnOfInterface
	PutWorkOfErrorThenInterface(*WorkOfErrorThenInterface)
	PutReturnOfInterface(*ReturnOfInterface)

	GetChReturnOfInterface() chan *ReturnOfInterface
	PutChReturnOfInterface(chan *ReturnOfInterface)
}

type PoolOfErrorThenInterfaceImpl struct {
	ErrorArg            sync.Pool
	InterfaceRtn        sync.Pool
	ErrorWork           sync.Pool
	InterfaceReturn     sync.Pool
	ChReturnOfInterface sync.Pool
}

func (__ *PoolOfErrorThenInterfaceImpl) GetErrorArg() *error {
	return __.ErrorArg.Get().(*error)
}
func (__ *PoolOfErrorThenInterfaceImpl) PutErrorArg(p *error) {
	__.ErrorArg.Put(p)
}
func (__ *PoolOfErrorThenInterfaceImpl) GetInterfaceReturn() *interface{} {
	return __.InterfaceRtn.Get().(*interface{})
}
func (__ *PoolOfErrorThenInterfaceImpl) PutInterfaceReturn(p *interface{}) {
	__.InterfaceRtn.Put(p)
}

func (__ *PoolOfErrorThenInterfaceImpl) GetWorkOfErrorThenInterface() *WorkOfErrorThenInterface {
	return __.ErrorWork.Get().(*WorkOfErrorThenInterface)
}
func (__ *PoolOfErrorThenInterfaceImpl) PutWorkOfErrorThenInterface(p *WorkOfErrorThenInterface) {
	__.ErrorWork.Put(p)
}
func (__ *PoolOfErrorThenInterfaceImpl) GetReturnOfInterface() *ReturnOfInterface {
	return __.InterfaceReturn.Get().(*ReturnOfInterface)
}
func (__ *PoolOfErrorThenInterfaceImpl) PutReturnOfInterface(p *ReturnOfInterface) {
	__.InterfaceReturn.Put(p)
}

func (__ *PoolOfErrorThenInterfaceImpl) GetChReturnOfInterface() chan *ReturnOfInterface {
	return __.ChReturnOfInterface.Get().(chan *ReturnOfInterface)
}
func (__ *PoolOfErrorThenInterfaceImpl) PutChReturnOfInterface(p chan *ReturnOfInterface) {
	__.ChReturnOfInterface.Put(p)
}

func NewPoolOfErrorThenInterfaceImpl() *PoolOfErrorThenInterfaceImpl {
	return &PoolOfErrorThenInterfaceImpl{
		ErrorArg: sync.Pool{
			New: func() interface{} {
				return new(error)
			},
		},
		ErrorWork: sync.Pool{
			New: func() interface{} {
				return new(WorkOfErrorThenInterface)
			},
		},
		InterfaceRtn: sync.Pool{
			New: func() interface{} {
				return new(interface{})
			},
		},
		InterfaceReturn: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfInterface)
			},
		},
		ChReturnOfInterface: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfInterface, 1)
			},
		},
	}
}

type ApiDecouplerOfErrorThenInterface struct {
	pool PoolOfErrorThenInterface
}

func NewApiDecouplerOfErrorThenInterface() *ApiDecouplerOfErrorThenInterface {
	return &ApiDecouplerOfErrorThenInterface{
		pool: NewPoolOfErrorThenInterfaceImpl(),
	}
}

func (__ *ApiDecouplerOfErrorThenInterface) ReturnError(rtn_ch chan<- *ReturnOfInterface, err error) {
	rtn := __.pool.GetReturnOfInterface()
	var other interface{}
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfErrorThenInterface) HandleOfErrorThenInterface(ctx context.Context, req *WorkOfErrorThenInterface, h func(ctx context.Context, arg error) (interface{}, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfInterface()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfErrorThenInterface) DoOfErrorThenInterface(ctx context.Context, worker WorkerOfPushErrorThenInterface, arg error) (interface{}, error) {
	// ch := make(chan *ReturnOfInterface, 1)
	ch := __.pool.GetChReturnOfInterface()
	defer __.pool.PutChReturnOfInterface(ch)

	req := __.pool.GetWorkOfErrorThenInterface()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfErrorThenInterface(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfInterface(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfErrorThenInterface = func(ctx context.Context, arg error) (interface{}, error)

type WorkerOfErrorThenInterface struct {
	api_syncer *ApiDecouplerOfErrorThenInterface
	handler    WorkHandlerOfErrorThenInterface

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfErrorThenInterface
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfErrorThenInterface(ctx context.Context, h WorkHandlerOfErrorThenInterface, n int) *WorkerOfErrorThenInterface {
	__ := &WorkerOfErrorThenInterface{
		api_syncer: NewApiDecouplerOfErrorThenInterface(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfErrorThenInterface, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfErrorThenInterface{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfErrorThenInterface(req.Context, req.WorkOfErrorThenInterface, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfErrorThenInterface) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfErrorThenInterface) Push(ctx context.Context, req *WorkOfErrorThenInterface) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfErrorThenInterface)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfErrorThenInterface = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfErrorThenInterface) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfErrorThenInterface) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfErrorThenInterface) Call(ctx context.Context, arg error) (interface{}, error) {
	return __.api_syncer.DoOfErrorThenInterface(ctx, __, arg)
}

type PoolOfErrorThenStruct interface {
	GetErrorArg() *error
	PutErrorArg(*error)
	GetStructReturn() *struct{}
	PutStructReturn(*struct{})

	GetWorkOfErrorThenStruct() *WorkOfErrorThenStruct
	GetReturnOfStruct() *ReturnOfStruct
	PutWorkOfErrorThenStruct(*WorkOfErrorThenStruct)
	PutReturnOfStruct(*ReturnOfStruct)

	GetChReturnOfStruct() chan *ReturnOfStruct
	PutChReturnOfStruct(chan *ReturnOfStruct)
}

type PoolOfErrorThenStructImpl struct {
	ErrorArg         sync.Pool
	StructRtn        sync.Pool
	ErrorWork        sync.Pool
	StructReturn     sync.Pool
	ChReturnOfStruct sync.Pool
}

func (__ *PoolOfErrorThenStructImpl) GetErrorArg() *error {
	return __.ErrorArg.Get().(*error)
}
func (__ *PoolOfErrorThenStructImpl) PutErrorArg(p *error) {
	__.ErrorArg.Put(p)
}
func (__ *PoolOfErrorThenStructImpl) GetStructReturn() *struct{} {
	return __.StructRtn.Get().(*struct{})
}
func (__ *PoolOfErrorThenStructImpl) PutStructReturn(p *struct{}) {
	__.StructRtn.Put(p)
}

func (__ *PoolOfErrorThenStructImpl) GetWorkOfErrorThenStruct() *WorkOfErrorThenStruct {
	return __.ErrorWork.Get().(*WorkOfErrorThenStruct)
}
func (__ *PoolOfErrorThenStructImpl) PutWorkOfErrorThenStruct(p *WorkOfErrorThenStruct) {
	__.ErrorWork.Put(p)
}
func (__ *PoolOfErrorThenStructImpl) GetReturnOfStruct() *ReturnOfStruct {
	return __.StructReturn.Get().(*ReturnOfStruct)
}
func (__ *PoolOfErrorThenStructImpl) PutReturnOfStruct(p *ReturnOfStruct) {
	__.StructReturn.Put(p)
}

func (__ *PoolOfErrorThenStructImpl) GetChReturnOfStruct() chan *ReturnOfStruct {
	return __.ChReturnOfStruct.Get().(chan *ReturnOfStruct)
}
func (__ *PoolOfErrorThenStructImpl) PutChReturnOfStruct(p chan *ReturnOfStruct) {
	__.ChReturnOfStruct.Put(p)
}

func NewPoolOfErrorThenStructImpl() *PoolOfErrorThenStructImpl {
	return &PoolOfErrorThenStructImpl{
		ErrorArg: sync.Pool{
			New: func() interface{} {
				return new(error)
			},
		},
		ErrorWork: sync.Pool{
			New: func() interface{} {
				return new(WorkOfErrorThenStruct)
			},
		},
		StructRtn: sync.Pool{
			New: func() interface{} {
				return new(struct{})
			},
		},
		StructReturn: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfStruct)
			},
		},
		ChReturnOfStruct: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfStruct, 1)
			},
		},
	}
}

type ApiDecouplerOfErrorThenStruct struct {
	pool PoolOfErrorThenStruct
}

func NewApiDecouplerOfErrorThenStruct() *ApiDecouplerOfErrorThenStruct {
	return &ApiDecouplerOfErrorThenStruct{
		pool: NewPoolOfErrorThenStructImpl(),
	}
}

func (__ *ApiDecouplerOfErrorThenStruct) ReturnError(rtn_ch chan<- *ReturnOfStruct, err error) {
	rtn := __.pool.GetReturnOfStruct()
	var other struct{}
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfErrorThenStruct) HandleOfErrorThenStruct(ctx context.Context, req *WorkOfErrorThenStruct, h func(ctx context.Context, arg error) (struct{}, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfStruct()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfErrorThenStruct) DoOfErrorThenStruct(ctx context.Context, worker WorkerOfPushErrorThenStruct, arg error) (struct{}, error) {
	// ch := make(chan *ReturnOfStruct, 1)
	ch := __.pool.GetChReturnOfStruct()
	defer __.pool.PutChReturnOfStruct(ch)

	req := __.pool.GetWorkOfErrorThenStruct()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfErrorThenStruct(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfStruct(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfErrorThenStruct = func(ctx context.Context, arg error) (struct{}, error)

type WorkerOfErrorThenStruct struct {
	api_syncer *ApiDecouplerOfErrorThenStruct
	handler    WorkHandlerOfErrorThenStruct

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfErrorThenStruct
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfErrorThenStruct(ctx context.Context, h WorkHandlerOfErrorThenStruct, n int) *WorkerOfErrorThenStruct {
	__ := &WorkerOfErrorThenStruct{
		api_syncer: NewApiDecouplerOfErrorThenStruct(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfErrorThenStruct, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfErrorThenStruct{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfErrorThenStruct(req.Context, req.WorkOfErrorThenStruct, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfErrorThenStruct) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfErrorThenStruct) Push(ctx context.Context, req *WorkOfErrorThenStruct) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfErrorThenStruct)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfErrorThenStruct = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfErrorThenStruct) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfErrorThenStruct) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfErrorThenStruct) Call(ctx context.Context, arg error) (struct{}, error) {
	return __.api_syncer.DoOfErrorThenStruct(ctx, __, arg)
}

type PoolOfFloat32ThenBool interface {
	GetFloat32Arg() *float32
	PutFloat32Arg(*float32)
	GetBoolReturn() *bool
	PutBoolReturn(*bool)

	GetWorkOfFloat32ThenBool() *WorkOfFloat32ThenBool
	GetReturnOfBool() *ReturnOfBool
	PutWorkOfFloat32ThenBool(*WorkOfFloat32ThenBool)
	PutReturnOfBool(*ReturnOfBool)

	GetChReturnOfBool() chan *ReturnOfBool
	PutChReturnOfBool(chan *ReturnOfBool)
}

type PoolOfFloat32ThenBoolImpl struct {
	Float32Arg     sync.Pool
	BoolRtn        sync.Pool
	Float32Work    sync.Pool
	BoolReturn     sync.Pool
	ChReturnOfBool sync.Pool
}

func (__ *PoolOfFloat32ThenBoolImpl) GetFloat32Arg() *float32 {
	return __.Float32Arg.Get().(*float32)
}
func (__ *PoolOfFloat32ThenBoolImpl) PutFloat32Arg(p *float32) {
	__.Float32Arg.Put(p)
}
func (__ *PoolOfFloat32ThenBoolImpl) GetBoolReturn() *bool {
	return __.BoolRtn.Get().(*bool)
}
func (__ *PoolOfFloat32ThenBoolImpl) PutBoolReturn(p *bool) {
	__.BoolRtn.Put(p)
}

func (__ *PoolOfFloat32ThenBoolImpl) GetWorkOfFloat32ThenBool() *WorkOfFloat32ThenBool {
	return __.Float32Work.Get().(*WorkOfFloat32ThenBool)
}
func (__ *PoolOfFloat32ThenBoolImpl) PutWorkOfFloat32ThenBool(p *WorkOfFloat32ThenBool) {
	__.Float32Work.Put(p)
}
func (__ *PoolOfFloat32ThenBoolImpl) GetReturnOfBool() *ReturnOfBool {
	return __.BoolReturn.Get().(*ReturnOfBool)
}
func (__ *PoolOfFloat32ThenBoolImpl) PutReturnOfBool(p *ReturnOfBool) {
	__.BoolReturn.Put(p)
}

func (__ *PoolOfFloat32ThenBoolImpl) GetChReturnOfBool() chan *ReturnOfBool {
	return __.ChReturnOfBool.Get().(chan *ReturnOfBool)
}
func (__ *PoolOfFloat32ThenBoolImpl) PutChReturnOfBool(p chan *ReturnOfBool) {
	__.ChReturnOfBool.Put(p)
}

func NewPoolOfFloat32ThenBoolImpl() *PoolOfFloat32ThenBoolImpl {
	return &PoolOfFloat32ThenBoolImpl{
		Float32Arg: sync.Pool{
			New: func() interface{} {
				return new(float32)
			},
		},
		Float32Work: sync.Pool{
			New: func() interface{} {
				return new(WorkOfFloat32ThenBool)
			},
		},
		BoolRtn: sync.Pool{
			New: func() interface{} {
				return new(bool)
			},
		},
		BoolReturn: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfBool)
			},
		},
		ChReturnOfBool: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfBool, 1)
			},
		},
	}
}

type ApiDecouplerOfFloat32ThenBool struct {
	pool PoolOfFloat32ThenBool
}

func NewApiDecouplerOfFloat32ThenBool() *ApiDecouplerOfFloat32ThenBool {
	return &ApiDecouplerOfFloat32ThenBool{
		pool: NewPoolOfFloat32ThenBoolImpl(),
	}
}

func (__ *ApiDecouplerOfFloat32ThenBool) ReturnError(rtn_ch chan<- *ReturnOfBool, err error) {
	rtn := __.pool.GetReturnOfBool()
	var other bool
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfFloat32ThenBool) HandleOfFloat32ThenBool(ctx context.Context, req *WorkOfFloat32ThenBool, h func(ctx context.Context, arg float32) (bool, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfBool()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfFloat32ThenBool) DoOfFloat32ThenBool(ctx context.Context, worker WorkerOfPushFloat32ThenBool, arg float32) (bool, error) {
	// ch := make(chan *ReturnOfBool, 1)
	ch := __.pool.GetChReturnOfBool()
	defer __.pool.PutChReturnOfBool(ch)

	req := __.pool.GetWorkOfFloat32ThenBool()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfFloat32ThenBool(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfBool(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfFloat32ThenBool = func(ctx context.Context, arg float32) (bool, error)

type WorkerOfFloat32ThenBool struct {
	api_syncer *ApiDecouplerOfFloat32ThenBool
	handler    WorkHandlerOfFloat32ThenBool

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfFloat32ThenBool
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfFloat32ThenBool(ctx context.Context, h WorkHandlerOfFloat32ThenBool, n int) *WorkerOfFloat32ThenBool {
	__ := &WorkerOfFloat32ThenBool{
		api_syncer: NewApiDecouplerOfFloat32ThenBool(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfFloat32ThenBool, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfFloat32ThenBool{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfFloat32ThenBool(req.Context, req.WorkOfFloat32ThenBool, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfFloat32ThenBool) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfFloat32ThenBool) Push(ctx context.Context, req *WorkOfFloat32ThenBool) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfFloat32ThenBool)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfFloat32ThenBool = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfFloat32ThenBool) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfFloat32ThenBool) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfFloat32ThenBool) Call(ctx context.Context, arg float32) (bool, error) {
	return __.api_syncer.DoOfFloat32ThenBool(ctx, __, arg)
}

type PoolOfFloat32ThenByte interface {
	GetFloat32Arg() *float32
	PutFloat32Arg(*float32)
	GetByteReturn() *byte
	PutByteReturn(*byte)

	GetWorkOfFloat32ThenByte() *WorkOfFloat32ThenByte
	GetReturnOfByte() *ReturnOfByte
	PutWorkOfFloat32ThenByte(*WorkOfFloat32ThenByte)
	PutReturnOfByte(*ReturnOfByte)

	GetChReturnOfByte() chan *ReturnOfByte
	PutChReturnOfByte(chan *ReturnOfByte)
}

type PoolOfFloat32ThenByteImpl struct {
	Float32Arg     sync.Pool
	ByteRtn        sync.Pool
	Float32Work    sync.Pool
	ByteReturn     sync.Pool
	ChReturnOfByte sync.Pool
}

func (__ *PoolOfFloat32ThenByteImpl) GetFloat32Arg() *float32 {
	return __.Float32Arg.Get().(*float32)
}
func (__ *PoolOfFloat32ThenByteImpl) PutFloat32Arg(p *float32) {
	__.Float32Arg.Put(p)
}
func (__ *PoolOfFloat32ThenByteImpl) GetByteReturn() *byte {
	return __.ByteRtn.Get().(*byte)
}
func (__ *PoolOfFloat32ThenByteImpl) PutByteReturn(p *byte) {
	__.ByteRtn.Put(p)
}

func (__ *PoolOfFloat32ThenByteImpl) GetWorkOfFloat32ThenByte() *WorkOfFloat32ThenByte {
	return __.Float32Work.Get().(*WorkOfFloat32ThenByte)
}
func (__ *PoolOfFloat32ThenByteImpl) PutWorkOfFloat32ThenByte(p *WorkOfFloat32ThenByte) {
	__.Float32Work.Put(p)
}
func (__ *PoolOfFloat32ThenByteImpl) GetReturnOfByte() *ReturnOfByte {
	return __.ByteReturn.Get().(*ReturnOfByte)
}
func (__ *PoolOfFloat32ThenByteImpl) PutReturnOfByte(p *ReturnOfByte) {
	__.ByteReturn.Put(p)
}

func (__ *PoolOfFloat32ThenByteImpl) GetChReturnOfByte() chan *ReturnOfByte {
	return __.ChReturnOfByte.Get().(chan *ReturnOfByte)
}
func (__ *PoolOfFloat32ThenByteImpl) PutChReturnOfByte(p chan *ReturnOfByte) {
	__.ChReturnOfByte.Put(p)
}

func NewPoolOfFloat32ThenByteImpl() *PoolOfFloat32ThenByteImpl {
	return &PoolOfFloat32ThenByteImpl{
		Float32Arg: sync.Pool{
			New: func() interface{} {
				return new(float32)
			},
		},
		Float32Work: sync.Pool{
			New: func() interface{} {
				return new(WorkOfFloat32ThenByte)
			},
		},
		ByteRtn: sync.Pool{
			New: func() interface{} {
				return new(byte)
			},
		},
		ByteReturn: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfByte)
			},
		},
		ChReturnOfByte: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfByte, 1)
			},
		},
	}
}

type ApiDecouplerOfFloat32ThenByte struct {
	pool PoolOfFloat32ThenByte
}

func NewApiDecouplerOfFloat32ThenByte() *ApiDecouplerOfFloat32ThenByte {
	return &ApiDecouplerOfFloat32ThenByte{
		pool: NewPoolOfFloat32ThenByteImpl(),
	}
}

func (__ *ApiDecouplerOfFloat32ThenByte) ReturnError(rtn_ch chan<- *ReturnOfByte, err error) {
	rtn := __.pool.GetReturnOfByte()
	var other byte
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfFloat32ThenByte) HandleOfFloat32ThenByte(ctx context.Context, req *WorkOfFloat32ThenByte, h func(ctx context.Context, arg float32) (byte, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfByte()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfFloat32ThenByte) DoOfFloat32ThenByte(ctx context.Context, worker WorkerOfPushFloat32ThenByte, arg float32) (byte, error) {
	// ch := make(chan *ReturnOfByte, 1)
	ch := __.pool.GetChReturnOfByte()
	defer __.pool.PutChReturnOfByte(ch)

	req := __.pool.GetWorkOfFloat32ThenByte()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfFloat32ThenByte(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfByte(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfFloat32ThenByte = func(ctx context.Context, arg float32) (byte, error)

type WorkerOfFloat32ThenByte struct {
	api_syncer *ApiDecouplerOfFloat32ThenByte
	handler    WorkHandlerOfFloat32ThenByte

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfFloat32ThenByte
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfFloat32ThenByte(ctx context.Context, h WorkHandlerOfFloat32ThenByte, n int) *WorkerOfFloat32ThenByte {
	__ := &WorkerOfFloat32ThenByte{
		api_syncer: NewApiDecouplerOfFloat32ThenByte(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfFloat32ThenByte, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfFloat32ThenByte{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfFloat32ThenByte(req.Context, req.WorkOfFloat32ThenByte, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfFloat32ThenByte) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfFloat32ThenByte) Push(ctx context.Context, req *WorkOfFloat32ThenByte) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfFloat32ThenByte)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfFloat32ThenByte = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfFloat32ThenByte) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfFloat32ThenByte) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfFloat32ThenByte) Call(ctx context.Context, arg float32) (byte, error) {
	return __.api_syncer.DoOfFloat32ThenByte(ctx, __, arg)
}

type PoolOfFloat32ThenComplex128 interface {
	GetFloat32Arg() *float32
	PutFloat32Arg(*float32)
	GetComplex128Return() *complex128
	PutComplex128Return(*complex128)

	GetWorkOfFloat32ThenComplex128() *WorkOfFloat32ThenComplex128
	GetReturnOfComplex128() *ReturnOfComplex128
	PutWorkOfFloat32ThenComplex128(*WorkOfFloat32ThenComplex128)
	PutReturnOfComplex128(*ReturnOfComplex128)

	GetChReturnOfComplex128() chan *ReturnOfComplex128
	PutChReturnOfComplex128(chan *ReturnOfComplex128)
}

type PoolOfFloat32ThenComplex128Impl struct {
	Float32Arg           sync.Pool
	Complex128Rtn        sync.Pool
	Float32Work          sync.Pool
	Complex128Return     sync.Pool
	ChReturnOfComplex128 sync.Pool
}

func (__ *PoolOfFloat32ThenComplex128Impl) GetFloat32Arg() *float32 {
	return __.Float32Arg.Get().(*float32)
}
func (__ *PoolOfFloat32ThenComplex128Impl) PutFloat32Arg(p *float32) {
	__.Float32Arg.Put(p)
}
func (__ *PoolOfFloat32ThenComplex128Impl) GetComplex128Return() *complex128 {
	return __.Complex128Rtn.Get().(*complex128)
}
func (__ *PoolOfFloat32ThenComplex128Impl) PutComplex128Return(p *complex128) {
	__.Complex128Rtn.Put(p)
}

func (__ *PoolOfFloat32ThenComplex128Impl) GetWorkOfFloat32ThenComplex128() *WorkOfFloat32ThenComplex128 {
	return __.Float32Work.Get().(*WorkOfFloat32ThenComplex128)
}
func (__ *PoolOfFloat32ThenComplex128Impl) PutWorkOfFloat32ThenComplex128(p *WorkOfFloat32ThenComplex128) {
	__.Float32Work.Put(p)
}
func (__ *PoolOfFloat32ThenComplex128Impl) GetReturnOfComplex128() *ReturnOfComplex128 {
	return __.Complex128Return.Get().(*ReturnOfComplex128)
}
func (__ *PoolOfFloat32ThenComplex128Impl) PutReturnOfComplex128(p *ReturnOfComplex128) {
	__.Complex128Return.Put(p)
}

func (__ *PoolOfFloat32ThenComplex128Impl) GetChReturnOfComplex128() chan *ReturnOfComplex128 {
	return __.ChReturnOfComplex128.Get().(chan *ReturnOfComplex128)
}
func (__ *PoolOfFloat32ThenComplex128Impl) PutChReturnOfComplex128(p chan *ReturnOfComplex128) {
	__.ChReturnOfComplex128.Put(p)
}

func NewPoolOfFloat32ThenComplex128Impl() *PoolOfFloat32ThenComplex128Impl {
	return &PoolOfFloat32ThenComplex128Impl{
		Float32Arg: sync.Pool{
			New: func() interface{} {
				return new(float32)
			},
		},
		Float32Work: sync.Pool{
			New: func() interface{} {
				return new(WorkOfFloat32ThenComplex128)
			},
		},
		Complex128Rtn: sync.Pool{
			New: func() interface{} {
				return new(complex128)
			},
		},
		Complex128Return: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfComplex128)
			},
		},
		ChReturnOfComplex128: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfComplex128, 1)
			},
		},
	}
}

type ApiDecouplerOfFloat32ThenComplex128 struct {
	pool PoolOfFloat32ThenComplex128
}

func NewApiDecouplerOfFloat32ThenComplex128() *ApiDecouplerOfFloat32ThenComplex128 {
	return &ApiDecouplerOfFloat32ThenComplex128{
		pool: NewPoolOfFloat32ThenComplex128Impl(),
	}
}

func (__ *ApiDecouplerOfFloat32ThenComplex128) ReturnError(rtn_ch chan<- *ReturnOfComplex128, err error) {
	rtn := __.pool.GetReturnOfComplex128()
	var other complex128
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfFloat32ThenComplex128) HandleOfFloat32ThenComplex128(ctx context.Context, req *WorkOfFloat32ThenComplex128, h func(ctx context.Context, arg float32) (complex128, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfComplex128()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfFloat32ThenComplex128) DoOfFloat32ThenComplex128(ctx context.Context, worker WorkerOfPushFloat32ThenComplex128, arg float32) (complex128, error) {
	// ch := make(chan *ReturnOfComplex128, 1)
	ch := __.pool.GetChReturnOfComplex128()
	defer __.pool.PutChReturnOfComplex128(ch)

	req := __.pool.GetWorkOfFloat32ThenComplex128()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfFloat32ThenComplex128(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfComplex128(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfFloat32ThenComplex128 = func(ctx context.Context, arg float32) (complex128, error)

type WorkerOfFloat32ThenComplex128 struct {
	api_syncer *ApiDecouplerOfFloat32ThenComplex128
	handler    WorkHandlerOfFloat32ThenComplex128

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfFloat32ThenComplex128
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfFloat32ThenComplex128(ctx context.Context, h WorkHandlerOfFloat32ThenComplex128, n int) *WorkerOfFloat32ThenComplex128 {
	__ := &WorkerOfFloat32ThenComplex128{
		api_syncer: NewApiDecouplerOfFloat32ThenComplex128(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfFloat32ThenComplex128, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfFloat32ThenComplex128{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfFloat32ThenComplex128(req.Context, req.WorkOfFloat32ThenComplex128, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfFloat32ThenComplex128) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfFloat32ThenComplex128) Push(ctx context.Context, req *WorkOfFloat32ThenComplex128) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfFloat32ThenComplex128)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfFloat32ThenComplex128 = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfFloat32ThenComplex128) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfFloat32ThenComplex128) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfFloat32ThenComplex128) Call(ctx context.Context, arg float32) (complex128, error) {
	return __.api_syncer.DoOfFloat32ThenComplex128(ctx, __, arg)
}

type PoolOfFloat32ThenComplex64 interface {
	GetFloat32Arg() *float32
	PutFloat32Arg(*float32)
	GetComplex64Return() *complex64
	PutComplex64Return(*complex64)

	GetWorkOfFloat32ThenComplex64() *WorkOfFloat32ThenComplex64
	GetReturnOfComplex64() *ReturnOfComplex64
	PutWorkOfFloat32ThenComplex64(*WorkOfFloat32ThenComplex64)
	PutReturnOfComplex64(*ReturnOfComplex64)

	GetChReturnOfComplex64() chan *ReturnOfComplex64
	PutChReturnOfComplex64(chan *ReturnOfComplex64)
}

type PoolOfFloat32ThenComplex64Impl struct {
	Float32Arg          sync.Pool
	Complex64Rtn        sync.Pool
	Float32Work         sync.Pool
	Complex64Return     sync.Pool
	ChReturnOfComplex64 sync.Pool
}

func (__ *PoolOfFloat32ThenComplex64Impl) GetFloat32Arg() *float32 {
	return __.Float32Arg.Get().(*float32)
}
func (__ *PoolOfFloat32ThenComplex64Impl) PutFloat32Arg(p *float32) {
	__.Float32Arg.Put(p)
}
func (__ *PoolOfFloat32ThenComplex64Impl) GetComplex64Return() *complex64 {
	return __.Complex64Rtn.Get().(*complex64)
}
func (__ *PoolOfFloat32ThenComplex64Impl) PutComplex64Return(p *complex64) {
	__.Complex64Rtn.Put(p)
}

func (__ *PoolOfFloat32ThenComplex64Impl) GetWorkOfFloat32ThenComplex64() *WorkOfFloat32ThenComplex64 {
	return __.Float32Work.Get().(*WorkOfFloat32ThenComplex64)
}
func (__ *PoolOfFloat32ThenComplex64Impl) PutWorkOfFloat32ThenComplex64(p *WorkOfFloat32ThenComplex64) {
	__.Float32Work.Put(p)
}
func (__ *PoolOfFloat32ThenComplex64Impl) GetReturnOfComplex64() *ReturnOfComplex64 {
	return __.Complex64Return.Get().(*ReturnOfComplex64)
}
func (__ *PoolOfFloat32ThenComplex64Impl) PutReturnOfComplex64(p *ReturnOfComplex64) {
	__.Complex64Return.Put(p)
}

func (__ *PoolOfFloat32ThenComplex64Impl) GetChReturnOfComplex64() chan *ReturnOfComplex64 {
	return __.ChReturnOfComplex64.Get().(chan *ReturnOfComplex64)
}
func (__ *PoolOfFloat32ThenComplex64Impl) PutChReturnOfComplex64(p chan *ReturnOfComplex64) {
	__.ChReturnOfComplex64.Put(p)
}

func NewPoolOfFloat32ThenComplex64Impl() *PoolOfFloat32ThenComplex64Impl {
	return &PoolOfFloat32ThenComplex64Impl{
		Float32Arg: sync.Pool{
			New: func() interface{} {
				return new(float32)
			},
		},
		Float32Work: sync.Pool{
			New: func() interface{} {
				return new(WorkOfFloat32ThenComplex64)
			},
		},
		Complex64Rtn: sync.Pool{
			New: func() interface{} {
				return new(complex64)
			},
		},
		Complex64Return: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfComplex64)
			},
		},
		ChReturnOfComplex64: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfComplex64, 1)
			},
		},
	}
}

type ApiDecouplerOfFloat32ThenComplex64 struct {
	pool PoolOfFloat32ThenComplex64
}

func NewApiDecouplerOfFloat32ThenComplex64() *ApiDecouplerOfFloat32ThenComplex64 {
	return &ApiDecouplerOfFloat32ThenComplex64{
		pool: NewPoolOfFloat32ThenComplex64Impl(),
	}
}

func (__ *ApiDecouplerOfFloat32ThenComplex64) ReturnError(rtn_ch chan<- *ReturnOfComplex64, err error) {
	rtn := __.pool.GetReturnOfComplex64()
	var other complex64
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfFloat32ThenComplex64) HandleOfFloat32ThenComplex64(ctx context.Context, req *WorkOfFloat32ThenComplex64, h func(ctx context.Context, arg float32) (complex64, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfComplex64()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfFloat32ThenComplex64) DoOfFloat32ThenComplex64(ctx context.Context, worker WorkerOfPushFloat32ThenComplex64, arg float32) (complex64, error) {
	// ch := make(chan *ReturnOfComplex64, 1)
	ch := __.pool.GetChReturnOfComplex64()
	defer __.pool.PutChReturnOfComplex64(ch)

	req := __.pool.GetWorkOfFloat32ThenComplex64()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfFloat32ThenComplex64(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfComplex64(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfFloat32ThenComplex64 = func(ctx context.Context, arg float32) (complex64, error)

type WorkerOfFloat32ThenComplex64 struct {
	api_syncer *ApiDecouplerOfFloat32ThenComplex64
	handler    WorkHandlerOfFloat32ThenComplex64

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfFloat32ThenComplex64
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfFloat32ThenComplex64(ctx context.Context, h WorkHandlerOfFloat32ThenComplex64, n int) *WorkerOfFloat32ThenComplex64 {
	__ := &WorkerOfFloat32ThenComplex64{
		api_syncer: NewApiDecouplerOfFloat32ThenComplex64(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfFloat32ThenComplex64, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfFloat32ThenComplex64{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfFloat32ThenComplex64(req.Context, req.WorkOfFloat32ThenComplex64, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfFloat32ThenComplex64) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfFloat32ThenComplex64) Push(ctx context.Context, req *WorkOfFloat32ThenComplex64) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfFloat32ThenComplex64)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfFloat32ThenComplex64 = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfFloat32ThenComplex64) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfFloat32ThenComplex64) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfFloat32ThenComplex64) Call(ctx context.Context, arg float32) (complex64, error) {
	return __.api_syncer.DoOfFloat32ThenComplex64(ctx, __, arg)
}

type PoolOfFloat32ThenError interface {
	GetFloat32Arg() *float32
	PutFloat32Arg(*float32)
	GetErrorReturn() *error
	PutErrorReturn(*error)

	GetWorkOfFloat32ThenError() *WorkOfFloat32ThenError
	GetReturnOfError() *ReturnOfError
	PutWorkOfFloat32ThenError(*WorkOfFloat32ThenError)
	PutReturnOfError(*ReturnOfError)

	GetChReturnOfError() chan *ReturnOfError
	PutChReturnOfError(chan *ReturnOfError)
}

type PoolOfFloat32ThenErrorImpl struct {
	Float32Arg      sync.Pool
	ErrorRtn        sync.Pool
	Float32Work     sync.Pool
	ErrorReturn     sync.Pool
	ChReturnOfError sync.Pool
}

func (__ *PoolOfFloat32ThenErrorImpl) GetFloat32Arg() *float32 {
	return __.Float32Arg.Get().(*float32)
}
func (__ *PoolOfFloat32ThenErrorImpl) PutFloat32Arg(p *float32) {
	__.Float32Arg.Put(p)
}
func (__ *PoolOfFloat32ThenErrorImpl) GetErrorReturn() *error {
	return __.ErrorRtn.Get().(*error)
}
func (__ *PoolOfFloat32ThenErrorImpl) PutErrorReturn(p *error) {
	__.ErrorRtn.Put(p)
}

func (__ *PoolOfFloat32ThenErrorImpl) GetWorkOfFloat32ThenError() *WorkOfFloat32ThenError {
	return __.Float32Work.Get().(*WorkOfFloat32ThenError)
}
func (__ *PoolOfFloat32ThenErrorImpl) PutWorkOfFloat32ThenError(p *WorkOfFloat32ThenError) {
	__.Float32Work.Put(p)
}
func (__ *PoolOfFloat32ThenErrorImpl) GetReturnOfError() *ReturnOfError {
	return __.ErrorReturn.Get().(*ReturnOfError)
}
func (__ *PoolOfFloat32ThenErrorImpl) PutReturnOfError(p *ReturnOfError) {
	__.ErrorReturn.Put(p)
}

func (__ *PoolOfFloat32ThenErrorImpl) GetChReturnOfError() chan *ReturnOfError {
	return __.ChReturnOfError.Get().(chan *ReturnOfError)
}
func (__ *PoolOfFloat32ThenErrorImpl) PutChReturnOfError(p chan *ReturnOfError) {
	__.ChReturnOfError.Put(p)
}

func NewPoolOfFloat32ThenErrorImpl() *PoolOfFloat32ThenErrorImpl {
	return &PoolOfFloat32ThenErrorImpl{
		Float32Arg: sync.Pool{
			New: func() interface{} {
				return new(float32)
			},
		},
		Float32Work: sync.Pool{
			New: func() interface{} {
				return new(WorkOfFloat32ThenError)
			},
		},
		ErrorRtn: sync.Pool{
			New: func() interface{} {
				return new(error)
			},
		},
		ErrorReturn: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfError)
			},
		},
		ChReturnOfError: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfError, 1)
			},
		},
	}
}

type ApiDecouplerOfFloat32ThenError struct {
	pool PoolOfFloat32ThenError
}

func NewApiDecouplerOfFloat32ThenError() *ApiDecouplerOfFloat32ThenError {
	return &ApiDecouplerOfFloat32ThenError{
		pool: NewPoolOfFloat32ThenErrorImpl(),
	}
}

func (__ *ApiDecouplerOfFloat32ThenError) ReturnError(rtn_ch chan<- *ReturnOfError, err error) {
	rtn := __.pool.GetReturnOfError()
	var other error
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfFloat32ThenError) HandleOfFloat32ThenError(ctx context.Context, req *WorkOfFloat32ThenError, h func(ctx context.Context, arg float32) (error, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfError()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfFloat32ThenError) DoOfFloat32ThenError(ctx context.Context, worker WorkerOfPushFloat32ThenError, arg float32) (error, error) {
	// ch := make(chan *ReturnOfError, 1)
	ch := __.pool.GetChReturnOfError()
	defer __.pool.PutChReturnOfError(ch)

	req := __.pool.GetWorkOfFloat32ThenError()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfFloat32ThenError(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfError(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfFloat32ThenError = func(ctx context.Context, arg float32) (error, error)

type WorkerOfFloat32ThenError struct {
	api_syncer *ApiDecouplerOfFloat32ThenError
	handler    WorkHandlerOfFloat32ThenError

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfFloat32ThenError
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfFloat32ThenError(ctx context.Context, h WorkHandlerOfFloat32ThenError, n int) *WorkerOfFloat32ThenError {
	__ := &WorkerOfFloat32ThenError{
		api_syncer: NewApiDecouplerOfFloat32ThenError(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfFloat32ThenError, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfFloat32ThenError{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfFloat32ThenError(req.Context, req.WorkOfFloat32ThenError, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfFloat32ThenError) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfFloat32ThenError) Push(ctx context.Context, req *WorkOfFloat32ThenError) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfFloat32ThenError)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfFloat32ThenError = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfFloat32ThenError) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfFloat32ThenError) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfFloat32ThenError) Call(ctx context.Context, arg float32) (error, error) {
	return __.api_syncer.DoOfFloat32ThenError(ctx, __, arg)
}

type PoolOfFloat32ThenFloat32 interface {
	GetFloat32Arg() *float32
	PutFloat32Arg(*float32)
	GetFloat32Return() *float32
	PutFloat32Return(*float32)

	GetWorkOfFloat32ThenFloat32() *WorkOfFloat32ThenFloat32
	GetReturnOfFloat32() *ReturnOfFloat32
	PutWorkOfFloat32ThenFloat32(*WorkOfFloat32ThenFloat32)
	PutReturnOfFloat32(*ReturnOfFloat32)

	GetChReturnOfFloat32() chan *ReturnOfFloat32
	PutChReturnOfFloat32(chan *ReturnOfFloat32)
}

type PoolOfFloat32ThenFloat32Impl struct {
	Float32Arg        sync.Pool
	Float32Rtn        sync.Pool
	Float32Work       sync.Pool
	Float32Return     sync.Pool
	ChReturnOfFloat32 sync.Pool
}

func (__ *PoolOfFloat32ThenFloat32Impl) GetFloat32Arg() *float32 {
	return __.Float32Arg.Get().(*float32)
}
func (__ *PoolOfFloat32ThenFloat32Impl) PutFloat32Arg(p *float32) {
	__.Float32Arg.Put(p)
}
func (__ *PoolOfFloat32ThenFloat32Impl) GetFloat32Return() *float32 {
	return __.Float32Rtn.Get().(*float32)
}
func (__ *PoolOfFloat32ThenFloat32Impl) PutFloat32Return(p *float32) {
	__.Float32Rtn.Put(p)
}

func (__ *PoolOfFloat32ThenFloat32Impl) GetWorkOfFloat32ThenFloat32() *WorkOfFloat32ThenFloat32 {
	return __.Float32Work.Get().(*WorkOfFloat32ThenFloat32)
}
func (__ *PoolOfFloat32ThenFloat32Impl) PutWorkOfFloat32ThenFloat32(p *WorkOfFloat32ThenFloat32) {
	__.Float32Work.Put(p)
}
func (__ *PoolOfFloat32ThenFloat32Impl) GetReturnOfFloat32() *ReturnOfFloat32 {
	return __.Float32Return.Get().(*ReturnOfFloat32)
}
func (__ *PoolOfFloat32ThenFloat32Impl) PutReturnOfFloat32(p *ReturnOfFloat32) {
	__.Float32Return.Put(p)
}

func (__ *PoolOfFloat32ThenFloat32Impl) GetChReturnOfFloat32() chan *ReturnOfFloat32 {
	return __.ChReturnOfFloat32.Get().(chan *ReturnOfFloat32)
}
func (__ *PoolOfFloat32ThenFloat32Impl) PutChReturnOfFloat32(p chan *ReturnOfFloat32) {
	__.ChReturnOfFloat32.Put(p)
}

func NewPoolOfFloat32ThenFloat32Impl() *PoolOfFloat32ThenFloat32Impl {
	return &PoolOfFloat32ThenFloat32Impl{
		Float32Arg: sync.Pool{
			New: func() interface{} {
				return new(float32)
			},
		},
		Float32Work: sync.Pool{
			New: func() interface{} {
				return new(WorkOfFloat32ThenFloat32)
			},
		},
		Float32Rtn: sync.Pool{
			New: func() interface{} {
				return new(float32)
			},
		},
		Float32Return: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfFloat32)
			},
		},
		ChReturnOfFloat32: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfFloat32, 1)
			},
		},
	}
}

type ApiDecouplerOfFloat32ThenFloat32 struct {
	pool PoolOfFloat32ThenFloat32
}

func NewApiDecouplerOfFloat32ThenFloat32() *ApiDecouplerOfFloat32ThenFloat32 {
	return &ApiDecouplerOfFloat32ThenFloat32{
		pool: NewPoolOfFloat32ThenFloat32Impl(),
	}
}

func (__ *ApiDecouplerOfFloat32ThenFloat32) ReturnError(rtn_ch chan<- *ReturnOfFloat32, err error) {
	rtn := __.pool.GetReturnOfFloat32()
	var other float32
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfFloat32ThenFloat32) HandleOfFloat32ThenFloat32(ctx context.Context, req *WorkOfFloat32ThenFloat32, h func(ctx context.Context, arg float32) (float32, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfFloat32()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfFloat32ThenFloat32) DoOfFloat32ThenFloat32(ctx context.Context, worker WorkerOfPushFloat32ThenFloat32, arg float32) (float32, error) {
	// ch := make(chan *ReturnOfFloat32, 1)
	ch := __.pool.GetChReturnOfFloat32()
	defer __.pool.PutChReturnOfFloat32(ch)

	req := __.pool.GetWorkOfFloat32ThenFloat32()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfFloat32ThenFloat32(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfFloat32(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfFloat32ThenFloat32 = func(ctx context.Context, arg float32) (float32, error)

type WorkerOfFloat32ThenFloat32 struct {
	api_syncer *ApiDecouplerOfFloat32ThenFloat32
	handler    WorkHandlerOfFloat32ThenFloat32

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfFloat32ThenFloat32
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfFloat32ThenFloat32(ctx context.Context, h WorkHandlerOfFloat32ThenFloat32, n int) *WorkerOfFloat32ThenFloat32 {
	__ := &WorkerOfFloat32ThenFloat32{
		api_syncer: NewApiDecouplerOfFloat32ThenFloat32(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfFloat32ThenFloat32, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfFloat32ThenFloat32{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfFloat32ThenFloat32(req.Context, req.WorkOfFloat32ThenFloat32, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfFloat32ThenFloat32) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfFloat32ThenFloat32) Push(ctx context.Context, req *WorkOfFloat32ThenFloat32) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfFloat32ThenFloat32)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfFloat32ThenFloat32 = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfFloat32ThenFloat32) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfFloat32ThenFloat32) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfFloat32ThenFloat32) Call(ctx context.Context, arg float32) (float32, error) {
	return __.api_syncer.DoOfFloat32ThenFloat32(ctx, __, arg)
}

type PoolOfFloat32ThenFloat64 interface {
	GetFloat32Arg() *float32
	PutFloat32Arg(*float32)
	GetFloat64Return() *float64
	PutFloat64Return(*float64)

	GetWorkOfFloat32ThenFloat64() *WorkOfFloat32ThenFloat64
	GetReturnOfFloat64() *ReturnOfFloat64
	PutWorkOfFloat32ThenFloat64(*WorkOfFloat32ThenFloat64)
	PutReturnOfFloat64(*ReturnOfFloat64)

	GetChReturnOfFloat64() chan *ReturnOfFloat64
	PutChReturnOfFloat64(chan *ReturnOfFloat64)
}

type PoolOfFloat32ThenFloat64Impl struct {
	Float32Arg        sync.Pool
	Float64Rtn        sync.Pool
	Float32Work       sync.Pool
	Float64Return     sync.Pool
	ChReturnOfFloat64 sync.Pool
}

func (__ *PoolOfFloat32ThenFloat64Impl) GetFloat32Arg() *float32 {
	return __.Float32Arg.Get().(*float32)
}
func (__ *PoolOfFloat32ThenFloat64Impl) PutFloat32Arg(p *float32) {
	__.Float32Arg.Put(p)
}
func (__ *PoolOfFloat32ThenFloat64Impl) GetFloat64Return() *float64 {
	return __.Float64Rtn.Get().(*float64)
}
func (__ *PoolOfFloat32ThenFloat64Impl) PutFloat64Return(p *float64) {
	__.Float64Rtn.Put(p)
}

func (__ *PoolOfFloat32ThenFloat64Impl) GetWorkOfFloat32ThenFloat64() *WorkOfFloat32ThenFloat64 {
	return __.Float32Work.Get().(*WorkOfFloat32ThenFloat64)
}
func (__ *PoolOfFloat32ThenFloat64Impl) PutWorkOfFloat32ThenFloat64(p *WorkOfFloat32ThenFloat64) {
	__.Float32Work.Put(p)
}
func (__ *PoolOfFloat32ThenFloat64Impl) GetReturnOfFloat64() *ReturnOfFloat64 {
	return __.Float64Return.Get().(*ReturnOfFloat64)
}
func (__ *PoolOfFloat32ThenFloat64Impl) PutReturnOfFloat64(p *ReturnOfFloat64) {
	__.Float64Return.Put(p)
}

func (__ *PoolOfFloat32ThenFloat64Impl) GetChReturnOfFloat64() chan *ReturnOfFloat64 {
	return __.ChReturnOfFloat64.Get().(chan *ReturnOfFloat64)
}
func (__ *PoolOfFloat32ThenFloat64Impl) PutChReturnOfFloat64(p chan *ReturnOfFloat64) {
	__.ChReturnOfFloat64.Put(p)
}

func NewPoolOfFloat32ThenFloat64Impl() *PoolOfFloat32ThenFloat64Impl {
	return &PoolOfFloat32ThenFloat64Impl{
		Float32Arg: sync.Pool{
			New: func() interface{} {
				return new(float32)
			},
		},
		Float32Work: sync.Pool{
			New: func() interface{} {
				return new(WorkOfFloat32ThenFloat64)
			},
		},
		Float64Rtn: sync.Pool{
			New: func() interface{} {
				return new(float64)
			},
		},
		Float64Return: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfFloat64)
			},
		},
		ChReturnOfFloat64: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfFloat64, 1)
			},
		},
	}
}

type ApiDecouplerOfFloat32ThenFloat64 struct {
	pool PoolOfFloat32ThenFloat64
}

func NewApiDecouplerOfFloat32ThenFloat64() *ApiDecouplerOfFloat32ThenFloat64 {
	return &ApiDecouplerOfFloat32ThenFloat64{
		pool: NewPoolOfFloat32ThenFloat64Impl(),
	}
}

func (__ *ApiDecouplerOfFloat32ThenFloat64) ReturnError(rtn_ch chan<- *ReturnOfFloat64, err error) {
	rtn := __.pool.GetReturnOfFloat64()
	var other float64
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfFloat32ThenFloat64) HandleOfFloat32ThenFloat64(ctx context.Context, req *WorkOfFloat32ThenFloat64, h func(ctx context.Context, arg float32) (float64, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfFloat64()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfFloat32ThenFloat64) DoOfFloat32ThenFloat64(ctx context.Context, worker WorkerOfPushFloat32ThenFloat64, arg float32) (float64, error) {
	// ch := make(chan *ReturnOfFloat64, 1)
	ch := __.pool.GetChReturnOfFloat64()
	defer __.pool.PutChReturnOfFloat64(ch)

	req := __.pool.GetWorkOfFloat32ThenFloat64()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfFloat32ThenFloat64(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfFloat64(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfFloat32ThenFloat64 = func(ctx context.Context, arg float32) (float64, error)

type WorkerOfFloat32ThenFloat64 struct {
	api_syncer *ApiDecouplerOfFloat32ThenFloat64
	handler    WorkHandlerOfFloat32ThenFloat64

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfFloat32ThenFloat64
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfFloat32ThenFloat64(ctx context.Context, h WorkHandlerOfFloat32ThenFloat64, n int) *WorkerOfFloat32ThenFloat64 {
	__ := &WorkerOfFloat32ThenFloat64{
		api_syncer: NewApiDecouplerOfFloat32ThenFloat64(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfFloat32ThenFloat64, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfFloat32ThenFloat64{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfFloat32ThenFloat64(req.Context, req.WorkOfFloat32ThenFloat64, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfFloat32ThenFloat64) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfFloat32ThenFloat64) Push(ctx context.Context, req *WorkOfFloat32ThenFloat64) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfFloat32ThenFloat64)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfFloat32ThenFloat64 = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfFloat32ThenFloat64) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfFloat32ThenFloat64) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfFloat32ThenFloat64) Call(ctx context.Context, arg float32) (float64, error) {
	return __.api_syncer.DoOfFloat32ThenFloat64(ctx, __, arg)
}

type PoolOfFloat32ThenInt interface {
	GetFloat32Arg() *float32
	PutFloat32Arg(*float32)
	GetIntReturn() *int
	PutIntReturn(*int)

	GetWorkOfFloat32ThenInt() *WorkOfFloat32ThenInt
	GetReturnOfInt() *ReturnOfInt
	PutWorkOfFloat32ThenInt(*WorkOfFloat32ThenInt)
	PutReturnOfInt(*ReturnOfInt)

	GetChReturnOfInt() chan *ReturnOfInt
	PutChReturnOfInt(chan *ReturnOfInt)
}

type PoolOfFloat32ThenIntImpl struct {
	Float32Arg    sync.Pool
	IntRtn        sync.Pool
	Float32Work   sync.Pool
	IntReturn     sync.Pool
	ChReturnOfInt sync.Pool
}

func (__ *PoolOfFloat32ThenIntImpl) GetFloat32Arg() *float32 {
	return __.Float32Arg.Get().(*float32)
}
func (__ *PoolOfFloat32ThenIntImpl) PutFloat32Arg(p *float32) {
	__.Float32Arg.Put(p)
}
func (__ *PoolOfFloat32ThenIntImpl) GetIntReturn() *int {
	return __.IntRtn.Get().(*int)
}
func (__ *PoolOfFloat32ThenIntImpl) PutIntReturn(p *int) {
	__.IntRtn.Put(p)
}

func (__ *PoolOfFloat32ThenIntImpl) GetWorkOfFloat32ThenInt() *WorkOfFloat32ThenInt {
	return __.Float32Work.Get().(*WorkOfFloat32ThenInt)
}
func (__ *PoolOfFloat32ThenIntImpl) PutWorkOfFloat32ThenInt(p *WorkOfFloat32ThenInt) {
	__.Float32Work.Put(p)
}
func (__ *PoolOfFloat32ThenIntImpl) GetReturnOfInt() *ReturnOfInt {
	return __.IntReturn.Get().(*ReturnOfInt)
}
func (__ *PoolOfFloat32ThenIntImpl) PutReturnOfInt(p *ReturnOfInt) {
	__.IntReturn.Put(p)
}

func (__ *PoolOfFloat32ThenIntImpl) GetChReturnOfInt() chan *ReturnOfInt {
	return __.ChReturnOfInt.Get().(chan *ReturnOfInt)
}
func (__ *PoolOfFloat32ThenIntImpl) PutChReturnOfInt(p chan *ReturnOfInt) {
	__.ChReturnOfInt.Put(p)
}

func NewPoolOfFloat32ThenIntImpl() *PoolOfFloat32ThenIntImpl {
	return &PoolOfFloat32ThenIntImpl{
		Float32Arg: sync.Pool{
			New: func() interface{} {
				return new(float32)
			},
		},
		Float32Work: sync.Pool{
			New: func() interface{} {
				return new(WorkOfFloat32ThenInt)
			},
		},
		IntRtn: sync.Pool{
			New: func() interface{} {
				return new(int)
			},
		},
		IntReturn: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfInt)
			},
		},
		ChReturnOfInt: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfInt, 1)
			},
		},
	}
}

type ApiDecouplerOfFloat32ThenInt struct {
	pool PoolOfFloat32ThenInt
}

func NewApiDecouplerOfFloat32ThenInt() *ApiDecouplerOfFloat32ThenInt {
	return &ApiDecouplerOfFloat32ThenInt{
		pool: NewPoolOfFloat32ThenIntImpl(),
	}
}

func (__ *ApiDecouplerOfFloat32ThenInt) ReturnError(rtn_ch chan<- *ReturnOfInt, err error) {
	rtn := __.pool.GetReturnOfInt()
	var other int
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfFloat32ThenInt) HandleOfFloat32ThenInt(ctx context.Context, req *WorkOfFloat32ThenInt, h func(ctx context.Context, arg float32) (int, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfInt()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfFloat32ThenInt) DoOfFloat32ThenInt(ctx context.Context, worker WorkerOfPushFloat32ThenInt, arg float32) (int, error) {
	// ch := make(chan *ReturnOfInt, 1)
	ch := __.pool.GetChReturnOfInt()
	defer __.pool.PutChReturnOfInt(ch)

	req := __.pool.GetWorkOfFloat32ThenInt()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfFloat32ThenInt(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfInt(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfFloat32ThenInt = func(ctx context.Context, arg float32) (int, error)

type WorkerOfFloat32ThenInt struct {
	api_syncer *ApiDecouplerOfFloat32ThenInt
	handler    WorkHandlerOfFloat32ThenInt

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfFloat32ThenInt
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfFloat32ThenInt(ctx context.Context, h WorkHandlerOfFloat32ThenInt, n int) *WorkerOfFloat32ThenInt {
	__ := &WorkerOfFloat32ThenInt{
		api_syncer: NewApiDecouplerOfFloat32ThenInt(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfFloat32ThenInt, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfFloat32ThenInt{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfFloat32ThenInt(req.Context, req.WorkOfFloat32ThenInt, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfFloat32ThenInt) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfFloat32ThenInt) Push(ctx context.Context, req *WorkOfFloat32ThenInt) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfFloat32ThenInt)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfFloat32ThenInt = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfFloat32ThenInt) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfFloat32ThenInt) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfFloat32ThenInt) Call(ctx context.Context, arg float32) (int, error) {
	return __.api_syncer.DoOfFloat32ThenInt(ctx, __, arg)
}

type PoolOfFloat32ThenInt16 interface {
	GetFloat32Arg() *float32
	PutFloat32Arg(*float32)
	GetInt16Return() *int16
	PutInt16Return(*int16)

	GetWorkOfFloat32ThenInt16() *WorkOfFloat32ThenInt16
	GetReturnOfInt16() *ReturnOfInt16
	PutWorkOfFloat32ThenInt16(*WorkOfFloat32ThenInt16)
	PutReturnOfInt16(*ReturnOfInt16)

	GetChReturnOfInt16() chan *ReturnOfInt16
	PutChReturnOfInt16(chan *ReturnOfInt16)
}

type PoolOfFloat32ThenInt16Impl struct {
	Float32Arg      sync.Pool
	Int16Rtn        sync.Pool
	Float32Work     sync.Pool
	Int16Return     sync.Pool
	ChReturnOfInt16 sync.Pool
}

func (__ *PoolOfFloat32ThenInt16Impl) GetFloat32Arg() *float32 {
	return __.Float32Arg.Get().(*float32)
}
func (__ *PoolOfFloat32ThenInt16Impl) PutFloat32Arg(p *float32) {
	__.Float32Arg.Put(p)
}
func (__ *PoolOfFloat32ThenInt16Impl) GetInt16Return() *int16 {
	return __.Int16Rtn.Get().(*int16)
}
func (__ *PoolOfFloat32ThenInt16Impl) PutInt16Return(p *int16) {
	__.Int16Rtn.Put(p)
}

func (__ *PoolOfFloat32ThenInt16Impl) GetWorkOfFloat32ThenInt16() *WorkOfFloat32ThenInt16 {
	return __.Float32Work.Get().(*WorkOfFloat32ThenInt16)
}
func (__ *PoolOfFloat32ThenInt16Impl) PutWorkOfFloat32ThenInt16(p *WorkOfFloat32ThenInt16) {
	__.Float32Work.Put(p)
}
func (__ *PoolOfFloat32ThenInt16Impl) GetReturnOfInt16() *ReturnOfInt16 {
	return __.Int16Return.Get().(*ReturnOfInt16)
}
func (__ *PoolOfFloat32ThenInt16Impl) PutReturnOfInt16(p *ReturnOfInt16) {
	__.Int16Return.Put(p)
}

func (__ *PoolOfFloat32ThenInt16Impl) GetChReturnOfInt16() chan *ReturnOfInt16 {
	return __.ChReturnOfInt16.Get().(chan *ReturnOfInt16)
}
func (__ *PoolOfFloat32ThenInt16Impl) PutChReturnOfInt16(p chan *ReturnOfInt16) {
	__.ChReturnOfInt16.Put(p)
}

func NewPoolOfFloat32ThenInt16Impl() *PoolOfFloat32ThenInt16Impl {
	return &PoolOfFloat32ThenInt16Impl{
		Float32Arg: sync.Pool{
			New: func() interface{} {
				return new(float32)
			},
		},
		Float32Work: sync.Pool{
			New: func() interface{} {
				return new(WorkOfFloat32ThenInt16)
			},
		},
		Int16Rtn: sync.Pool{
			New: func() interface{} {
				return new(int16)
			},
		},
		Int16Return: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfInt16)
			},
		},
		ChReturnOfInt16: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfInt16, 1)
			},
		},
	}
}

type ApiDecouplerOfFloat32ThenInt16 struct {
	pool PoolOfFloat32ThenInt16
}

func NewApiDecouplerOfFloat32ThenInt16() *ApiDecouplerOfFloat32ThenInt16 {
	return &ApiDecouplerOfFloat32ThenInt16{
		pool: NewPoolOfFloat32ThenInt16Impl(),
	}
}

func (__ *ApiDecouplerOfFloat32ThenInt16) ReturnError(rtn_ch chan<- *ReturnOfInt16, err error) {
	rtn := __.pool.GetReturnOfInt16()
	var other int16
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfFloat32ThenInt16) HandleOfFloat32ThenInt16(ctx context.Context, req *WorkOfFloat32ThenInt16, h func(ctx context.Context, arg float32) (int16, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfInt16()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfFloat32ThenInt16) DoOfFloat32ThenInt16(ctx context.Context, worker WorkerOfPushFloat32ThenInt16, arg float32) (int16, error) {
	// ch := make(chan *ReturnOfInt16, 1)
	ch := __.pool.GetChReturnOfInt16()
	defer __.pool.PutChReturnOfInt16(ch)

	req := __.pool.GetWorkOfFloat32ThenInt16()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfFloat32ThenInt16(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfInt16(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfFloat32ThenInt16 = func(ctx context.Context, arg float32) (int16, error)

type WorkerOfFloat32ThenInt16 struct {
	api_syncer *ApiDecouplerOfFloat32ThenInt16
	handler    WorkHandlerOfFloat32ThenInt16

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfFloat32ThenInt16
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfFloat32ThenInt16(ctx context.Context, h WorkHandlerOfFloat32ThenInt16, n int) *WorkerOfFloat32ThenInt16 {
	__ := &WorkerOfFloat32ThenInt16{
		api_syncer: NewApiDecouplerOfFloat32ThenInt16(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfFloat32ThenInt16, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfFloat32ThenInt16{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfFloat32ThenInt16(req.Context, req.WorkOfFloat32ThenInt16, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfFloat32ThenInt16) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfFloat32ThenInt16) Push(ctx context.Context, req *WorkOfFloat32ThenInt16) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfFloat32ThenInt16)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfFloat32ThenInt16 = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfFloat32ThenInt16) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfFloat32ThenInt16) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfFloat32ThenInt16) Call(ctx context.Context, arg float32) (int16, error) {
	return __.api_syncer.DoOfFloat32ThenInt16(ctx, __, arg)
}

type PoolOfFloat32ThenInt32 interface {
	GetFloat32Arg() *float32
	PutFloat32Arg(*float32)
	GetInt32Return() *int32
	PutInt32Return(*int32)

	GetWorkOfFloat32ThenInt32() *WorkOfFloat32ThenInt32
	GetReturnOfInt32() *ReturnOfInt32
	PutWorkOfFloat32ThenInt32(*WorkOfFloat32ThenInt32)
	PutReturnOfInt32(*ReturnOfInt32)

	GetChReturnOfInt32() chan *ReturnOfInt32
	PutChReturnOfInt32(chan *ReturnOfInt32)
}

type PoolOfFloat32ThenInt32Impl struct {
	Float32Arg      sync.Pool
	Int32Rtn        sync.Pool
	Float32Work     sync.Pool
	Int32Return     sync.Pool
	ChReturnOfInt32 sync.Pool
}

func (__ *PoolOfFloat32ThenInt32Impl) GetFloat32Arg() *float32 {
	return __.Float32Arg.Get().(*float32)
}
func (__ *PoolOfFloat32ThenInt32Impl) PutFloat32Arg(p *float32) {
	__.Float32Arg.Put(p)
}
func (__ *PoolOfFloat32ThenInt32Impl) GetInt32Return() *int32 {
	return __.Int32Rtn.Get().(*int32)
}
func (__ *PoolOfFloat32ThenInt32Impl) PutInt32Return(p *int32) {
	__.Int32Rtn.Put(p)
}

func (__ *PoolOfFloat32ThenInt32Impl) GetWorkOfFloat32ThenInt32() *WorkOfFloat32ThenInt32 {
	return __.Float32Work.Get().(*WorkOfFloat32ThenInt32)
}
func (__ *PoolOfFloat32ThenInt32Impl) PutWorkOfFloat32ThenInt32(p *WorkOfFloat32ThenInt32) {
	__.Float32Work.Put(p)
}
func (__ *PoolOfFloat32ThenInt32Impl) GetReturnOfInt32() *ReturnOfInt32 {
	return __.Int32Return.Get().(*ReturnOfInt32)
}
func (__ *PoolOfFloat32ThenInt32Impl) PutReturnOfInt32(p *ReturnOfInt32) {
	__.Int32Return.Put(p)
}

func (__ *PoolOfFloat32ThenInt32Impl) GetChReturnOfInt32() chan *ReturnOfInt32 {
	return __.ChReturnOfInt32.Get().(chan *ReturnOfInt32)
}
func (__ *PoolOfFloat32ThenInt32Impl) PutChReturnOfInt32(p chan *ReturnOfInt32) {
	__.ChReturnOfInt32.Put(p)
}

func NewPoolOfFloat32ThenInt32Impl() *PoolOfFloat32ThenInt32Impl {
	return &PoolOfFloat32ThenInt32Impl{
		Float32Arg: sync.Pool{
			New: func() interface{} {
				return new(float32)
			},
		},
		Float32Work: sync.Pool{
			New: func() interface{} {
				return new(WorkOfFloat32ThenInt32)
			},
		},
		Int32Rtn: sync.Pool{
			New: func() interface{} {
				return new(int32)
			},
		},
		Int32Return: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfInt32)
			},
		},
		ChReturnOfInt32: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfInt32, 1)
			},
		},
	}
}

type ApiDecouplerOfFloat32ThenInt32 struct {
	pool PoolOfFloat32ThenInt32
}

func NewApiDecouplerOfFloat32ThenInt32() *ApiDecouplerOfFloat32ThenInt32 {
	return &ApiDecouplerOfFloat32ThenInt32{
		pool: NewPoolOfFloat32ThenInt32Impl(),
	}
}

func (__ *ApiDecouplerOfFloat32ThenInt32) ReturnError(rtn_ch chan<- *ReturnOfInt32, err error) {
	rtn := __.pool.GetReturnOfInt32()
	var other int32
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfFloat32ThenInt32) HandleOfFloat32ThenInt32(ctx context.Context, req *WorkOfFloat32ThenInt32, h func(ctx context.Context, arg float32) (int32, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfInt32()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfFloat32ThenInt32) DoOfFloat32ThenInt32(ctx context.Context, worker WorkerOfPushFloat32ThenInt32, arg float32) (int32, error) {
	// ch := make(chan *ReturnOfInt32, 1)
	ch := __.pool.GetChReturnOfInt32()
	defer __.pool.PutChReturnOfInt32(ch)

	req := __.pool.GetWorkOfFloat32ThenInt32()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfFloat32ThenInt32(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfInt32(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfFloat32ThenInt32 = func(ctx context.Context, arg float32) (int32, error)

type WorkerOfFloat32ThenInt32 struct {
	api_syncer *ApiDecouplerOfFloat32ThenInt32
	handler    WorkHandlerOfFloat32ThenInt32

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfFloat32ThenInt32
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfFloat32ThenInt32(ctx context.Context, h WorkHandlerOfFloat32ThenInt32, n int) *WorkerOfFloat32ThenInt32 {
	__ := &WorkerOfFloat32ThenInt32{
		api_syncer: NewApiDecouplerOfFloat32ThenInt32(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfFloat32ThenInt32, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfFloat32ThenInt32{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfFloat32ThenInt32(req.Context, req.WorkOfFloat32ThenInt32, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfFloat32ThenInt32) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfFloat32ThenInt32) Push(ctx context.Context, req *WorkOfFloat32ThenInt32) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfFloat32ThenInt32)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfFloat32ThenInt32 = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfFloat32ThenInt32) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfFloat32ThenInt32) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfFloat32ThenInt32) Call(ctx context.Context, arg float32) (int32, error) {
	return __.api_syncer.DoOfFloat32ThenInt32(ctx, __, arg)
}

type PoolOfFloat32ThenInt64 interface {
	GetFloat32Arg() *float32
	PutFloat32Arg(*float32)
	GetInt64Return() *int64
	PutInt64Return(*int64)

	GetWorkOfFloat32ThenInt64() *WorkOfFloat32ThenInt64
	GetReturnOfInt64() *ReturnOfInt64
	PutWorkOfFloat32ThenInt64(*WorkOfFloat32ThenInt64)
	PutReturnOfInt64(*ReturnOfInt64)

	GetChReturnOfInt64() chan *ReturnOfInt64
	PutChReturnOfInt64(chan *ReturnOfInt64)
}

type PoolOfFloat32ThenInt64Impl struct {
	Float32Arg      sync.Pool
	Int64Rtn        sync.Pool
	Float32Work     sync.Pool
	Int64Return     sync.Pool
	ChReturnOfInt64 sync.Pool
}

func (__ *PoolOfFloat32ThenInt64Impl) GetFloat32Arg() *float32 {
	return __.Float32Arg.Get().(*float32)
}
func (__ *PoolOfFloat32ThenInt64Impl) PutFloat32Arg(p *float32) {
	__.Float32Arg.Put(p)
}
func (__ *PoolOfFloat32ThenInt64Impl) GetInt64Return() *int64 {
	return __.Int64Rtn.Get().(*int64)
}
func (__ *PoolOfFloat32ThenInt64Impl) PutInt64Return(p *int64) {
	__.Int64Rtn.Put(p)
}

func (__ *PoolOfFloat32ThenInt64Impl) GetWorkOfFloat32ThenInt64() *WorkOfFloat32ThenInt64 {
	return __.Float32Work.Get().(*WorkOfFloat32ThenInt64)
}
func (__ *PoolOfFloat32ThenInt64Impl) PutWorkOfFloat32ThenInt64(p *WorkOfFloat32ThenInt64) {
	__.Float32Work.Put(p)
}
func (__ *PoolOfFloat32ThenInt64Impl) GetReturnOfInt64() *ReturnOfInt64 {
	return __.Int64Return.Get().(*ReturnOfInt64)
}
func (__ *PoolOfFloat32ThenInt64Impl) PutReturnOfInt64(p *ReturnOfInt64) {
	__.Int64Return.Put(p)
}

func (__ *PoolOfFloat32ThenInt64Impl) GetChReturnOfInt64() chan *ReturnOfInt64 {
	return __.ChReturnOfInt64.Get().(chan *ReturnOfInt64)
}
func (__ *PoolOfFloat32ThenInt64Impl) PutChReturnOfInt64(p chan *ReturnOfInt64) {
	__.ChReturnOfInt64.Put(p)
}

func NewPoolOfFloat32ThenInt64Impl() *PoolOfFloat32ThenInt64Impl {
	return &PoolOfFloat32ThenInt64Impl{
		Float32Arg: sync.Pool{
			New: func() interface{} {
				return new(float32)
			},
		},
		Float32Work: sync.Pool{
			New: func() interface{} {
				return new(WorkOfFloat32ThenInt64)
			},
		},
		Int64Rtn: sync.Pool{
			New: func() interface{} {
				return new(int64)
			},
		},
		Int64Return: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfInt64)
			},
		},
		ChReturnOfInt64: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfInt64, 1)
			},
		},
	}
}

type ApiDecouplerOfFloat32ThenInt64 struct {
	pool PoolOfFloat32ThenInt64
}

func NewApiDecouplerOfFloat32ThenInt64() *ApiDecouplerOfFloat32ThenInt64 {
	return &ApiDecouplerOfFloat32ThenInt64{
		pool: NewPoolOfFloat32ThenInt64Impl(),
	}
}

func (__ *ApiDecouplerOfFloat32ThenInt64) ReturnError(rtn_ch chan<- *ReturnOfInt64, err error) {
	rtn := __.pool.GetReturnOfInt64()
	var other int64
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfFloat32ThenInt64) HandleOfFloat32ThenInt64(ctx context.Context, req *WorkOfFloat32ThenInt64, h func(ctx context.Context, arg float32) (int64, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfInt64()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfFloat32ThenInt64) DoOfFloat32ThenInt64(ctx context.Context, worker WorkerOfPushFloat32ThenInt64, arg float32) (int64, error) {
	// ch := make(chan *ReturnOfInt64, 1)
	ch := __.pool.GetChReturnOfInt64()
	defer __.pool.PutChReturnOfInt64(ch)

	req := __.pool.GetWorkOfFloat32ThenInt64()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfFloat32ThenInt64(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfInt64(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfFloat32ThenInt64 = func(ctx context.Context, arg float32) (int64, error)

type WorkerOfFloat32ThenInt64 struct {
	api_syncer *ApiDecouplerOfFloat32ThenInt64
	handler    WorkHandlerOfFloat32ThenInt64

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfFloat32ThenInt64
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfFloat32ThenInt64(ctx context.Context, h WorkHandlerOfFloat32ThenInt64, n int) *WorkerOfFloat32ThenInt64 {
	__ := &WorkerOfFloat32ThenInt64{
		api_syncer: NewApiDecouplerOfFloat32ThenInt64(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfFloat32ThenInt64, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfFloat32ThenInt64{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfFloat32ThenInt64(req.Context, req.WorkOfFloat32ThenInt64, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfFloat32ThenInt64) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfFloat32ThenInt64) Push(ctx context.Context, req *WorkOfFloat32ThenInt64) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfFloat32ThenInt64)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfFloat32ThenInt64 = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfFloat32ThenInt64) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfFloat32ThenInt64) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfFloat32ThenInt64) Call(ctx context.Context, arg float32) (int64, error) {
	return __.api_syncer.DoOfFloat32ThenInt64(ctx, __, arg)
}

type PoolOfFloat32ThenInt8 interface {
	GetFloat32Arg() *float32
	PutFloat32Arg(*float32)
	GetInt8Return() *int8
	PutInt8Return(*int8)

	GetWorkOfFloat32ThenInt8() *WorkOfFloat32ThenInt8
	GetReturnOfInt8() *ReturnOfInt8
	PutWorkOfFloat32ThenInt8(*WorkOfFloat32ThenInt8)
	PutReturnOfInt8(*ReturnOfInt8)

	GetChReturnOfInt8() chan *ReturnOfInt8
	PutChReturnOfInt8(chan *ReturnOfInt8)
}

type PoolOfFloat32ThenInt8Impl struct {
	Float32Arg     sync.Pool
	Int8Rtn        sync.Pool
	Float32Work    sync.Pool
	Int8Return     sync.Pool
	ChReturnOfInt8 sync.Pool
}

func (__ *PoolOfFloat32ThenInt8Impl) GetFloat32Arg() *float32 {
	return __.Float32Arg.Get().(*float32)
}
func (__ *PoolOfFloat32ThenInt8Impl) PutFloat32Arg(p *float32) {
	__.Float32Arg.Put(p)
}
func (__ *PoolOfFloat32ThenInt8Impl) GetInt8Return() *int8 {
	return __.Int8Rtn.Get().(*int8)
}
func (__ *PoolOfFloat32ThenInt8Impl) PutInt8Return(p *int8) {
	__.Int8Rtn.Put(p)
}

func (__ *PoolOfFloat32ThenInt8Impl) GetWorkOfFloat32ThenInt8() *WorkOfFloat32ThenInt8 {
	return __.Float32Work.Get().(*WorkOfFloat32ThenInt8)
}
func (__ *PoolOfFloat32ThenInt8Impl) PutWorkOfFloat32ThenInt8(p *WorkOfFloat32ThenInt8) {
	__.Float32Work.Put(p)
}
func (__ *PoolOfFloat32ThenInt8Impl) GetReturnOfInt8() *ReturnOfInt8 {
	return __.Int8Return.Get().(*ReturnOfInt8)
}
func (__ *PoolOfFloat32ThenInt8Impl) PutReturnOfInt8(p *ReturnOfInt8) {
	__.Int8Return.Put(p)
}

func (__ *PoolOfFloat32ThenInt8Impl) GetChReturnOfInt8() chan *ReturnOfInt8 {
	return __.ChReturnOfInt8.Get().(chan *ReturnOfInt8)
}
func (__ *PoolOfFloat32ThenInt8Impl) PutChReturnOfInt8(p chan *ReturnOfInt8) {
	__.ChReturnOfInt8.Put(p)
}

func NewPoolOfFloat32ThenInt8Impl() *PoolOfFloat32ThenInt8Impl {
	return &PoolOfFloat32ThenInt8Impl{
		Float32Arg: sync.Pool{
			New: func() interface{} {
				return new(float32)
			},
		},
		Float32Work: sync.Pool{
			New: func() interface{} {
				return new(WorkOfFloat32ThenInt8)
			},
		},
		Int8Rtn: sync.Pool{
			New: func() interface{} {
				return new(int8)
			},
		},
		Int8Return: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfInt8)
			},
		},
		ChReturnOfInt8: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfInt8, 1)
			},
		},
	}
}

type ApiDecouplerOfFloat32ThenInt8 struct {
	pool PoolOfFloat32ThenInt8
}

func NewApiDecouplerOfFloat32ThenInt8() *ApiDecouplerOfFloat32ThenInt8 {
	return &ApiDecouplerOfFloat32ThenInt8{
		pool: NewPoolOfFloat32ThenInt8Impl(),
	}
}

func (__ *ApiDecouplerOfFloat32ThenInt8) ReturnError(rtn_ch chan<- *ReturnOfInt8, err error) {
	rtn := __.pool.GetReturnOfInt8()
	var other int8
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfFloat32ThenInt8) HandleOfFloat32ThenInt8(ctx context.Context, req *WorkOfFloat32ThenInt8, h func(ctx context.Context, arg float32) (int8, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfInt8()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfFloat32ThenInt8) DoOfFloat32ThenInt8(ctx context.Context, worker WorkerOfPushFloat32ThenInt8, arg float32) (int8, error) {
	// ch := make(chan *ReturnOfInt8, 1)
	ch := __.pool.GetChReturnOfInt8()
	defer __.pool.PutChReturnOfInt8(ch)

	req := __.pool.GetWorkOfFloat32ThenInt8()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfFloat32ThenInt8(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfInt8(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfFloat32ThenInt8 = func(ctx context.Context, arg float32) (int8, error)

type WorkerOfFloat32ThenInt8 struct {
	api_syncer *ApiDecouplerOfFloat32ThenInt8
	handler    WorkHandlerOfFloat32ThenInt8

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfFloat32ThenInt8
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfFloat32ThenInt8(ctx context.Context, h WorkHandlerOfFloat32ThenInt8, n int) *WorkerOfFloat32ThenInt8 {
	__ := &WorkerOfFloat32ThenInt8{
		api_syncer: NewApiDecouplerOfFloat32ThenInt8(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfFloat32ThenInt8, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfFloat32ThenInt8{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfFloat32ThenInt8(req.Context, req.WorkOfFloat32ThenInt8, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfFloat32ThenInt8) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfFloat32ThenInt8) Push(ctx context.Context, req *WorkOfFloat32ThenInt8) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfFloat32ThenInt8)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfFloat32ThenInt8 = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfFloat32ThenInt8) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfFloat32ThenInt8) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfFloat32ThenInt8) Call(ctx context.Context, arg float32) (int8, error) {
	return __.api_syncer.DoOfFloat32ThenInt8(ctx, __, arg)
}

type PoolOfFloat32ThenRune interface {
	GetFloat32Arg() *float32
	PutFloat32Arg(*float32)
	GetRuneReturn() *rune
	PutRuneReturn(*rune)

	GetWorkOfFloat32ThenRune() *WorkOfFloat32ThenRune
	GetReturnOfRune() *ReturnOfRune
	PutWorkOfFloat32ThenRune(*WorkOfFloat32ThenRune)
	PutReturnOfRune(*ReturnOfRune)

	GetChReturnOfRune() chan *ReturnOfRune
	PutChReturnOfRune(chan *ReturnOfRune)
}

type PoolOfFloat32ThenRuneImpl struct {
	Float32Arg     sync.Pool
	RuneRtn        sync.Pool
	Float32Work    sync.Pool
	RuneReturn     sync.Pool
	ChReturnOfRune sync.Pool
}

func (__ *PoolOfFloat32ThenRuneImpl) GetFloat32Arg() *float32 {
	return __.Float32Arg.Get().(*float32)
}
func (__ *PoolOfFloat32ThenRuneImpl) PutFloat32Arg(p *float32) {
	__.Float32Arg.Put(p)
}
func (__ *PoolOfFloat32ThenRuneImpl) GetRuneReturn() *rune {
	return __.RuneRtn.Get().(*rune)
}
func (__ *PoolOfFloat32ThenRuneImpl) PutRuneReturn(p *rune) {
	__.RuneRtn.Put(p)
}

func (__ *PoolOfFloat32ThenRuneImpl) GetWorkOfFloat32ThenRune() *WorkOfFloat32ThenRune {
	return __.Float32Work.Get().(*WorkOfFloat32ThenRune)
}
func (__ *PoolOfFloat32ThenRuneImpl) PutWorkOfFloat32ThenRune(p *WorkOfFloat32ThenRune) {
	__.Float32Work.Put(p)
}
func (__ *PoolOfFloat32ThenRuneImpl) GetReturnOfRune() *ReturnOfRune {
	return __.RuneReturn.Get().(*ReturnOfRune)
}
func (__ *PoolOfFloat32ThenRuneImpl) PutReturnOfRune(p *ReturnOfRune) {
	__.RuneReturn.Put(p)
}

func (__ *PoolOfFloat32ThenRuneImpl) GetChReturnOfRune() chan *ReturnOfRune {
	return __.ChReturnOfRune.Get().(chan *ReturnOfRune)
}
func (__ *PoolOfFloat32ThenRuneImpl) PutChReturnOfRune(p chan *ReturnOfRune) {
	__.ChReturnOfRune.Put(p)
}

func NewPoolOfFloat32ThenRuneImpl() *PoolOfFloat32ThenRuneImpl {
	return &PoolOfFloat32ThenRuneImpl{
		Float32Arg: sync.Pool{
			New: func() interface{} {
				return new(float32)
			},
		},
		Float32Work: sync.Pool{
			New: func() interface{} {
				return new(WorkOfFloat32ThenRune)
			},
		},
		RuneRtn: sync.Pool{
			New: func() interface{} {
				return new(rune)
			},
		},
		RuneReturn: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfRune)
			},
		},
		ChReturnOfRune: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfRune, 1)
			},
		},
	}
}

type ApiDecouplerOfFloat32ThenRune struct {
	pool PoolOfFloat32ThenRune
}

func NewApiDecouplerOfFloat32ThenRune() *ApiDecouplerOfFloat32ThenRune {
	return &ApiDecouplerOfFloat32ThenRune{
		pool: NewPoolOfFloat32ThenRuneImpl(),
	}
}

func (__ *ApiDecouplerOfFloat32ThenRune) ReturnError(rtn_ch chan<- *ReturnOfRune, err error) {
	rtn := __.pool.GetReturnOfRune()
	var other rune
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfFloat32ThenRune) HandleOfFloat32ThenRune(ctx context.Context, req *WorkOfFloat32ThenRune, h func(ctx context.Context, arg float32) (rune, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfRune()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfFloat32ThenRune) DoOfFloat32ThenRune(ctx context.Context, worker WorkerOfPushFloat32ThenRune, arg float32) (rune, error) {
	// ch := make(chan *ReturnOfRune, 1)
	ch := __.pool.GetChReturnOfRune()
	defer __.pool.PutChReturnOfRune(ch)

	req := __.pool.GetWorkOfFloat32ThenRune()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfFloat32ThenRune(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfRune(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfFloat32ThenRune = func(ctx context.Context, arg float32) (rune, error)

type WorkerOfFloat32ThenRune struct {
	api_syncer *ApiDecouplerOfFloat32ThenRune
	handler    WorkHandlerOfFloat32ThenRune

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfFloat32ThenRune
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfFloat32ThenRune(ctx context.Context, h WorkHandlerOfFloat32ThenRune, n int) *WorkerOfFloat32ThenRune {
	__ := &WorkerOfFloat32ThenRune{
		api_syncer: NewApiDecouplerOfFloat32ThenRune(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfFloat32ThenRune, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfFloat32ThenRune{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfFloat32ThenRune(req.Context, req.WorkOfFloat32ThenRune, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfFloat32ThenRune) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfFloat32ThenRune) Push(ctx context.Context, req *WorkOfFloat32ThenRune) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfFloat32ThenRune)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfFloat32ThenRune = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfFloat32ThenRune) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfFloat32ThenRune) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfFloat32ThenRune) Call(ctx context.Context, arg float32) (rune, error) {
	return __.api_syncer.DoOfFloat32ThenRune(ctx, __, arg)
}

type PoolOfFloat32ThenString interface {
	GetFloat32Arg() *float32
	PutFloat32Arg(*float32)
	GetStringReturn() *string
	PutStringReturn(*string)

	GetWorkOfFloat32ThenString() *WorkOfFloat32ThenString
	GetReturnOfString() *ReturnOfString
	PutWorkOfFloat32ThenString(*WorkOfFloat32ThenString)
	PutReturnOfString(*ReturnOfString)

	GetChReturnOfString() chan *ReturnOfString
	PutChReturnOfString(chan *ReturnOfString)
}

type PoolOfFloat32ThenStringImpl struct {
	Float32Arg       sync.Pool
	StringRtn        sync.Pool
	Float32Work      sync.Pool
	StringReturn     sync.Pool
	ChReturnOfString sync.Pool
}

func (__ *PoolOfFloat32ThenStringImpl) GetFloat32Arg() *float32 {
	return __.Float32Arg.Get().(*float32)
}
func (__ *PoolOfFloat32ThenStringImpl) PutFloat32Arg(p *float32) {
	__.Float32Arg.Put(p)
}
func (__ *PoolOfFloat32ThenStringImpl) GetStringReturn() *string {
	return __.StringRtn.Get().(*string)
}
func (__ *PoolOfFloat32ThenStringImpl) PutStringReturn(p *string) {
	__.StringRtn.Put(p)
}

func (__ *PoolOfFloat32ThenStringImpl) GetWorkOfFloat32ThenString() *WorkOfFloat32ThenString {
	return __.Float32Work.Get().(*WorkOfFloat32ThenString)
}
func (__ *PoolOfFloat32ThenStringImpl) PutWorkOfFloat32ThenString(p *WorkOfFloat32ThenString) {
	__.Float32Work.Put(p)
}
func (__ *PoolOfFloat32ThenStringImpl) GetReturnOfString() *ReturnOfString {
	return __.StringReturn.Get().(*ReturnOfString)
}
func (__ *PoolOfFloat32ThenStringImpl) PutReturnOfString(p *ReturnOfString) {
	__.StringReturn.Put(p)
}

func (__ *PoolOfFloat32ThenStringImpl) GetChReturnOfString() chan *ReturnOfString {
	return __.ChReturnOfString.Get().(chan *ReturnOfString)
}
func (__ *PoolOfFloat32ThenStringImpl) PutChReturnOfString(p chan *ReturnOfString) {
	__.ChReturnOfString.Put(p)
}

func NewPoolOfFloat32ThenStringImpl() *PoolOfFloat32ThenStringImpl {
	return &PoolOfFloat32ThenStringImpl{
		Float32Arg: sync.Pool{
			New: func() interface{} {
				return new(float32)
			},
		},
		Float32Work: sync.Pool{
			New: func() interface{} {
				return new(WorkOfFloat32ThenString)
			},
		},
		StringRtn: sync.Pool{
			New: func() interface{} {
				return new(string)
			},
		},
		StringReturn: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfString)
			},
		},
		ChReturnOfString: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfString, 1)
			},
		},
	}
}

type ApiDecouplerOfFloat32ThenString struct {
	pool PoolOfFloat32ThenString
}

func NewApiDecouplerOfFloat32ThenString() *ApiDecouplerOfFloat32ThenString {
	return &ApiDecouplerOfFloat32ThenString{
		pool: NewPoolOfFloat32ThenStringImpl(),
	}
}

func (__ *ApiDecouplerOfFloat32ThenString) ReturnError(rtn_ch chan<- *ReturnOfString, err error) {
	rtn := __.pool.GetReturnOfString()
	var other string
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfFloat32ThenString) HandleOfFloat32ThenString(ctx context.Context, req *WorkOfFloat32ThenString, h func(ctx context.Context, arg float32) (string, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfString()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfFloat32ThenString) DoOfFloat32ThenString(ctx context.Context, worker WorkerOfPushFloat32ThenString, arg float32) (string, error) {
	// ch := make(chan *ReturnOfString, 1)
	ch := __.pool.GetChReturnOfString()
	defer __.pool.PutChReturnOfString(ch)

	req := __.pool.GetWorkOfFloat32ThenString()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfFloat32ThenString(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfString(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfFloat32ThenString = func(ctx context.Context, arg float32) (string, error)

type WorkerOfFloat32ThenString struct {
	api_syncer *ApiDecouplerOfFloat32ThenString
	handler    WorkHandlerOfFloat32ThenString

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfFloat32ThenString
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfFloat32ThenString(ctx context.Context, h WorkHandlerOfFloat32ThenString, n int) *WorkerOfFloat32ThenString {
	__ := &WorkerOfFloat32ThenString{
		api_syncer: NewApiDecouplerOfFloat32ThenString(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfFloat32ThenString, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfFloat32ThenString{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfFloat32ThenString(req.Context, req.WorkOfFloat32ThenString, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfFloat32ThenString) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfFloat32ThenString) Push(ctx context.Context, req *WorkOfFloat32ThenString) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfFloat32ThenString)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfFloat32ThenString = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfFloat32ThenString) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfFloat32ThenString) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfFloat32ThenString) Call(ctx context.Context, arg float32) (string, error) {
	return __.api_syncer.DoOfFloat32ThenString(ctx, __, arg)
}

type PoolOfFloat32ThenUint interface {
	GetFloat32Arg() *float32
	PutFloat32Arg(*float32)
	GetUintReturn() *uint
	PutUintReturn(*uint)

	GetWorkOfFloat32ThenUint() *WorkOfFloat32ThenUint
	GetReturnOfUint() *ReturnOfUint
	PutWorkOfFloat32ThenUint(*WorkOfFloat32ThenUint)
	PutReturnOfUint(*ReturnOfUint)

	GetChReturnOfUint() chan *ReturnOfUint
	PutChReturnOfUint(chan *ReturnOfUint)
}

type PoolOfFloat32ThenUintImpl struct {
	Float32Arg     sync.Pool
	UintRtn        sync.Pool
	Float32Work    sync.Pool
	UintReturn     sync.Pool
	ChReturnOfUint sync.Pool
}

func (__ *PoolOfFloat32ThenUintImpl) GetFloat32Arg() *float32 {
	return __.Float32Arg.Get().(*float32)
}
func (__ *PoolOfFloat32ThenUintImpl) PutFloat32Arg(p *float32) {
	__.Float32Arg.Put(p)
}
func (__ *PoolOfFloat32ThenUintImpl) GetUintReturn() *uint {
	return __.UintRtn.Get().(*uint)
}
func (__ *PoolOfFloat32ThenUintImpl) PutUintReturn(p *uint) {
	__.UintRtn.Put(p)
}

func (__ *PoolOfFloat32ThenUintImpl) GetWorkOfFloat32ThenUint() *WorkOfFloat32ThenUint {
	return __.Float32Work.Get().(*WorkOfFloat32ThenUint)
}
func (__ *PoolOfFloat32ThenUintImpl) PutWorkOfFloat32ThenUint(p *WorkOfFloat32ThenUint) {
	__.Float32Work.Put(p)
}
func (__ *PoolOfFloat32ThenUintImpl) GetReturnOfUint() *ReturnOfUint {
	return __.UintReturn.Get().(*ReturnOfUint)
}
func (__ *PoolOfFloat32ThenUintImpl) PutReturnOfUint(p *ReturnOfUint) {
	__.UintReturn.Put(p)
}

func (__ *PoolOfFloat32ThenUintImpl) GetChReturnOfUint() chan *ReturnOfUint {
	return __.ChReturnOfUint.Get().(chan *ReturnOfUint)
}
func (__ *PoolOfFloat32ThenUintImpl) PutChReturnOfUint(p chan *ReturnOfUint) {
	__.ChReturnOfUint.Put(p)
}

func NewPoolOfFloat32ThenUintImpl() *PoolOfFloat32ThenUintImpl {
	return &PoolOfFloat32ThenUintImpl{
		Float32Arg: sync.Pool{
			New: func() interface{} {
				return new(float32)
			},
		},
		Float32Work: sync.Pool{
			New: func() interface{} {
				return new(WorkOfFloat32ThenUint)
			},
		},
		UintRtn: sync.Pool{
			New: func() interface{} {
				return new(uint)
			},
		},
		UintReturn: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfUint)
			},
		},
		ChReturnOfUint: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfUint, 1)
			},
		},
	}
}

type ApiDecouplerOfFloat32ThenUint struct {
	pool PoolOfFloat32ThenUint
}

func NewApiDecouplerOfFloat32ThenUint() *ApiDecouplerOfFloat32ThenUint {
	return &ApiDecouplerOfFloat32ThenUint{
		pool: NewPoolOfFloat32ThenUintImpl(),
	}
}

func (__ *ApiDecouplerOfFloat32ThenUint) ReturnError(rtn_ch chan<- *ReturnOfUint, err error) {
	rtn := __.pool.GetReturnOfUint()
	var other uint
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfFloat32ThenUint) HandleOfFloat32ThenUint(ctx context.Context, req *WorkOfFloat32ThenUint, h func(ctx context.Context, arg float32) (uint, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfUint()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfFloat32ThenUint) DoOfFloat32ThenUint(ctx context.Context, worker WorkerOfPushFloat32ThenUint, arg float32) (uint, error) {
	// ch := make(chan *ReturnOfUint, 1)
	ch := __.pool.GetChReturnOfUint()
	defer __.pool.PutChReturnOfUint(ch)

	req := __.pool.GetWorkOfFloat32ThenUint()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfFloat32ThenUint(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfUint(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfFloat32ThenUint = func(ctx context.Context, arg float32) (uint, error)

type WorkerOfFloat32ThenUint struct {
	api_syncer *ApiDecouplerOfFloat32ThenUint
	handler    WorkHandlerOfFloat32ThenUint

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfFloat32ThenUint
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfFloat32ThenUint(ctx context.Context, h WorkHandlerOfFloat32ThenUint, n int) *WorkerOfFloat32ThenUint {
	__ := &WorkerOfFloat32ThenUint{
		api_syncer: NewApiDecouplerOfFloat32ThenUint(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfFloat32ThenUint, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfFloat32ThenUint{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfFloat32ThenUint(req.Context, req.WorkOfFloat32ThenUint, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfFloat32ThenUint) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfFloat32ThenUint) Push(ctx context.Context, req *WorkOfFloat32ThenUint) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfFloat32ThenUint)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfFloat32ThenUint = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfFloat32ThenUint) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfFloat32ThenUint) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfFloat32ThenUint) Call(ctx context.Context, arg float32) (uint, error) {
	return __.api_syncer.DoOfFloat32ThenUint(ctx, __, arg)
}

type PoolOfFloat32ThenUint16 interface {
	GetFloat32Arg() *float32
	PutFloat32Arg(*float32)
	GetUint16Return() *uint16
	PutUint16Return(*uint16)

	GetWorkOfFloat32ThenUint16() *WorkOfFloat32ThenUint16
	GetReturnOfUint16() *ReturnOfUint16
	PutWorkOfFloat32ThenUint16(*WorkOfFloat32ThenUint16)
	PutReturnOfUint16(*ReturnOfUint16)

	GetChReturnOfUint16() chan *ReturnOfUint16
	PutChReturnOfUint16(chan *ReturnOfUint16)
}

type PoolOfFloat32ThenUint16Impl struct {
	Float32Arg       sync.Pool
	Uint16Rtn        sync.Pool
	Float32Work      sync.Pool
	Uint16Return     sync.Pool
	ChReturnOfUint16 sync.Pool
}

func (__ *PoolOfFloat32ThenUint16Impl) GetFloat32Arg() *float32 {
	return __.Float32Arg.Get().(*float32)
}
func (__ *PoolOfFloat32ThenUint16Impl) PutFloat32Arg(p *float32) {
	__.Float32Arg.Put(p)
}
func (__ *PoolOfFloat32ThenUint16Impl) GetUint16Return() *uint16 {
	return __.Uint16Rtn.Get().(*uint16)
}
func (__ *PoolOfFloat32ThenUint16Impl) PutUint16Return(p *uint16) {
	__.Uint16Rtn.Put(p)
}

func (__ *PoolOfFloat32ThenUint16Impl) GetWorkOfFloat32ThenUint16() *WorkOfFloat32ThenUint16 {
	return __.Float32Work.Get().(*WorkOfFloat32ThenUint16)
}
func (__ *PoolOfFloat32ThenUint16Impl) PutWorkOfFloat32ThenUint16(p *WorkOfFloat32ThenUint16) {
	__.Float32Work.Put(p)
}
func (__ *PoolOfFloat32ThenUint16Impl) GetReturnOfUint16() *ReturnOfUint16 {
	return __.Uint16Return.Get().(*ReturnOfUint16)
}
func (__ *PoolOfFloat32ThenUint16Impl) PutReturnOfUint16(p *ReturnOfUint16) {
	__.Uint16Return.Put(p)
}

func (__ *PoolOfFloat32ThenUint16Impl) GetChReturnOfUint16() chan *ReturnOfUint16 {
	return __.ChReturnOfUint16.Get().(chan *ReturnOfUint16)
}
func (__ *PoolOfFloat32ThenUint16Impl) PutChReturnOfUint16(p chan *ReturnOfUint16) {
	__.ChReturnOfUint16.Put(p)
}

func NewPoolOfFloat32ThenUint16Impl() *PoolOfFloat32ThenUint16Impl {
	return &PoolOfFloat32ThenUint16Impl{
		Float32Arg: sync.Pool{
			New: func() interface{} {
				return new(float32)
			},
		},
		Float32Work: sync.Pool{
			New: func() interface{} {
				return new(WorkOfFloat32ThenUint16)
			},
		},
		Uint16Rtn: sync.Pool{
			New: func() interface{} {
				return new(uint16)
			},
		},
		Uint16Return: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfUint16)
			},
		},
		ChReturnOfUint16: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfUint16, 1)
			},
		},
	}
}

type ApiDecouplerOfFloat32ThenUint16 struct {
	pool PoolOfFloat32ThenUint16
}

func NewApiDecouplerOfFloat32ThenUint16() *ApiDecouplerOfFloat32ThenUint16 {
	return &ApiDecouplerOfFloat32ThenUint16{
		pool: NewPoolOfFloat32ThenUint16Impl(),
	}
}

func (__ *ApiDecouplerOfFloat32ThenUint16) ReturnError(rtn_ch chan<- *ReturnOfUint16, err error) {
	rtn := __.pool.GetReturnOfUint16()
	var other uint16
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfFloat32ThenUint16) HandleOfFloat32ThenUint16(ctx context.Context, req *WorkOfFloat32ThenUint16, h func(ctx context.Context, arg float32) (uint16, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfUint16()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfFloat32ThenUint16) DoOfFloat32ThenUint16(ctx context.Context, worker WorkerOfPushFloat32ThenUint16, arg float32) (uint16, error) {
	// ch := make(chan *ReturnOfUint16, 1)
	ch := __.pool.GetChReturnOfUint16()
	defer __.pool.PutChReturnOfUint16(ch)

	req := __.pool.GetWorkOfFloat32ThenUint16()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfFloat32ThenUint16(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfUint16(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfFloat32ThenUint16 = func(ctx context.Context, arg float32) (uint16, error)

type WorkerOfFloat32ThenUint16 struct {
	api_syncer *ApiDecouplerOfFloat32ThenUint16
	handler    WorkHandlerOfFloat32ThenUint16

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfFloat32ThenUint16
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfFloat32ThenUint16(ctx context.Context, h WorkHandlerOfFloat32ThenUint16, n int) *WorkerOfFloat32ThenUint16 {
	__ := &WorkerOfFloat32ThenUint16{
		api_syncer: NewApiDecouplerOfFloat32ThenUint16(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfFloat32ThenUint16, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfFloat32ThenUint16{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfFloat32ThenUint16(req.Context, req.WorkOfFloat32ThenUint16, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfFloat32ThenUint16) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfFloat32ThenUint16) Push(ctx context.Context, req *WorkOfFloat32ThenUint16) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfFloat32ThenUint16)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfFloat32ThenUint16 = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfFloat32ThenUint16) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfFloat32ThenUint16) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfFloat32ThenUint16) Call(ctx context.Context, arg float32) (uint16, error) {
	return __.api_syncer.DoOfFloat32ThenUint16(ctx, __, arg)
}

type PoolOfFloat32ThenUint32 interface {
	GetFloat32Arg() *float32
	PutFloat32Arg(*float32)
	GetUint32Return() *uint32
	PutUint32Return(*uint32)

	GetWorkOfFloat32ThenUint32() *WorkOfFloat32ThenUint32
	GetReturnOfUint32() *ReturnOfUint32
	PutWorkOfFloat32ThenUint32(*WorkOfFloat32ThenUint32)
	PutReturnOfUint32(*ReturnOfUint32)

	GetChReturnOfUint32() chan *ReturnOfUint32
	PutChReturnOfUint32(chan *ReturnOfUint32)
}

type PoolOfFloat32ThenUint32Impl struct {
	Float32Arg       sync.Pool
	Uint32Rtn        sync.Pool
	Float32Work      sync.Pool
	Uint32Return     sync.Pool
	ChReturnOfUint32 sync.Pool
}

func (__ *PoolOfFloat32ThenUint32Impl) GetFloat32Arg() *float32 {
	return __.Float32Arg.Get().(*float32)
}
func (__ *PoolOfFloat32ThenUint32Impl) PutFloat32Arg(p *float32) {
	__.Float32Arg.Put(p)
}
func (__ *PoolOfFloat32ThenUint32Impl) GetUint32Return() *uint32 {
	return __.Uint32Rtn.Get().(*uint32)
}
func (__ *PoolOfFloat32ThenUint32Impl) PutUint32Return(p *uint32) {
	__.Uint32Rtn.Put(p)
}

func (__ *PoolOfFloat32ThenUint32Impl) GetWorkOfFloat32ThenUint32() *WorkOfFloat32ThenUint32 {
	return __.Float32Work.Get().(*WorkOfFloat32ThenUint32)
}
func (__ *PoolOfFloat32ThenUint32Impl) PutWorkOfFloat32ThenUint32(p *WorkOfFloat32ThenUint32) {
	__.Float32Work.Put(p)
}
func (__ *PoolOfFloat32ThenUint32Impl) GetReturnOfUint32() *ReturnOfUint32 {
	return __.Uint32Return.Get().(*ReturnOfUint32)
}
func (__ *PoolOfFloat32ThenUint32Impl) PutReturnOfUint32(p *ReturnOfUint32) {
	__.Uint32Return.Put(p)
}

func (__ *PoolOfFloat32ThenUint32Impl) GetChReturnOfUint32() chan *ReturnOfUint32 {
	return __.ChReturnOfUint32.Get().(chan *ReturnOfUint32)
}
func (__ *PoolOfFloat32ThenUint32Impl) PutChReturnOfUint32(p chan *ReturnOfUint32) {
	__.ChReturnOfUint32.Put(p)
}

func NewPoolOfFloat32ThenUint32Impl() *PoolOfFloat32ThenUint32Impl {
	return &PoolOfFloat32ThenUint32Impl{
		Float32Arg: sync.Pool{
			New: func() interface{} {
				return new(float32)
			},
		},
		Float32Work: sync.Pool{
			New: func() interface{} {
				return new(WorkOfFloat32ThenUint32)
			},
		},
		Uint32Rtn: sync.Pool{
			New: func() interface{} {
				return new(uint32)
			},
		},
		Uint32Return: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfUint32)
			},
		},
		ChReturnOfUint32: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfUint32, 1)
			},
		},
	}
}

type ApiDecouplerOfFloat32ThenUint32 struct {
	pool PoolOfFloat32ThenUint32
}

func NewApiDecouplerOfFloat32ThenUint32() *ApiDecouplerOfFloat32ThenUint32 {
	return &ApiDecouplerOfFloat32ThenUint32{
		pool: NewPoolOfFloat32ThenUint32Impl(),
	}
}

func (__ *ApiDecouplerOfFloat32ThenUint32) ReturnError(rtn_ch chan<- *ReturnOfUint32, err error) {
	rtn := __.pool.GetReturnOfUint32()
	var other uint32
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfFloat32ThenUint32) HandleOfFloat32ThenUint32(ctx context.Context, req *WorkOfFloat32ThenUint32, h func(ctx context.Context, arg float32) (uint32, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfUint32()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfFloat32ThenUint32) DoOfFloat32ThenUint32(ctx context.Context, worker WorkerOfPushFloat32ThenUint32, arg float32) (uint32, error) {
	// ch := make(chan *ReturnOfUint32, 1)
	ch := __.pool.GetChReturnOfUint32()
	defer __.pool.PutChReturnOfUint32(ch)

	req := __.pool.GetWorkOfFloat32ThenUint32()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfFloat32ThenUint32(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfUint32(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfFloat32ThenUint32 = func(ctx context.Context, arg float32) (uint32, error)

type WorkerOfFloat32ThenUint32 struct {
	api_syncer *ApiDecouplerOfFloat32ThenUint32
	handler    WorkHandlerOfFloat32ThenUint32

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfFloat32ThenUint32
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfFloat32ThenUint32(ctx context.Context, h WorkHandlerOfFloat32ThenUint32, n int) *WorkerOfFloat32ThenUint32 {
	__ := &WorkerOfFloat32ThenUint32{
		api_syncer: NewApiDecouplerOfFloat32ThenUint32(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfFloat32ThenUint32, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfFloat32ThenUint32{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfFloat32ThenUint32(req.Context, req.WorkOfFloat32ThenUint32, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfFloat32ThenUint32) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfFloat32ThenUint32) Push(ctx context.Context, req *WorkOfFloat32ThenUint32) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfFloat32ThenUint32)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfFloat32ThenUint32 = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfFloat32ThenUint32) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfFloat32ThenUint32) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfFloat32ThenUint32) Call(ctx context.Context, arg float32) (uint32, error) {
	return __.api_syncer.DoOfFloat32ThenUint32(ctx, __, arg)
}

type PoolOfFloat32ThenUint64 interface {
	GetFloat32Arg() *float32
	PutFloat32Arg(*float32)
	GetUint64Return() *uint64
	PutUint64Return(*uint64)

	GetWorkOfFloat32ThenUint64() *WorkOfFloat32ThenUint64
	GetReturnOfUint64() *ReturnOfUint64
	PutWorkOfFloat32ThenUint64(*WorkOfFloat32ThenUint64)
	PutReturnOfUint64(*ReturnOfUint64)

	GetChReturnOfUint64() chan *ReturnOfUint64
	PutChReturnOfUint64(chan *ReturnOfUint64)
}

type PoolOfFloat32ThenUint64Impl struct {
	Float32Arg       sync.Pool
	Uint64Rtn        sync.Pool
	Float32Work      sync.Pool
	Uint64Return     sync.Pool
	ChReturnOfUint64 sync.Pool
}

func (__ *PoolOfFloat32ThenUint64Impl) GetFloat32Arg() *float32 {
	return __.Float32Arg.Get().(*float32)
}
func (__ *PoolOfFloat32ThenUint64Impl) PutFloat32Arg(p *float32) {
	__.Float32Arg.Put(p)
}
func (__ *PoolOfFloat32ThenUint64Impl) GetUint64Return() *uint64 {
	return __.Uint64Rtn.Get().(*uint64)
}
func (__ *PoolOfFloat32ThenUint64Impl) PutUint64Return(p *uint64) {
	__.Uint64Rtn.Put(p)
}

func (__ *PoolOfFloat32ThenUint64Impl) GetWorkOfFloat32ThenUint64() *WorkOfFloat32ThenUint64 {
	return __.Float32Work.Get().(*WorkOfFloat32ThenUint64)
}
func (__ *PoolOfFloat32ThenUint64Impl) PutWorkOfFloat32ThenUint64(p *WorkOfFloat32ThenUint64) {
	__.Float32Work.Put(p)
}
func (__ *PoolOfFloat32ThenUint64Impl) GetReturnOfUint64() *ReturnOfUint64 {
	return __.Uint64Return.Get().(*ReturnOfUint64)
}
func (__ *PoolOfFloat32ThenUint64Impl) PutReturnOfUint64(p *ReturnOfUint64) {
	__.Uint64Return.Put(p)
}

func (__ *PoolOfFloat32ThenUint64Impl) GetChReturnOfUint64() chan *ReturnOfUint64 {
	return __.ChReturnOfUint64.Get().(chan *ReturnOfUint64)
}
func (__ *PoolOfFloat32ThenUint64Impl) PutChReturnOfUint64(p chan *ReturnOfUint64) {
	__.ChReturnOfUint64.Put(p)
}

func NewPoolOfFloat32ThenUint64Impl() *PoolOfFloat32ThenUint64Impl {
	return &PoolOfFloat32ThenUint64Impl{
		Float32Arg: sync.Pool{
			New: func() interface{} {
				return new(float32)
			},
		},
		Float32Work: sync.Pool{
			New: func() interface{} {
				return new(WorkOfFloat32ThenUint64)
			},
		},
		Uint64Rtn: sync.Pool{
			New: func() interface{} {
				return new(uint64)
			},
		},
		Uint64Return: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfUint64)
			},
		},
		ChReturnOfUint64: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfUint64, 1)
			},
		},
	}
}

type ApiDecouplerOfFloat32ThenUint64 struct {
	pool PoolOfFloat32ThenUint64
}

func NewApiDecouplerOfFloat32ThenUint64() *ApiDecouplerOfFloat32ThenUint64 {
	return &ApiDecouplerOfFloat32ThenUint64{
		pool: NewPoolOfFloat32ThenUint64Impl(),
	}
}

func (__ *ApiDecouplerOfFloat32ThenUint64) ReturnError(rtn_ch chan<- *ReturnOfUint64, err error) {
	rtn := __.pool.GetReturnOfUint64()
	var other uint64
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfFloat32ThenUint64) HandleOfFloat32ThenUint64(ctx context.Context, req *WorkOfFloat32ThenUint64, h func(ctx context.Context, arg float32) (uint64, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfUint64()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfFloat32ThenUint64) DoOfFloat32ThenUint64(ctx context.Context, worker WorkerOfPushFloat32ThenUint64, arg float32) (uint64, error) {
	// ch := make(chan *ReturnOfUint64, 1)
	ch := __.pool.GetChReturnOfUint64()
	defer __.pool.PutChReturnOfUint64(ch)

	req := __.pool.GetWorkOfFloat32ThenUint64()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfFloat32ThenUint64(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfUint64(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfFloat32ThenUint64 = func(ctx context.Context, arg float32) (uint64, error)

type WorkerOfFloat32ThenUint64 struct {
	api_syncer *ApiDecouplerOfFloat32ThenUint64
	handler    WorkHandlerOfFloat32ThenUint64

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfFloat32ThenUint64
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfFloat32ThenUint64(ctx context.Context, h WorkHandlerOfFloat32ThenUint64, n int) *WorkerOfFloat32ThenUint64 {
	__ := &WorkerOfFloat32ThenUint64{
		api_syncer: NewApiDecouplerOfFloat32ThenUint64(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfFloat32ThenUint64, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfFloat32ThenUint64{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfFloat32ThenUint64(req.Context, req.WorkOfFloat32ThenUint64, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfFloat32ThenUint64) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfFloat32ThenUint64) Push(ctx context.Context, req *WorkOfFloat32ThenUint64) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfFloat32ThenUint64)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfFloat32ThenUint64 = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfFloat32ThenUint64) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfFloat32ThenUint64) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfFloat32ThenUint64) Call(ctx context.Context, arg float32) (uint64, error) {
	return __.api_syncer.DoOfFloat32ThenUint64(ctx, __, arg)
}

type PoolOfFloat32ThenUint8 interface {
	GetFloat32Arg() *float32
	PutFloat32Arg(*float32)
	GetUint8Return() *uint8
	PutUint8Return(*uint8)

	GetWorkOfFloat32ThenUint8() *WorkOfFloat32ThenUint8
	GetReturnOfUint8() *ReturnOfUint8
	PutWorkOfFloat32ThenUint8(*WorkOfFloat32ThenUint8)
	PutReturnOfUint8(*ReturnOfUint8)

	GetChReturnOfUint8() chan *ReturnOfUint8
	PutChReturnOfUint8(chan *ReturnOfUint8)
}

type PoolOfFloat32ThenUint8Impl struct {
	Float32Arg      sync.Pool
	Uint8Rtn        sync.Pool
	Float32Work     sync.Pool
	Uint8Return     sync.Pool
	ChReturnOfUint8 sync.Pool
}

func (__ *PoolOfFloat32ThenUint8Impl) GetFloat32Arg() *float32 {
	return __.Float32Arg.Get().(*float32)
}
func (__ *PoolOfFloat32ThenUint8Impl) PutFloat32Arg(p *float32) {
	__.Float32Arg.Put(p)
}
func (__ *PoolOfFloat32ThenUint8Impl) GetUint8Return() *uint8 {
	return __.Uint8Rtn.Get().(*uint8)
}
func (__ *PoolOfFloat32ThenUint8Impl) PutUint8Return(p *uint8) {
	__.Uint8Rtn.Put(p)
}

func (__ *PoolOfFloat32ThenUint8Impl) GetWorkOfFloat32ThenUint8() *WorkOfFloat32ThenUint8 {
	return __.Float32Work.Get().(*WorkOfFloat32ThenUint8)
}
func (__ *PoolOfFloat32ThenUint8Impl) PutWorkOfFloat32ThenUint8(p *WorkOfFloat32ThenUint8) {
	__.Float32Work.Put(p)
}
func (__ *PoolOfFloat32ThenUint8Impl) GetReturnOfUint8() *ReturnOfUint8 {
	return __.Uint8Return.Get().(*ReturnOfUint8)
}
func (__ *PoolOfFloat32ThenUint8Impl) PutReturnOfUint8(p *ReturnOfUint8) {
	__.Uint8Return.Put(p)
}

func (__ *PoolOfFloat32ThenUint8Impl) GetChReturnOfUint8() chan *ReturnOfUint8 {
	return __.ChReturnOfUint8.Get().(chan *ReturnOfUint8)
}
func (__ *PoolOfFloat32ThenUint8Impl) PutChReturnOfUint8(p chan *ReturnOfUint8) {
	__.ChReturnOfUint8.Put(p)
}

func NewPoolOfFloat32ThenUint8Impl() *PoolOfFloat32ThenUint8Impl {
	return &PoolOfFloat32ThenUint8Impl{
		Float32Arg: sync.Pool{
			New: func() interface{} {
				return new(float32)
			},
		},
		Float32Work: sync.Pool{
			New: func() interface{} {
				return new(WorkOfFloat32ThenUint8)
			},
		},
		Uint8Rtn: sync.Pool{
			New: func() interface{} {
				return new(uint8)
			},
		},
		Uint8Return: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfUint8)
			},
		},
		ChReturnOfUint8: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfUint8, 1)
			},
		},
	}
}

type ApiDecouplerOfFloat32ThenUint8 struct {
	pool PoolOfFloat32ThenUint8
}

func NewApiDecouplerOfFloat32ThenUint8() *ApiDecouplerOfFloat32ThenUint8 {
	return &ApiDecouplerOfFloat32ThenUint8{
		pool: NewPoolOfFloat32ThenUint8Impl(),
	}
}

func (__ *ApiDecouplerOfFloat32ThenUint8) ReturnError(rtn_ch chan<- *ReturnOfUint8, err error) {
	rtn := __.pool.GetReturnOfUint8()
	var other uint8
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfFloat32ThenUint8) HandleOfFloat32ThenUint8(ctx context.Context, req *WorkOfFloat32ThenUint8, h func(ctx context.Context, arg float32) (uint8, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfUint8()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfFloat32ThenUint8) DoOfFloat32ThenUint8(ctx context.Context, worker WorkerOfPushFloat32ThenUint8, arg float32) (uint8, error) {
	// ch := make(chan *ReturnOfUint8, 1)
	ch := __.pool.GetChReturnOfUint8()
	defer __.pool.PutChReturnOfUint8(ch)

	req := __.pool.GetWorkOfFloat32ThenUint8()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfFloat32ThenUint8(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfUint8(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfFloat32ThenUint8 = func(ctx context.Context, arg float32) (uint8, error)

type WorkerOfFloat32ThenUint8 struct {
	api_syncer *ApiDecouplerOfFloat32ThenUint8
	handler    WorkHandlerOfFloat32ThenUint8

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfFloat32ThenUint8
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfFloat32ThenUint8(ctx context.Context, h WorkHandlerOfFloat32ThenUint8, n int) *WorkerOfFloat32ThenUint8 {
	__ := &WorkerOfFloat32ThenUint8{
		api_syncer: NewApiDecouplerOfFloat32ThenUint8(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfFloat32ThenUint8, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfFloat32ThenUint8{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfFloat32ThenUint8(req.Context, req.WorkOfFloat32ThenUint8, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfFloat32ThenUint8) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfFloat32ThenUint8) Push(ctx context.Context, req *WorkOfFloat32ThenUint8) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfFloat32ThenUint8)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfFloat32ThenUint8 = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfFloat32ThenUint8) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfFloat32ThenUint8) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfFloat32ThenUint8) Call(ctx context.Context, arg float32) (uint8, error) {
	return __.api_syncer.DoOfFloat32ThenUint8(ctx, __, arg)
}

type PoolOfFloat32ThenUintptr interface {
	GetFloat32Arg() *float32
	PutFloat32Arg(*float32)
	GetUintptrReturn() *uintptr
	PutUintptrReturn(*uintptr)

	GetWorkOfFloat32ThenUintptr() *WorkOfFloat32ThenUintptr
	GetReturnOfUintptr() *ReturnOfUintptr
	PutWorkOfFloat32ThenUintptr(*WorkOfFloat32ThenUintptr)
	PutReturnOfUintptr(*ReturnOfUintptr)

	GetChReturnOfUintptr() chan *ReturnOfUintptr
	PutChReturnOfUintptr(chan *ReturnOfUintptr)
}

type PoolOfFloat32ThenUintptrImpl struct {
	Float32Arg        sync.Pool
	UintptrRtn        sync.Pool
	Float32Work       sync.Pool
	UintptrReturn     sync.Pool
	ChReturnOfUintptr sync.Pool
}

func (__ *PoolOfFloat32ThenUintptrImpl) GetFloat32Arg() *float32 {
	return __.Float32Arg.Get().(*float32)
}
func (__ *PoolOfFloat32ThenUintptrImpl) PutFloat32Arg(p *float32) {
	__.Float32Arg.Put(p)
}
func (__ *PoolOfFloat32ThenUintptrImpl) GetUintptrReturn() *uintptr {
	return __.UintptrRtn.Get().(*uintptr)
}
func (__ *PoolOfFloat32ThenUintptrImpl) PutUintptrReturn(p *uintptr) {
	__.UintptrRtn.Put(p)
}

func (__ *PoolOfFloat32ThenUintptrImpl) GetWorkOfFloat32ThenUintptr() *WorkOfFloat32ThenUintptr {
	return __.Float32Work.Get().(*WorkOfFloat32ThenUintptr)
}
func (__ *PoolOfFloat32ThenUintptrImpl) PutWorkOfFloat32ThenUintptr(p *WorkOfFloat32ThenUintptr) {
	__.Float32Work.Put(p)
}
func (__ *PoolOfFloat32ThenUintptrImpl) GetReturnOfUintptr() *ReturnOfUintptr {
	return __.UintptrReturn.Get().(*ReturnOfUintptr)
}
func (__ *PoolOfFloat32ThenUintptrImpl) PutReturnOfUintptr(p *ReturnOfUintptr) {
	__.UintptrReturn.Put(p)
}

func (__ *PoolOfFloat32ThenUintptrImpl) GetChReturnOfUintptr() chan *ReturnOfUintptr {
	return __.ChReturnOfUintptr.Get().(chan *ReturnOfUintptr)
}
func (__ *PoolOfFloat32ThenUintptrImpl) PutChReturnOfUintptr(p chan *ReturnOfUintptr) {
	__.ChReturnOfUintptr.Put(p)
}

func NewPoolOfFloat32ThenUintptrImpl() *PoolOfFloat32ThenUintptrImpl {
	return &PoolOfFloat32ThenUintptrImpl{
		Float32Arg: sync.Pool{
			New: func() interface{} {
				return new(float32)
			},
		},
		Float32Work: sync.Pool{
			New: func() interface{} {
				return new(WorkOfFloat32ThenUintptr)
			},
		},
		UintptrRtn: sync.Pool{
			New: func() interface{} {
				return new(uintptr)
			},
		},
		UintptrReturn: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfUintptr)
			},
		},
		ChReturnOfUintptr: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfUintptr, 1)
			},
		},
	}
}

type ApiDecouplerOfFloat32ThenUintptr struct {
	pool PoolOfFloat32ThenUintptr
}

func NewApiDecouplerOfFloat32ThenUintptr() *ApiDecouplerOfFloat32ThenUintptr {
	return &ApiDecouplerOfFloat32ThenUintptr{
		pool: NewPoolOfFloat32ThenUintptrImpl(),
	}
}

func (__ *ApiDecouplerOfFloat32ThenUintptr) ReturnError(rtn_ch chan<- *ReturnOfUintptr, err error) {
	rtn := __.pool.GetReturnOfUintptr()
	var other uintptr
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfFloat32ThenUintptr) HandleOfFloat32ThenUintptr(ctx context.Context, req *WorkOfFloat32ThenUintptr, h func(ctx context.Context, arg float32) (uintptr, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfUintptr()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfFloat32ThenUintptr) DoOfFloat32ThenUintptr(ctx context.Context, worker WorkerOfPushFloat32ThenUintptr, arg float32) (uintptr, error) {
	// ch := make(chan *ReturnOfUintptr, 1)
	ch := __.pool.GetChReturnOfUintptr()
	defer __.pool.PutChReturnOfUintptr(ch)

	req := __.pool.GetWorkOfFloat32ThenUintptr()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfFloat32ThenUintptr(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfUintptr(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfFloat32ThenUintptr = func(ctx context.Context, arg float32) (uintptr, error)

type WorkerOfFloat32ThenUintptr struct {
	api_syncer *ApiDecouplerOfFloat32ThenUintptr
	handler    WorkHandlerOfFloat32ThenUintptr

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfFloat32ThenUintptr
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfFloat32ThenUintptr(ctx context.Context, h WorkHandlerOfFloat32ThenUintptr, n int) *WorkerOfFloat32ThenUintptr {
	__ := &WorkerOfFloat32ThenUintptr{
		api_syncer: NewApiDecouplerOfFloat32ThenUintptr(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfFloat32ThenUintptr, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfFloat32ThenUintptr{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfFloat32ThenUintptr(req.Context, req.WorkOfFloat32ThenUintptr, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfFloat32ThenUintptr) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfFloat32ThenUintptr) Push(ctx context.Context, req *WorkOfFloat32ThenUintptr) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfFloat32ThenUintptr)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfFloat32ThenUintptr = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfFloat32ThenUintptr) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfFloat32ThenUintptr) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfFloat32ThenUintptr) Call(ctx context.Context, arg float32) (uintptr, error) {
	return __.api_syncer.DoOfFloat32ThenUintptr(ctx, __, arg)
}

type PoolOfFloat32ThenInterface interface {
	GetFloat32Arg() *float32
	PutFloat32Arg(*float32)
	GetInterfaceReturn() *interface{}
	PutInterfaceReturn(*interface{})

	GetWorkOfFloat32ThenInterface() *WorkOfFloat32ThenInterface
	GetReturnOfInterface() *ReturnOfInterface
	PutWorkOfFloat32ThenInterface(*WorkOfFloat32ThenInterface)
	PutReturnOfInterface(*ReturnOfInterface)

	GetChReturnOfInterface() chan *ReturnOfInterface
	PutChReturnOfInterface(chan *ReturnOfInterface)
}

type PoolOfFloat32ThenInterfaceImpl struct {
	Float32Arg          sync.Pool
	InterfaceRtn        sync.Pool
	Float32Work         sync.Pool
	InterfaceReturn     sync.Pool
	ChReturnOfInterface sync.Pool
}

func (__ *PoolOfFloat32ThenInterfaceImpl) GetFloat32Arg() *float32 {
	return __.Float32Arg.Get().(*float32)
}
func (__ *PoolOfFloat32ThenInterfaceImpl) PutFloat32Arg(p *float32) {
	__.Float32Arg.Put(p)
}
func (__ *PoolOfFloat32ThenInterfaceImpl) GetInterfaceReturn() *interface{} {
	return __.InterfaceRtn.Get().(*interface{})
}
func (__ *PoolOfFloat32ThenInterfaceImpl) PutInterfaceReturn(p *interface{}) {
	__.InterfaceRtn.Put(p)
}

func (__ *PoolOfFloat32ThenInterfaceImpl) GetWorkOfFloat32ThenInterface() *WorkOfFloat32ThenInterface {
	return __.Float32Work.Get().(*WorkOfFloat32ThenInterface)
}
func (__ *PoolOfFloat32ThenInterfaceImpl) PutWorkOfFloat32ThenInterface(p *WorkOfFloat32ThenInterface) {
	__.Float32Work.Put(p)
}
func (__ *PoolOfFloat32ThenInterfaceImpl) GetReturnOfInterface() *ReturnOfInterface {
	return __.InterfaceReturn.Get().(*ReturnOfInterface)
}
func (__ *PoolOfFloat32ThenInterfaceImpl) PutReturnOfInterface(p *ReturnOfInterface) {
	__.InterfaceReturn.Put(p)
}

func (__ *PoolOfFloat32ThenInterfaceImpl) GetChReturnOfInterface() chan *ReturnOfInterface {
	return __.ChReturnOfInterface.Get().(chan *ReturnOfInterface)
}
func (__ *PoolOfFloat32ThenInterfaceImpl) PutChReturnOfInterface(p chan *ReturnOfInterface) {
	__.ChReturnOfInterface.Put(p)
}

func NewPoolOfFloat32ThenInterfaceImpl() *PoolOfFloat32ThenInterfaceImpl {
	return &PoolOfFloat32ThenInterfaceImpl{
		Float32Arg: sync.Pool{
			New: func() interface{} {
				return new(float32)
			},
		},
		Float32Work: sync.Pool{
			New: func() interface{} {
				return new(WorkOfFloat32ThenInterface)
			},
		},
		InterfaceRtn: sync.Pool{
			New: func() interface{} {
				return new(interface{})
			},
		},
		InterfaceReturn: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfInterface)
			},
		},
		ChReturnOfInterface: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfInterface, 1)
			},
		},
	}
}

type ApiDecouplerOfFloat32ThenInterface struct {
	pool PoolOfFloat32ThenInterface
}

func NewApiDecouplerOfFloat32ThenInterface() *ApiDecouplerOfFloat32ThenInterface {
	return &ApiDecouplerOfFloat32ThenInterface{
		pool: NewPoolOfFloat32ThenInterfaceImpl(),
	}
}

func (__ *ApiDecouplerOfFloat32ThenInterface) ReturnError(rtn_ch chan<- *ReturnOfInterface, err error) {
	rtn := __.pool.GetReturnOfInterface()
	var other interface{}
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfFloat32ThenInterface) HandleOfFloat32ThenInterface(ctx context.Context, req *WorkOfFloat32ThenInterface, h func(ctx context.Context, arg float32) (interface{}, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfInterface()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfFloat32ThenInterface) DoOfFloat32ThenInterface(ctx context.Context, worker WorkerOfPushFloat32ThenInterface, arg float32) (interface{}, error) {
	// ch := make(chan *ReturnOfInterface, 1)
	ch := __.pool.GetChReturnOfInterface()
	defer __.pool.PutChReturnOfInterface(ch)

	req := __.pool.GetWorkOfFloat32ThenInterface()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfFloat32ThenInterface(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfInterface(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfFloat32ThenInterface = func(ctx context.Context, arg float32) (interface{}, error)

type WorkerOfFloat32ThenInterface struct {
	api_syncer *ApiDecouplerOfFloat32ThenInterface
	handler    WorkHandlerOfFloat32ThenInterface

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfFloat32ThenInterface
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfFloat32ThenInterface(ctx context.Context, h WorkHandlerOfFloat32ThenInterface, n int) *WorkerOfFloat32ThenInterface {
	__ := &WorkerOfFloat32ThenInterface{
		api_syncer: NewApiDecouplerOfFloat32ThenInterface(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfFloat32ThenInterface, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfFloat32ThenInterface{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfFloat32ThenInterface(req.Context, req.WorkOfFloat32ThenInterface, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfFloat32ThenInterface) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfFloat32ThenInterface) Push(ctx context.Context, req *WorkOfFloat32ThenInterface) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfFloat32ThenInterface)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfFloat32ThenInterface = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfFloat32ThenInterface) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfFloat32ThenInterface) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfFloat32ThenInterface) Call(ctx context.Context, arg float32) (interface{}, error) {
	return __.api_syncer.DoOfFloat32ThenInterface(ctx, __, arg)
}

type PoolOfFloat32ThenStruct interface {
	GetFloat32Arg() *float32
	PutFloat32Arg(*float32)
	GetStructReturn() *struct{}
	PutStructReturn(*struct{})

	GetWorkOfFloat32ThenStruct() *WorkOfFloat32ThenStruct
	GetReturnOfStruct() *ReturnOfStruct
	PutWorkOfFloat32ThenStruct(*WorkOfFloat32ThenStruct)
	PutReturnOfStruct(*ReturnOfStruct)

	GetChReturnOfStruct() chan *ReturnOfStruct
	PutChReturnOfStruct(chan *ReturnOfStruct)
}

type PoolOfFloat32ThenStructImpl struct {
	Float32Arg       sync.Pool
	StructRtn        sync.Pool
	Float32Work      sync.Pool
	StructReturn     sync.Pool
	ChReturnOfStruct sync.Pool
}

func (__ *PoolOfFloat32ThenStructImpl) GetFloat32Arg() *float32 {
	return __.Float32Arg.Get().(*float32)
}
func (__ *PoolOfFloat32ThenStructImpl) PutFloat32Arg(p *float32) {
	__.Float32Arg.Put(p)
}
func (__ *PoolOfFloat32ThenStructImpl) GetStructReturn() *struct{} {
	return __.StructRtn.Get().(*struct{})
}
func (__ *PoolOfFloat32ThenStructImpl) PutStructReturn(p *struct{}) {
	__.StructRtn.Put(p)
}

func (__ *PoolOfFloat32ThenStructImpl) GetWorkOfFloat32ThenStruct() *WorkOfFloat32ThenStruct {
	return __.Float32Work.Get().(*WorkOfFloat32ThenStruct)
}
func (__ *PoolOfFloat32ThenStructImpl) PutWorkOfFloat32ThenStruct(p *WorkOfFloat32ThenStruct) {
	__.Float32Work.Put(p)
}
func (__ *PoolOfFloat32ThenStructImpl) GetReturnOfStruct() *ReturnOfStruct {
	return __.StructReturn.Get().(*ReturnOfStruct)
}
func (__ *PoolOfFloat32ThenStructImpl) PutReturnOfStruct(p *ReturnOfStruct) {
	__.StructReturn.Put(p)
}

func (__ *PoolOfFloat32ThenStructImpl) GetChReturnOfStruct() chan *ReturnOfStruct {
	return __.ChReturnOfStruct.Get().(chan *ReturnOfStruct)
}
func (__ *PoolOfFloat32ThenStructImpl) PutChReturnOfStruct(p chan *ReturnOfStruct) {
	__.ChReturnOfStruct.Put(p)
}

func NewPoolOfFloat32ThenStructImpl() *PoolOfFloat32ThenStructImpl {
	return &PoolOfFloat32ThenStructImpl{
		Float32Arg: sync.Pool{
			New: func() interface{} {
				return new(float32)
			},
		},
		Float32Work: sync.Pool{
			New: func() interface{} {
				return new(WorkOfFloat32ThenStruct)
			},
		},
		StructRtn: sync.Pool{
			New: func() interface{} {
				return new(struct{})
			},
		},
		StructReturn: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfStruct)
			},
		},
		ChReturnOfStruct: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfStruct, 1)
			},
		},
	}
}

type ApiDecouplerOfFloat32ThenStruct struct {
	pool PoolOfFloat32ThenStruct
}

func NewApiDecouplerOfFloat32ThenStruct() *ApiDecouplerOfFloat32ThenStruct {
	return &ApiDecouplerOfFloat32ThenStruct{
		pool: NewPoolOfFloat32ThenStructImpl(),
	}
}

func (__ *ApiDecouplerOfFloat32ThenStruct) ReturnError(rtn_ch chan<- *ReturnOfStruct, err error) {
	rtn := __.pool.GetReturnOfStruct()
	var other struct{}
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfFloat32ThenStruct) HandleOfFloat32ThenStruct(ctx context.Context, req *WorkOfFloat32ThenStruct, h func(ctx context.Context, arg float32) (struct{}, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfStruct()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfFloat32ThenStruct) DoOfFloat32ThenStruct(ctx context.Context, worker WorkerOfPushFloat32ThenStruct, arg float32) (struct{}, error) {
	// ch := make(chan *ReturnOfStruct, 1)
	ch := __.pool.GetChReturnOfStruct()
	defer __.pool.PutChReturnOfStruct(ch)

	req := __.pool.GetWorkOfFloat32ThenStruct()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfFloat32ThenStruct(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfStruct(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfFloat32ThenStruct = func(ctx context.Context, arg float32) (struct{}, error)

type WorkerOfFloat32ThenStruct struct {
	api_syncer *ApiDecouplerOfFloat32ThenStruct
	handler    WorkHandlerOfFloat32ThenStruct

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfFloat32ThenStruct
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfFloat32ThenStruct(ctx context.Context, h WorkHandlerOfFloat32ThenStruct, n int) *WorkerOfFloat32ThenStruct {
	__ := &WorkerOfFloat32ThenStruct{
		api_syncer: NewApiDecouplerOfFloat32ThenStruct(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfFloat32ThenStruct, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfFloat32ThenStruct{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfFloat32ThenStruct(req.Context, req.WorkOfFloat32ThenStruct, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfFloat32ThenStruct) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfFloat32ThenStruct) Push(ctx context.Context, req *WorkOfFloat32ThenStruct) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfFloat32ThenStruct)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfFloat32ThenStruct = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfFloat32ThenStruct) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfFloat32ThenStruct) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfFloat32ThenStruct) Call(ctx context.Context, arg float32) (struct{}, error) {
	return __.api_syncer.DoOfFloat32ThenStruct(ctx, __, arg)
}

type PoolOfFloat64ThenBool interface {
	GetFloat64Arg() *float64
	PutFloat64Arg(*float64)
	GetBoolReturn() *bool
	PutBoolReturn(*bool)

	GetWorkOfFloat64ThenBool() *WorkOfFloat64ThenBool
	GetReturnOfBool() *ReturnOfBool
	PutWorkOfFloat64ThenBool(*WorkOfFloat64ThenBool)
	PutReturnOfBool(*ReturnOfBool)

	GetChReturnOfBool() chan *ReturnOfBool
	PutChReturnOfBool(chan *ReturnOfBool)
}

type PoolOfFloat64ThenBoolImpl struct {
	Float64Arg     sync.Pool
	BoolRtn        sync.Pool
	Float64Work    sync.Pool
	BoolReturn     sync.Pool
	ChReturnOfBool sync.Pool
}

func (__ *PoolOfFloat64ThenBoolImpl) GetFloat64Arg() *float64 {
	return __.Float64Arg.Get().(*float64)
}
func (__ *PoolOfFloat64ThenBoolImpl) PutFloat64Arg(p *float64) {
	__.Float64Arg.Put(p)
}
func (__ *PoolOfFloat64ThenBoolImpl) GetBoolReturn() *bool {
	return __.BoolRtn.Get().(*bool)
}
func (__ *PoolOfFloat64ThenBoolImpl) PutBoolReturn(p *bool) {
	__.BoolRtn.Put(p)
}

func (__ *PoolOfFloat64ThenBoolImpl) GetWorkOfFloat64ThenBool() *WorkOfFloat64ThenBool {
	return __.Float64Work.Get().(*WorkOfFloat64ThenBool)
}
func (__ *PoolOfFloat64ThenBoolImpl) PutWorkOfFloat64ThenBool(p *WorkOfFloat64ThenBool) {
	__.Float64Work.Put(p)
}
func (__ *PoolOfFloat64ThenBoolImpl) GetReturnOfBool() *ReturnOfBool {
	return __.BoolReturn.Get().(*ReturnOfBool)
}
func (__ *PoolOfFloat64ThenBoolImpl) PutReturnOfBool(p *ReturnOfBool) {
	__.BoolReturn.Put(p)
}

func (__ *PoolOfFloat64ThenBoolImpl) GetChReturnOfBool() chan *ReturnOfBool {
	return __.ChReturnOfBool.Get().(chan *ReturnOfBool)
}
func (__ *PoolOfFloat64ThenBoolImpl) PutChReturnOfBool(p chan *ReturnOfBool) {
	__.ChReturnOfBool.Put(p)
}

func NewPoolOfFloat64ThenBoolImpl() *PoolOfFloat64ThenBoolImpl {
	return &PoolOfFloat64ThenBoolImpl{
		Float64Arg: sync.Pool{
			New: func() interface{} {
				return new(float64)
			},
		},
		Float64Work: sync.Pool{
			New: func() interface{} {
				return new(WorkOfFloat64ThenBool)
			},
		},
		BoolRtn: sync.Pool{
			New: func() interface{} {
				return new(bool)
			},
		},
		BoolReturn: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfBool)
			},
		},
		ChReturnOfBool: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfBool, 1)
			},
		},
	}
}

type ApiDecouplerOfFloat64ThenBool struct {
	pool PoolOfFloat64ThenBool
}

func NewApiDecouplerOfFloat64ThenBool() *ApiDecouplerOfFloat64ThenBool {
	return &ApiDecouplerOfFloat64ThenBool{
		pool: NewPoolOfFloat64ThenBoolImpl(),
	}
}

func (__ *ApiDecouplerOfFloat64ThenBool) ReturnError(rtn_ch chan<- *ReturnOfBool, err error) {
	rtn := __.pool.GetReturnOfBool()
	var other bool
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfFloat64ThenBool) HandleOfFloat64ThenBool(ctx context.Context, req *WorkOfFloat64ThenBool, h func(ctx context.Context, arg float64) (bool, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfBool()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfFloat64ThenBool) DoOfFloat64ThenBool(ctx context.Context, worker WorkerOfPushFloat64ThenBool, arg float64) (bool, error) {
	// ch := make(chan *ReturnOfBool, 1)
	ch := __.pool.GetChReturnOfBool()
	defer __.pool.PutChReturnOfBool(ch)

	req := __.pool.GetWorkOfFloat64ThenBool()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfFloat64ThenBool(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfBool(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfFloat64ThenBool = func(ctx context.Context, arg float64) (bool, error)

type WorkerOfFloat64ThenBool struct {
	api_syncer *ApiDecouplerOfFloat64ThenBool
	handler    WorkHandlerOfFloat64ThenBool

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfFloat64ThenBool
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfFloat64ThenBool(ctx context.Context, h WorkHandlerOfFloat64ThenBool, n int) *WorkerOfFloat64ThenBool {
	__ := &WorkerOfFloat64ThenBool{
		api_syncer: NewApiDecouplerOfFloat64ThenBool(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfFloat64ThenBool, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfFloat64ThenBool{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfFloat64ThenBool(req.Context, req.WorkOfFloat64ThenBool, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfFloat64ThenBool) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfFloat64ThenBool) Push(ctx context.Context, req *WorkOfFloat64ThenBool) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfFloat64ThenBool)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfFloat64ThenBool = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfFloat64ThenBool) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfFloat64ThenBool) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfFloat64ThenBool) Call(ctx context.Context, arg float64) (bool, error) {
	return __.api_syncer.DoOfFloat64ThenBool(ctx, __, arg)
}

type PoolOfFloat64ThenByte interface {
	GetFloat64Arg() *float64
	PutFloat64Arg(*float64)
	GetByteReturn() *byte
	PutByteReturn(*byte)

	GetWorkOfFloat64ThenByte() *WorkOfFloat64ThenByte
	GetReturnOfByte() *ReturnOfByte
	PutWorkOfFloat64ThenByte(*WorkOfFloat64ThenByte)
	PutReturnOfByte(*ReturnOfByte)

	GetChReturnOfByte() chan *ReturnOfByte
	PutChReturnOfByte(chan *ReturnOfByte)
}

type PoolOfFloat64ThenByteImpl struct {
	Float64Arg     sync.Pool
	ByteRtn        sync.Pool
	Float64Work    sync.Pool
	ByteReturn     sync.Pool
	ChReturnOfByte sync.Pool
}

func (__ *PoolOfFloat64ThenByteImpl) GetFloat64Arg() *float64 {
	return __.Float64Arg.Get().(*float64)
}
func (__ *PoolOfFloat64ThenByteImpl) PutFloat64Arg(p *float64) {
	__.Float64Arg.Put(p)
}
func (__ *PoolOfFloat64ThenByteImpl) GetByteReturn() *byte {
	return __.ByteRtn.Get().(*byte)
}
func (__ *PoolOfFloat64ThenByteImpl) PutByteReturn(p *byte) {
	__.ByteRtn.Put(p)
}

func (__ *PoolOfFloat64ThenByteImpl) GetWorkOfFloat64ThenByte() *WorkOfFloat64ThenByte {
	return __.Float64Work.Get().(*WorkOfFloat64ThenByte)
}
func (__ *PoolOfFloat64ThenByteImpl) PutWorkOfFloat64ThenByte(p *WorkOfFloat64ThenByte) {
	__.Float64Work.Put(p)
}
func (__ *PoolOfFloat64ThenByteImpl) GetReturnOfByte() *ReturnOfByte {
	return __.ByteReturn.Get().(*ReturnOfByte)
}
func (__ *PoolOfFloat64ThenByteImpl) PutReturnOfByte(p *ReturnOfByte) {
	__.ByteReturn.Put(p)
}

func (__ *PoolOfFloat64ThenByteImpl) GetChReturnOfByte() chan *ReturnOfByte {
	return __.ChReturnOfByte.Get().(chan *ReturnOfByte)
}
func (__ *PoolOfFloat64ThenByteImpl) PutChReturnOfByte(p chan *ReturnOfByte) {
	__.ChReturnOfByte.Put(p)
}

func NewPoolOfFloat64ThenByteImpl() *PoolOfFloat64ThenByteImpl {
	return &PoolOfFloat64ThenByteImpl{
		Float64Arg: sync.Pool{
			New: func() interface{} {
				return new(float64)
			},
		},
		Float64Work: sync.Pool{
			New: func() interface{} {
				return new(WorkOfFloat64ThenByte)
			},
		},
		ByteRtn: sync.Pool{
			New: func() interface{} {
				return new(byte)
			},
		},
		ByteReturn: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfByte)
			},
		},
		ChReturnOfByte: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfByte, 1)
			},
		},
	}
}

type ApiDecouplerOfFloat64ThenByte struct {
	pool PoolOfFloat64ThenByte
}

func NewApiDecouplerOfFloat64ThenByte() *ApiDecouplerOfFloat64ThenByte {
	return &ApiDecouplerOfFloat64ThenByte{
		pool: NewPoolOfFloat64ThenByteImpl(),
	}
}

func (__ *ApiDecouplerOfFloat64ThenByte) ReturnError(rtn_ch chan<- *ReturnOfByte, err error) {
	rtn := __.pool.GetReturnOfByte()
	var other byte
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfFloat64ThenByte) HandleOfFloat64ThenByte(ctx context.Context, req *WorkOfFloat64ThenByte, h func(ctx context.Context, arg float64) (byte, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfByte()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfFloat64ThenByte) DoOfFloat64ThenByte(ctx context.Context, worker WorkerOfPushFloat64ThenByte, arg float64) (byte, error) {
	// ch := make(chan *ReturnOfByte, 1)
	ch := __.pool.GetChReturnOfByte()
	defer __.pool.PutChReturnOfByte(ch)

	req := __.pool.GetWorkOfFloat64ThenByte()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfFloat64ThenByte(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfByte(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfFloat64ThenByte = func(ctx context.Context, arg float64) (byte, error)

type WorkerOfFloat64ThenByte struct {
	api_syncer *ApiDecouplerOfFloat64ThenByte
	handler    WorkHandlerOfFloat64ThenByte

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfFloat64ThenByte
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfFloat64ThenByte(ctx context.Context, h WorkHandlerOfFloat64ThenByte, n int) *WorkerOfFloat64ThenByte {
	__ := &WorkerOfFloat64ThenByte{
		api_syncer: NewApiDecouplerOfFloat64ThenByte(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfFloat64ThenByte, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfFloat64ThenByte{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfFloat64ThenByte(req.Context, req.WorkOfFloat64ThenByte, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfFloat64ThenByte) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfFloat64ThenByte) Push(ctx context.Context, req *WorkOfFloat64ThenByte) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfFloat64ThenByte)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfFloat64ThenByte = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfFloat64ThenByte) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfFloat64ThenByte) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfFloat64ThenByte) Call(ctx context.Context, arg float64) (byte, error) {
	return __.api_syncer.DoOfFloat64ThenByte(ctx, __, arg)
}

type PoolOfFloat64ThenComplex128 interface {
	GetFloat64Arg() *float64
	PutFloat64Arg(*float64)
	GetComplex128Return() *complex128
	PutComplex128Return(*complex128)

	GetWorkOfFloat64ThenComplex128() *WorkOfFloat64ThenComplex128
	GetReturnOfComplex128() *ReturnOfComplex128
	PutWorkOfFloat64ThenComplex128(*WorkOfFloat64ThenComplex128)
	PutReturnOfComplex128(*ReturnOfComplex128)

	GetChReturnOfComplex128() chan *ReturnOfComplex128
	PutChReturnOfComplex128(chan *ReturnOfComplex128)
}

type PoolOfFloat64ThenComplex128Impl struct {
	Float64Arg           sync.Pool
	Complex128Rtn        sync.Pool
	Float64Work          sync.Pool
	Complex128Return     sync.Pool
	ChReturnOfComplex128 sync.Pool
}

func (__ *PoolOfFloat64ThenComplex128Impl) GetFloat64Arg() *float64 {
	return __.Float64Arg.Get().(*float64)
}
func (__ *PoolOfFloat64ThenComplex128Impl) PutFloat64Arg(p *float64) {
	__.Float64Arg.Put(p)
}
func (__ *PoolOfFloat64ThenComplex128Impl) GetComplex128Return() *complex128 {
	return __.Complex128Rtn.Get().(*complex128)
}
func (__ *PoolOfFloat64ThenComplex128Impl) PutComplex128Return(p *complex128) {
	__.Complex128Rtn.Put(p)
}

func (__ *PoolOfFloat64ThenComplex128Impl) GetWorkOfFloat64ThenComplex128() *WorkOfFloat64ThenComplex128 {
	return __.Float64Work.Get().(*WorkOfFloat64ThenComplex128)
}
func (__ *PoolOfFloat64ThenComplex128Impl) PutWorkOfFloat64ThenComplex128(p *WorkOfFloat64ThenComplex128) {
	__.Float64Work.Put(p)
}
func (__ *PoolOfFloat64ThenComplex128Impl) GetReturnOfComplex128() *ReturnOfComplex128 {
	return __.Complex128Return.Get().(*ReturnOfComplex128)
}
func (__ *PoolOfFloat64ThenComplex128Impl) PutReturnOfComplex128(p *ReturnOfComplex128) {
	__.Complex128Return.Put(p)
}

func (__ *PoolOfFloat64ThenComplex128Impl) GetChReturnOfComplex128() chan *ReturnOfComplex128 {
	return __.ChReturnOfComplex128.Get().(chan *ReturnOfComplex128)
}
func (__ *PoolOfFloat64ThenComplex128Impl) PutChReturnOfComplex128(p chan *ReturnOfComplex128) {
	__.ChReturnOfComplex128.Put(p)
}

func NewPoolOfFloat64ThenComplex128Impl() *PoolOfFloat64ThenComplex128Impl {
	return &PoolOfFloat64ThenComplex128Impl{
		Float64Arg: sync.Pool{
			New: func() interface{} {
				return new(float64)
			},
		},
		Float64Work: sync.Pool{
			New: func() interface{} {
				return new(WorkOfFloat64ThenComplex128)
			},
		},
		Complex128Rtn: sync.Pool{
			New: func() interface{} {
				return new(complex128)
			},
		},
		Complex128Return: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfComplex128)
			},
		},
		ChReturnOfComplex128: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfComplex128, 1)
			},
		},
	}
}

type ApiDecouplerOfFloat64ThenComplex128 struct {
	pool PoolOfFloat64ThenComplex128
}

func NewApiDecouplerOfFloat64ThenComplex128() *ApiDecouplerOfFloat64ThenComplex128 {
	return &ApiDecouplerOfFloat64ThenComplex128{
		pool: NewPoolOfFloat64ThenComplex128Impl(),
	}
}

func (__ *ApiDecouplerOfFloat64ThenComplex128) ReturnError(rtn_ch chan<- *ReturnOfComplex128, err error) {
	rtn := __.pool.GetReturnOfComplex128()
	var other complex128
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfFloat64ThenComplex128) HandleOfFloat64ThenComplex128(ctx context.Context, req *WorkOfFloat64ThenComplex128, h func(ctx context.Context, arg float64) (complex128, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfComplex128()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfFloat64ThenComplex128) DoOfFloat64ThenComplex128(ctx context.Context, worker WorkerOfPushFloat64ThenComplex128, arg float64) (complex128, error) {
	// ch := make(chan *ReturnOfComplex128, 1)
	ch := __.pool.GetChReturnOfComplex128()
	defer __.pool.PutChReturnOfComplex128(ch)

	req := __.pool.GetWorkOfFloat64ThenComplex128()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfFloat64ThenComplex128(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfComplex128(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfFloat64ThenComplex128 = func(ctx context.Context, arg float64) (complex128, error)

type WorkerOfFloat64ThenComplex128 struct {
	api_syncer *ApiDecouplerOfFloat64ThenComplex128
	handler    WorkHandlerOfFloat64ThenComplex128

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfFloat64ThenComplex128
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfFloat64ThenComplex128(ctx context.Context, h WorkHandlerOfFloat64ThenComplex128, n int) *WorkerOfFloat64ThenComplex128 {
	__ := &WorkerOfFloat64ThenComplex128{
		api_syncer: NewApiDecouplerOfFloat64ThenComplex128(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfFloat64ThenComplex128, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfFloat64ThenComplex128{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfFloat64ThenComplex128(req.Context, req.WorkOfFloat64ThenComplex128, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfFloat64ThenComplex128) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfFloat64ThenComplex128) Push(ctx context.Context, req *WorkOfFloat64ThenComplex128) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfFloat64ThenComplex128)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfFloat64ThenComplex128 = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfFloat64ThenComplex128) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfFloat64ThenComplex128) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfFloat64ThenComplex128) Call(ctx context.Context, arg float64) (complex128, error) {
	return __.api_syncer.DoOfFloat64ThenComplex128(ctx, __, arg)
}

type PoolOfFloat64ThenComplex64 interface {
	GetFloat64Arg() *float64
	PutFloat64Arg(*float64)
	GetComplex64Return() *complex64
	PutComplex64Return(*complex64)

	GetWorkOfFloat64ThenComplex64() *WorkOfFloat64ThenComplex64
	GetReturnOfComplex64() *ReturnOfComplex64
	PutWorkOfFloat64ThenComplex64(*WorkOfFloat64ThenComplex64)
	PutReturnOfComplex64(*ReturnOfComplex64)

	GetChReturnOfComplex64() chan *ReturnOfComplex64
	PutChReturnOfComplex64(chan *ReturnOfComplex64)
}

type PoolOfFloat64ThenComplex64Impl struct {
	Float64Arg          sync.Pool
	Complex64Rtn        sync.Pool
	Float64Work         sync.Pool
	Complex64Return     sync.Pool
	ChReturnOfComplex64 sync.Pool
}

func (__ *PoolOfFloat64ThenComplex64Impl) GetFloat64Arg() *float64 {
	return __.Float64Arg.Get().(*float64)
}
func (__ *PoolOfFloat64ThenComplex64Impl) PutFloat64Arg(p *float64) {
	__.Float64Arg.Put(p)
}
func (__ *PoolOfFloat64ThenComplex64Impl) GetComplex64Return() *complex64 {
	return __.Complex64Rtn.Get().(*complex64)
}
func (__ *PoolOfFloat64ThenComplex64Impl) PutComplex64Return(p *complex64) {
	__.Complex64Rtn.Put(p)
}

func (__ *PoolOfFloat64ThenComplex64Impl) GetWorkOfFloat64ThenComplex64() *WorkOfFloat64ThenComplex64 {
	return __.Float64Work.Get().(*WorkOfFloat64ThenComplex64)
}
func (__ *PoolOfFloat64ThenComplex64Impl) PutWorkOfFloat64ThenComplex64(p *WorkOfFloat64ThenComplex64) {
	__.Float64Work.Put(p)
}
func (__ *PoolOfFloat64ThenComplex64Impl) GetReturnOfComplex64() *ReturnOfComplex64 {
	return __.Complex64Return.Get().(*ReturnOfComplex64)
}
func (__ *PoolOfFloat64ThenComplex64Impl) PutReturnOfComplex64(p *ReturnOfComplex64) {
	__.Complex64Return.Put(p)
}

func (__ *PoolOfFloat64ThenComplex64Impl) GetChReturnOfComplex64() chan *ReturnOfComplex64 {
	return __.ChReturnOfComplex64.Get().(chan *ReturnOfComplex64)
}
func (__ *PoolOfFloat64ThenComplex64Impl) PutChReturnOfComplex64(p chan *ReturnOfComplex64) {
	__.ChReturnOfComplex64.Put(p)
}

func NewPoolOfFloat64ThenComplex64Impl() *PoolOfFloat64ThenComplex64Impl {
	return &PoolOfFloat64ThenComplex64Impl{
		Float64Arg: sync.Pool{
			New: func() interface{} {
				return new(float64)
			},
		},
		Float64Work: sync.Pool{
			New: func() interface{} {
				return new(WorkOfFloat64ThenComplex64)
			},
		},
		Complex64Rtn: sync.Pool{
			New: func() interface{} {
				return new(complex64)
			},
		},
		Complex64Return: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfComplex64)
			},
		},
		ChReturnOfComplex64: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfComplex64, 1)
			},
		},
	}
}

type ApiDecouplerOfFloat64ThenComplex64 struct {
	pool PoolOfFloat64ThenComplex64
}

func NewApiDecouplerOfFloat64ThenComplex64() *ApiDecouplerOfFloat64ThenComplex64 {
	return &ApiDecouplerOfFloat64ThenComplex64{
		pool: NewPoolOfFloat64ThenComplex64Impl(),
	}
}

func (__ *ApiDecouplerOfFloat64ThenComplex64) ReturnError(rtn_ch chan<- *ReturnOfComplex64, err error) {
	rtn := __.pool.GetReturnOfComplex64()
	var other complex64
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfFloat64ThenComplex64) HandleOfFloat64ThenComplex64(ctx context.Context, req *WorkOfFloat64ThenComplex64, h func(ctx context.Context, arg float64) (complex64, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfComplex64()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfFloat64ThenComplex64) DoOfFloat64ThenComplex64(ctx context.Context, worker WorkerOfPushFloat64ThenComplex64, arg float64) (complex64, error) {
	// ch := make(chan *ReturnOfComplex64, 1)
	ch := __.pool.GetChReturnOfComplex64()
	defer __.pool.PutChReturnOfComplex64(ch)

	req := __.pool.GetWorkOfFloat64ThenComplex64()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfFloat64ThenComplex64(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfComplex64(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfFloat64ThenComplex64 = func(ctx context.Context, arg float64) (complex64, error)

type WorkerOfFloat64ThenComplex64 struct {
	api_syncer *ApiDecouplerOfFloat64ThenComplex64
	handler    WorkHandlerOfFloat64ThenComplex64

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfFloat64ThenComplex64
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfFloat64ThenComplex64(ctx context.Context, h WorkHandlerOfFloat64ThenComplex64, n int) *WorkerOfFloat64ThenComplex64 {
	__ := &WorkerOfFloat64ThenComplex64{
		api_syncer: NewApiDecouplerOfFloat64ThenComplex64(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfFloat64ThenComplex64, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfFloat64ThenComplex64{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfFloat64ThenComplex64(req.Context, req.WorkOfFloat64ThenComplex64, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfFloat64ThenComplex64) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfFloat64ThenComplex64) Push(ctx context.Context, req *WorkOfFloat64ThenComplex64) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfFloat64ThenComplex64)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfFloat64ThenComplex64 = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfFloat64ThenComplex64) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfFloat64ThenComplex64) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfFloat64ThenComplex64) Call(ctx context.Context, arg float64) (complex64, error) {
	return __.api_syncer.DoOfFloat64ThenComplex64(ctx, __, arg)
}

type PoolOfFloat64ThenError interface {
	GetFloat64Arg() *float64
	PutFloat64Arg(*float64)
	GetErrorReturn() *error
	PutErrorReturn(*error)

	GetWorkOfFloat64ThenError() *WorkOfFloat64ThenError
	GetReturnOfError() *ReturnOfError
	PutWorkOfFloat64ThenError(*WorkOfFloat64ThenError)
	PutReturnOfError(*ReturnOfError)

	GetChReturnOfError() chan *ReturnOfError
	PutChReturnOfError(chan *ReturnOfError)
}

type PoolOfFloat64ThenErrorImpl struct {
	Float64Arg      sync.Pool
	ErrorRtn        sync.Pool
	Float64Work     sync.Pool
	ErrorReturn     sync.Pool
	ChReturnOfError sync.Pool
}

func (__ *PoolOfFloat64ThenErrorImpl) GetFloat64Arg() *float64 {
	return __.Float64Arg.Get().(*float64)
}
func (__ *PoolOfFloat64ThenErrorImpl) PutFloat64Arg(p *float64) {
	__.Float64Arg.Put(p)
}
func (__ *PoolOfFloat64ThenErrorImpl) GetErrorReturn() *error {
	return __.ErrorRtn.Get().(*error)
}
func (__ *PoolOfFloat64ThenErrorImpl) PutErrorReturn(p *error) {
	__.ErrorRtn.Put(p)
}

func (__ *PoolOfFloat64ThenErrorImpl) GetWorkOfFloat64ThenError() *WorkOfFloat64ThenError {
	return __.Float64Work.Get().(*WorkOfFloat64ThenError)
}
func (__ *PoolOfFloat64ThenErrorImpl) PutWorkOfFloat64ThenError(p *WorkOfFloat64ThenError) {
	__.Float64Work.Put(p)
}
func (__ *PoolOfFloat64ThenErrorImpl) GetReturnOfError() *ReturnOfError {
	return __.ErrorReturn.Get().(*ReturnOfError)
}
func (__ *PoolOfFloat64ThenErrorImpl) PutReturnOfError(p *ReturnOfError) {
	__.ErrorReturn.Put(p)
}

func (__ *PoolOfFloat64ThenErrorImpl) GetChReturnOfError() chan *ReturnOfError {
	return __.ChReturnOfError.Get().(chan *ReturnOfError)
}
func (__ *PoolOfFloat64ThenErrorImpl) PutChReturnOfError(p chan *ReturnOfError) {
	__.ChReturnOfError.Put(p)
}

func NewPoolOfFloat64ThenErrorImpl() *PoolOfFloat64ThenErrorImpl {
	return &PoolOfFloat64ThenErrorImpl{
		Float64Arg: sync.Pool{
			New: func() interface{} {
				return new(float64)
			},
		},
		Float64Work: sync.Pool{
			New: func() interface{} {
				return new(WorkOfFloat64ThenError)
			},
		},
		ErrorRtn: sync.Pool{
			New: func() interface{} {
				return new(error)
			},
		},
		ErrorReturn: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfError)
			},
		},
		ChReturnOfError: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfError, 1)
			},
		},
	}
}

type ApiDecouplerOfFloat64ThenError struct {
	pool PoolOfFloat64ThenError
}

func NewApiDecouplerOfFloat64ThenError() *ApiDecouplerOfFloat64ThenError {
	return &ApiDecouplerOfFloat64ThenError{
		pool: NewPoolOfFloat64ThenErrorImpl(),
	}
}

func (__ *ApiDecouplerOfFloat64ThenError) ReturnError(rtn_ch chan<- *ReturnOfError, err error) {
	rtn := __.pool.GetReturnOfError()
	var other error
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfFloat64ThenError) HandleOfFloat64ThenError(ctx context.Context, req *WorkOfFloat64ThenError, h func(ctx context.Context, arg float64) (error, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfError()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfFloat64ThenError) DoOfFloat64ThenError(ctx context.Context, worker WorkerOfPushFloat64ThenError, arg float64) (error, error) {
	// ch := make(chan *ReturnOfError, 1)
	ch := __.pool.GetChReturnOfError()
	defer __.pool.PutChReturnOfError(ch)

	req := __.pool.GetWorkOfFloat64ThenError()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfFloat64ThenError(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfError(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfFloat64ThenError = func(ctx context.Context, arg float64) (error, error)

type WorkerOfFloat64ThenError struct {
	api_syncer *ApiDecouplerOfFloat64ThenError
	handler    WorkHandlerOfFloat64ThenError

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfFloat64ThenError
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfFloat64ThenError(ctx context.Context, h WorkHandlerOfFloat64ThenError, n int) *WorkerOfFloat64ThenError {
	__ := &WorkerOfFloat64ThenError{
		api_syncer: NewApiDecouplerOfFloat64ThenError(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfFloat64ThenError, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfFloat64ThenError{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfFloat64ThenError(req.Context, req.WorkOfFloat64ThenError, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfFloat64ThenError) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfFloat64ThenError) Push(ctx context.Context, req *WorkOfFloat64ThenError) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfFloat64ThenError)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfFloat64ThenError = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfFloat64ThenError) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfFloat64ThenError) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfFloat64ThenError) Call(ctx context.Context, arg float64) (error, error) {
	return __.api_syncer.DoOfFloat64ThenError(ctx, __, arg)
}

type PoolOfFloat64ThenFloat32 interface {
	GetFloat64Arg() *float64
	PutFloat64Arg(*float64)
	GetFloat32Return() *float32
	PutFloat32Return(*float32)

	GetWorkOfFloat64ThenFloat32() *WorkOfFloat64ThenFloat32
	GetReturnOfFloat32() *ReturnOfFloat32
	PutWorkOfFloat64ThenFloat32(*WorkOfFloat64ThenFloat32)
	PutReturnOfFloat32(*ReturnOfFloat32)

	GetChReturnOfFloat32() chan *ReturnOfFloat32
	PutChReturnOfFloat32(chan *ReturnOfFloat32)
}

type PoolOfFloat64ThenFloat32Impl struct {
	Float64Arg        sync.Pool
	Float32Rtn        sync.Pool
	Float64Work       sync.Pool
	Float32Return     sync.Pool
	ChReturnOfFloat32 sync.Pool
}

func (__ *PoolOfFloat64ThenFloat32Impl) GetFloat64Arg() *float64 {
	return __.Float64Arg.Get().(*float64)
}
func (__ *PoolOfFloat64ThenFloat32Impl) PutFloat64Arg(p *float64) {
	__.Float64Arg.Put(p)
}
func (__ *PoolOfFloat64ThenFloat32Impl) GetFloat32Return() *float32 {
	return __.Float32Rtn.Get().(*float32)
}
func (__ *PoolOfFloat64ThenFloat32Impl) PutFloat32Return(p *float32) {
	__.Float32Rtn.Put(p)
}

func (__ *PoolOfFloat64ThenFloat32Impl) GetWorkOfFloat64ThenFloat32() *WorkOfFloat64ThenFloat32 {
	return __.Float64Work.Get().(*WorkOfFloat64ThenFloat32)
}
func (__ *PoolOfFloat64ThenFloat32Impl) PutWorkOfFloat64ThenFloat32(p *WorkOfFloat64ThenFloat32) {
	__.Float64Work.Put(p)
}
func (__ *PoolOfFloat64ThenFloat32Impl) GetReturnOfFloat32() *ReturnOfFloat32 {
	return __.Float32Return.Get().(*ReturnOfFloat32)
}
func (__ *PoolOfFloat64ThenFloat32Impl) PutReturnOfFloat32(p *ReturnOfFloat32) {
	__.Float32Return.Put(p)
}

func (__ *PoolOfFloat64ThenFloat32Impl) GetChReturnOfFloat32() chan *ReturnOfFloat32 {
	return __.ChReturnOfFloat32.Get().(chan *ReturnOfFloat32)
}
func (__ *PoolOfFloat64ThenFloat32Impl) PutChReturnOfFloat32(p chan *ReturnOfFloat32) {
	__.ChReturnOfFloat32.Put(p)
}

func NewPoolOfFloat64ThenFloat32Impl() *PoolOfFloat64ThenFloat32Impl {
	return &PoolOfFloat64ThenFloat32Impl{
		Float64Arg: sync.Pool{
			New: func() interface{} {
				return new(float64)
			},
		},
		Float64Work: sync.Pool{
			New: func() interface{} {
				return new(WorkOfFloat64ThenFloat32)
			},
		},
		Float32Rtn: sync.Pool{
			New: func() interface{} {
				return new(float32)
			},
		},
		Float32Return: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfFloat32)
			},
		},
		ChReturnOfFloat32: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfFloat32, 1)
			},
		},
	}
}

type ApiDecouplerOfFloat64ThenFloat32 struct {
	pool PoolOfFloat64ThenFloat32
}

func NewApiDecouplerOfFloat64ThenFloat32() *ApiDecouplerOfFloat64ThenFloat32 {
	return &ApiDecouplerOfFloat64ThenFloat32{
		pool: NewPoolOfFloat64ThenFloat32Impl(),
	}
}

func (__ *ApiDecouplerOfFloat64ThenFloat32) ReturnError(rtn_ch chan<- *ReturnOfFloat32, err error) {
	rtn := __.pool.GetReturnOfFloat32()
	var other float32
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfFloat64ThenFloat32) HandleOfFloat64ThenFloat32(ctx context.Context, req *WorkOfFloat64ThenFloat32, h func(ctx context.Context, arg float64) (float32, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfFloat32()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfFloat64ThenFloat32) DoOfFloat64ThenFloat32(ctx context.Context, worker WorkerOfPushFloat64ThenFloat32, arg float64) (float32, error) {
	// ch := make(chan *ReturnOfFloat32, 1)
	ch := __.pool.GetChReturnOfFloat32()
	defer __.pool.PutChReturnOfFloat32(ch)

	req := __.pool.GetWorkOfFloat64ThenFloat32()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfFloat64ThenFloat32(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfFloat32(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfFloat64ThenFloat32 = func(ctx context.Context, arg float64) (float32, error)

type WorkerOfFloat64ThenFloat32 struct {
	api_syncer *ApiDecouplerOfFloat64ThenFloat32
	handler    WorkHandlerOfFloat64ThenFloat32

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfFloat64ThenFloat32
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfFloat64ThenFloat32(ctx context.Context, h WorkHandlerOfFloat64ThenFloat32, n int) *WorkerOfFloat64ThenFloat32 {
	__ := &WorkerOfFloat64ThenFloat32{
		api_syncer: NewApiDecouplerOfFloat64ThenFloat32(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfFloat64ThenFloat32, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfFloat64ThenFloat32{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfFloat64ThenFloat32(req.Context, req.WorkOfFloat64ThenFloat32, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfFloat64ThenFloat32) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfFloat64ThenFloat32) Push(ctx context.Context, req *WorkOfFloat64ThenFloat32) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfFloat64ThenFloat32)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfFloat64ThenFloat32 = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfFloat64ThenFloat32) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfFloat64ThenFloat32) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfFloat64ThenFloat32) Call(ctx context.Context, arg float64) (float32, error) {
	return __.api_syncer.DoOfFloat64ThenFloat32(ctx, __, arg)
}

type PoolOfFloat64ThenFloat64 interface {
	GetFloat64Arg() *float64
	PutFloat64Arg(*float64)
	GetFloat64Return() *float64
	PutFloat64Return(*float64)

	GetWorkOfFloat64ThenFloat64() *WorkOfFloat64ThenFloat64
	GetReturnOfFloat64() *ReturnOfFloat64
	PutWorkOfFloat64ThenFloat64(*WorkOfFloat64ThenFloat64)
	PutReturnOfFloat64(*ReturnOfFloat64)

	GetChReturnOfFloat64() chan *ReturnOfFloat64
	PutChReturnOfFloat64(chan *ReturnOfFloat64)
}

type PoolOfFloat64ThenFloat64Impl struct {
	Float64Arg        sync.Pool
	Float64Rtn        sync.Pool
	Float64Work       sync.Pool
	Float64Return     sync.Pool
	ChReturnOfFloat64 sync.Pool
}

func (__ *PoolOfFloat64ThenFloat64Impl) GetFloat64Arg() *float64 {
	return __.Float64Arg.Get().(*float64)
}
func (__ *PoolOfFloat64ThenFloat64Impl) PutFloat64Arg(p *float64) {
	__.Float64Arg.Put(p)
}
func (__ *PoolOfFloat64ThenFloat64Impl) GetFloat64Return() *float64 {
	return __.Float64Rtn.Get().(*float64)
}
func (__ *PoolOfFloat64ThenFloat64Impl) PutFloat64Return(p *float64) {
	__.Float64Rtn.Put(p)
}

func (__ *PoolOfFloat64ThenFloat64Impl) GetWorkOfFloat64ThenFloat64() *WorkOfFloat64ThenFloat64 {
	return __.Float64Work.Get().(*WorkOfFloat64ThenFloat64)
}
func (__ *PoolOfFloat64ThenFloat64Impl) PutWorkOfFloat64ThenFloat64(p *WorkOfFloat64ThenFloat64) {
	__.Float64Work.Put(p)
}
func (__ *PoolOfFloat64ThenFloat64Impl) GetReturnOfFloat64() *ReturnOfFloat64 {
	return __.Float64Return.Get().(*ReturnOfFloat64)
}
func (__ *PoolOfFloat64ThenFloat64Impl) PutReturnOfFloat64(p *ReturnOfFloat64) {
	__.Float64Return.Put(p)
}

func (__ *PoolOfFloat64ThenFloat64Impl) GetChReturnOfFloat64() chan *ReturnOfFloat64 {
	return __.ChReturnOfFloat64.Get().(chan *ReturnOfFloat64)
}
func (__ *PoolOfFloat64ThenFloat64Impl) PutChReturnOfFloat64(p chan *ReturnOfFloat64) {
	__.ChReturnOfFloat64.Put(p)
}

func NewPoolOfFloat64ThenFloat64Impl() *PoolOfFloat64ThenFloat64Impl {
	return &PoolOfFloat64ThenFloat64Impl{
		Float64Arg: sync.Pool{
			New: func() interface{} {
				return new(float64)
			},
		},
		Float64Work: sync.Pool{
			New: func() interface{} {
				return new(WorkOfFloat64ThenFloat64)
			},
		},
		Float64Rtn: sync.Pool{
			New: func() interface{} {
				return new(float64)
			},
		},
		Float64Return: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfFloat64)
			},
		},
		ChReturnOfFloat64: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfFloat64, 1)
			},
		},
	}
}

type ApiDecouplerOfFloat64ThenFloat64 struct {
	pool PoolOfFloat64ThenFloat64
}

func NewApiDecouplerOfFloat64ThenFloat64() *ApiDecouplerOfFloat64ThenFloat64 {
	return &ApiDecouplerOfFloat64ThenFloat64{
		pool: NewPoolOfFloat64ThenFloat64Impl(),
	}
}

func (__ *ApiDecouplerOfFloat64ThenFloat64) ReturnError(rtn_ch chan<- *ReturnOfFloat64, err error) {
	rtn := __.pool.GetReturnOfFloat64()
	var other float64
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfFloat64ThenFloat64) HandleOfFloat64ThenFloat64(ctx context.Context, req *WorkOfFloat64ThenFloat64, h func(ctx context.Context, arg float64) (float64, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfFloat64()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfFloat64ThenFloat64) DoOfFloat64ThenFloat64(ctx context.Context, worker WorkerOfPushFloat64ThenFloat64, arg float64) (float64, error) {
	// ch := make(chan *ReturnOfFloat64, 1)
	ch := __.pool.GetChReturnOfFloat64()
	defer __.pool.PutChReturnOfFloat64(ch)

	req := __.pool.GetWorkOfFloat64ThenFloat64()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfFloat64ThenFloat64(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfFloat64(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfFloat64ThenFloat64 = func(ctx context.Context, arg float64) (float64, error)

type WorkerOfFloat64ThenFloat64 struct {
	api_syncer *ApiDecouplerOfFloat64ThenFloat64
	handler    WorkHandlerOfFloat64ThenFloat64

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfFloat64ThenFloat64
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfFloat64ThenFloat64(ctx context.Context, h WorkHandlerOfFloat64ThenFloat64, n int) *WorkerOfFloat64ThenFloat64 {
	__ := &WorkerOfFloat64ThenFloat64{
		api_syncer: NewApiDecouplerOfFloat64ThenFloat64(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfFloat64ThenFloat64, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfFloat64ThenFloat64{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfFloat64ThenFloat64(req.Context, req.WorkOfFloat64ThenFloat64, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfFloat64ThenFloat64) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfFloat64ThenFloat64) Push(ctx context.Context, req *WorkOfFloat64ThenFloat64) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfFloat64ThenFloat64)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfFloat64ThenFloat64 = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfFloat64ThenFloat64) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfFloat64ThenFloat64) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfFloat64ThenFloat64) Call(ctx context.Context, arg float64) (float64, error) {
	return __.api_syncer.DoOfFloat64ThenFloat64(ctx, __, arg)
}

type PoolOfFloat64ThenInt interface {
	GetFloat64Arg() *float64
	PutFloat64Arg(*float64)
	GetIntReturn() *int
	PutIntReturn(*int)

	GetWorkOfFloat64ThenInt() *WorkOfFloat64ThenInt
	GetReturnOfInt() *ReturnOfInt
	PutWorkOfFloat64ThenInt(*WorkOfFloat64ThenInt)
	PutReturnOfInt(*ReturnOfInt)

	GetChReturnOfInt() chan *ReturnOfInt
	PutChReturnOfInt(chan *ReturnOfInt)
}

type PoolOfFloat64ThenIntImpl struct {
	Float64Arg    sync.Pool
	IntRtn        sync.Pool
	Float64Work   sync.Pool
	IntReturn     sync.Pool
	ChReturnOfInt sync.Pool
}

func (__ *PoolOfFloat64ThenIntImpl) GetFloat64Arg() *float64 {
	return __.Float64Arg.Get().(*float64)
}
func (__ *PoolOfFloat64ThenIntImpl) PutFloat64Arg(p *float64) {
	__.Float64Arg.Put(p)
}
func (__ *PoolOfFloat64ThenIntImpl) GetIntReturn() *int {
	return __.IntRtn.Get().(*int)
}
func (__ *PoolOfFloat64ThenIntImpl) PutIntReturn(p *int) {
	__.IntRtn.Put(p)
}

func (__ *PoolOfFloat64ThenIntImpl) GetWorkOfFloat64ThenInt() *WorkOfFloat64ThenInt {
	return __.Float64Work.Get().(*WorkOfFloat64ThenInt)
}
func (__ *PoolOfFloat64ThenIntImpl) PutWorkOfFloat64ThenInt(p *WorkOfFloat64ThenInt) {
	__.Float64Work.Put(p)
}
func (__ *PoolOfFloat64ThenIntImpl) GetReturnOfInt() *ReturnOfInt {
	return __.IntReturn.Get().(*ReturnOfInt)
}
func (__ *PoolOfFloat64ThenIntImpl) PutReturnOfInt(p *ReturnOfInt) {
	__.IntReturn.Put(p)
}

func (__ *PoolOfFloat64ThenIntImpl) GetChReturnOfInt() chan *ReturnOfInt {
	return __.ChReturnOfInt.Get().(chan *ReturnOfInt)
}
func (__ *PoolOfFloat64ThenIntImpl) PutChReturnOfInt(p chan *ReturnOfInt) {
	__.ChReturnOfInt.Put(p)
}

func NewPoolOfFloat64ThenIntImpl() *PoolOfFloat64ThenIntImpl {
	return &PoolOfFloat64ThenIntImpl{
		Float64Arg: sync.Pool{
			New: func() interface{} {
				return new(float64)
			},
		},
		Float64Work: sync.Pool{
			New: func() interface{} {
				return new(WorkOfFloat64ThenInt)
			},
		},
		IntRtn: sync.Pool{
			New: func() interface{} {
				return new(int)
			},
		},
		IntReturn: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfInt)
			},
		},
		ChReturnOfInt: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfInt, 1)
			},
		},
	}
}

type ApiDecouplerOfFloat64ThenInt struct {
	pool PoolOfFloat64ThenInt
}

func NewApiDecouplerOfFloat64ThenInt() *ApiDecouplerOfFloat64ThenInt {
	return &ApiDecouplerOfFloat64ThenInt{
		pool: NewPoolOfFloat64ThenIntImpl(),
	}
}

func (__ *ApiDecouplerOfFloat64ThenInt) ReturnError(rtn_ch chan<- *ReturnOfInt, err error) {
	rtn := __.pool.GetReturnOfInt()
	var other int
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfFloat64ThenInt) HandleOfFloat64ThenInt(ctx context.Context, req *WorkOfFloat64ThenInt, h func(ctx context.Context, arg float64) (int, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfInt()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfFloat64ThenInt) DoOfFloat64ThenInt(ctx context.Context, worker WorkerOfPushFloat64ThenInt, arg float64) (int, error) {
	// ch := make(chan *ReturnOfInt, 1)
	ch := __.pool.GetChReturnOfInt()
	defer __.pool.PutChReturnOfInt(ch)

	req := __.pool.GetWorkOfFloat64ThenInt()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfFloat64ThenInt(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfInt(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfFloat64ThenInt = func(ctx context.Context, arg float64) (int, error)

type WorkerOfFloat64ThenInt struct {
	api_syncer *ApiDecouplerOfFloat64ThenInt
	handler    WorkHandlerOfFloat64ThenInt

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfFloat64ThenInt
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfFloat64ThenInt(ctx context.Context, h WorkHandlerOfFloat64ThenInt, n int) *WorkerOfFloat64ThenInt {
	__ := &WorkerOfFloat64ThenInt{
		api_syncer: NewApiDecouplerOfFloat64ThenInt(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfFloat64ThenInt, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfFloat64ThenInt{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfFloat64ThenInt(req.Context, req.WorkOfFloat64ThenInt, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfFloat64ThenInt) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfFloat64ThenInt) Push(ctx context.Context, req *WorkOfFloat64ThenInt) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfFloat64ThenInt)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfFloat64ThenInt = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfFloat64ThenInt) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfFloat64ThenInt) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfFloat64ThenInt) Call(ctx context.Context, arg float64) (int, error) {
	return __.api_syncer.DoOfFloat64ThenInt(ctx, __, arg)
}

type PoolOfFloat64ThenInt16 interface {
	GetFloat64Arg() *float64
	PutFloat64Arg(*float64)
	GetInt16Return() *int16
	PutInt16Return(*int16)

	GetWorkOfFloat64ThenInt16() *WorkOfFloat64ThenInt16
	GetReturnOfInt16() *ReturnOfInt16
	PutWorkOfFloat64ThenInt16(*WorkOfFloat64ThenInt16)
	PutReturnOfInt16(*ReturnOfInt16)

	GetChReturnOfInt16() chan *ReturnOfInt16
	PutChReturnOfInt16(chan *ReturnOfInt16)
}

type PoolOfFloat64ThenInt16Impl struct {
	Float64Arg      sync.Pool
	Int16Rtn        sync.Pool
	Float64Work     sync.Pool
	Int16Return     sync.Pool
	ChReturnOfInt16 sync.Pool
}

func (__ *PoolOfFloat64ThenInt16Impl) GetFloat64Arg() *float64 {
	return __.Float64Arg.Get().(*float64)
}
func (__ *PoolOfFloat64ThenInt16Impl) PutFloat64Arg(p *float64) {
	__.Float64Arg.Put(p)
}
func (__ *PoolOfFloat64ThenInt16Impl) GetInt16Return() *int16 {
	return __.Int16Rtn.Get().(*int16)
}
func (__ *PoolOfFloat64ThenInt16Impl) PutInt16Return(p *int16) {
	__.Int16Rtn.Put(p)
}

func (__ *PoolOfFloat64ThenInt16Impl) GetWorkOfFloat64ThenInt16() *WorkOfFloat64ThenInt16 {
	return __.Float64Work.Get().(*WorkOfFloat64ThenInt16)
}
func (__ *PoolOfFloat64ThenInt16Impl) PutWorkOfFloat64ThenInt16(p *WorkOfFloat64ThenInt16) {
	__.Float64Work.Put(p)
}
func (__ *PoolOfFloat64ThenInt16Impl) GetReturnOfInt16() *ReturnOfInt16 {
	return __.Int16Return.Get().(*ReturnOfInt16)
}
func (__ *PoolOfFloat64ThenInt16Impl) PutReturnOfInt16(p *ReturnOfInt16) {
	__.Int16Return.Put(p)
}

func (__ *PoolOfFloat64ThenInt16Impl) GetChReturnOfInt16() chan *ReturnOfInt16 {
	return __.ChReturnOfInt16.Get().(chan *ReturnOfInt16)
}
func (__ *PoolOfFloat64ThenInt16Impl) PutChReturnOfInt16(p chan *ReturnOfInt16) {
	__.ChReturnOfInt16.Put(p)
}

func NewPoolOfFloat64ThenInt16Impl() *PoolOfFloat64ThenInt16Impl {
	return &PoolOfFloat64ThenInt16Impl{
		Float64Arg: sync.Pool{
			New: func() interface{} {
				return new(float64)
			},
		},
		Float64Work: sync.Pool{
			New: func() interface{} {
				return new(WorkOfFloat64ThenInt16)
			},
		},
		Int16Rtn: sync.Pool{
			New: func() interface{} {
				return new(int16)
			},
		},
		Int16Return: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfInt16)
			},
		},
		ChReturnOfInt16: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfInt16, 1)
			},
		},
	}
}

type ApiDecouplerOfFloat64ThenInt16 struct {
	pool PoolOfFloat64ThenInt16
}

func NewApiDecouplerOfFloat64ThenInt16() *ApiDecouplerOfFloat64ThenInt16 {
	return &ApiDecouplerOfFloat64ThenInt16{
		pool: NewPoolOfFloat64ThenInt16Impl(),
	}
}

func (__ *ApiDecouplerOfFloat64ThenInt16) ReturnError(rtn_ch chan<- *ReturnOfInt16, err error) {
	rtn := __.pool.GetReturnOfInt16()
	var other int16
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfFloat64ThenInt16) HandleOfFloat64ThenInt16(ctx context.Context, req *WorkOfFloat64ThenInt16, h func(ctx context.Context, arg float64) (int16, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfInt16()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfFloat64ThenInt16) DoOfFloat64ThenInt16(ctx context.Context, worker WorkerOfPushFloat64ThenInt16, arg float64) (int16, error) {
	// ch := make(chan *ReturnOfInt16, 1)
	ch := __.pool.GetChReturnOfInt16()
	defer __.pool.PutChReturnOfInt16(ch)

	req := __.pool.GetWorkOfFloat64ThenInt16()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfFloat64ThenInt16(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfInt16(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfFloat64ThenInt16 = func(ctx context.Context, arg float64) (int16, error)

type WorkerOfFloat64ThenInt16 struct {
	api_syncer *ApiDecouplerOfFloat64ThenInt16
	handler    WorkHandlerOfFloat64ThenInt16

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfFloat64ThenInt16
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfFloat64ThenInt16(ctx context.Context, h WorkHandlerOfFloat64ThenInt16, n int) *WorkerOfFloat64ThenInt16 {
	__ := &WorkerOfFloat64ThenInt16{
		api_syncer: NewApiDecouplerOfFloat64ThenInt16(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfFloat64ThenInt16, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfFloat64ThenInt16{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfFloat64ThenInt16(req.Context, req.WorkOfFloat64ThenInt16, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfFloat64ThenInt16) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfFloat64ThenInt16) Push(ctx context.Context, req *WorkOfFloat64ThenInt16) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfFloat64ThenInt16)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfFloat64ThenInt16 = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfFloat64ThenInt16) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfFloat64ThenInt16) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfFloat64ThenInt16) Call(ctx context.Context, arg float64) (int16, error) {
	return __.api_syncer.DoOfFloat64ThenInt16(ctx, __, arg)
}

type PoolOfFloat64ThenInt32 interface {
	GetFloat64Arg() *float64
	PutFloat64Arg(*float64)
	GetInt32Return() *int32
	PutInt32Return(*int32)

	GetWorkOfFloat64ThenInt32() *WorkOfFloat64ThenInt32
	GetReturnOfInt32() *ReturnOfInt32
	PutWorkOfFloat64ThenInt32(*WorkOfFloat64ThenInt32)
	PutReturnOfInt32(*ReturnOfInt32)

	GetChReturnOfInt32() chan *ReturnOfInt32
	PutChReturnOfInt32(chan *ReturnOfInt32)
}

type PoolOfFloat64ThenInt32Impl struct {
	Float64Arg      sync.Pool
	Int32Rtn        sync.Pool
	Float64Work     sync.Pool
	Int32Return     sync.Pool
	ChReturnOfInt32 sync.Pool
}

func (__ *PoolOfFloat64ThenInt32Impl) GetFloat64Arg() *float64 {
	return __.Float64Arg.Get().(*float64)
}
func (__ *PoolOfFloat64ThenInt32Impl) PutFloat64Arg(p *float64) {
	__.Float64Arg.Put(p)
}
func (__ *PoolOfFloat64ThenInt32Impl) GetInt32Return() *int32 {
	return __.Int32Rtn.Get().(*int32)
}
func (__ *PoolOfFloat64ThenInt32Impl) PutInt32Return(p *int32) {
	__.Int32Rtn.Put(p)
}

func (__ *PoolOfFloat64ThenInt32Impl) GetWorkOfFloat64ThenInt32() *WorkOfFloat64ThenInt32 {
	return __.Float64Work.Get().(*WorkOfFloat64ThenInt32)
}
func (__ *PoolOfFloat64ThenInt32Impl) PutWorkOfFloat64ThenInt32(p *WorkOfFloat64ThenInt32) {
	__.Float64Work.Put(p)
}
func (__ *PoolOfFloat64ThenInt32Impl) GetReturnOfInt32() *ReturnOfInt32 {
	return __.Int32Return.Get().(*ReturnOfInt32)
}
func (__ *PoolOfFloat64ThenInt32Impl) PutReturnOfInt32(p *ReturnOfInt32) {
	__.Int32Return.Put(p)
}

func (__ *PoolOfFloat64ThenInt32Impl) GetChReturnOfInt32() chan *ReturnOfInt32 {
	return __.ChReturnOfInt32.Get().(chan *ReturnOfInt32)
}
func (__ *PoolOfFloat64ThenInt32Impl) PutChReturnOfInt32(p chan *ReturnOfInt32) {
	__.ChReturnOfInt32.Put(p)
}

func NewPoolOfFloat64ThenInt32Impl() *PoolOfFloat64ThenInt32Impl {
	return &PoolOfFloat64ThenInt32Impl{
		Float64Arg: sync.Pool{
			New: func() interface{} {
				return new(float64)
			},
		},
		Float64Work: sync.Pool{
			New: func() interface{} {
				return new(WorkOfFloat64ThenInt32)
			},
		},
		Int32Rtn: sync.Pool{
			New: func() interface{} {
				return new(int32)
			},
		},
		Int32Return: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfInt32)
			},
		},
		ChReturnOfInt32: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfInt32, 1)
			},
		},
	}
}

type ApiDecouplerOfFloat64ThenInt32 struct {
	pool PoolOfFloat64ThenInt32
}

func NewApiDecouplerOfFloat64ThenInt32() *ApiDecouplerOfFloat64ThenInt32 {
	return &ApiDecouplerOfFloat64ThenInt32{
		pool: NewPoolOfFloat64ThenInt32Impl(),
	}
}

func (__ *ApiDecouplerOfFloat64ThenInt32) ReturnError(rtn_ch chan<- *ReturnOfInt32, err error) {
	rtn := __.pool.GetReturnOfInt32()
	var other int32
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfFloat64ThenInt32) HandleOfFloat64ThenInt32(ctx context.Context, req *WorkOfFloat64ThenInt32, h func(ctx context.Context, arg float64) (int32, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfInt32()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfFloat64ThenInt32) DoOfFloat64ThenInt32(ctx context.Context, worker WorkerOfPushFloat64ThenInt32, arg float64) (int32, error) {
	// ch := make(chan *ReturnOfInt32, 1)
	ch := __.pool.GetChReturnOfInt32()
	defer __.pool.PutChReturnOfInt32(ch)

	req := __.pool.GetWorkOfFloat64ThenInt32()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfFloat64ThenInt32(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfInt32(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfFloat64ThenInt32 = func(ctx context.Context, arg float64) (int32, error)

type WorkerOfFloat64ThenInt32 struct {
	api_syncer *ApiDecouplerOfFloat64ThenInt32
	handler    WorkHandlerOfFloat64ThenInt32

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfFloat64ThenInt32
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfFloat64ThenInt32(ctx context.Context, h WorkHandlerOfFloat64ThenInt32, n int) *WorkerOfFloat64ThenInt32 {
	__ := &WorkerOfFloat64ThenInt32{
		api_syncer: NewApiDecouplerOfFloat64ThenInt32(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfFloat64ThenInt32, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfFloat64ThenInt32{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfFloat64ThenInt32(req.Context, req.WorkOfFloat64ThenInt32, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfFloat64ThenInt32) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfFloat64ThenInt32) Push(ctx context.Context, req *WorkOfFloat64ThenInt32) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfFloat64ThenInt32)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfFloat64ThenInt32 = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfFloat64ThenInt32) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfFloat64ThenInt32) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfFloat64ThenInt32) Call(ctx context.Context, arg float64) (int32, error) {
	return __.api_syncer.DoOfFloat64ThenInt32(ctx, __, arg)
}

type PoolOfFloat64ThenInt64 interface {
	GetFloat64Arg() *float64
	PutFloat64Arg(*float64)
	GetInt64Return() *int64
	PutInt64Return(*int64)

	GetWorkOfFloat64ThenInt64() *WorkOfFloat64ThenInt64
	GetReturnOfInt64() *ReturnOfInt64
	PutWorkOfFloat64ThenInt64(*WorkOfFloat64ThenInt64)
	PutReturnOfInt64(*ReturnOfInt64)

	GetChReturnOfInt64() chan *ReturnOfInt64
	PutChReturnOfInt64(chan *ReturnOfInt64)
}

type PoolOfFloat64ThenInt64Impl struct {
	Float64Arg      sync.Pool
	Int64Rtn        sync.Pool
	Float64Work     sync.Pool
	Int64Return     sync.Pool
	ChReturnOfInt64 sync.Pool
}

func (__ *PoolOfFloat64ThenInt64Impl) GetFloat64Arg() *float64 {
	return __.Float64Arg.Get().(*float64)
}
func (__ *PoolOfFloat64ThenInt64Impl) PutFloat64Arg(p *float64) {
	__.Float64Arg.Put(p)
}
func (__ *PoolOfFloat64ThenInt64Impl) GetInt64Return() *int64 {
	return __.Int64Rtn.Get().(*int64)
}
func (__ *PoolOfFloat64ThenInt64Impl) PutInt64Return(p *int64) {
	__.Int64Rtn.Put(p)
}

func (__ *PoolOfFloat64ThenInt64Impl) GetWorkOfFloat64ThenInt64() *WorkOfFloat64ThenInt64 {
	return __.Float64Work.Get().(*WorkOfFloat64ThenInt64)
}
func (__ *PoolOfFloat64ThenInt64Impl) PutWorkOfFloat64ThenInt64(p *WorkOfFloat64ThenInt64) {
	__.Float64Work.Put(p)
}
func (__ *PoolOfFloat64ThenInt64Impl) GetReturnOfInt64() *ReturnOfInt64 {
	return __.Int64Return.Get().(*ReturnOfInt64)
}
func (__ *PoolOfFloat64ThenInt64Impl) PutReturnOfInt64(p *ReturnOfInt64) {
	__.Int64Return.Put(p)
}

func (__ *PoolOfFloat64ThenInt64Impl) GetChReturnOfInt64() chan *ReturnOfInt64 {
	return __.ChReturnOfInt64.Get().(chan *ReturnOfInt64)
}
func (__ *PoolOfFloat64ThenInt64Impl) PutChReturnOfInt64(p chan *ReturnOfInt64) {
	__.ChReturnOfInt64.Put(p)
}

func NewPoolOfFloat64ThenInt64Impl() *PoolOfFloat64ThenInt64Impl {
	return &PoolOfFloat64ThenInt64Impl{
		Float64Arg: sync.Pool{
			New: func() interface{} {
				return new(float64)
			},
		},
		Float64Work: sync.Pool{
			New: func() interface{} {
				return new(WorkOfFloat64ThenInt64)
			},
		},
		Int64Rtn: sync.Pool{
			New: func() interface{} {
				return new(int64)
			},
		},
		Int64Return: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfInt64)
			},
		},
		ChReturnOfInt64: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfInt64, 1)
			},
		},
	}
}

type ApiDecouplerOfFloat64ThenInt64 struct {
	pool PoolOfFloat64ThenInt64
}

func NewApiDecouplerOfFloat64ThenInt64() *ApiDecouplerOfFloat64ThenInt64 {
	return &ApiDecouplerOfFloat64ThenInt64{
		pool: NewPoolOfFloat64ThenInt64Impl(),
	}
}

func (__ *ApiDecouplerOfFloat64ThenInt64) ReturnError(rtn_ch chan<- *ReturnOfInt64, err error) {
	rtn := __.pool.GetReturnOfInt64()
	var other int64
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfFloat64ThenInt64) HandleOfFloat64ThenInt64(ctx context.Context, req *WorkOfFloat64ThenInt64, h func(ctx context.Context, arg float64) (int64, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfInt64()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfFloat64ThenInt64) DoOfFloat64ThenInt64(ctx context.Context, worker WorkerOfPushFloat64ThenInt64, arg float64) (int64, error) {
	// ch := make(chan *ReturnOfInt64, 1)
	ch := __.pool.GetChReturnOfInt64()
	defer __.pool.PutChReturnOfInt64(ch)

	req := __.pool.GetWorkOfFloat64ThenInt64()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfFloat64ThenInt64(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfInt64(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfFloat64ThenInt64 = func(ctx context.Context, arg float64) (int64, error)

type WorkerOfFloat64ThenInt64 struct {
	api_syncer *ApiDecouplerOfFloat64ThenInt64
	handler    WorkHandlerOfFloat64ThenInt64

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfFloat64ThenInt64
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfFloat64ThenInt64(ctx context.Context, h WorkHandlerOfFloat64ThenInt64, n int) *WorkerOfFloat64ThenInt64 {
	__ := &WorkerOfFloat64ThenInt64{
		api_syncer: NewApiDecouplerOfFloat64ThenInt64(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfFloat64ThenInt64, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfFloat64ThenInt64{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfFloat64ThenInt64(req.Context, req.WorkOfFloat64ThenInt64, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfFloat64ThenInt64) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfFloat64ThenInt64) Push(ctx context.Context, req *WorkOfFloat64ThenInt64) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfFloat64ThenInt64)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfFloat64ThenInt64 = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfFloat64ThenInt64) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfFloat64ThenInt64) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfFloat64ThenInt64) Call(ctx context.Context, arg float64) (int64, error) {
	return __.api_syncer.DoOfFloat64ThenInt64(ctx, __, arg)
}

type PoolOfFloat64ThenInt8 interface {
	GetFloat64Arg() *float64
	PutFloat64Arg(*float64)
	GetInt8Return() *int8
	PutInt8Return(*int8)

	GetWorkOfFloat64ThenInt8() *WorkOfFloat64ThenInt8
	GetReturnOfInt8() *ReturnOfInt8
	PutWorkOfFloat64ThenInt8(*WorkOfFloat64ThenInt8)
	PutReturnOfInt8(*ReturnOfInt8)

	GetChReturnOfInt8() chan *ReturnOfInt8
	PutChReturnOfInt8(chan *ReturnOfInt8)
}

type PoolOfFloat64ThenInt8Impl struct {
	Float64Arg     sync.Pool
	Int8Rtn        sync.Pool
	Float64Work    sync.Pool
	Int8Return     sync.Pool
	ChReturnOfInt8 sync.Pool
}

func (__ *PoolOfFloat64ThenInt8Impl) GetFloat64Arg() *float64 {
	return __.Float64Arg.Get().(*float64)
}
func (__ *PoolOfFloat64ThenInt8Impl) PutFloat64Arg(p *float64) {
	__.Float64Arg.Put(p)
}
func (__ *PoolOfFloat64ThenInt8Impl) GetInt8Return() *int8 {
	return __.Int8Rtn.Get().(*int8)
}
func (__ *PoolOfFloat64ThenInt8Impl) PutInt8Return(p *int8) {
	__.Int8Rtn.Put(p)
}

func (__ *PoolOfFloat64ThenInt8Impl) GetWorkOfFloat64ThenInt8() *WorkOfFloat64ThenInt8 {
	return __.Float64Work.Get().(*WorkOfFloat64ThenInt8)
}
func (__ *PoolOfFloat64ThenInt8Impl) PutWorkOfFloat64ThenInt8(p *WorkOfFloat64ThenInt8) {
	__.Float64Work.Put(p)
}
func (__ *PoolOfFloat64ThenInt8Impl) GetReturnOfInt8() *ReturnOfInt8 {
	return __.Int8Return.Get().(*ReturnOfInt8)
}
func (__ *PoolOfFloat64ThenInt8Impl) PutReturnOfInt8(p *ReturnOfInt8) {
	__.Int8Return.Put(p)
}

func (__ *PoolOfFloat64ThenInt8Impl) GetChReturnOfInt8() chan *ReturnOfInt8 {
	return __.ChReturnOfInt8.Get().(chan *ReturnOfInt8)
}
func (__ *PoolOfFloat64ThenInt8Impl) PutChReturnOfInt8(p chan *ReturnOfInt8) {
	__.ChReturnOfInt8.Put(p)
}

func NewPoolOfFloat64ThenInt8Impl() *PoolOfFloat64ThenInt8Impl {
	return &PoolOfFloat64ThenInt8Impl{
		Float64Arg: sync.Pool{
			New: func() interface{} {
				return new(float64)
			},
		},
		Float64Work: sync.Pool{
			New: func() interface{} {
				return new(WorkOfFloat64ThenInt8)
			},
		},
		Int8Rtn: sync.Pool{
			New: func() interface{} {
				return new(int8)
			},
		},
		Int8Return: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfInt8)
			},
		},
		ChReturnOfInt8: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfInt8, 1)
			},
		},
	}
}

type ApiDecouplerOfFloat64ThenInt8 struct {
	pool PoolOfFloat64ThenInt8
}

func NewApiDecouplerOfFloat64ThenInt8() *ApiDecouplerOfFloat64ThenInt8 {
	return &ApiDecouplerOfFloat64ThenInt8{
		pool: NewPoolOfFloat64ThenInt8Impl(),
	}
}

func (__ *ApiDecouplerOfFloat64ThenInt8) ReturnError(rtn_ch chan<- *ReturnOfInt8, err error) {
	rtn := __.pool.GetReturnOfInt8()
	var other int8
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfFloat64ThenInt8) HandleOfFloat64ThenInt8(ctx context.Context, req *WorkOfFloat64ThenInt8, h func(ctx context.Context, arg float64) (int8, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfInt8()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfFloat64ThenInt8) DoOfFloat64ThenInt8(ctx context.Context, worker WorkerOfPushFloat64ThenInt8, arg float64) (int8, error) {
	// ch := make(chan *ReturnOfInt8, 1)
	ch := __.pool.GetChReturnOfInt8()
	defer __.pool.PutChReturnOfInt8(ch)

	req := __.pool.GetWorkOfFloat64ThenInt8()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfFloat64ThenInt8(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfInt8(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfFloat64ThenInt8 = func(ctx context.Context, arg float64) (int8, error)

type WorkerOfFloat64ThenInt8 struct {
	api_syncer *ApiDecouplerOfFloat64ThenInt8
	handler    WorkHandlerOfFloat64ThenInt8

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfFloat64ThenInt8
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfFloat64ThenInt8(ctx context.Context, h WorkHandlerOfFloat64ThenInt8, n int) *WorkerOfFloat64ThenInt8 {
	__ := &WorkerOfFloat64ThenInt8{
		api_syncer: NewApiDecouplerOfFloat64ThenInt8(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfFloat64ThenInt8, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfFloat64ThenInt8{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfFloat64ThenInt8(req.Context, req.WorkOfFloat64ThenInt8, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfFloat64ThenInt8) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfFloat64ThenInt8) Push(ctx context.Context, req *WorkOfFloat64ThenInt8) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfFloat64ThenInt8)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfFloat64ThenInt8 = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfFloat64ThenInt8) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfFloat64ThenInt8) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfFloat64ThenInt8) Call(ctx context.Context, arg float64) (int8, error) {
	return __.api_syncer.DoOfFloat64ThenInt8(ctx, __, arg)
}

type PoolOfFloat64ThenRune interface {
	GetFloat64Arg() *float64
	PutFloat64Arg(*float64)
	GetRuneReturn() *rune
	PutRuneReturn(*rune)

	GetWorkOfFloat64ThenRune() *WorkOfFloat64ThenRune
	GetReturnOfRune() *ReturnOfRune
	PutWorkOfFloat64ThenRune(*WorkOfFloat64ThenRune)
	PutReturnOfRune(*ReturnOfRune)

	GetChReturnOfRune() chan *ReturnOfRune
	PutChReturnOfRune(chan *ReturnOfRune)
}

type PoolOfFloat64ThenRuneImpl struct {
	Float64Arg     sync.Pool
	RuneRtn        sync.Pool
	Float64Work    sync.Pool
	RuneReturn     sync.Pool
	ChReturnOfRune sync.Pool
}

func (__ *PoolOfFloat64ThenRuneImpl) GetFloat64Arg() *float64 {
	return __.Float64Arg.Get().(*float64)
}
func (__ *PoolOfFloat64ThenRuneImpl) PutFloat64Arg(p *float64) {
	__.Float64Arg.Put(p)
}
func (__ *PoolOfFloat64ThenRuneImpl) GetRuneReturn() *rune {
	return __.RuneRtn.Get().(*rune)
}
func (__ *PoolOfFloat64ThenRuneImpl) PutRuneReturn(p *rune) {
	__.RuneRtn.Put(p)
}

func (__ *PoolOfFloat64ThenRuneImpl) GetWorkOfFloat64ThenRune() *WorkOfFloat64ThenRune {
	return __.Float64Work.Get().(*WorkOfFloat64ThenRune)
}
func (__ *PoolOfFloat64ThenRuneImpl) PutWorkOfFloat64ThenRune(p *WorkOfFloat64ThenRune) {
	__.Float64Work.Put(p)
}
func (__ *PoolOfFloat64ThenRuneImpl) GetReturnOfRune() *ReturnOfRune {
	return __.RuneReturn.Get().(*ReturnOfRune)
}
func (__ *PoolOfFloat64ThenRuneImpl) PutReturnOfRune(p *ReturnOfRune) {
	__.RuneReturn.Put(p)
}

func (__ *PoolOfFloat64ThenRuneImpl) GetChReturnOfRune() chan *ReturnOfRune {
	return __.ChReturnOfRune.Get().(chan *ReturnOfRune)
}
func (__ *PoolOfFloat64ThenRuneImpl) PutChReturnOfRune(p chan *ReturnOfRune) {
	__.ChReturnOfRune.Put(p)
}

func NewPoolOfFloat64ThenRuneImpl() *PoolOfFloat64ThenRuneImpl {
	return &PoolOfFloat64ThenRuneImpl{
		Float64Arg: sync.Pool{
			New: func() interface{} {
				return new(float64)
			},
		},
		Float64Work: sync.Pool{
			New: func() interface{} {
				return new(WorkOfFloat64ThenRune)
			},
		},
		RuneRtn: sync.Pool{
			New: func() interface{} {
				return new(rune)
			},
		},
		RuneReturn: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfRune)
			},
		},
		ChReturnOfRune: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfRune, 1)
			},
		},
	}
}

type ApiDecouplerOfFloat64ThenRune struct {
	pool PoolOfFloat64ThenRune
}

func NewApiDecouplerOfFloat64ThenRune() *ApiDecouplerOfFloat64ThenRune {
	return &ApiDecouplerOfFloat64ThenRune{
		pool: NewPoolOfFloat64ThenRuneImpl(),
	}
}

func (__ *ApiDecouplerOfFloat64ThenRune) ReturnError(rtn_ch chan<- *ReturnOfRune, err error) {
	rtn := __.pool.GetReturnOfRune()
	var other rune
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfFloat64ThenRune) HandleOfFloat64ThenRune(ctx context.Context, req *WorkOfFloat64ThenRune, h func(ctx context.Context, arg float64) (rune, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfRune()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfFloat64ThenRune) DoOfFloat64ThenRune(ctx context.Context, worker WorkerOfPushFloat64ThenRune, arg float64) (rune, error) {
	// ch := make(chan *ReturnOfRune, 1)
	ch := __.pool.GetChReturnOfRune()
	defer __.pool.PutChReturnOfRune(ch)

	req := __.pool.GetWorkOfFloat64ThenRune()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfFloat64ThenRune(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfRune(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfFloat64ThenRune = func(ctx context.Context, arg float64) (rune, error)

type WorkerOfFloat64ThenRune struct {
	api_syncer *ApiDecouplerOfFloat64ThenRune
	handler    WorkHandlerOfFloat64ThenRune

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfFloat64ThenRune
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfFloat64ThenRune(ctx context.Context, h WorkHandlerOfFloat64ThenRune, n int) *WorkerOfFloat64ThenRune {
	__ := &WorkerOfFloat64ThenRune{
		api_syncer: NewApiDecouplerOfFloat64ThenRune(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfFloat64ThenRune, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfFloat64ThenRune{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfFloat64ThenRune(req.Context, req.WorkOfFloat64ThenRune, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfFloat64ThenRune) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfFloat64ThenRune) Push(ctx context.Context, req *WorkOfFloat64ThenRune) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfFloat64ThenRune)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfFloat64ThenRune = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfFloat64ThenRune) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfFloat64ThenRune) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfFloat64ThenRune) Call(ctx context.Context, arg float64) (rune, error) {
	return __.api_syncer.DoOfFloat64ThenRune(ctx, __, arg)
}

type PoolOfFloat64ThenString interface {
	GetFloat64Arg() *float64
	PutFloat64Arg(*float64)
	GetStringReturn() *string
	PutStringReturn(*string)

	GetWorkOfFloat64ThenString() *WorkOfFloat64ThenString
	GetReturnOfString() *ReturnOfString
	PutWorkOfFloat64ThenString(*WorkOfFloat64ThenString)
	PutReturnOfString(*ReturnOfString)

	GetChReturnOfString() chan *ReturnOfString
	PutChReturnOfString(chan *ReturnOfString)
}

type PoolOfFloat64ThenStringImpl struct {
	Float64Arg       sync.Pool
	StringRtn        sync.Pool
	Float64Work      sync.Pool
	StringReturn     sync.Pool
	ChReturnOfString sync.Pool
}

func (__ *PoolOfFloat64ThenStringImpl) GetFloat64Arg() *float64 {
	return __.Float64Arg.Get().(*float64)
}
func (__ *PoolOfFloat64ThenStringImpl) PutFloat64Arg(p *float64) {
	__.Float64Arg.Put(p)
}
func (__ *PoolOfFloat64ThenStringImpl) GetStringReturn() *string {
	return __.StringRtn.Get().(*string)
}
func (__ *PoolOfFloat64ThenStringImpl) PutStringReturn(p *string) {
	__.StringRtn.Put(p)
}

func (__ *PoolOfFloat64ThenStringImpl) GetWorkOfFloat64ThenString() *WorkOfFloat64ThenString {
	return __.Float64Work.Get().(*WorkOfFloat64ThenString)
}
func (__ *PoolOfFloat64ThenStringImpl) PutWorkOfFloat64ThenString(p *WorkOfFloat64ThenString) {
	__.Float64Work.Put(p)
}
func (__ *PoolOfFloat64ThenStringImpl) GetReturnOfString() *ReturnOfString {
	return __.StringReturn.Get().(*ReturnOfString)
}
func (__ *PoolOfFloat64ThenStringImpl) PutReturnOfString(p *ReturnOfString) {
	__.StringReturn.Put(p)
}

func (__ *PoolOfFloat64ThenStringImpl) GetChReturnOfString() chan *ReturnOfString {
	return __.ChReturnOfString.Get().(chan *ReturnOfString)
}
func (__ *PoolOfFloat64ThenStringImpl) PutChReturnOfString(p chan *ReturnOfString) {
	__.ChReturnOfString.Put(p)
}

func NewPoolOfFloat64ThenStringImpl() *PoolOfFloat64ThenStringImpl {
	return &PoolOfFloat64ThenStringImpl{
		Float64Arg: sync.Pool{
			New: func() interface{} {
				return new(float64)
			},
		},
		Float64Work: sync.Pool{
			New: func() interface{} {
				return new(WorkOfFloat64ThenString)
			},
		},
		StringRtn: sync.Pool{
			New: func() interface{} {
				return new(string)
			},
		},
		StringReturn: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfString)
			},
		},
		ChReturnOfString: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfString, 1)
			},
		},
	}
}

type ApiDecouplerOfFloat64ThenString struct {
	pool PoolOfFloat64ThenString
}

func NewApiDecouplerOfFloat64ThenString() *ApiDecouplerOfFloat64ThenString {
	return &ApiDecouplerOfFloat64ThenString{
		pool: NewPoolOfFloat64ThenStringImpl(),
	}
}

func (__ *ApiDecouplerOfFloat64ThenString) ReturnError(rtn_ch chan<- *ReturnOfString, err error) {
	rtn := __.pool.GetReturnOfString()
	var other string
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfFloat64ThenString) HandleOfFloat64ThenString(ctx context.Context, req *WorkOfFloat64ThenString, h func(ctx context.Context, arg float64) (string, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfString()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfFloat64ThenString) DoOfFloat64ThenString(ctx context.Context, worker WorkerOfPushFloat64ThenString, arg float64) (string, error) {
	// ch := make(chan *ReturnOfString, 1)
	ch := __.pool.GetChReturnOfString()
	defer __.pool.PutChReturnOfString(ch)

	req := __.pool.GetWorkOfFloat64ThenString()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfFloat64ThenString(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfString(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfFloat64ThenString = func(ctx context.Context, arg float64) (string, error)

type WorkerOfFloat64ThenString struct {
	api_syncer *ApiDecouplerOfFloat64ThenString
	handler    WorkHandlerOfFloat64ThenString

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfFloat64ThenString
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfFloat64ThenString(ctx context.Context, h WorkHandlerOfFloat64ThenString, n int) *WorkerOfFloat64ThenString {
	__ := &WorkerOfFloat64ThenString{
		api_syncer: NewApiDecouplerOfFloat64ThenString(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfFloat64ThenString, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfFloat64ThenString{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfFloat64ThenString(req.Context, req.WorkOfFloat64ThenString, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfFloat64ThenString) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfFloat64ThenString) Push(ctx context.Context, req *WorkOfFloat64ThenString) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfFloat64ThenString)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfFloat64ThenString = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfFloat64ThenString) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfFloat64ThenString) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfFloat64ThenString) Call(ctx context.Context, arg float64) (string, error) {
	return __.api_syncer.DoOfFloat64ThenString(ctx, __, arg)
}

type PoolOfFloat64ThenUint interface {
	GetFloat64Arg() *float64
	PutFloat64Arg(*float64)
	GetUintReturn() *uint
	PutUintReturn(*uint)

	GetWorkOfFloat64ThenUint() *WorkOfFloat64ThenUint
	GetReturnOfUint() *ReturnOfUint
	PutWorkOfFloat64ThenUint(*WorkOfFloat64ThenUint)
	PutReturnOfUint(*ReturnOfUint)

	GetChReturnOfUint() chan *ReturnOfUint
	PutChReturnOfUint(chan *ReturnOfUint)
}

type PoolOfFloat64ThenUintImpl struct {
	Float64Arg     sync.Pool
	UintRtn        sync.Pool
	Float64Work    sync.Pool
	UintReturn     sync.Pool
	ChReturnOfUint sync.Pool
}

func (__ *PoolOfFloat64ThenUintImpl) GetFloat64Arg() *float64 {
	return __.Float64Arg.Get().(*float64)
}
func (__ *PoolOfFloat64ThenUintImpl) PutFloat64Arg(p *float64) {
	__.Float64Arg.Put(p)
}
func (__ *PoolOfFloat64ThenUintImpl) GetUintReturn() *uint {
	return __.UintRtn.Get().(*uint)
}
func (__ *PoolOfFloat64ThenUintImpl) PutUintReturn(p *uint) {
	__.UintRtn.Put(p)
}

func (__ *PoolOfFloat64ThenUintImpl) GetWorkOfFloat64ThenUint() *WorkOfFloat64ThenUint {
	return __.Float64Work.Get().(*WorkOfFloat64ThenUint)
}
func (__ *PoolOfFloat64ThenUintImpl) PutWorkOfFloat64ThenUint(p *WorkOfFloat64ThenUint) {
	__.Float64Work.Put(p)
}
func (__ *PoolOfFloat64ThenUintImpl) GetReturnOfUint() *ReturnOfUint {
	return __.UintReturn.Get().(*ReturnOfUint)
}
func (__ *PoolOfFloat64ThenUintImpl) PutReturnOfUint(p *ReturnOfUint) {
	__.UintReturn.Put(p)
}

func (__ *PoolOfFloat64ThenUintImpl) GetChReturnOfUint() chan *ReturnOfUint {
	return __.ChReturnOfUint.Get().(chan *ReturnOfUint)
}
func (__ *PoolOfFloat64ThenUintImpl) PutChReturnOfUint(p chan *ReturnOfUint) {
	__.ChReturnOfUint.Put(p)
}

func NewPoolOfFloat64ThenUintImpl() *PoolOfFloat64ThenUintImpl {
	return &PoolOfFloat64ThenUintImpl{
		Float64Arg: sync.Pool{
			New: func() interface{} {
				return new(float64)
			},
		},
		Float64Work: sync.Pool{
			New: func() interface{} {
				return new(WorkOfFloat64ThenUint)
			},
		},
		UintRtn: sync.Pool{
			New: func() interface{} {
				return new(uint)
			},
		},
		UintReturn: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfUint)
			},
		},
		ChReturnOfUint: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfUint, 1)
			},
		},
	}
}

type ApiDecouplerOfFloat64ThenUint struct {
	pool PoolOfFloat64ThenUint
}

func NewApiDecouplerOfFloat64ThenUint() *ApiDecouplerOfFloat64ThenUint {
	return &ApiDecouplerOfFloat64ThenUint{
		pool: NewPoolOfFloat64ThenUintImpl(),
	}
}

func (__ *ApiDecouplerOfFloat64ThenUint) ReturnError(rtn_ch chan<- *ReturnOfUint, err error) {
	rtn := __.pool.GetReturnOfUint()
	var other uint
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfFloat64ThenUint) HandleOfFloat64ThenUint(ctx context.Context, req *WorkOfFloat64ThenUint, h func(ctx context.Context, arg float64) (uint, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfUint()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfFloat64ThenUint) DoOfFloat64ThenUint(ctx context.Context, worker WorkerOfPushFloat64ThenUint, arg float64) (uint, error) {
	// ch := make(chan *ReturnOfUint, 1)
	ch := __.pool.GetChReturnOfUint()
	defer __.pool.PutChReturnOfUint(ch)

	req := __.pool.GetWorkOfFloat64ThenUint()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfFloat64ThenUint(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfUint(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfFloat64ThenUint = func(ctx context.Context, arg float64) (uint, error)

type WorkerOfFloat64ThenUint struct {
	api_syncer *ApiDecouplerOfFloat64ThenUint
	handler    WorkHandlerOfFloat64ThenUint

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfFloat64ThenUint
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfFloat64ThenUint(ctx context.Context, h WorkHandlerOfFloat64ThenUint, n int) *WorkerOfFloat64ThenUint {
	__ := &WorkerOfFloat64ThenUint{
		api_syncer: NewApiDecouplerOfFloat64ThenUint(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfFloat64ThenUint, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfFloat64ThenUint{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfFloat64ThenUint(req.Context, req.WorkOfFloat64ThenUint, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfFloat64ThenUint) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfFloat64ThenUint) Push(ctx context.Context, req *WorkOfFloat64ThenUint) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfFloat64ThenUint)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfFloat64ThenUint = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfFloat64ThenUint) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfFloat64ThenUint) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfFloat64ThenUint) Call(ctx context.Context, arg float64) (uint, error) {
	return __.api_syncer.DoOfFloat64ThenUint(ctx, __, arg)
}

type PoolOfFloat64ThenUint16 interface {
	GetFloat64Arg() *float64
	PutFloat64Arg(*float64)
	GetUint16Return() *uint16
	PutUint16Return(*uint16)

	GetWorkOfFloat64ThenUint16() *WorkOfFloat64ThenUint16
	GetReturnOfUint16() *ReturnOfUint16
	PutWorkOfFloat64ThenUint16(*WorkOfFloat64ThenUint16)
	PutReturnOfUint16(*ReturnOfUint16)

	GetChReturnOfUint16() chan *ReturnOfUint16
	PutChReturnOfUint16(chan *ReturnOfUint16)
}

type PoolOfFloat64ThenUint16Impl struct {
	Float64Arg       sync.Pool
	Uint16Rtn        sync.Pool
	Float64Work      sync.Pool
	Uint16Return     sync.Pool
	ChReturnOfUint16 sync.Pool
}

func (__ *PoolOfFloat64ThenUint16Impl) GetFloat64Arg() *float64 {
	return __.Float64Arg.Get().(*float64)
}
func (__ *PoolOfFloat64ThenUint16Impl) PutFloat64Arg(p *float64) {
	__.Float64Arg.Put(p)
}
func (__ *PoolOfFloat64ThenUint16Impl) GetUint16Return() *uint16 {
	return __.Uint16Rtn.Get().(*uint16)
}
func (__ *PoolOfFloat64ThenUint16Impl) PutUint16Return(p *uint16) {
	__.Uint16Rtn.Put(p)
}

func (__ *PoolOfFloat64ThenUint16Impl) GetWorkOfFloat64ThenUint16() *WorkOfFloat64ThenUint16 {
	return __.Float64Work.Get().(*WorkOfFloat64ThenUint16)
}
func (__ *PoolOfFloat64ThenUint16Impl) PutWorkOfFloat64ThenUint16(p *WorkOfFloat64ThenUint16) {
	__.Float64Work.Put(p)
}
func (__ *PoolOfFloat64ThenUint16Impl) GetReturnOfUint16() *ReturnOfUint16 {
	return __.Uint16Return.Get().(*ReturnOfUint16)
}
func (__ *PoolOfFloat64ThenUint16Impl) PutReturnOfUint16(p *ReturnOfUint16) {
	__.Uint16Return.Put(p)
}

func (__ *PoolOfFloat64ThenUint16Impl) GetChReturnOfUint16() chan *ReturnOfUint16 {
	return __.ChReturnOfUint16.Get().(chan *ReturnOfUint16)
}
func (__ *PoolOfFloat64ThenUint16Impl) PutChReturnOfUint16(p chan *ReturnOfUint16) {
	__.ChReturnOfUint16.Put(p)
}

func NewPoolOfFloat64ThenUint16Impl() *PoolOfFloat64ThenUint16Impl {
	return &PoolOfFloat64ThenUint16Impl{
		Float64Arg: sync.Pool{
			New: func() interface{} {
				return new(float64)
			},
		},
		Float64Work: sync.Pool{
			New: func() interface{} {
				return new(WorkOfFloat64ThenUint16)
			},
		},
		Uint16Rtn: sync.Pool{
			New: func() interface{} {
				return new(uint16)
			},
		},
		Uint16Return: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfUint16)
			},
		},
		ChReturnOfUint16: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfUint16, 1)
			},
		},
	}
}

type ApiDecouplerOfFloat64ThenUint16 struct {
	pool PoolOfFloat64ThenUint16
}

func NewApiDecouplerOfFloat64ThenUint16() *ApiDecouplerOfFloat64ThenUint16 {
	return &ApiDecouplerOfFloat64ThenUint16{
		pool: NewPoolOfFloat64ThenUint16Impl(),
	}
}

func (__ *ApiDecouplerOfFloat64ThenUint16) ReturnError(rtn_ch chan<- *ReturnOfUint16, err error) {
	rtn := __.pool.GetReturnOfUint16()
	var other uint16
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfFloat64ThenUint16) HandleOfFloat64ThenUint16(ctx context.Context, req *WorkOfFloat64ThenUint16, h func(ctx context.Context, arg float64) (uint16, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfUint16()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfFloat64ThenUint16) DoOfFloat64ThenUint16(ctx context.Context, worker WorkerOfPushFloat64ThenUint16, arg float64) (uint16, error) {
	// ch := make(chan *ReturnOfUint16, 1)
	ch := __.pool.GetChReturnOfUint16()
	defer __.pool.PutChReturnOfUint16(ch)

	req := __.pool.GetWorkOfFloat64ThenUint16()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfFloat64ThenUint16(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfUint16(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfFloat64ThenUint16 = func(ctx context.Context, arg float64) (uint16, error)

type WorkerOfFloat64ThenUint16 struct {
	api_syncer *ApiDecouplerOfFloat64ThenUint16
	handler    WorkHandlerOfFloat64ThenUint16

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfFloat64ThenUint16
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfFloat64ThenUint16(ctx context.Context, h WorkHandlerOfFloat64ThenUint16, n int) *WorkerOfFloat64ThenUint16 {
	__ := &WorkerOfFloat64ThenUint16{
		api_syncer: NewApiDecouplerOfFloat64ThenUint16(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfFloat64ThenUint16, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfFloat64ThenUint16{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfFloat64ThenUint16(req.Context, req.WorkOfFloat64ThenUint16, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfFloat64ThenUint16) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfFloat64ThenUint16) Push(ctx context.Context, req *WorkOfFloat64ThenUint16) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfFloat64ThenUint16)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfFloat64ThenUint16 = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfFloat64ThenUint16) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfFloat64ThenUint16) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfFloat64ThenUint16) Call(ctx context.Context, arg float64) (uint16, error) {
	return __.api_syncer.DoOfFloat64ThenUint16(ctx, __, arg)
}

type PoolOfFloat64ThenUint32 interface {
	GetFloat64Arg() *float64
	PutFloat64Arg(*float64)
	GetUint32Return() *uint32
	PutUint32Return(*uint32)

	GetWorkOfFloat64ThenUint32() *WorkOfFloat64ThenUint32
	GetReturnOfUint32() *ReturnOfUint32
	PutWorkOfFloat64ThenUint32(*WorkOfFloat64ThenUint32)
	PutReturnOfUint32(*ReturnOfUint32)

	GetChReturnOfUint32() chan *ReturnOfUint32
	PutChReturnOfUint32(chan *ReturnOfUint32)
}

type PoolOfFloat64ThenUint32Impl struct {
	Float64Arg       sync.Pool
	Uint32Rtn        sync.Pool
	Float64Work      sync.Pool
	Uint32Return     sync.Pool
	ChReturnOfUint32 sync.Pool
}

func (__ *PoolOfFloat64ThenUint32Impl) GetFloat64Arg() *float64 {
	return __.Float64Arg.Get().(*float64)
}
func (__ *PoolOfFloat64ThenUint32Impl) PutFloat64Arg(p *float64) {
	__.Float64Arg.Put(p)
}
func (__ *PoolOfFloat64ThenUint32Impl) GetUint32Return() *uint32 {
	return __.Uint32Rtn.Get().(*uint32)
}
func (__ *PoolOfFloat64ThenUint32Impl) PutUint32Return(p *uint32) {
	__.Uint32Rtn.Put(p)
}

func (__ *PoolOfFloat64ThenUint32Impl) GetWorkOfFloat64ThenUint32() *WorkOfFloat64ThenUint32 {
	return __.Float64Work.Get().(*WorkOfFloat64ThenUint32)
}
func (__ *PoolOfFloat64ThenUint32Impl) PutWorkOfFloat64ThenUint32(p *WorkOfFloat64ThenUint32) {
	__.Float64Work.Put(p)
}
func (__ *PoolOfFloat64ThenUint32Impl) GetReturnOfUint32() *ReturnOfUint32 {
	return __.Uint32Return.Get().(*ReturnOfUint32)
}
func (__ *PoolOfFloat64ThenUint32Impl) PutReturnOfUint32(p *ReturnOfUint32) {
	__.Uint32Return.Put(p)
}

func (__ *PoolOfFloat64ThenUint32Impl) GetChReturnOfUint32() chan *ReturnOfUint32 {
	return __.ChReturnOfUint32.Get().(chan *ReturnOfUint32)
}
func (__ *PoolOfFloat64ThenUint32Impl) PutChReturnOfUint32(p chan *ReturnOfUint32) {
	__.ChReturnOfUint32.Put(p)
}

func NewPoolOfFloat64ThenUint32Impl() *PoolOfFloat64ThenUint32Impl {
	return &PoolOfFloat64ThenUint32Impl{
		Float64Arg: sync.Pool{
			New: func() interface{} {
				return new(float64)
			},
		},
		Float64Work: sync.Pool{
			New: func() interface{} {
				return new(WorkOfFloat64ThenUint32)
			},
		},
		Uint32Rtn: sync.Pool{
			New: func() interface{} {
				return new(uint32)
			},
		},
		Uint32Return: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfUint32)
			},
		},
		ChReturnOfUint32: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfUint32, 1)
			},
		},
	}
}

type ApiDecouplerOfFloat64ThenUint32 struct {
	pool PoolOfFloat64ThenUint32
}

func NewApiDecouplerOfFloat64ThenUint32() *ApiDecouplerOfFloat64ThenUint32 {
	return &ApiDecouplerOfFloat64ThenUint32{
		pool: NewPoolOfFloat64ThenUint32Impl(),
	}
}

func (__ *ApiDecouplerOfFloat64ThenUint32) ReturnError(rtn_ch chan<- *ReturnOfUint32, err error) {
	rtn := __.pool.GetReturnOfUint32()
	var other uint32
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfFloat64ThenUint32) HandleOfFloat64ThenUint32(ctx context.Context, req *WorkOfFloat64ThenUint32, h func(ctx context.Context, arg float64) (uint32, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfUint32()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfFloat64ThenUint32) DoOfFloat64ThenUint32(ctx context.Context, worker WorkerOfPushFloat64ThenUint32, arg float64) (uint32, error) {
	// ch := make(chan *ReturnOfUint32, 1)
	ch := __.pool.GetChReturnOfUint32()
	defer __.pool.PutChReturnOfUint32(ch)

	req := __.pool.GetWorkOfFloat64ThenUint32()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfFloat64ThenUint32(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfUint32(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfFloat64ThenUint32 = func(ctx context.Context, arg float64) (uint32, error)

type WorkerOfFloat64ThenUint32 struct {
	api_syncer *ApiDecouplerOfFloat64ThenUint32
	handler    WorkHandlerOfFloat64ThenUint32

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfFloat64ThenUint32
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfFloat64ThenUint32(ctx context.Context, h WorkHandlerOfFloat64ThenUint32, n int) *WorkerOfFloat64ThenUint32 {
	__ := &WorkerOfFloat64ThenUint32{
		api_syncer: NewApiDecouplerOfFloat64ThenUint32(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfFloat64ThenUint32, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfFloat64ThenUint32{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfFloat64ThenUint32(req.Context, req.WorkOfFloat64ThenUint32, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfFloat64ThenUint32) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfFloat64ThenUint32) Push(ctx context.Context, req *WorkOfFloat64ThenUint32) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfFloat64ThenUint32)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfFloat64ThenUint32 = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfFloat64ThenUint32) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfFloat64ThenUint32) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfFloat64ThenUint32) Call(ctx context.Context, arg float64) (uint32, error) {
	return __.api_syncer.DoOfFloat64ThenUint32(ctx, __, arg)
}

type PoolOfFloat64ThenUint64 interface {
	GetFloat64Arg() *float64
	PutFloat64Arg(*float64)
	GetUint64Return() *uint64
	PutUint64Return(*uint64)

	GetWorkOfFloat64ThenUint64() *WorkOfFloat64ThenUint64
	GetReturnOfUint64() *ReturnOfUint64
	PutWorkOfFloat64ThenUint64(*WorkOfFloat64ThenUint64)
	PutReturnOfUint64(*ReturnOfUint64)

	GetChReturnOfUint64() chan *ReturnOfUint64
	PutChReturnOfUint64(chan *ReturnOfUint64)
}

type PoolOfFloat64ThenUint64Impl struct {
	Float64Arg       sync.Pool
	Uint64Rtn        sync.Pool
	Float64Work      sync.Pool
	Uint64Return     sync.Pool
	ChReturnOfUint64 sync.Pool
}

func (__ *PoolOfFloat64ThenUint64Impl) GetFloat64Arg() *float64 {
	return __.Float64Arg.Get().(*float64)
}
func (__ *PoolOfFloat64ThenUint64Impl) PutFloat64Arg(p *float64) {
	__.Float64Arg.Put(p)
}
func (__ *PoolOfFloat64ThenUint64Impl) GetUint64Return() *uint64 {
	return __.Uint64Rtn.Get().(*uint64)
}
func (__ *PoolOfFloat64ThenUint64Impl) PutUint64Return(p *uint64) {
	__.Uint64Rtn.Put(p)
}

func (__ *PoolOfFloat64ThenUint64Impl) GetWorkOfFloat64ThenUint64() *WorkOfFloat64ThenUint64 {
	return __.Float64Work.Get().(*WorkOfFloat64ThenUint64)
}
func (__ *PoolOfFloat64ThenUint64Impl) PutWorkOfFloat64ThenUint64(p *WorkOfFloat64ThenUint64) {
	__.Float64Work.Put(p)
}
func (__ *PoolOfFloat64ThenUint64Impl) GetReturnOfUint64() *ReturnOfUint64 {
	return __.Uint64Return.Get().(*ReturnOfUint64)
}
func (__ *PoolOfFloat64ThenUint64Impl) PutReturnOfUint64(p *ReturnOfUint64) {
	__.Uint64Return.Put(p)
}

func (__ *PoolOfFloat64ThenUint64Impl) GetChReturnOfUint64() chan *ReturnOfUint64 {
	return __.ChReturnOfUint64.Get().(chan *ReturnOfUint64)
}
func (__ *PoolOfFloat64ThenUint64Impl) PutChReturnOfUint64(p chan *ReturnOfUint64) {
	__.ChReturnOfUint64.Put(p)
}

func NewPoolOfFloat64ThenUint64Impl() *PoolOfFloat64ThenUint64Impl {
	return &PoolOfFloat64ThenUint64Impl{
		Float64Arg: sync.Pool{
			New: func() interface{} {
				return new(float64)
			},
		},
		Float64Work: sync.Pool{
			New: func() interface{} {
				return new(WorkOfFloat64ThenUint64)
			},
		},
		Uint64Rtn: sync.Pool{
			New: func() interface{} {
				return new(uint64)
			},
		},
		Uint64Return: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfUint64)
			},
		},
		ChReturnOfUint64: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfUint64, 1)
			},
		},
	}
}

type ApiDecouplerOfFloat64ThenUint64 struct {
	pool PoolOfFloat64ThenUint64
}

func NewApiDecouplerOfFloat64ThenUint64() *ApiDecouplerOfFloat64ThenUint64 {
	return &ApiDecouplerOfFloat64ThenUint64{
		pool: NewPoolOfFloat64ThenUint64Impl(),
	}
}

func (__ *ApiDecouplerOfFloat64ThenUint64) ReturnError(rtn_ch chan<- *ReturnOfUint64, err error) {
	rtn := __.pool.GetReturnOfUint64()
	var other uint64
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfFloat64ThenUint64) HandleOfFloat64ThenUint64(ctx context.Context, req *WorkOfFloat64ThenUint64, h func(ctx context.Context, arg float64) (uint64, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfUint64()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfFloat64ThenUint64) DoOfFloat64ThenUint64(ctx context.Context, worker WorkerOfPushFloat64ThenUint64, arg float64) (uint64, error) {
	// ch := make(chan *ReturnOfUint64, 1)
	ch := __.pool.GetChReturnOfUint64()
	defer __.pool.PutChReturnOfUint64(ch)

	req := __.pool.GetWorkOfFloat64ThenUint64()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfFloat64ThenUint64(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfUint64(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfFloat64ThenUint64 = func(ctx context.Context, arg float64) (uint64, error)

type WorkerOfFloat64ThenUint64 struct {
	api_syncer *ApiDecouplerOfFloat64ThenUint64
	handler    WorkHandlerOfFloat64ThenUint64

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfFloat64ThenUint64
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfFloat64ThenUint64(ctx context.Context, h WorkHandlerOfFloat64ThenUint64, n int) *WorkerOfFloat64ThenUint64 {
	__ := &WorkerOfFloat64ThenUint64{
		api_syncer: NewApiDecouplerOfFloat64ThenUint64(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfFloat64ThenUint64, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfFloat64ThenUint64{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfFloat64ThenUint64(req.Context, req.WorkOfFloat64ThenUint64, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfFloat64ThenUint64) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfFloat64ThenUint64) Push(ctx context.Context, req *WorkOfFloat64ThenUint64) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfFloat64ThenUint64)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfFloat64ThenUint64 = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfFloat64ThenUint64) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfFloat64ThenUint64) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfFloat64ThenUint64) Call(ctx context.Context, arg float64) (uint64, error) {
	return __.api_syncer.DoOfFloat64ThenUint64(ctx, __, arg)
}

type PoolOfFloat64ThenUint8 interface {
	GetFloat64Arg() *float64
	PutFloat64Arg(*float64)
	GetUint8Return() *uint8
	PutUint8Return(*uint8)

	GetWorkOfFloat64ThenUint8() *WorkOfFloat64ThenUint8
	GetReturnOfUint8() *ReturnOfUint8
	PutWorkOfFloat64ThenUint8(*WorkOfFloat64ThenUint8)
	PutReturnOfUint8(*ReturnOfUint8)

	GetChReturnOfUint8() chan *ReturnOfUint8
	PutChReturnOfUint8(chan *ReturnOfUint8)
}

type PoolOfFloat64ThenUint8Impl struct {
	Float64Arg      sync.Pool
	Uint8Rtn        sync.Pool
	Float64Work     sync.Pool
	Uint8Return     sync.Pool
	ChReturnOfUint8 sync.Pool
}

func (__ *PoolOfFloat64ThenUint8Impl) GetFloat64Arg() *float64 {
	return __.Float64Arg.Get().(*float64)
}
func (__ *PoolOfFloat64ThenUint8Impl) PutFloat64Arg(p *float64) {
	__.Float64Arg.Put(p)
}
func (__ *PoolOfFloat64ThenUint8Impl) GetUint8Return() *uint8 {
	return __.Uint8Rtn.Get().(*uint8)
}
func (__ *PoolOfFloat64ThenUint8Impl) PutUint8Return(p *uint8) {
	__.Uint8Rtn.Put(p)
}

func (__ *PoolOfFloat64ThenUint8Impl) GetWorkOfFloat64ThenUint8() *WorkOfFloat64ThenUint8 {
	return __.Float64Work.Get().(*WorkOfFloat64ThenUint8)
}
func (__ *PoolOfFloat64ThenUint8Impl) PutWorkOfFloat64ThenUint8(p *WorkOfFloat64ThenUint8) {
	__.Float64Work.Put(p)
}
func (__ *PoolOfFloat64ThenUint8Impl) GetReturnOfUint8() *ReturnOfUint8 {
	return __.Uint8Return.Get().(*ReturnOfUint8)
}
func (__ *PoolOfFloat64ThenUint8Impl) PutReturnOfUint8(p *ReturnOfUint8) {
	__.Uint8Return.Put(p)
}

func (__ *PoolOfFloat64ThenUint8Impl) GetChReturnOfUint8() chan *ReturnOfUint8 {
	return __.ChReturnOfUint8.Get().(chan *ReturnOfUint8)
}
func (__ *PoolOfFloat64ThenUint8Impl) PutChReturnOfUint8(p chan *ReturnOfUint8) {
	__.ChReturnOfUint8.Put(p)
}

func NewPoolOfFloat64ThenUint8Impl() *PoolOfFloat64ThenUint8Impl {
	return &PoolOfFloat64ThenUint8Impl{
		Float64Arg: sync.Pool{
			New: func() interface{} {
				return new(float64)
			},
		},
		Float64Work: sync.Pool{
			New: func() interface{} {
				return new(WorkOfFloat64ThenUint8)
			},
		},
		Uint8Rtn: sync.Pool{
			New: func() interface{} {
				return new(uint8)
			},
		},
		Uint8Return: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfUint8)
			},
		},
		ChReturnOfUint8: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfUint8, 1)
			},
		},
	}
}

type ApiDecouplerOfFloat64ThenUint8 struct {
	pool PoolOfFloat64ThenUint8
}

func NewApiDecouplerOfFloat64ThenUint8() *ApiDecouplerOfFloat64ThenUint8 {
	return &ApiDecouplerOfFloat64ThenUint8{
		pool: NewPoolOfFloat64ThenUint8Impl(),
	}
}

func (__ *ApiDecouplerOfFloat64ThenUint8) ReturnError(rtn_ch chan<- *ReturnOfUint8, err error) {
	rtn := __.pool.GetReturnOfUint8()
	var other uint8
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfFloat64ThenUint8) HandleOfFloat64ThenUint8(ctx context.Context, req *WorkOfFloat64ThenUint8, h func(ctx context.Context, arg float64) (uint8, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfUint8()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfFloat64ThenUint8) DoOfFloat64ThenUint8(ctx context.Context, worker WorkerOfPushFloat64ThenUint8, arg float64) (uint8, error) {
	// ch := make(chan *ReturnOfUint8, 1)
	ch := __.pool.GetChReturnOfUint8()
	defer __.pool.PutChReturnOfUint8(ch)

	req := __.pool.GetWorkOfFloat64ThenUint8()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfFloat64ThenUint8(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfUint8(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfFloat64ThenUint8 = func(ctx context.Context, arg float64) (uint8, error)

type WorkerOfFloat64ThenUint8 struct {
	api_syncer *ApiDecouplerOfFloat64ThenUint8
	handler    WorkHandlerOfFloat64ThenUint8

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfFloat64ThenUint8
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfFloat64ThenUint8(ctx context.Context, h WorkHandlerOfFloat64ThenUint8, n int) *WorkerOfFloat64ThenUint8 {
	__ := &WorkerOfFloat64ThenUint8{
		api_syncer: NewApiDecouplerOfFloat64ThenUint8(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfFloat64ThenUint8, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfFloat64ThenUint8{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfFloat64ThenUint8(req.Context, req.WorkOfFloat64ThenUint8, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfFloat64ThenUint8) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfFloat64ThenUint8) Push(ctx context.Context, req *WorkOfFloat64ThenUint8) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfFloat64ThenUint8)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfFloat64ThenUint8 = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfFloat64ThenUint8) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfFloat64ThenUint8) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfFloat64ThenUint8) Call(ctx context.Context, arg float64) (uint8, error) {
	return __.api_syncer.DoOfFloat64ThenUint8(ctx, __, arg)
}

type PoolOfFloat64ThenUintptr interface {
	GetFloat64Arg() *float64
	PutFloat64Arg(*float64)
	GetUintptrReturn() *uintptr
	PutUintptrReturn(*uintptr)

	GetWorkOfFloat64ThenUintptr() *WorkOfFloat64ThenUintptr
	GetReturnOfUintptr() *ReturnOfUintptr
	PutWorkOfFloat64ThenUintptr(*WorkOfFloat64ThenUintptr)
	PutReturnOfUintptr(*ReturnOfUintptr)

	GetChReturnOfUintptr() chan *ReturnOfUintptr
	PutChReturnOfUintptr(chan *ReturnOfUintptr)
}

type PoolOfFloat64ThenUintptrImpl struct {
	Float64Arg        sync.Pool
	UintptrRtn        sync.Pool
	Float64Work       sync.Pool
	UintptrReturn     sync.Pool
	ChReturnOfUintptr sync.Pool
}

func (__ *PoolOfFloat64ThenUintptrImpl) GetFloat64Arg() *float64 {
	return __.Float64Arg.Get().(*float64)
}
func (__ *PoolOfFloat64ThenUintptrImpl) PutFloat64Arg(p *float64) {
	__.Float64Arg.Put(p)
}
func (__ *PoolOfFloat64ThenUintptrImpl) GetUintptrReturn() *uintptr {
	return __.UintptrRtn.Get().(*uintptr)
}
func (__ *PoolOfFloat64ThenUintptrImpl) PutUintptrReturn(p *uintptr) {
	__.UintptrRtn.Put(p)
}

func (__ *PoolOfFloat64ThenUintptrImpl) GetWorkOfFloat64ThenUintptr() *WorkOfFloat64ThenUintptr {
	return __.Float64Work.Get().(*WorkOfFloat64ThenUintptr)
}
func (__ *PoolOfFloat64ThenUintptrImpl) PutWorkOfFloat64ThenUintptr(p *WorkOfFloat64ThenUintptr) {
	__.Float64Work.Put(p)
}
func (__ *PoolOfFloat64ThenUintptrImpl) GetReturnOfUintptr() *ReturnOfUintptr {
	return __.UintptrReturn.Get().(*ReturnOfUintptr)
}
func (__ *PoolOfFloat64ThenUintptrImpl) PutReturnOfUintptr(p *ReturnOfUintptr) {
	__.UintptrReturn.Put(p)
}

func (__ *PoolOfFloat64ThenUintptrImpl) GetChReturnOfUintptr() chan *ReturnOfUintptr {
	return __.ChReturnOfUintptr.Get().(chan *ReturnOfUintptr)
}
func (__ *PoolOfFloat64ThenUintptrImpl) PutChReturnOfUintptr(p chan *ReturnOfUintptr) {
	__.ChReturnOfUintptr.Put(p)
}

func NewPoolOfFloat64ThenUintptrImpl() *PoolOfFloat64ThenUintptrImpl {
	return &PoolOfFloat64ThenUintptrImpl{
		Float64Arg: sync.Pool{
			New: func() interface{} {
				return new(float64)
			},
		},
		Float64Work: sync.Pool{
			New: func() interface{} {
				return new(WorkOfFloat64ThenUintptr)
			},
		},
		UintptrRtn: sync.Pool{
			New: func() interface{} {
				return new(uintptr)
			},
		},
		UintptrReturn: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfUintptr)
			},
		},
		ChReturnOfUintptr: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfUintptr, 1)
			},
		},
	}
}

type ApiDecouplerOfFloat64ThenUintptr struct {
	pool PoolOfFloat64ThenUintptr
}

func NewApiDecouplerOfFloat64ThenUintptr() *ApiDecouplerOfFloat64ThenUintptr {
	return &ApiDecouplerOfFloat64ThenUintptr{
		pool: NewPoolOfFloat64ThenUintptrImpl(),
	}
}

func (__ *ApiDecouplerOfFloat64ThenUintptr) ReturnError(rtn_ch chan<- *ReturnOfUintptr, err error) {
	rtn := __.pool.GetReturnOfUintptr()
	var other uintptr
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfFloat64ThenUintptr) HandleOfFloat64ThenUintptr(ctx context.Context, req *WorkOfFloat64ThenUintptr, h func(ctx context.Context, arg float64) (uintptr, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfUintptr()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfFloat64ThenUintptr) DoOfFloat64ThenUintptr(ctx context.Context, worker WorkerOfPushFloat64ThenUintptr, arg float64) (uintptr, error) {
	// ch := make(chan *ReturnOfUintptr, 1)
	ch := __.pool.GetChReturnOfUintptr()
	defer __.pool.PutChReturnOfUintptr(ch)

	req := __.pool.GetWorkOfFloat64ThenUintptr()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfFloat64ThenUintptr(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfUintptr(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfFloat64ThenUintptr = func(ctx context.Context, arg float64) (uintptr, error)

type WorkerOfFloat64ThenUintptr struct {
	api_syncer *ApiDecouplerOfFloat64ThenUintptr
	handler    WorkHandlerOfFloat64ThenUintptr

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfFloat64ThenUintptr
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfFloat64ThenUintptr(ctx context.Context, h WorkHandlerOfFloat64ThenUintptr, n int) *WorkerOfFloat64ThenUintptr {
	__ := &WorkerOfFloat64ThenUintptr{
		api_syncer: NewApiDecouplerOfFloat64ThenUintptr(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfFloat64ThenUintptr, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfFloat64ThenUintptr{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfFloat64ThenUintptr(req.Context, req.WorkOfFloat64ThenUintptr, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfFloat64ThenUintptr) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfFloat64ThenUintptr) Push(ctx context.Context, req *WorkOfFloat64ThenUintptr) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfFloat64ThenUintptr)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfFloat64ThenUintptr = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfFloat64ThenUintptr) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfFloat64ThenUintptr) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfFloat64ThenUintptr) Call(ctx context.Context, arg float64) (uintptr, error) {
	return __.api_syncer.DoOfFloat64ThenUintptr(ctx, __, arg)
}

type PoolOfFloat64ThenInterface interface {
	GetFloat64Arg() *float64
	PutFloat64Arg(*float64)
	GetInterfaceReturn() *interface{}
	PutInterfaceReturn(*interface{})

	GetWorkOfFloat64ThenInterface() *WorkOfFloat64ThenInterface
	GetReturnOfInterface() *ReturnOfInterface
	PutWorkOfFloat64ThenInterface(*WorkOfFloat64ThenInterface)
	PutReturnOfInterface(*ReturnOfInterface)

	GetChReturnOfInterface() chan *ReturnOfInterface
	PutChReturnOfInterface(chan *ReturnOfInterface)
}

type PoolOfFloat64ThenInterfaceImpl struct {
	Float64Arg          sync.Pool
	InterfaceRtn        sync.Pool
	Float64Work         sync.Pool
	InterfaceReturn     sync.Pool
	ChReturnOfInterface sync.Pool
}

func (__ *PoolOfFloat64ThenInterfaceImpl) GetFloat64Arg() *float64 {
	return __.Float64Arg.Get().(*float64)
}
func (__ *PoolOfFloat64ThenInterfaceImpl) PutFloat64Arg(p *float64) {
	__.Float64Arg.Put(p)
}
func (__ *PoolOfFloat64ThenInterfaceImpl) GetInterfaceReturn() *interface{} {
	return __.InterfaceRtn.Get().(*interface{})
}
func (__ *PoolOfFloat64ThenInterfaceImpl) PutInterfaceReturn(p *interface{}) {
	__.InterfaceRtn.Put(p)
}

func (__ *PoolOfFloat64ThenInterfaceImpl) GetWorkOfFloat64ThenInterface() *WorkOfFloat64ThenInterface {
	return __.Float64Work.Get().(*WorkOfFloat64ThenInterface)
}
func (__ *PoolOfFloat64ThenInterfaceImpl) PutWorkOfFloat64ThenInterface(p *WorkOfFloat64ThenInterface) {
	__.Float64Work.Put(p)
}
func (__ *PoolOfFloat64ThenInterfaceImpl) GetReturnOfInterface() *ReturnOfInterface {
	return __.InterfaceReturn.Get().(*ReturnOfInterface)
}
func (__ *PoolOfFloat64ThenInterfaceImpl) PutReturnOfInterface(p *ReturnOfInterface) {
	__.InterfaceReturn.Put(p)
}

func (__ *PoolOfFloat64ThenInterfaceImpl) GetChReturnOfInterface() chan *ReturnOfInterface {
	return __.ChReturnOfInterface.Get().(chan *ReturnOfInterface)
}
func (__ *PoolOfFloat64ThenInterfaceImpl) PutChReturnOfInterface(p chan *ReturnOfInterface) {
	__.ChReturnOfInterface.Put(p)
}

func NewPoolOfFloat64ThenInterfaceImpl() *PoolOfFloat64ThenInterfaceImpl {
	return &PoolOfFloat64ThenInterfaceImpl{
		Float64Arg: sync.Pool{
			New: func() interface{} {
				return new(float64)
			},
		},
		Float64Work: sync.Pool{
			New: func() interface{} {
				return new(WorkOfFloat64ThenInterface)
			},
		},
		InterfaceRtn: sync.Pool{
			New: func() interface{} {
				return new(interface{})
			},
		},
		InterfaceReturn: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfInterface)
			},
		},
		ChReturnOfInterface: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfInterface, 1)
			},
		},
	}
}

type ApiDecouplerOfFloat64ThenInterface struct {
	pool PoolOfFloat64ThenInterface
}

func NewApiDecouplerOfFloat64ThenInterface() *ApiDecouplerOfFloat64ThenInterface {
	return &ApiDecouplerOfFloat64ThenInterface{
		pool: NewPoolOfFloat64ThenInterfaceImpl(),
	}
}

func (__ *ApiDecouplerOfFloat64ThenInterface) ReturnError(rtn_ch chan<- *ReturnOfInterface, err error) {
	rtn := __.pool.GetReturnOfInterface()
	var other interface{}
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfFloat64ThenInterface) HandleOfFloat64ThenInterface(ctx context.Context, req *WorkOfFloat64ThenInterface, h func(ctx context.Context, arg float64) (interface{}, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfInterface()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfFloat64ThenInterface) DoOfFloat64ThenInterface(ctx context.Context, worker WorkerOfPushFloat64ThenInterface, arg float64) (interface{}, error) {
	// ch := make(chan *ReturnOfInterface, 1)
	ch := __.pool.GetChReturnOfInterface()
	defer __.pool.PutChReturnOfInterface(ch)

	req := __.pool.GetWorkOfFloat64ThenInterface()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfFloat64ThenInterface(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfInterface(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfFloat64ThenInterface = func(ctx context.Context, arg float64) (interface{}, error)

type WorkerOfFloat64ThenInterface struct {
	api_syncer *ApiDecouplerOfFloat64ThenInterface
	handler    WorkHandlerOfFloat64ThenInterface

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfFloat64ThenInterface
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfFloat64ThenInterface(ctx context.Context, h WorkHandlerOfFloat64ThenInterface, n int) *WorkerOfFloat64ThenInterface {
	__ := &WorkerOfFloat64ThenInterface{
		api_syncer: NewApiDecouplerOfFloat64ThenInterface(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfFloat64ThenInterface, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfFloat64ThenInterface{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfFloat64ThenInterface(req.Context, req.WorkOfFloat64ThenInterface, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfFloat64ThenInterface) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfFloat64ThenInterface) Push(ctx context.Context, req *WorkOfFloat64ThenInterface) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfFloat64ThenInterface)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfFloat64ThenInterface = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfFloat64ThenInterface) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfFloat64ThenInterface) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfFloat64ThenInterface) Call(ctx context.Context, arg float64) (interface{}, error) {
	return __.api_syncer.DoOfFloat64ThenInterface(ctx, __, arg)
}

type PoolOfFloat64ThenStruct interface {
	GetFloat64Arg() *float64
	PutFloat64Arg(*float64)
	GetStructReturn() *struct{}
	PutStructReturn(*struct{})

	GetWorkOfFloat64ThenStruct() *WorkOfFloat64ThenStruct
	GetReturnOfStruct() *ReturnOfStruct
	PutWorkOfFloat64ThenStruct(*WorkOfFloat64ThenStruct)
	PutReturnOfStruct(*ReturnOfStruct)

	GetChReturnOfStruct() chan *ReturnOfStruct
	PutChReturnOfStruct(chan *ReturnOfStruct)
}

type PoolOfFloat64ThenStructImpl struct {
	Float64Arg       sync.Pool
	StructRtn        sync.Pool
	Float64Work      sync.Pool
	StructReturn     sync.Pool
	ChReturnOfStruct sync.Pool
}

func (__ *PoolOfFloat64ThenStructImpl) GetFloat64Arg() *float64 {
	return __.Float64Arg.Get().(*float64)
}
func (__ *PoolOfFloat64ThenStructImpl) PutFloat64Arg(p *float64) {
	__.Float64Arg.Put(p)
}
func (__ *PoolOfFloat64ThenStructImpl) GetStructReturn() *struct{} {
	return __.StructRtn.Get().(*struct{})
}
func (__ *PoolOfFloat64ThenStructImpl) PutStructReturn(p *struct{}) {
	__.StructRtn.Put(p)
}

func (__ *PoolOfFloat64ThenStructImpl) GetWorkOfFloat64ThenStruct() *WorkOfFloat64ThenStruct {
	return __.Float64Work.Get().(*WorkOfFloat64ThenStruct)
}
func (__ *PoolOfFloat64ThenStructImpl) PutWorkOfFloat64ThenStruct(p *WorkOfFloat64ThenStruct) {
	__.Float64Work.Put(p)
}
func (__ *PoolOfFloat64ThenStructImpl) GetReturnOfStruct() *ReturnOfStruct {
	return __.StructReturn.Get().(*ReturnOfStruct)
}
func (__ *PoolOfFloat64ThenStructImpl) PutReturnOfStruct(p *ReturnOfStruct) {
	__.StructReturn.Put(p)
}

func (__ *PoolOfFloat64ThenStructImpl) GetChReturnOfStruct() chan *ReturnOfStruct {
	return __.ChReturnOfStruct.Get().(chan *ReturnOfStruct)
}
func (__ *PoolOfFloat64ThenStructImpl) PutChReturnOfStruct(p chan *ReturnOfStruct) {
	__.ChReturnOfStruct.Put(p)
}

func NewPoolOfFloat64ThenStructImpl() *PoolOfFloat64ThenStructImpl {
	return &PoolOfFloat64ThenStructImpl{
		Float64Arg: sync.Pool{
			New: func() interface{} {
				return new(float64)
			},
		},
		Float64Work: sync.Pool{
			New: func() interface{} {
				return new(WorkOfFloat64ThenStruct)
			},
		},
		StructRtn: sync.Pool{
			New: func() interface{} {
				return new(struct{})
			},
		},
		StructReturn: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfStruct)
			},
		},
		ChReturnOfStruct: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfStruct, 1)
			},
		},
	}
}

type ApiDecouplerOfFloat64ThenStruct struct {
	pool PoolOfFloat64ThenStruct
}

func NewApiDecouplerOfFloat64ThenStruct() *ApiDecouplerOfFloat64ThenStruct {
	return &ApiDecouplerOfFloat64ThenStruct{
		pool: NewPoolOfFloat64ThenStructImpl(),
	}
}

func (__ *ApiDecouplerOfFloat64ThenStruct) ReturnError(rtn_ch chan<- *ReturnOfStruct, err error) {
	rtn := __.pool.GetReturnOfStruct()
	var other struct{}
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfFloat64ThenStruct) HandleOfFloat64ThenStruct(ctx context.Context, req *WorkOfFloat64ThenStruct, h func(ctx context.Context, arg float64) (struct{}, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfStruct()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfFloat64ThenStruct) DoOfFloat64ThenStruct(ctx context.Context, worker WorkerOfPushFloat64ThenStruct, arg float64) (struct{}, error) {
	// ch := make(chan *ReturnOfStruct, 1)
	ch := __.pool.GetChReturnOfStruct()
	defer __.pool.PutChReturnOfStruct(ch)

	req := __.pool.GetWorkOfFloat64ThenStruct()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfFloat64ThenStruct(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfStruct(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfFloat64ThenStruct = func(ctx context.Context, arg float64) (struct{}, error)

type WorkerOfFloat64ThenStruct struct {
	api_syncer *ApiDecouplerOfFloat64ThenStruct
	handler    WorkHandlerOfFloat64ThenStruct

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfFloat64ThenStruct
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfFloat64ThenStruct(ctx context.Context, h WorkHandlerOfFloat64ThenStruct, n int) *WorkerOfFloat64ThenStruct {
	__ := &WorkerOfFloat64ThenStruct{
		api_syncer: NewApiDecouplerOfFloat64ThenStruct(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfFloat64ThenStruct, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfFloat64ThenStruct{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfFloat64ThenStruct(req.Context, req.WorkOfFloat64ThenStruct, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfFloat64ThenStruct) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfFloat64ThenStruct) Push(ctx context.Context, req *WorkOfFloat64ThenStruct) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfFloat64ThenStruct)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfFloat64ThenStruct = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfFloat64ThenStruct) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfFloat64ThenStruct) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfFloat64ThenStruct) Call(ctx context.Context, arg float64) (struct{}, error) {
	return __.api_syncer.DoOfFloat64ThenStruct(ctx, __, arg)
}

type PoolOfIntThenBool interface {
	GetIntArg() *int
	PutIntArg(*int)
	GetBoolReturn() *bool
	PutBoolReturn(*bool)

	GetWorkOfIntThenBool() *WorkOfIntThenBool
	GetReturnOfBool() *ReturnOfBool
	PutWorkOfIntThenBool(*WorkOfIntThenBool)
	PutReturnOfBool(*ReturnOfBool)

	GetChReturnOfBool() chan *ReturnOfBool
	PutChReturnOfBool(chan *ReturnOfBool)
}

type PoolOfIntThenBoolImpl struct {
	IntArg         sync.Pool
	BoolRtn        sync.Pool
	IntWork        sync.Pool
	BoolReturn     sync.Pool
	ChReturnOfBool sync.Pool
}

func (__ *PoolOfIntThenBoolImpl) GetIntArg() *int {
	return __.IntArg.Get().(*int)
}
func (__ *PoolOfIntThenBoolImpl) PutIntArg(p *int) {
	__.IntArg.Put(p)
}
func (__ *PoolOfIntThenBoolImpl) GetBoolReturn() *bool {
	return __.BoolRtn.Get().(*bool)
}
func (__ *PoolOfIntThenBoolImpl) PutBoolReturn(p *bool) {
	__.BoolRtn.Put(p)
}

func (__ *PoolOfIntThenBoolImpl) GetWorkOfIntThenBool() *WorkOfIntThenBool {
	return __.IntWork.Get().(*WorkOfIntThenBool)
}
func (__ *PoolOfIntThenBoolImpl) PutWorkOfIntThenBool(p *WorkOfIntThenBool) {
	__.IntWork.Put(p)
}
func (__ *PoolOfIntThenBoolImpl) GetReturnOfBool() *ReturnOfBool {
	return __.BoolReturn.Get().(*ReturnOfBool)
}
func (__ *PoolOfIntThenBoolImpl) PutReturnOfBool(p *ReturnOfBool) {
	__.BoolReturn.Put(p)
}

func (__ *PoolOfIntThenBoolImpl) GetChReturnOfBool() chan *ReturnOfBool {
	return __.ChReturnOfBool.Get().(chan *ReturnOfBool)
}
func (__ *PoolOfIntThenBoolImpl) PutChReturnOfBool(p chan *ReturnOfBool) {
	__.ChReturnOfBool.Put(p)
}

func NewPoolOfIntThenBoolImpl() *PoolOfIntThenBoolImpl {
	return &PoolOfIntThenBoolImpl{
		IntArg: sync.Pool{
			New: func() interface{} {
				return new(int)
			},
		},
		IntWork: sync.Pool{
			New: func() interface{} {
				return new(WorkOfIntThenBool)
			},
		},
		BoolRtn: sync.Pool{
			New: func() interface{} {
				return new(bool)
			},
		},
		BoolReturn: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfBool)
			},
		},
		ChReturnOfBool: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfBool, 1)
			},
		},
	}
}

type ApiDecouplerOfIntThenBool struct {
	pool PoolOfIntThenBool
}

func NewApiDecouplerOfIntThenBool() *ApiDecouplerOfIntThenBool {
	return &ApiDecouplerOfIntThenBool{
		pool: NewPoolOfIntThenBoolImpl(),
	}
}

func (__ *ApiDecouplerOfIntThenBool) ReturnError(rtn_ch chan<- *ReturnOfBool, err error) {
	rtn := __.pool.GetReturnOfBool()
	var other bool
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfIntThenBool) HandleOfIntThenBool(ctx context.Context, req *WorkOfIntThenBool, h func(ctx context.Context, arg int) (bool, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfBool()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfIntThenBool) DoOfIntThenBool(ctx context.Context, worker WorkerOfPushIntThenBool, arg int) (bool, error) {
	// ch := make(chan *ReturnOfBool, 1)
	ch := __.pool.GetChReturnOfBool()
	defer __.pool.PutChReturnOfBool(ch)

	req := __.pool.GetWorkOfIntThenBool()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfIntThenBool(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfBool(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfIntThenBool = func(ctx context.Context, arg int) (bool, error)

type WorkerOfIntThenBool struct {
	api_syncer *ApiDecouplerOfIntThenBool
	handler    WorkHandlerOfIntThenBool

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfIntThenBool
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfIntThenBool(ctx context.Context, h WorkHandlerOfIntThenBool, n int) *WorkerOfIntThenBool {
	__ := &WorkerOfIntThenBool{
		api_syncer: NewApiDecouplerOfIntThenBool(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfIntThenBool, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfIntThenBool{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfIntThenBool(req.Context, req.WorkOfIntThenBool, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfIntThenBool) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfIntThenBool) Push(ctx context.Context, req *WorkOfIntThenBool) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfIntThenBool)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfIntThenBool = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfIntThenBool) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfIntThenBool) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfIntThenBool) Call(ctx context.Context, arg int) (bool, error) {
	return __.api_syncer.DoOfIntThenBool(ctx, __, arg)
}

type PoolOfIntThenByte interface {
	GetIntArg() *int
	PutIntArg(*int)
	GetByteReturn() *byte
	PutByteReturn(*byte)

	GetWorkOfIntThenByte() *WorkOfIntThenByte
	GetReturnOfByte() *ReturnOfByte
	PutWorkOfIntThenByte(*WorkOfIntThenByte)
	PutReturnOfByte(*ReturnOfByte)

	GetChReturnOfByte() chan *ReturnOfByte
	PutChReturnOfByte(chan *ReturnOfByte)
}

type PoolOfIntThenByteImpl struct {
	IntArg         sync.Pool
	ByteRtn        sync.Pool
	IntWork        sync.Pool
	ByteReturn     sync.Pool
	ChReturnOfByte sync.Pool
}

func (__ *PoolOfIntThenByteImpl) GetIntArg() *int {
	return __.IntArg.Get().(*int)
}
func (__ *PoolOfIntThenByteImpl) PutIntArg(p *int) {
	__.IntArg.Put(p)
}
func (__ *PoolOfIntThenByteImpl) GetByteReturn() *byte {
	return __.ByteRtn.Get().(*byte)
}
func (__ *PoolOfIntThenByteImpl) PutByteReturn(p *byte) {
	__.ByteRtn.Put(p)
}

func (__ *PoolOfIntThenByteImpl) GetWorkOfIntThenByte() *WorkOfIntThenByte {
	return __.IntWork.Get().(*WorkOfIntThenByte)
}
func (__ *PoolOfIntThenByteImpl) PutWorkOfIntThenByte(p *WorkOfIntThenByte) {
	__.IntWork.Put(p)
}
func (__ *PoolOfIntThenByteImpl) GetReturnOfByte() *ReturnOfByte {
	return __.ByteReturn.Get().(*ReturnOfByte)
}
func (__ *PoolOfIntThenByteImpl) PutReturnOfByte(p *ReturnOfByte) {
	__.ByteReturn.Put(p)
}

func (__ *PoolOfIntThenByteImpl) GetChReturnOfByte() chan *ReturnOfByte {
	return __.ChReturnOfByte.Get().(chan *ReturnOfByte)
}
func (__ *PoolOfIntThenByteImpl) PutChReturnOfByte(p chan *ReturnOfByte) {
	__.ChReturnOfByte.Put(p)
}

func NewPoolOfIntThenByteImpl() *PoolOfIntThenByteImpl {
	return &PoolOfIntThenByteImpl{
		IntArg: sync.Pool{
			New: func() interface{} {
				return new(int)
			},
		},
		IntWork: sync.Pool{
			New: func() interface{} {
				return new(WorkOfIntThenByte)
			},
		},
		ByteRtn: sync.Pool{
			New: func() interface{} {
				return new(byte)
			},
		},
		ByteReturn: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfByte)
			},
		},
		ChReturnOfByte: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfByte, 1)
			},
		},
	}
}

type ApiDecouplerOfIntThenByte struct {
	pool PoolOfIntThenByte
}

func NewApiDecouplerOfIntThenByte() *ApiDecouplerOfIntThenByte {
	return &ApiDecouplerOfIntThenByte{
		pool: NewPoolOfIntThenByteImpl(),
	}
}

func (__ *ApiDecouplerOfIntThenByte) ReturnError(rtn_ch chan<- *ReturnOfByte, err error) {
	rtn := __.pool.GetReturnOfByte()
	var other byte
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfIntThenByte) HandleOfIntThenByte(ctx context.Context, req *WorkOfIntThenByte, h func(ctx context.Context, arg int) (byte, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfByte()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfIntThenByte) DoOfIntThenByte(ctx context.Context, worker WorkerOfPushIntThenByte, arg int) (byte, error) {
	// ch := make(chan *ReturnOfByte, 1)
	ch := __.pool.GetChReturnOfByte()
	defer __.pool.PutChReturnOfByte(ch)

	req := __.pool.GetWorkOfIntThenByte()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfIntThenByte(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfByte(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfIntThenByte = func(ctx context.Context, arg int) (byte, error)

type WorkerOfIntThenByte struct {
	api_syncer *ApiDecouplerOfIntThenByte
	handler    WorkHandlerOfIntThenByte

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfIntThenByte
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfIntThenByte(ctx context.Context, h WorkHandlerOfIntThenByte, n int) *WorkerOfIntThenByte {
	__ := &WorkerOfIntThenByte{
		api_syncer: NewApiDecouplerOfIntThenByte(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfIntThenByte, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfIntThenByte{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfIntThenByte(req.Context, req.WorkOfIntThenByte, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfIntThenByte) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfIntThenByte) Push(ctx context.Context, req *WorkOfIntThenByte) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfIntThenByte)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfIntThenByte = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfIntThenByte) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfIntThenByte) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfIntThenByte) Call(ctx context.Context, arg int) (byte, error) {
	return __.api_syncer.DoOfIntThenByte(ctx, __, arg)
}

type PoolOfIntThenComplex128 interface {
	GetIntArg() *int
	PutIntArg(*int)
	GetComplex128Return() *complex128
	PutComplex128Return(*complex128)

	GetWorkOfIntThenComplex128() *WorkOfIntThenComplex128
	GetReturnOfComplex128() *ReturnOfComplex128
	PutWorkOfIntThenComplex128(*WorkOfIntThenComplex128)
	PutReturnOfComplex128(*ReturnOfComplex128)

	GetChReturnOfComplex128() chan *ReturnOfComplex128
	PutChReturnOfComplex128(chan *ReturnOfComplex128)
}

type PoolOfIntThenComplex128Impl struct {
	IntArg               sync.Pool
	Complex128Rtn        sync.Pool
	IntWork              sync.Pool
	Complex128Return     sync.Pool
	ChReturnOfComplex128 sync.Pool
}

func (__ *PoolOfIntThenComplex128Impl) GetIntArg() *int {
	return __.IntArg.Get().(*int)
}
func (__ *PoolOfIntThenComplex128Impl) PutIntArg(p *int) {
	__.IntArg.Put(p)
}
func (__ *PoolOfIntThenComplex128Impl) GetComplex128Return() *complex128 {
	return __.Complex128Rtn.Get().(*complex128)
}
func (__ *PoolOfIntThenComplex128Impl) PutComplex128Return(p *complex128) {
	__.Complex128Rtn.Put(p)
}

func (__ *PoolOfIntThenComplex128Impl) GetWorkOfIntThenComplex128() *WorkOfIntThenComplex128 {
	return __.IntWork.Get().(*WorkOfIntThenComplex128)
}
func (__ *PoolOfIntThenComplex128Impl) PutWorkOfIntThenComplex128(p *WorkOfIntThenComplex128) {
	__.IntWork.Put(p)
}
func (__ *PoolOfIntThenComplex128Impl) GetReturnOfComplex128() *ReturnOfComplex128 {
	return __.Complex128Return.Get().(*ReturnOfComplex128)
}
func (__ *PoolOfIntThenComplex128Impl) PutReturnOfComplex128(p *ReturnOfComplex128) {
	__.Complex128Return.Put(p)
}

func (__ *PoolOfIntThenComplex128Impl) GetChReturnOfComplex128() chan *ReturnOfComplex128 {
	return __.ChReturnOfComplex128.Get().(chan *ReturnOfComplex128)
}
func (__ *PoolOfIntThenComplex128Impl) PutChReturnOfComplex128(p chan *ReturnOfComplex128) {
	__.ChReturnOfComplex128.Put(p)
}

func NewPoolOfIntThenComplex128Impl() *PoolOfIntThenComplex128Impl {
	return &PoolOfIntThenComplex128Impl{
		IntArg: sync.Pool{
			New: func() interface{} {
				return new(int)
			},
		},
		IntWork: sync.Pool{
			New: func() interface{} {
				return new(WorkOfIntThenComplex128)
			},
		},
		Complex128Rtn: sync.Pool{
			New: func() interface{} {
				return new(complex128)
			},
		},
		Complex128Return: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfComplex128)
			},
		},
		ChReturnOfComplex128: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfComplex128, 1)
			},
		},
	}
}

type ApiDecouplerOfIntThenComplex128 struct {
	pool PoolOfIntThenComplex128
}

func NewApiDecouplerOfIntThenComplex128() *ApiDecouplerOfIntThenComplex128 {
	return &ApiDecouplerOfIntThenComplex128{
		pool: NewPoolOfIntThenComplex128Impl(),
	}
}

func (__ *ApiDecouplerOfIntThenComplex128) ReturnError(rtn_ch chan<- *ReturnOfComplex128, err error) {
	rtn := __.pool.GetReturnOfComplex128()
	var other complex128
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfIntThenComplex128) HandleOfIntThenComplex128(ctx context.Context, req *WorkOfIntThenComplex128, h func(ctx context.Context, arg int) (complex128, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfComplex128()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfIntThenComplex128) DoOfIntThenComplex128(ctx context.Context, worker WorkerOfPushIntThenComplex128, arg int) (complex128, error) {
	// ch := make(chan *ReturnOfComplex128, 1)
	ch := __.pool.GetChReturnOfComplex128()
	defer __.pool.PutChReturnOfComplex128(ch)

	req := __.pool.GetWorkOfIntThenComplex128()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfIntThenComplex128(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfComplex128(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfIntThenComplex128 = func(ctx context.Context, arg int) (complex128, error)

type WorkerOfIntThenComplex128 struct {
	api_syncer *ApiDecouplerOfIntThenComplex128
	handler    WorkHandlerOfIntThenComplex128

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfIntThenComplex128
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfIntThenComplex128(ctx context.Context, h WorkHandlerOfIntThenComplex128, n int) *WorkerOfIntThenComplex128 {
	__ := &WorkerOfIntThenComplex128{
		api_syncer: NewApiDecouplerOfIntThenComplex128(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfIntThenComplex128, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfIntThenComplex128{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfIntThenComplex128(req.Context, req.WorkOfIntThenComplex128, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfIntThenComplex128) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfIntThenComplex128) Push(ctx context.Context, req *WorkOfIntThenComplex128) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfIntThenComplex128)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfIntThenComplex128 = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfIntThenComplex128) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfIntThenComplex128) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfIntThenComplex128) Call(ctx context.Context, arg int) (complex128, error) {
	return __.api_syncer.DoOfIntThenComplex128(ctx, __, arg)
}

type PoolOfIntThenComplex64 interface {
	GetIntArg() *int
	PutIntArg(*int)
	GetComplex64Return() *complex64
	PutComplex64Return(*complex64)

	GetWorkOfIntThenComplex64() *WorkOfIntThenComplex64
	GetReturnOfComplex64() *ReturnOfComplex64
	PutWorkOfIntThenComplex64(*WorkOfIntThenComplex64)
	PutReturnOfComplex64(*ReturnOfComplex64)

	GetChReturnOfComplex64() chan *ReturnOfComplex64
	PutChReturnOfComplex64(chan *ReturnOfComplex64)
}

type PoolOfIntThenComplex64Impl struct {
	IntArg              sync.Pool
	Complex64Rtn        sync.Pool
	IntWork             sync.Pool
	Complex64Return     sync.Pool
	ChReturnOfComplex64 sync.Pool
}

func (__ *PoolOfIntThenComplex64Impl) GetIntArg() *int {
	return __.IntArg.Get().(*int)
}
func (__ *PoolOfIntThenComplex64Impl) PutIntArg(p *int) {
	__.IntArg.Put(p)
}
func (__ *PoolOfIntThenComplex64Impl) GetComplex64Return() *complex64 {
	return __.Complex64Rtn.Get().(*complex64)
}
func (__ *PoolOfIntThenComplex64Impl) PutComplex64Return(p *complex64) {
	__.Complex64Rtn.Put(p)
}

func (__ *PoolOfIntThenComplex64Impl) GetWorkOfIntThenComplex64() *WorkOfIntThenComplex64 {
	return __.IntWork.Get().(*WorkOfIntThenComplex64)
}
func (__ *PoolOfIntThenComplex64Impl) PutWorkOfIntThenComplex64(p *WorkOfIntThenComplex64) {
	__.IntWork.Put(p)
}
func (__ *PoolOfIntThenComplex64Impl) GetReturnOfComplex64() *ReturnOfComplex64 {
	return __.Complex64Return.Get().(*ReturnOfComplex64)
}
func (__ *PoolOfIntThenComplex64Impl) PutReturnOfComplex64(p *ReturnOfComplex64) {
	__.Complex64Return.Put(p)
}

func (__ *PoolOfIntThenComplex64Impl) GetChReturnOfComplex64() chan *ReturnOfComplex64 {
	return __.ChReturnOfComplex64.Get().(chan *ReturnOfComplex64)
}
func (__ *PoolOfIntThenComplex64Impl) PutChReturnOfComplex64(p chan *ReturnOfComplex64) {
	__.ChReturnOfComplex64.Put(p)
}

func NewPoolOfIntThenComplex64Impl() *PoolOfIntThenComplex64Impl {
	return &PoolOfIntThenComplex64Impl{
		IntArg: sync.Pool{
			New: func() interface{} {
				return new(int)
			},
		},
		IntWork: sync.Pool{
			New: func() interface{} {
				return new(WorkOfIntThenComplex64)
			},
		},
		Complex64Rtn: sync.Pool{
			New: func() interface{} {
				return new(complex64)
			},
		},
		Complex64Return: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfComplex64)
			},
		},
		ChReturnOfComplex64: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfComplex64, 1)
			},
		},
	}
}

type ApiDecouplerOfIntThenComplex64 struct {
	pool PoolOfIntThenComplex64
}

func NewApiDecouplerOfIntThenComplex64() *ApiDecouplerOfIntThenComplex64 {
	return &ApiDecouplerOfIntThenComplex64{
		pool: NewPoolOfIntThenComplex64Impl(),
	}
}

func (__ *ApiDecouplerOfIntThenComplex64) ReturnError(rtn_ch chan<- *ReturnOfComplex64, err error) {
	rtn := __.pool.GetReturnOfComplex64()
	var other complex64
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfIntThenComplex64) HandleOfIntThenComplex64(ctx context.Context, req *WorkOfIntThenComplex64, h func(ctx context.Context, arg int) (complex64, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfComplex64()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfIntThenComplex64) DoOfIntThenComplex64(ctx context.Context, worker WorkerOfPushIntThenComplex64, arg int) (complex64, error) {
	// ch := make(chan *ReturnOfComplex64, 1)
	ch := __.pool.GetChReturnOfComplex64()
	defer __.pool.PutChReturnOfComplex64(ch)

	req := __.pool.GetWorkOfIntThenComplex64()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfIntThenComplex64(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfComplex64(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfIntThenComplex64 = func(ctx context.Context, arg int) (complex64, error)

type WorkerOfIntThenComplex64 struct {
	api_syncer *ApiDecouplerOfIntThenComplex64
	handler    WorkHandlerOfIntThenComplex64

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfIntThenComplex64
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfIntThenComplex64(ctx context.Context, h WorkHandlerOfIntThenComplex64, n int) *WorkerOfIntThenComplex64 {
	__ := &WorkerOfIntThenComplex64{
		api_syncer: NewApiDecouplerOfIntThenComplex64(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfIntThenComplex64, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfIntThenComplex64{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfIntThenComplex64(req.Context, req.WorkOfIntThenComplex64, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfIntThenComplex64) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfIntThenComplex64) Push(ctx context.Context, req *WorkOfIntThenComplex64) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfIntThenComplex64)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfIntThenComplex64 = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfIntThenComplex64) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfIntThenComplex64) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfIntThenComplex64) Call(ctx context.Context, arg int) (complex64, error) {
	return __.api_syncer.DoOfIntThenComplex64(ctx, __, arg)
}

type PoolOfIntThenError interface {
	GetIntArg() *int
	PutIntArg(*int)
	GetErrorReturn() *error
	PutErrorReturn(*error)

	GetWorkOfIntThenError() *WorkOfIntThenError
	GetReturnOfError() *ReturnOfError
	PutWorkOfIntThenError(*WorkOfIntThenError)
	PutReturnOfError(*ReturnOfError)

	GetChReturnOfError() chan *ReturnOfError
	PutChReturnOfError(chan *ReturnOfError)
}

type PoolOfIntThenErrorImpl struct {
	IntArg          sync.Pool
	ErrorRtn        sync.Pool
	IntWork         sync.Pool
	ErrorReturn     sync.Pool
	ChReturnOfError sync.Pool
}

func (__ *PoolOfIntThenErrorImpl) GetIntArg() *int {
	return __.IntArg.Get().(*int)
}
func (__ *PoolOfIntThenErrorImpl) PutIntArg(p *int) {
	__.IntArg.Put(p)
}
func (__ *PoolOfIntThenErrorImpl) GetErrorReturn() *error {
	return __.ErrorRtn.Get().(*error)
}
func (__ *PoolOfIntThenErrorImpl) PutErrorReturn(p *error) {
	__.ErrorRtn.Put(p)
}

func (__ *PoolOfIntThenErrorImpl) GetWorkOfIntThenError() *WorkOfIntThenError {
	return __.IntWork.Get().(*WorkOfIntThenError)
}
func (__ *PoolOfIntThenErrorImpl) PutWorkOfIntThenError(p *WorkOfIntThenError) {
	__.IntWork.Put(p)
}
func (__ *PoolOfIntThenErrorImpl) GetReturnOfError() *ReturnOfError {
	return __.ErrorReturn.Get().(*ReturnOfError)
}
func (__ *PoolOfIntThenErrorImpl) PutReturnOfError(p *ReturnOfError) {
	__.ErrorReturn.Put(p)
}

func (__ *PoolOfIntThenErrorImpl) GetChReturnOfError() chan *ReturnOfError {
	return __.ChReturnOfError.Get().(chan *ReturnOfError)
}
func (__ *PoolOfIntThenErrorImpl) PutChReturnOfError(p chan *ReturnOfError) {
	__.ChReturnOfError.Put(p)
}

func NewPoolOfIntThenErrorImpl() *PoolOfIntThenErrorImpl {
	return &PoolOfIntThenErrorImpl{
		IntArg: sync.Pool{
			New: func() interface{} {
				return new(int)
			},
		},
		IntWork: sync.Pool{
			New: func() interface{} {
				return new(WorkOfIntThenError)
			},
		},
		ErrorRtn: sync.Pool{
			New: func() interface{} {
				return new(error)
			},
		},
		ErrorReturn: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfError)
			},
		},
		ChReturnOfError: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfError, 1)
			},
		},
	}
}

type ApiDecouplerOfIntThenError struct {
	pool PoolOfIntThenError
}

func NewApiDecouplerOfIntThenError() *ApiDecouplerOfIntThenError {
	return &ApiDecouplerOfIntThenError{
		pool: NewPoolOfIntThenErrorImpl(),
	}
}

func (__ *ApiDecouplerOfIntThenError) ReturnError(rtn_ch chan<- *ReturnOfError, err error) {
	rtn := __.pool.GetReturnOfError()
	var other error
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfIntThenError) HandleOfIntThenError(ctx context.Context, req *WorkOfIntThenError, h func(ctx context.Context, arg int) (error, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfError()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfIntThenError) DoOfIntThenError(ctx context.Context, worker WorkerOfPushIntThenError, arg int) (error, error) {
	// ch := make(chan *ReturnOfError, 1)
	ch := __.pool.GetChReturnOfError()
	defer __.pool.PutChReturnOfError(ch)

	req := __.pool.GetWorkOfIntThenError()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfIntThenError(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfError(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfIntThenError = func(ctx context.Context, arg int) (error, error)

type WorkerOfIntThenError struct {
	api_syncer *ApiDecouplerOfIntThenError
	handler    WorkHandlerOfIntThenError

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfIntThenError
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfIntThenError(ctx context.Context, h WorkHandlerOfIntThenError, n int) *WorkerOfIntThenError {
	__ := &WorkerOfIntThenError{
		api_syncer: NewApiDecouplerOfIntThenError(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfIntThenError, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfIntThenError{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfIntThenError(req.Context, req.WorkOfIntThenError, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfIntThenError) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfIntThenError) Push(ctx context.Context, req *WorkOfIntThenError) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfIntThenError)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfIntThenError = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfIntThenError) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfIntThenError) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfIntThenError) Call(ctx context.Context, arg int) (error, error) {
	return __.api_syncer.DoOfIntThenError(ctx, __, arg)
}

type PoolOfIntThenFloat32 interface {
	GetIntArg() *int
	PutIntArg(*int)
	GetFloat32Return() *float32
	PutFloat32Return(*float32)

	GetWorkOfIntThenFloat32() *WorkOfIntThenFloat32
	GetReturnOfFloat32() *ReturnOfFloat32
	PutWorkOfIntThenFloat32(*WorkOfIntThenFloat32)
	PutReturnOfFloat32(*ReturnOfFloat32)

	GetChReturnOfFloat32() chan *ReturnOfFloat32
	PutChReturnOfFloat32(chan *ReturnOfFloat32)
}

type PoolOfIntThenFloat32Impl struct {
	IntArg            sync.Pool
	Float32Rtn        sync.Pool
	IntWork           sync.Pool
	Float32Return     sync.Pool
	ChReturnOfFloat32 sync.Pool
}

func (__ *PoolOfIntThenFloat32Impl) GetIntArg() *int {
	return __.IntArg.Get().(*int)
}
func (__ *PoolOfIntThenFloat32Impl) PutIntArg(p *int) {
	__.IntArg.Put(p)
}
func (__ *PoolOfIntThenFloat32Impl) GetFloat32Return() *float32 {
	return __.Float32Rtn.Get().(*float32)
}
func (__ *PoolOfIntThenFloat32Impl) PutFloat32Return(p *float32) {
	__.Float32Rtn.Put(p)
}

func (__ *PoolOfIntThenFloat32Impl) GetWorkOfIntThenFloat32() *WorkOfIntThenFloat32 {
	return __.IntWork.Get().(*WorkOfIntThenFloat32)
}
func (__ *PoolOfIntThenFloat32Impl) PutWorkOfIntThenFloat32(p *WorkOfIntThenFloat32) {
	__.IntWork.Put(p)
}
func (__ *PoolOfIntThenFloat32Impl) GetReturnOfFloat32() *ReturnOfFloat32 {
	return __.Float32Return.Get().(*ReturnOfFloat32)
}
func (__ *PoolOfIntThenFloat32Impl) PutReturnOfFloat32(p *ReturnOfFloat32) {
	__.Float32Return.Put(p)
}

func (__ *PoolOfIntThenFloat32Impl) GetChReturnOfFloat32() chan *ReturnOfFloat32 {
	return __.ChReturnOfFloat32.Get().(chan *ReturnOfFloat32)
}
func (__ *PoolOfIntThenFloat32Impl) PutChReturnOfFloat32(p chan *ReturnOfFloat32) {
	__.ChReturnOfFloat32.Put(p)
}

func NewPoolOfIntThenFloat32Impl() *PoolOfIntThenFloat32Impl {
	return &PoolOfIntThenFloat32Impl{
		IntArg: sync.Pool{
			New: func() interface{} {
				return new(int)
			},
		},
		IntWork: sync.Pool{
			New: func() interface{} {
				return new(WorkOfIntThenFloat32)
			},
		},
		Float32Rtn: sync.Pool{
			New: func() interface{} {
				return new(float32)
			},
		},
		Float32Return: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfFloat32)
			},
		},
		ChReturnOfFloat32: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfFloat32, 1)
			},
		},
	}
}

type ApiDecouplerOfIntThenFloat32 struct {
	pool PoolOfIntThenFloat32
}

func NewApiDecouplerOfIntThenFloat32() *ApiDecouplerOfIntThenFloat32 {
	return &ApiDecouplerOfIntThenFloat32{
		pool: NewPoolOfIntThenFloat32Impl(),
	}
}

func (__ *ApiDecouplerOfIntThenFloat32) ReturnError(rtn_ch chan<- *ReturnOfFloat32, err error) {
	rtn := __.pool.GetReturnOfFloat32()
	var other float32
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfIntThenFloat32) HandleOfIntThenFloat32(ctx context.Context, req *WorkOfIntThenFloat32, h func(ctx context.Context, arg int) (float32, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfFloat32()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfIntThenFloat32) DoOfIntThenFloat32(ctx context.Context, worker WorkerOfPushIntThenFloat32, arg int) (float32, error) {
	// ch := make(chan *ReturnOfFloat32, 1)
	ch := __.pool.GetChReturnOfFloat32()
	defer __.pool.PutChReturnOfFloat32(ch)

	req := __.pool.GetWorkOfIntThenFloat32()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfIntThenFloat32(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfFloat32(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfIntThenFloat32 = func(ctx context.Context, arg int) (float32, error)

type WorkerOfIntThenFloat32 struct {
	api_syncer *ApiDecouplerOfIntThenFloat32
	handler    WorkHandlerOfIntThenFloat32

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfIntThenFloat32
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfIntThenFloat32(ctx context.Context, h WorkHandlerOfIntThenFloat32, n int) *WorkerOfIntThenFloat32 {
	__ := &WorkerOfIntThenFloat32{
		api_syncer: NewApiDecouplerOfIntThenFloat32(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfIntThenFloat32, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfIntThenFloat32{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfIntThenFloat32(req.Context, req.WorkOfIntThenFloat32, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfIntThenFloat32) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfIntThenFloat32) Push(ctx context.Context, req *WorkOfIntThenFloat32) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfIntThenFloat32)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfIntThenFloat32 = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfIntThenFloat32) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfIntThenFloat32) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfIntThenFloat32) Call(ctx context.Context, arg int) (float32, error) {
	return __.api_syncer.DoOfIntThenFloat32(ctx, __, arg)
}

type PoolOfIntThenFloat64 interface {
	GetIntArg() *int
	PutIntArg(*int)
	GetFloat64Return() *float64
	PutFloat64Return(*float64)

	GetWorkOfIntThenFloat64() *WorkOfIntThenFloat64
	GetReturnOfFloat64() *ReturnOfFloat64
	PutWorkOfIntThenFloat64(*WorkOfIntThenFloat64)
	PutReturnOfFloat64(*ReturnOfFloat64)

	GetChReturnOfFloat64() chan *ReturnOfFloat64
	PutChReturnOfFloat64(chan *ReturnOfFloat64)
}

type PoolOfIntThenFloat64Impl struct {
	IntArg            sync.Pool
	Float64Rtn        sync.Pool
	IntWork           sync.Pool
	Float64Return     sync.Pool
	ChReturnOfFloat64 sync.Pool
}

func (__ *PoolOfIntThenFloat64Impl) GetIntArg() *int {
	return __.IntArg.Get().(*int)
}
func (__ *PoolOfIntThenFloat64Impl) PutIntArg(p *int) {
	__.IntArg.Put(p)
}
func (__ *PoolOfIntThenFloat64Impl) GetFloat64Return() *float64 {
	return __.Float64Rtn.Get().(*float64)
}
func (__ *PoolOfIntThenFloat64Impl) PutFloat64Return(p *float64) {
	__.Float64Rtn.Put(p)
}

func (__ *PoolOfIntThenFloat64Impl) GetWorkOfIntThenFloat64() *WorkOfIntThenFloat64 {
	return __.IntWork.Get().(*WorkOfIntThenFloat64)
}
func (__ *PoolOfIntThenFloat64Impl) PutWorkOfIntThenFloat64(p *WorkOfIntThenFloat64) {
	__.IntWork.Put(p)
}
func (__ *PoolOfIntThenFloat64Impl) GetReturnOfFloat64() *ReturnOfFloat64 {
	return __.Float64Return.Get().(*ReturnOfFloat64)
}
func (__ *PoolOfIntThenFloat64Impl) PutReturnOfFloat64(p *ReturnOfFloat64) {
	__.Float64Return.Put(p)
}

func (__ *PoolOfIntThenFloat64Impl) GetChReturnOfFloat64() chan *ReturnOfFloat64 {
	return __.ChReturnOfFloat64.Get().(chan *ReturnOfFloat64)
}
func (__ *PoolOfIntThenFloat64Impl) PutChReturnOfFloat64(p chan *ReturnOfFloat64) {
	__.ChReturnOfFloat64.Put(p)
}

func NewPoolOfIntThenFloat64Impl() *PoolOfIntThenFloat64Impl {
	return &PoolOfIntThenFloat64Impl{
		IntArg: sync.Pool{
			New: func() interface{} {
				return new(int)
			},
		},
		IntWork: sync.Pool{
			New: func() interface{} {
				return new(WorkOfIntThenFloat64)
			},
		},
		Float64Rtn: sync.Pool{
			New: func() interface{} {
				return new(float64)
			},
		},
		Float64Return: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfFloat64)
			},
		},
		ChReturnOfFloat64: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfFloat64, 1)
			},
		},
	}
}

type ApiDecouplerOfIntThenFloat64 struct {
	pool PoolOfIntThenFloat64
}

func NewApiDecouplerOfIntThenFloat64() *ApiDecouplerOfIntThenFloat64 {
	return &ApiDecouplerOfIntThenFloat64{
		pool: NewPoolOfIntThenFloat64Impl(),
	}
}

func (__ *ApiDecouplerOfIntThenFloat64) ReturnError(rtn_ch chan<- *ReturnOfFloat64, err error) {
	rtn := __.pool.GetReturnOfFloat64()
	var other float64
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfIntThenFloat64) HandleOfIntThenFloat64(ctx context.Context, req *WorkOfIntThenFloat64, h func(ctx context.Context, arg int) (float64, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfFloat64()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfIntThenFloat64) DoOfIntThenFloat64(ctx context.Context, worker WorkerOfPushIntThenFloat64, arg int) (float64, error) {
	// ch := make(chan *ReturnOfFloat64, 1)
	ch := __.pool.GetChReturnOfFloat64()
	defer __.pool.PutChReturnOfFloat64(ch)

	req := __.pool.GetWorkOfIntThenFloat64()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfIntThenFloat64(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfFloat64(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfIntThenFloat64 = func(ctx context.Context, arg int) (float64, error)

type WorkerOfIntThenFloat64 struct {
	api_syncer *ApiDecouplerOfIntThenFloat64
	handler    WorkHandlerOfIntThenFloat64

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfIntThenFloat64
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfIntThenFloat64(ctx context.Context, h WorkHandlerOfIntThenFloat64, n int) *WorkerOfIntThenFloat64 {
	__ := &WorkerOfIntThenFloat64{
		api_syncer: NewApiDecouplerOfIntThenFloat64(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfIntThenFloat64, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfIntThenFloat64{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfIntThenFloat64(req.Context, req.WorkOfIntThenFloat64, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfIntThenFloat64) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfIntThenFloat64) Push(ctx context.Context, req *WorkOfIntThenFloat64) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfIntThenFloat64)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfIntThenFloat64 = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfIntThenFloat64) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfIntThenFloat64) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfIntThenFloat64) Call(ctx context.Context, arg int) (float64, error) {
	return __.api_syncer.DoOfIntThenFloat64(ctx, __, arg)
}

type PoolOfIntThenInt interface {
	GetIntArg() *int
	PutIntArg(*int)
	GetIntReturn() *int
	PutIntReturn(*int)

	GetWorkOfIntThenInt() *WorkOfIntThenInt
	GetReturnOfInt() *ReturnOfInt
	PutWorkOfIntThenInt(*WorkOfIntThenInt)
	PutReturnOfInt(*ReturnOfInt)

	GetChReturnOfInt() chan *ReturnOfInt
	PutChReturnOfInt(chan *ReturnOfInt)
}

type PoolOfIntThenIntImpl struct {
	IntArg        sync.Pool
	IntRtn        sync.Pool
	IntWork       sync.Pool
	IntReturn     sync.Pool
	ChReturnOfInt sync.Pool
}

func (__ *PoolOfIntThenIntImpl) GetIntArg() *int {
	return __.IntArg.Get().(*int)
}
func (__ *PoolOfIntThenIntImpl) PutIntArg(p *int) {
	__.IntArg.Put(p)
}
func (__ *PoolOfIntThenIntImpl) GetIntReturn() *int {
	return __.IntRtn.Get().(*int)
}
func (__ *PoolOfIntThenIntImpl) PutIntReturn(p *int) {
	__.IntRtn.Put(p)
}

func (__ *PoolOfIntThenIntImpl) GetWorkOfIntThenInt() *WorkOfIntThenInt {
	return __.IntWork.Get().(*WorkOfIntThenInt)
}
func (__ *PoolOfIntThenIntImpl) PutWorkOfIntThenInt(p *WorkOfIntThenInt) {
	__.IntWork.Put(p)
}
func (__ *PoolOfIntThenIntImpl) GetReturnOfInt() *ReturnOfInt {
	return __.IntReturn.Get().(*ReturnOfInt)
}
func (__ *PoolOfIntThenIntImpl) PutReturnOfInt(p *ReturnOfInt) {
	__.IntReturn.Put(p)
}

func (__ *PoolOfIntThenIntImpl) GetChReturnOfInt() chan *ReturnOfInt {
	return __.ChReturnOfInt.Get().(chan *ReturnOfInt)
}
func (__ *PoolOfIntThenIntImpl) PutChReturnOfInt(p chan *ReturnOfInt) {
	__.ChReturnOfInt.Put(p)
}

func NewPoolOfIntThenIntImpl() *PoolOfIntThenIntImpl {
	return &PoolOfIntThenIntImpl{
		IntArg: sync.Pool{
			New: func() interface{} {
				return new(int)
			},
		},
		IntWork: sync.Pool{
			New: func() interface{} {
				return new(WorkOfIntThenInt)
			},
		},
		IntRtn: sync.Pool{
			New: func() interface{} {
				return new(int)
			},
		},
		IntReturn: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfInt)
			},
		},
		ChReturnOfInt: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfInt, 1)
			},
		},
	}
}

type ApiDecouplerOfIntThenInt struct {
	pool PoolOfIntThenInt
}

func NewApiDecouplerOfIntThenInt() *ApiDecouplerOfIntThenInt {
	return &ApiDecouplerOfIntThenInt{
		pool: NewPoolOfIntThenIntImpl(),
	}
}

func (__ *ApiDecouplerOfIntThenInt) ReturnError(rtn_ch chan<- *ReturnOfInt, err error) {
	rtn := __.pool.GetReturnOfInt()
	var other int
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfIntThenInt) HandleOfIntThenInt(ctx context.Context, req *WorkOfIntThenInt, h func(ctx context.Context, arg int) (int, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfInt()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfIntThenInt) DoOfIntThenInt(ctx context.Context, worker WorkerOfPushIntThenInt, arg int) (int, error) {
	// ch := make(chan *ReturnOfInt, 1)
	ch := __.pool.GetChReturnOfInt()
	defer __.pool.PutChReturnOfInt(ch)

	req := __.pool.GetWorkOfIntThenInt()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfIntThenInt(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfInt(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfIntThenInt = func(ctx context.Context, arg int) (int, error)

type WorkerOfIntThenInt struct {
	api_syncer *ApiDecouplerOfIntThenInt
	handler    WorkHandlerOfIntThenInt

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfIntThenInt
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfIntThenInt(ctx context.Context, h WorkHandlerOfIntThenInt, n int) *WorkerOfIntThenInt {
	__ := &WorkerOfIntThenInt{
		api_syncer: NewApiDecouplerOfIntThenInt(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfIntThenInt, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfIntThenInt{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfIntThenInt(req.Context, req.WorkOfIntThenInt, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfIntThenInt) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfIntThenInt) Push(ctx context.Context, req *WorkOfIntThenInt) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfIntThenInt)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfIntThenInt = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfIntThenInt) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfIntThenInt) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfIntThenInt) Call(ctx context.Context, arg int) (int, error) {
	return __.api_syncer.DoOfIntThenInt(ctx, __, arg)
}

type PoolOfIntThenInt16 interface {
	GetIntArg() *int
	PutIntArg(*int)
	GetInt16Return() *int16
	PutInt16Return(*int16)

	GetWorkOfIntThenInt16() *WorkOfIntThenInt16
	GetReturnOfInt16() *ReturnOfInt16
	PutWorkOfIntThenInt16(*WorkOfIntThenInt16)
	PutReturnOfInt16(*ReturnOfInt16)

	GetChReturnOfInt16() chan *ReturnOfInt16
	PutChReturnOfInt16(chan *ReturnOfInt16)
}

type PoolOfIntThenInt16Impl struct {
	IntArg          sync.Pool
	Int16Rtn        sync.Pool
	IntWork         sync.Pool
	Int16Return     sync.Pool
	ChReturnOfInt16 sync.Pool
}

func (__ *PoolOfIntThenInt16Impl) GetIntArg() *int {
	return __.IntArg.Get().(*int)
}
func (__ *PoolOfIntThenInt16Impl) PutIntArg(p *int) {
	__.IntArg.Put(p)
}
func (__ *PoolOfIntThenInt16Impl) GetInt16Return() *int16 {
	return __.Int16Rtn.Get().(*int16)
}
func (__ *PoolOfIntThenInt16Impl) PutInt16Return(p *int16) {
	__.Int16Rtn.Put(p)
}

func (__ *PoolOfIntThenInt16Impl) GetWorkOfIntThenInt16() *WorkOfIntThenInt16 {
	return __.IntWork.Get().(*WorkOfIntThenInt16)
}
func (__ *PoolOfIntThenInt16Impl) PutWorkOfIntThenInt16(p *WorkOfIntThenInt16) {
	__.IntWork.Put(p)
}
func (__ *PoolOfIntThenInt16Impl) GetReturnOfInt16() *ReturnOfInt16 {
	return __.Int16Return.Get().(*ReturnOfInt16)
}
func (__ *PoolOfIntThenInt16Impl) PutReturnOfInt16(p *ReturnOfInt16) {
	__.Int16Return.Put(p)
}

func (__ *PoolOfIntThenInt16Impl) GetChReturnOfInt16() chan *ReturnOfInt16 {
	return __.ChReturnOfInt16.Get().(chan *ReturnOfInt16)
}
func (__ *PoolOfIntThenInt16Impl) PutChReturnOfInt16(p chan *ReturnOfInt16) {
	__.ChReturnOfInt16.Put(p)
}

func NewPoolOfIntThenInt16Impl() *PoolOfIntThenInt16Impl {
	return &PoolOfIntThenInt16Impl{
		IntArg: sync.Pool{
			New: func() interface{} {
				return new(int)
			},
		},
		IntWork: sync.Pool{
			New: func() interface{} {
				return new(WorkOfIntThenInt16)
			},
		},
		Int16Rtn: sync.Pool{
			New: func() interface{} {
				return new(int16)
			},
		},
		Int16Return: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfInt16)
			},
		},
		ChReturnOfInt16: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfInt16, 1)
			},
		},
	}
}

type ApiDecouplerOfIntThenInt16 struct {
	pool PoolOfIntThenInt16
}

func NewApiDecouplerOfIntThenInt16() *ApiDecouplerOfIntThenInt16 {
	return &ApiDecouplerOfIntThenInt16{
		pool: NewPoolOfIntThenInt16Impl(),
	}
}

func (__ *ApiDecouplerOfIntThenInt16) ReturnError(rtn_ch chan<- *ReturnOfInt16, err error) {
	rtn := __.pool.GetReturnOfInt16()
	var other int16
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfIntThenInt16) HandleOfIntThenInt16(ctx context.Context, req *WorkOfIntThenInt16, h func(ctx context.Context, arg int) (int16, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfInt16()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfIntThenInt16) DoOfIntThenInt16(ctx context.Context, worker WorkerOfPushIntThenInt16, arg int) (int16, error) {
	// ch := make(chan *ReturnOfInt16, 1)
	ch := __.pool.GetChReturnOfInt16()
	defer __.pool.PutChReturnOfInt16(ch)

	req := __.pool.GetWorkOfIntThenInt16()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfIntThenInt16(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfInt16(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfIntThenInt16 = func(ctx context.Context, arg int) (int16, error)

type WorkerOfIntThenInt16 struct {
	api_syncer *ApiDecouplerOfIntThenInt16
	handler    WorkHandlerOfIntThenInt16

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfIntThenInt16
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfIntThenInt16(ctx context.Context, h WorkHandlerOfIntThenInt16, n int) *WorkerOfIntThenInt16 {
	__ := &WorkerOfIntThenInt16{
		api_syncer: NewApiDecouplerOfIntThenInt16(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfIntThenInt16, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfIntThenInt16{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfIntThenInt16(req.Context, req.WorkOfIntThenInt16, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfIntThenInt16) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfIntThenInt16) Push(ctx context.Context, req *WorkOfIntThenInt16) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfIntThenInt16)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfIntThenInt16 = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfIntThenInt16) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfIntThenInt16) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfIntThenInt16) Call(ctx context.Context, arg int) (int16, error) {
	return __.api_syncer.DoOfIntThenInt16(ctx, __, arg)
}

type PoolOfIntThenInt32 interface {
	GetIntArg() *int
	PutIntArg(*int)
	GetInt32Return() *int32
	PutInt32Return(*int32)

	GetWorkOfIntThenInt32() *WorkOfIntThenInt32
	GetReturnOfInt32() *ReturnOfInt32
	PutWorkOfIntThenInt32(*WorkOfIntThenInt32)
	PutReturnOfInt32(*ReturnOfInt32)

	GetChReturnOfInt32() chan *ReturnOfInt32
	PutChReturnOfInt32(chan *ReturnOfInt32)
}

type PoolOfIntThenInt32Impl struct {
	IntArg          sync.Pool
	Int32Rtn        sync.Pool
	IntWork         sync.Pool
	Int32Return     sync.Pool
	ChReturnOfInt32 sync.Pool
}

func (__ *PoolOfIntThenInt32Impl) GetIntArg() *int {
	return __.IntArg.Get().(*int)
}
func (__ *PoolOfIntThenInt32Impl) PutIntArg(p *int) {
	__.IntArg.Put(p)
}
func (__ *PoolOfIntThenInt32Impl) GetInt32Return() *int32 {
	return __.Int32Rtn.Get().(*int32)
}
func (__ *PoolOfIntThenInt32Impl) PutInt32Return(p *int32) {
	__.Int32Rtn.Put(p)
}

func (__ *PoolOfIntThenInt32Impl) GetWorkOfIntThenInt32() *WorkOfIntThenInt32 {
	return __.IntWork.Get().(*WorkOfIntThenInt32)
}
func (__ *PoolOfIntThenInt32Impl) PutWorkOfIntThenInt32(p *WorkOfIntThenInt32) {
	__.IntWork.Put(p)
}
func (__ *PoolOfIntThenInt32Impl) GetReturnOfInt32() *ReturnOfInt32 {
	return __.Int32Return.Get().(*ReturnOfInt32)
}
func (__ *PoolOfIntThenInt32Impl) PutReturnOfInt32(p *ReturnOfInt32) {
	__.Int32Return.Put(p)
}

func (__ *PoolOfIntThenInt32Impl) GetChReturnOfInt32() chan *ReturnOfInt32 {
	return __.ChReturnOfInt32.Get().(chan *ReturnOfInt32)
}
func (__ *PoolOfIntThenInt32Impl) PutChReturnOfInt32(p chan *ReturnOfInt32) {
	__.ChReturnOfInt32.Put(p)
}

func NewPoolOfIntThenInt32Impl() *PoolOfIntThenInt32Impl {
	return &PoolOfIntThenInt32Impl{
		IntArg: sync.Pool{
			New: func() interface{} {
				return new(int)
			},
		},
		IntWork: sync.Pool{
			New: func() interface{} {
				return new(WorkOfIntThenInt32)
			},
		},
		Int32Rtn: sync.Pool{
			New: func() interface{} {
				return new(int32)
			},
		},
		Int32Return: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfInt32)
			},
		},
		ChReturnOfInt32: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfInt32, 1)
			},
		},
	}
}

type ApiDecouplerOfIntThenInt32 struct {
	pool PoolOfIntThenInt32
}

func NewApiDecouplerOfIntThenInt32() *ApiDecouplerOfIntThenInt32 {
	return &ApiDecouplerOfIntThenInt32{
		pool: NewPoolOfIntThenInt32Impl(),
	}
}

func (__ *ApiDecouplerOfIntThenInt32) ReturnError(rtn_ch chan<- *ReturnOfInt32, err error) {
	rtn := __.pool.GetReturnOfInt32()
	var other int32
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfIntThenInt32) HandleOfIntThenInt32(ctx context.Context, req *WorkOfIntThenInt32, h func(ctx context.Context, arg int) (int32, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfInt32()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfIntThenInt32) DoOfIntThenInt32(ctx context.Context, worker WorkerOfPushIntThenInt32, arg int) (int32, error) {
	// ch := make(chan *ReturnOfInt32, 1)
	ch := __.pool.GetChReturnOfInt32()
	defer __.pool.PutChReturnOfInt32(ch)

	req := __.pool.GetWorkOfIntThenInt32()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfIntThenInt32(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfInt32(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfIntThenInt32 = func(ctx context.Context, arg int) (int32, error)

type WorkerOfIntThenInt32 struct {
	api_syncer *ApiDecouplerOfIntThenInt32
	handler    WorkHandlerOfIntThenInt32

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfIntThenInt32
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfIntThenInt32(ctx context.Context, h WorkHandlerOfIntThenInt32, n int) *WorkerOfIntThenInt32 {
	__ := &WorkerOfIntThenInt32{
		api_syncer: NewApiDecouplerOfIntThenInt32(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfIntThenInt32, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfIntThenInt32{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfIntThenInt32(req.Context, req.WorkOfIntThenInt32, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfIntThenInt32) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfIntThenInt32) Push(ctx context.Context, req *WorkOfIntThenInt32) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfIntThenInt32)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfIntThenInt32 = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfIntThenInt32) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfIntThenInt32) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfIntThenInt32) Call(ctx context.Context, arg int) (int32, error) {
	return __.api_syncer.DoOfIntThenInt32(ctx, __, arg)
}

type PoolOfIntThenInt64 interface {
	GetIntArg() *int
	PutIntArg(*int)
	GetInt64Return() *int64
	PutInt64Return(*int64)

	GetWorkOfIntThenInt64() *WorkOfIntThenInt64
	GetReturnOfInt64() *ReturnOfInt64
	PutWorkOfIntThenInt64(*WorkOfIntThenInt64)
	PutReturnOfInt64(*ReturnOfInt64)

	GetChReturnOfInt64() chan *ReturnOfInt64
	PutChReturnOfInt64(chan *ReturnOfInt64)
}

type PoolOfIntThenInt64Impl struct {
	IntArg          sync.Pool
	Int64Rtn        sync.Pool
	IntWork         sync.Pool
	Int64Return     sync.Pool
	ChReturnOfInt64 sync.Pool
}

func (__ *PoolOfIntThenInt64Impl) GetIntArg() *int {
	return __.IntArg.Get().(*int)
}
func (__ *PoolOfIntThenInt64Impl) PutIntArg(p *int) {
	__.IntArg.Put(p)
}
func (__ *PoolOfIntThenInt64Impl) GetInt64Return() *int64 {
	return __.Int64Rtn.Get().(*int64)
}
func (__ *PoolOfIntThenInt64Impl) PutInt64Return(p *int64) {
	__.Int64Rtn.Put(p)
}

func (__ *PoolOfIntThenInt64Impl) GetWorkOfIntThenInt64() *WorkOfIntThenInt64 {
	return __.IntWork.Get().(*WorkOfIntThenInt64)
}
func (__ *PoolOfIntThenInt64Impl) PutWorkOfIntThenInt64(p *WorkOfIntThenInt64) {
	__.IntWork.Put(p)
}
func (__ *PoolOfIntThenInt64Impl) GetReturnOfInt64() *ReturnOfInt64 {
	return __.Int64Return.Get().(*ReturnOfInt64)
}
func (__ *PoolOfIntThenInt64Impl) PutReturnOfInt64(p *ReturnOfInt64) {
	__.Int64Return.Put(p)
}

func (__ *PoolOfIntThenInt64Impl) GetChReturnOfInt64() chan *ReturnOfInt64 {
	return __.ChReturnOfInt64.Get().(chan *ReturnOfInt64)
}
func (__ *PoolOfIntThenInt64Impl) PutChReturnOfInt64(p chan *ReturnOfInt64) {
	__.ChReturnOfInt64.Put(p)
}

func NewPoolOfIntThenInt64Impl() *PoolOfIntThenInt64Impl {
	return &PoolOfIntThenInt64Impl{
		IntArg: sync.Pool{
			New: func() interface{} {
				return new(int)
			},
		},
		IntWork: sync.Pool{
			New: func() interface{} {
				return new(WorkOfIntThenInt64)
			},
		},
		Int64Rtn: sync.Pool{
			New: func() interface{} {
				return new(int64)
			},
		},
		Int64Return: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfInt64)
			},
		},
		ChReturnOfInt64: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfInt64, 1)
			},
		},
	}
}

type ApiDecouplerOfIntThenInt64 struct {
	pool PoolOfIntThenInt64
}

func NewApiDecouplerOfIntThenInt64() *ApiDecouplerOfIntThenInt64 {
	return &ApiDecouplerOfIntThenInt64{
		pool: NewPoolOfIntThenInt64Impl(),
	}
}

func (__ *ApiDecouplerOfIntThenInt64) ReturnError(rtn_ch chan<- *ReturnOfInt64, err error) {
	rtn := __.pool.GetReturnOfInt64()
	var other int64
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfIntThenInt64) HandleOfIntThenInt64(ctx context.Context, req *WorkOfIntThenInt64, h func(ctx context.Context, arg int) (int64, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfInt64()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfIntThenInt64) DoOfIntThenInt64(ctx context.Context, worker WorkerOfPushIntThenInt64, arg int) (int64, error) {
	// ch := make(chan *ReturnOfInt64, 1)
	ch := __.pool.GetChReturnOfInt64()
	defer __.pool.PutChReturnOfInt64(ch)

	req := __.pool.GetWorkOfIntThenInt64()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfIntThenInt64(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfInt64(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfIntThenInt64 = func(ctx context.Context, arg int) (int64, error)

type WorkerOfIntThenInt64 struct {
	api_syncer *ApiDecouplerOfIntThenInt64
	handler    WorkHandlerOfIntThenInt64

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfIntThenInt64
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfIntThenInt64(ctx context.Context, h WorkHandlerOfIntThenInt64, n int) *WorkerOfIntThenInt64 {
	__ := &WorkerOfIntThenInt64{
		api_syncer: NewApiDecouplerOfIntThenInt64(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfIntThenInt64, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfIntThenInt64{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfIntThenInt64(req.Context, req.WorkOfIntThenInt64, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfIntThenInt64) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfIntThenInt64) Push(ctx context.Context, req *WorkOfIntThenInt64) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfIntThenInt64)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfIntThenInt64 = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfIntThenInt64) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfIntThenInt64) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfIntThenInt64) Call(ctx context.Context, arg int) (int64, error) {
	return __.api_syncer.DoOfIntThenInt64(ctx, __, arg)
}

type PoolOfIntThenInt8 interface {
	GetIntArg() *int
	PutIntArg(*int)
	GetInt8Return() *int8
	PutInt8Return(*int8)

	GetWorkOfIntThenInt8() *WorkOfIntThenInt8
	GetReturnOfInt8() *ReturnOfInt8
	PutWorkOfIntThenInt8(*WorkOfIntThenInt8)
	PutReturnOfInt8(*ReturnOfInt8)

	GetChReturnOfInt8() chan *ReturnOfInt8
	PutChReturnOfInt8(chan *ReturnOfInt8)
}

type PoolOfIntThenInt8Impl struct {
	IntArg         sync.Pool
	Int8Rtn        sync.Pool
	IntWork        sync.Pool
	Int8Return     sync.Pool
	ChReturnOfInt8 sync.Pool
}

func (__ *PoolOfIntThenInt8Impl) GetIntArg() *int {
	return __.IntArg.Get().(*int)
}
func (__ *PoolOfIntThenInt8Impl) PutIntArg(p *int) {
	__.IntArg.Put(p)
}
func (__ *PoolOfIntThenInt8Impl) GetInt8Return() *int8 {
	return __.Int8Rtn.Get().(*int8)
}
func (__ *PoolOfIntThenInt8Impl) PutInt8Return(p *int8) {
	__.Int8Rtn.Put(p)
}

func (__ *PoolOfIntThenInt8Impl) GetWorkOfIntThenInt8() *WorkOfIntThenInt8 {
	return __.IntWork.Get().(*WorkOfIntThenInt8)
}
func (__ *PoolOfIntThenInt8Impl) PutWorkOfIntThenInt8(p *WorkOfIntThenInt8) {
	__.IntWork.Put(p)
}
func (__ *PoolOfIntThenInt8Impl) GetReturnOfInt8() *ReturnOfInt8 {
	return __.Int8Return.Get().(*ReturnOfInt8)
}
func (__ *PoolOfIntThenInt8Impl) PutReturnOfInt8(p *ReturnOfInt8) {
	__.Int8Return.Put(p)
}

func (__ *PoolOfIntThenInt8Impl) GetChReturnOfInt8() chan *ReturnOfInt8 {
	return __.ChReturnOfInt8.Get().(chan *ReturnOfInt8)
}
func (__ *PoolOfIntThenInt8Impl) PutChReturnOfInt8(p chan *ReturnOfInt8) {
	__.ChReturnOfInt8.Put(p)
}

func NewPoolOfIntThenInt8Impl() *PoolOfIntThenInt8Impl {
	return &PoolOfIntThenInt8Impl{
		IntArg: sync.Pool{
			New: func() interface{} {
				return new(int)
			},
		},
		IntWork: sync.Pool{
			New: func() interface{} {
				return new(WorkOfIntThenInt8)
			},
		},
		Int8Rtn: sync.Pool{
			New: func() interface{} {
				return new(int8)
			},
		},
		Int8Return: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfInt8)
			},
		},
		ChReturnOfInt8: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfInt8, 1)
			},
		},
	}
}

type ApiDecouplerOfIntThenInt8 struct {
	pool PoolOfIntThenInt8
}

func NewApiDecouplerOfIntThenInt8() *ApiDecouplerOfIntThenInt8 {
	return &ApiDecouplerOfIntThenInt8{
		pool: NewPoolOfIntThenInt8Impl(),
	}
}

func (__ *ApiDecouplerOfIntThenInt8) ReturnError(rtn_ch chan<- *ReturnOfInt8, err error) {
	rtn := __.pool.GetReturnOfInt8()
	var other int8
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfIntThenInt8) HandleOfIntThenInt8(ctx context.Context, req *WorkOfIntThenInt8, h func(ctx context.Context, arg int) (int8, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfInt8()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfIntThenInt8) DoOfIntThenInt8(ctx context.Context, worker WorkerOfPushIntThenInt8, arg int) (int8, error) {
	// ch := make(chan *ReturnOfInt8, 1)
	ch := __.pool.GetChReturnOfInt8()
	defer __.pool.PutChReturnOfInt8(ch)

	req := __.pool.GetWorkOfIntThenInt8()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfIntThenInt8(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfInt8(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfIntThenInt8 = func(ctx context.Context, arg int) (int8, error)

type WorkerOfIntThenInt8 struct {
	api_syncer *ApiDecouplerOfIntThenInt8
	handler    WorkHandlerOfIntThenInt8

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfIntThenInt8
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfIntThenInt8(ctx context.Context, h WorkHandlerOfIntThenInt8, n int) *WorkerOfIntThenInt8 {
	__ := &WorkerOfIntThenInt8{
		api_syncer: NewApiDecouplerOfIntThenInt8(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfIntThenInt8, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfIntThenInt8{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfIntThenInt8(req.Context, req.WorkOfIntThenInt8, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfIntThenInt8) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfIntThenInt8) Push(ctx context.Context, req *WorkOfIntThenInt8) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfIntThenInt8)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfIntThenInt8 = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfIntThenInt8) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfIntThenInt8) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfIntThenInt8) Call(ctx context.Context, arg int) (int8, error) {
	return __.api_syncer.DoOfIntThenInt8(ctx, __, arg)
}

type PoolOfIntThenRune interface {
	GetIntArg() *int
	PutIntArg(*int)
	GetRuneReturn() *rune
	PutRuneReturn(*rune)

	GetWorkOfIntThenRune() *WorkOfIntThenRune
	GetReturnOfRune() *ReturnOfRune
	PutWorkOfIntThenRune(*WorkOfIntThenRune)
	PutReturnOfRune(*ReturnOfRune)

	GetChReturnOfRune() chan *ReturnOfRune
	PutChReturnOfRune(chan *ReturnOfRune)
}

type PoolOfIntThenRuneImpl struct {
	IntArg         sync.Pool
	RuneRtn        sync.Pool
	IntWork        sync.Pool
	RuneReturn     sync.Pool
	ChReturnOfRune sync.Pool
}

func (__ *PoolOfIntThenRuneImpl) GetIntArg() *int {
	return __.IntArg.Get().(*int)
}
func (__ *PoolOfIntThenRuneImpl) PutIntArg(p *int) {
	__.IntArg.Put(p)
}
func (__ *PoolOfIntThenRuneImpl) GetRuneReturn() *rune {
	return __.RuneRtn.Get().(*rune)
}
func (__ *PoolOfIntThenRuneImpl) PutRuneReturn(p *rune) {
	__.RuneRtn.Put(p)
}

func (__ *PoolOfIntThenRuneImpl) GetWorkOfIntThenRune() *WorkOfIntThenRune {
	return __.IntWork.Get().(*WorkOfIntThenRune)
}
func (__ *PoolOfIntThenRuneImpl) PutWorkOfIntThenRune(p *WorkOfIntThenRune) {
	__.IntWork.Put(p)
}
func (__ *PoolOfIntThenRuneImpl) GetReturnOfRune() *ReturnOfRune {
	return __.RuneReturn.Get().(*ReturnOfRune)
}
func (__ *PoolOfIntThenRuneImpl) PutReturnOfRune(p *ReturnOfRune) {
	__.RuneReturn.Put(p)
}

func (__ *PoolOfIntThenRuneImpl) GetChReturnOfRune() chan *ReturnOfRune {
	return __.ChReturnOfRune.Get().(chan *ReturnOfRune)
}
func (__ *PoolOfIntThenRuneImpl) PutChReturnOfRune(p chan *ReturnOfRune) {
	__.ChReturnOfRune.Put(p)
}

func NewPoolOfIntThenRuneImpl() *PoolOfIntThenRuneImpl {
	return &PoolOfIntThenRuneImpl{
		IntArg: sync.Pool{
			New: func() interface{} {
				return new(int)
			},
		},
		IntWork: sync.Pool{
			New: func() interface{} {
				return new(WorkOfIntThenRune)
			},
		},
		RuneRtn: sync.Pool{
			New: func() interface{} {
				return new(rune)
			},
		},
		RuneReturn: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfRune)
			},
		},
		ChReturnOfRune: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfRune, 1)
			},
		},
	}
}

type ApiDecouplerOfIntThenRune struct {
	pool PoolOfIntThenRune
}

func NewApiDecouplerOfIntThenRune() *ApiDecouplerOfIntThenRune {
	return &ApiDecouplerOfIntThenRune{
		pool: NewPoolOfIntThenRuneImpl(),
	}
}

func (__ *ApiDecouplerOfIntThenRune) ReturnError(rtn_ch chan<- *ReturnOfRune, err error) {
	rtn := __.pool.GetReturnOfRune()
	var other rune
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfIntThenRune) HandleOfIntThenRune(ctx context.Context, req *WorkOfIntThenRune, h func(ctx context.Context, arg int) (rune, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfRune()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfIntThenRune) DoOfIntThenRune(ctx context.Context, worker WorkerOfPushIntThenRune, arg int) (rune, error) {
	// ch := make(chan *ReturnOfRune, 1)
	ch := __.pool.GetChReturnOfRune()
	defer __.pool.PutChReturnOfRune(ch)

	req := __.pool.GetWorkOfIntThenRune()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfIntThenRune(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfRune(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfIntThenRune = func(ctx context.Context, arg int) (rune, error)

type WorkerOfIntThenRune struct {
	api_syncer *ApiDecouplerOfIntThenRune
	handler    WorkHandlerOfIntThenRune

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfIntThenRune
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfIntThenRune(ctx context.Context, h WorkHandlerOfIntThenRune, n int) *WorkerOfIntThenRune {
	__ := &WorkerOfIntThenRune{
		api_syncer: NewApiDecouplerOfIntThenRune(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfIntThenRune, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfIntThenRune{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfIntThenRune(req.Context, req.WorkOfIntThenRune, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfIntThenRune) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfIntThenRune) Push(ctx context.Context, req *WorkOfIntThenRune) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfIntThenRune)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfIntThenRune = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfIntThenRune) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfIntThenRune) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfIntThenRune) Call(ctx context.Context, arg int) (rune, error) {
	return __.api_syncer.DoOfIntThenRune(ctx, __, arg)
}

type PoolOfIntThenString interface {
	GetIntArg() *int
	PutIntArg(*int)
	GetStringReturn() *string
	PutStringReturn(*string)

	GetWorkOfIntThenString() *WorkOfIntThenString
	GetReturnOfString() *ReturnOfString
	PutWorkOfIntThenString(*WorkOfIntThenString)
	PutReturnOfString(*ReturnOfString)

	GetChReturnOfString() chan *ReturnOfString
	PutChReturnOfString(chan *ReturnOfString)
}

type PoolOfIntThenStringImpl struct {
	IntArg           sync.Pool
	StringRtn        sync.Pool
	IntWork          sync.Pool
	StringReturn     sync.Pool
	ChReturnOfString sync.Pool
}

func (__ *PoolOfIntThenStringImpl) GetIntArg() *int {
	return __.IntArg.Get().(*int)
}
func (__ *PoolOfIntThenStringImpl) PutIntArg(p *int) {
	__.IntArg.Put(p)
}
func (__ *PoolOfIntThenStringImpl) GetStringReturn() *string {
	return __.StringRtn.Get().(*string)
}
func (__ *PoolOfIntThenStringImpl) PutStringReturn(p *string) {
	__.StringRtn.Put(p)
}

func (__ *PoolOfIntThenStringImpl) GetWorkOfIntThenString() *WorkOfIntThenString {
	return __.IntWork.Get().(*WorkOfIntThenString)
}
func (__ *PoolOfIntThenStringImpl) PutWorkOfIntThenString(p *WorkOfIntThenString) {
	__.IntWork.Put(p)
}
func (__ *PoolOfIntThenStringImpl) GetReturnOfString() *ReturnOfString {
	return __.StringReturn.Get().(*ReturnOfString)
}
func (__ *PoolOfIntThenStringImpl) PutReturnOfString(p *ReturnOfString) {
	__.StringReturn.Put(p)
}

func (__ *PoolOfIntThenStringImpl) GetChReturnOfString() chan *ReturnOfString {
	return __.ChReturnOfString.Get().(chan *ReturnOfString)
}
func (__ *PoolOfIntThenStringImpl) PutChReturnOfString(p chan *ReturnOfString) {
	__.ChReturnOfString.Put(p)
}

func NewPoolOfIntThenStringImpl() *PoolOfIntThenStringImpl {
	return &PoolOfIntThenStringImpl{
		IntArg: sync.Pool{
			New: func() interface{} {
				return new(int)
			},
		},
		IntWork: sync.Pool{
			New: func() interface{} {
				return new(WorkOfIntThenString)
			},
		},
		StringRtn: sync.Pool{
			New: func() interface{} {
				return new(string)
			},
		},
		StringReturn: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfString)
			},
		},
		ChReturnOfString: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfString, 1)
			},
		},
	}
}

type ApiDecouplerOfIntThenString struct {
	pool PoolOfIntThenString
}

func NewApiDecouplerOfIntThenString() *ApiDecouplerOfIntThenString {
	return &ApiDecouplerOfIntThenString{
		pool: NewPoolOfIntThenStringImpl(),
	}
}

func (__ *ApiDecouplerOfIntThenString) ReturnError(rtn_ch chan<- *ReturnOfString, err error) {
	rtn := __.pool.GetReturnOfString()
	var other string
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfIntThenString) HandleOfIntThenString(ctx context.Context, req *WorkOfIntThenString, h func(ctx context.Context, arg int) (string, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfString()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfIntThenString) DoOfIntThenString(ctx context.Context, worker WorkerOfPushIntThenString, arg int) (string, error) {
	// ch := make(chan *ReturnOfString, 1)
	ch := __.pool.GetChReturnOfString()
	defer __.pool.PutChReturnOfString(ch)

	req := __.pool.GetWorkOfIntThenString()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfIntThenString(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfString(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfIntThenString = func(ctx context.Context, arg int) (string, error)

type WorkerOfIntThenString struct {
	api_syncer *ApiDecouplerOfIntThenString
	handler    WorkHandlerOfIntThenString

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfIntThenString
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfIntThenString(ctx context.Context, h WorkHandlerOfIntThenString, n int) *WorkerOfIntThenString {
	__ := &WorkerOfIntThenString{
		api_syncer: NewApiDecouplerOfIntThenString(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfIntThenString, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfIntThenString{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfIntThenString(req.Context, req.WorkOfIntThenString, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfIntThenString) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfIntThenString) Push(ctx context.Context, req *WorkOfIntThenString) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfIntThenString)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfIntThenString = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfIntThenString) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfIntThenString) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfIntThenString) Call(ctx context.Context, arg int) (string, error) {
	return __.api_syncer.DoOfIntThenString(ctx, __, arg)
}

type PoolOfIntThenUint interface {
	GetIntArg() *int
	PutIntArg(*int)
	GetUintReturn() *uint
	PutUintReturn(*uint)

	GetWorkOfIntThenUint() *WorkOfIntThenUint
	GetReturnOfUint() *ReturnOfUint
	PutWorkOfIntThenUint(*WorkOfIntThenUint)
	PutReturnOfUint(*ReturnOfUint)

	GetChReturnOfUint() chan *ReturnOfUint
	PutChReturnOfUint(chan *ReturnOfUint)
}

type PoolOfIntThenUintImpl struct {
	IntArg         sync.Pool
	UintRtn        sync.Pool
	IntWork        sync.Pool
	UintReturn     sync.Pool
	ChReturnOfUint sync.Pool
}

func (__ *PoolOfIntThenUintImpl) GetIntArg() *int {
	return __.IntArg.Get().(*int)
}
func (__ *PoolOfIntThenUintImpl) PutIntArg(p *int) {
	__.IntArg.Put(p)
}
func (__ *PoolOfIntThenUintImpl) GetUintReturn() *uint {
	return __.UintRtn.Get().(*uint)
}
func (__ *PoolOfIntThenUintImpl) PutUintReturn(p *uint) {
	__.UintRtn.Put(p)
}

func (__ *PoolOfIntThenUintImpl) GetWorkOfIntThenUint() *WorkOfIntThenUint {
	return __.IntWork.Get().(*WorkOfIntThenUint)
}
func (__ *PoolOfIntThenUintImpl) PutWorkOfIntThenUint(p *WorkOfIntThenUint) {
	__.IntWork.Put(p)
}
func (__ *PoolOfIntThenUintImpl) GetReturnOfUint() *ReturnOfUint {
	return __.UintReturn.Get().(*ReturnOfUint)
}
func (__ *PoolOfIntThenUintImpl) PutReturnOfUint(p *ReturnOfUint) {
	__.UintReturn.Put(p)
}

func (__ *PoolOfIntThenUintImpl) GetChReturnOfUint() chan *ReturnOfUint {
	return __.ChReturnOfUint.Get().(chan *ReturnOfUint)
}
func (__ *PoolOfIntThenUintImpl) PutChReturnOfUint(p chan *ReturnOfUint) {
	__.ChReturnOfUint.Put(p)
}

func NewPoolOfIntThenUintImpl() *PoolOfIntThenUintImpl {
	return &PoolOfIntThenUintImpl{
		IntArg: sync.Pool{
			New: func() interface{} {
				return new(int)
			},
		},
		IntWork: sync.Pool{
			New: func() interface{} {
				return new(WorkOfIntThenUint)
			},
		},
		UintRtn: sync.Pool{
			New: func() interface{} {
				return new(uint)
			},
		},
		UintReturn: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfUint)
			},
		},
		ChReturnOfUint: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfUint, 1)
			},
		},
	}
}

type ApiDecouplerOfIntThenUint struct {
	pool PoolOfIntThenUint
}

func NewApiDecouplerOfIntThenUint() *ApiDecouplerOfIntThenUint {
	return &ApiDecouplerOfIntThenUint{
		pool: NewPoolOfIntThenUintImpl(),
	}
}

func (__ *ApiDecouplerOfIntThenUint) ReturnError(rtn_ch chan<- *ReturnOfUint, err error) {
	rtn := __.pool.GetReturnOfUint()
	var other uint
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfIntThenUint) HandleOfIntThenUint(ctx context.Context, req *WorkOfIntThenUint, h func(ctx context.Context, arg int) (uint, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfUint()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfIntThenUint) DoOfIntThenUint(ctx context.Context, worker WorkerOfPushIntThenUint, arg int) (uint, error) {
	// ch := make(chan *ReturnOfUint, 1)
	ch := __.pool.GetChReturnOfUint()
	defer __.pool.PutChReturnOfUint(ch)

	req := __.pool.GetWorkOfIntThenUint()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfIntThenUint(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfUint(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfIntThenUint = func(ctx context.Context, arg int) (uint, error)

type WorkerOfIntThenUint struct {
	api_syncer *ApiDecouplerOfIntThenUint
	handler    WorkHandlerOfIntThenUint

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfIntThenUint
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfIntThenUint(ctx context.Context, h WorkHandlerOfIntThenUint, n int) *WorkerOfIntThenUint {
	__ := &WorkerOfIntThenUint{
		api_syncer: NewApiDecouplerOfIntThenUint(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfIntThenUint, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfIntThenUint{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfIntThenUint(req.Context, req.WorkOfIntThenUint, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfIntThenUint) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfIntThenUint) Push(ctx context.Context, req *WorkOfIntThenUint) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfIntThenUint)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfIntThenUint = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfIntThenUint) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfIntThenUint) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfIntThenUint) Call(ctx context.Context, arg int) (uint, error) {
	return __.api_syncer.DoOfIntThenUint(ctx, __, arg)
}

type PoolOfIntThenUint16 interface {
	GetIntArg() *int
	PutIntArg(*int)
	GetUint16Return() *uint16
	PutUint16Return(*uint16)

	GetWorkOfIntThenUint16() *WorkOfIntThenUint16
	GetReturnOfUint16() *ReturnOfUint16
	PutWorkOfIntThenUint16(*WorkOfIntThenUint16)
	PutReturnOfUint16(*ReturnOfUint16)

	GetChReturnOfUint16() chan *ReturnOfUint16
	PutChReturnOfUint16(chan *ReturnOfUint16)
}

type PoolOfIntThenUint16Impl struct {
	IntArg           sync.Pool
	Uint16Rtn        sync.Pool
	IntWork          sync.Pool
	Uint16Return     sync.Pool
	ChReturnOfUint16 sync.Pool
}

func (__ *PoolOfIntThenUint16Impl) GetIntArg() *int {
	return __.IntArg.Get().(*int)
}
func (__ *PoolOfIntThenUint16Impl) PutIntArg(p *int) {
	__.IntArg.Put(p)
}
func (__ *PoolOfIntThenUint16Impl) GetUint16Return() *uint16 {
	return __.Uint16Rtn.Get().(*uint16)
}
func (__ *PoolOfIntThenUint16Impl) PutUint16Return(p *uint16) {
	__.Uint16Rtn.Put(p)
}

func (__ *PoolOfIntThenUint16Impl) GetWorkOfIntThenUint16() *WorkOfIntThenUint16 {
	return __.IntWork.Get().(*WorkOfIntThenUint16)
}
func (__ *PoolOfIntThenUint16Impl) PutWorkOfIntThenUint16(p *WorkOfIntThenUint16) {
	__.IntWork.Put(p)
}
func (__ *PoolOfIntThenUint16Impl) GetReturnOfUint16() *ReturnOfUint16 {
	return __.Uint16Return.Get().(*ReturnOfUint16)
}
func (__ *PoolOfIntThenUint16Impl) PutReturnOfUint16(p *ReturnOfUint16) {
	__.Uint16Return.Put(p)
}

func (__ *PoolOfIntThenUint16Impl) GetChReturnOfUint16() chan *ReturnOfUint16 {
	return __.ChReturnOfUint16.Get().(chan *ReturnOfUint16)
}
func (__ *PoolOfIntThenUint16Impl) PutChReturnOfUint16(p chan *ReturnOfUint16) {
	__.ChReturnOfUint16.Put(p)
}

func NewPoolOfIntThenUint16Impl() *PoolOfIntThenUint16Impl {
	return &PoolOfIntThenUint16Impl{
		IntArg: sync.Pool{
			New: func() interface{} {
				return new(int)
			},
		},
		IntWork: sync.Pool{
			New: func() interface{} {
				return new(WorkOfIntThenUint16)
			},
		},
		Uint16Rtn: sync.Pool{
			New: func() interface{} {
				return new(uint16)
			},
		},
		Uint16Return: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfUint16)
			},
		},
		ChReturnOfUint16: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfUint16, 1)
			},
		},
	}
}

type ApiDecouplerOfIntThenUint16 struct {
	pool PoolOfIntThenUint16
}

func NewApiDecouplerOfIntThenUint16() *ApiDecouplerOfIntThenUint16 {
	return &ApiDecouplerOfIntThenUint16{
		pool: NewPoolOfIntThenUint16Impl(),
	}
}

func (__ *ApiDecouplerOfIntThenUint16) ReturnError(rtn_ch chan<- *ReturnOfUint16, err error) {
	rtn := __.pool.GetReturnOfUint16()
	var other uint16
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfIntThenUint16) HandleOfIntThenUint16(ctx context.Context, req *WorkOfIntThenUint16, h func(ctx context.Context, arg int) (uint16, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfUint16()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfIntThenUint16) DoOfIntThenUint16(ctx context.Context, worker WorkerOfPushIntThenUint16, arg int) (uint16, error) {
	// ch := make(chan *ReturnOfUint16, 1)
	ch := __.pool.GetChReturnOfUint16()
	defer __.pool.PutChReturnOfUint16(ch)

	req := __.pool.GetWorkOfIntThenUint16()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfIntThenUint16(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfUint16(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfIntThenUint16 = func(ctx context.Context, arg int) (uint16, error)

type WorkerOfIntThenUint16 struct {
	api_syncer *ApiDecouplerOfIntThenUint16
	handler    WorkHandlerOfIntThenUint16

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfIntThenUint16
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfIntThenUint16(ctx context.Context, h WorkHandlerOfIntThenUint16, n int) *WorkerOfIntThenUint16 {
	__ := &WorkerOfIntThenUint16{
		api_syncer: NewApiDecouplerOfIntThenUint16(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfIntThenUint16, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfIntThenUint16{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfIntThenUint16(req.Context, req.WorkOfIntThenUint16, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfIntThenUint16) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfIntThenUint16) Push(ctx context.Context, req *WorkOfIntThenUint16) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfIntThenUint16)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfIntThenUint16 = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfIntThenUint16) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfIntThenUint16) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfIntThenUint16) Call(ctx context.Context, arg int) (uint16, error) {
	return __.api_syncer.DoOfIntThenUint16(ctx, __, arg)
}

type PoolOfIntThenUint32 interface {
	GetIntArg() *int
	PutIntArg(*int)
	GetUint32Return() *uint32
	PutUint32Return(*uint32)

	GetWorkOfIntThenUint32() *WorkOfIntThenUint32
	GetReturnOfUint32() *ReturnOfUint32
	PutWorkOfIntThenUint32(*WorkOfIntThenUint32)
	PutReturnOfUint32(*ReturnOfUint32)

	GetChReturnOfUint32() chan *ReturnOfUint32
	PutChReturnOfUint32(chan *ReturnOfUint32)
}

type PoolOfIntThenUint32Impl struct {
	IntArg           sync.Pool
	Uint32Rtn        sync.Pool
	IntWork          sync.Pool
	Uint32Return     sync.Pool
	ChReturnOfUint32 sync.Pool
}

func (__ *PoolOfIntThenUint32Impl) GetIntArg() *int {
	return __.IntArg.Get().(*int)
}
func (__ *PoolOfIntThenUint32Impl) PutIntArg(p *int) {
	__.IntArg.Put(p)
}
func (__ *PoolOfIntThenUint32Impl) GetUint32Return() *uint32 {
	return __.Uint32Rtn.Get().(*uint32)
}
func (__ *PoolOfIntThenUint32Impl) PutUint32Return(p *uint32) {
	__.Uint32Rtn.Put(p)
}

func (__ *PoolOfIntThenUint32Impl) GetWorkOfIntThenUint32() *WorkOfIntThenUint32 {
	return __.IntWork.Get().(*WorkOfIntThenUint32)
}
func (__ *PoolOfIntThenUint32Impl) PutWorkOfIntThenUint32(p *WorkOfIntThenUint32) {
	__.IntWork.Put(p)
}
func (__ *PoolOfIntThenUint32Impl) GetReturnOfUint32() *ReturnOfUint32 {
	return __.Uint32Return.Get().(*ReturnOfUint32)
}
func (__ *PoolOfIntThenUint32Impl) PutReturnOfUint32(p *ReturnOfUint32) {
	__.Uint32Return.Put(p)
}

func (__ *PoolOfIntThenUint32Impl) GetChReturnOfUint32() chan *ReturnOfUint32 {
	return __.ChReturnOfUint32.Get().(chan *ReturnOfUint32)
}
func (__ *PoolOfIntThenUint32Impl) PutChReturnOfUint32(p chan *ReturnOfUint32) {
	__.ChReturnOfUint32.Put(p)
}

func NewPoolOfIntThenUint32Impl() *PoolOfIntThenUint32Impl {
	return &PoolOfIntThenUint32Impl{
		IntArg: sync.Pool{
			New: func() interface{} {
				return new(int)
			},
		},
		IntWork: sync.Pool{
			New: func() interface{} {
				return new(WorkOfIntThenUint32)
			},
		},
		Uint32Rtn: sync.Pool{
			New: func() interface{} {
				return new(uint32)
			},
		},
		Uint32Return: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfUint32)
			},
		},
		ChReturnOfUint32: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfUint32, 1)
			},
		},
	}
}

type ApiDecouplerOfIntThenUint32 struct {
	pool PoolOfIntThenUint32
}

func NewApiDecouplerOfIntThenUint32() *ApiDecouplerOfIntThenUint32 {
	return &ApiDecouplerOfIntThenUint32{
		pool: NewPoolOfIntThenUint32Impl(),
	}
}

func (__ *ApiDecouplerOfIntThenUint32) ReturnError(rtn_ch chan<- *ReturnOfUint32, err error) {
	rtn := __.pool.GetReturnOfUint32()
	var other uint32
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfIntThenUint32) HandleOfIntThenUint32(ctx context.Context, req *WorkOfIntThenUint32, h func(ctx context.Context, arg int) (uint32, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfUint32()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfIntThenUint32) DoOfIntThenUint32(ctx context.Context, worker WorkerOfPushIntThenUint32, arg int) (uint32, error) {
	// ch := make(chan *ReturnOfUint32, 1)
	ch := __.pool.GetChReturnOfUint32()
	defer __.pool.PutChReturnOfUint32(ch)

	req := __.pool.GetWorkOfIntThenUint32()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfIntThenUint32(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfUint32(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfIntThenUint32 = func(ctx context.Context, arg int) (uint32, error)

type WorkerOfIntThenUint32 struct {
	api_syncer *ApiDecouplerOfIntThenUint32
	handler    WorkHandlerOfIntThenUint32

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfIntThenUint32
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfIntThenUint32(ctx context.Context, h WorkHandlerOfIntThenUint32, n int) *WorkerOfIntThenUint32 {
	__ := &WorkerOfIntThenUint32{
		api_syncer: NewApiDecouplerOfIntThenUint32(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfIntThenUint32, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfIntThenUint32{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfIntThenUint32(req.Context, req.WorkOfIntThenUint32, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfIntThenUint32) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfIntThenUint32) Push(ctx context.Context, req *WorkOfIntThenUint32) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfIntThenUint32)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfIntThenUint32 = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfIntThenUint32) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfIntThenUint32) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfIntThenUint32) Call(ctx context.Context, arg int) (uint32, error) {
	return __.api_syncer.DoOfIntThenUint32(ctx, __, arg)
}

type PoolOfIntThenUint64 interface {
	GetIntArg() *int
	PutIntArg(*int)
	GetUint64Return() *uint64
	PutUint64Return(*uint64)

	GetWorkOfIntThenUint64() *WorkOfIntThenUint64
	GetReturnOfUint64() *ReturnOfUint64
	PutWorkOfIntThenUint64(*WorkOfIntThenUint64)
	PutReturnOfUint64(*ReturnOfUint64)

	GetChReturnOfUint64() chan *ReturnOfUint64
	PutChReturnOfUint64(chan *ReturnOfUint64)
}

type PoolOfIntThenUint64Impl struct {
	IntArg           sync.Pool
	Uint64Rtn        sync.Pool
	IntWork          sync.Pool
	Uint64Return     sync.Pool
	ChReturnOfUint64 sync.Pool
}

func (__ *PoolOfIntThenUint64Impl) GetIntArg() *int {
	return __.IntArg.Get().(*int)
}
func (__ *PoolOfIntThenUint64Impl) PutIntArg(p *int) {
	__.IntArg.Put(p)
}
func (__ *PoolOfIntThenUint64Impl) GetUint64Return() *uint64 {
	return __.Uint64Rtn.Get().(*uint64)
}
func (__ *PoolOfIntThenUint64Impl) PutUint64Return(p *uint64) {
	__.Uint64Rtn.Put(p)
}

func (__ *PoolOfIntThenUint64Impl) GetWorkOfIntThenUint64() *WorkOfIntThenUint64 {
	return __.IntWork.Get().(*WorkOfIntThenUint64)
}
func (__ *PoolOfIntThenUint64Impl) PutWorkOfIntThenUint64(p *WorkOfIntThenUint64) {
	__.IntWork.Put(p)
}
func (__ *PoolOfIntThenUint64Impl) GetReturnOfUint64() *ReturnOfUint64 {
	return __.Uint64Return.Get().(*ReturnOfUint64)
}
func (__ *PoolOfIntThenUint64Impl) PutReturnOfUint64(p *ReturnOfUint64) {
	__.Uint64Return.Put(p)
}

func (__ *PoolOfIntThenUint64Impl) GetChReturnOfUint64() chan *ReturnOfUint64 {
	return __.ChReturnOfUint64.Get().(chan *ReturnOfUint64)
}
func (__ *PoolOfIntThenUint64Impl) PutChReturnOfUint64(p chan *ReturnOfUint64) {
	__.ChReturnOfUint64.Put(p)
}

func NewPoolOfIntThenUint64Impl() *PoolOfIntThenUint64Impl {
	return &PoolOfIntThenUint64Impl{
		IntArg: sync.Pool{
			New: func() interface{} {
				return new(int)
			},
		},
		IntWork: sync.Pool{
			New: func() interface{} {
				return new(WorkOfIntThenUint64)
			},
		},
		Uint64Rtn: sync.Pool{
			New: func() interface{} {
				return new(uint64)
			},
		},
		Uint64Return: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfUint64)
			},
		},
		ChReturnOfUint64: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfUint64, 1)
			},
		},
	}
}

type ApiDecouplerOfIntThenUint64 struct {
	pool PoolOfIntThenUint64
}

func NewApiDecouplerOfIntThenUint64() *ApiDecouplerOfIntThenUint64 {
	return &ApiDecouplerOfIntThenUint64{
		pool: NewPoolOfIntThenUint64Impl(),
	}
}

func (__ *ApiDecouplerOfIntThenUint64) ReturnError(rtn_ch chan<- *ReturnOfUint64, err error) {
	rtn := __.pool.GetReturnOfUint64()
	var other uint64
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfIntThenUint64) HandleOfIntThenUint64(ctx context.Context, req *WorkOfIntThenUint64, h func(ctx context.Context, arg int) (uint64, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfUint64()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfIntThenUint64) DoOfIntThenUint64(ctx context.Context, worker WorkerOfPushIntThenUint64, arg int) (uint64, error) {
	// ch := make(chan *ReturnOfUint64, 1)
	ch := __.pool.GetChReturnOfUint64()
	defer __.pool.PutChReturnOfUint64(ch)

	req := __.pool.GetWorkOfIntThenUint64()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfIntThenUint64(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfUint64(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfIntThenUint64 = func(ctx context.Context, arg int) (uint64, error)

type WorkerOfIntThenUint64 struct {
	api_syncer *ApiDecouplerOfIntThenUint64
	handler    WorkHandlerOfIntThenUint64

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfIntThenUint64
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfIntThenUint64(ctx context.Context, h WorkHandlerOfIntThenUint64, n int) *WorkerOfIntThenUint64 {
	__ := &WorkerOfIntThenUint64{
		api_syncer: NewApiDecouplerOfIntThenUint64(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfIntThenUint64, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfIntThenUint64{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfIntThenUint64(req.Context, req.WorkOfIntThenUint64, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfIntThenUint64) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfIntThenUint64) Push(ctx context.Context, req *WorkOfIntThenUint64) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfIntThenUint64)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfIntThenUint64 = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfIntThenUint64) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfIntThenUint64) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfIntThenUint64) Call(ctx context.Context, arg int) (uint64, error) {
	return __.api_syncer.DoOfIntThenUint64(ctx, __, arg)
}

type PoolOfIntThenUint8 interface {
	GetIntArg() *int
	PutIntArg(*int)
	GetUint8Return() *uint8
	PutUint8Return(*uint8)

	GetWorkOfIntThenUint8() *WorkOfIntThenUint8
	GetReturnOfUint8() *ReturnOfUint8
	PutWorkOfIntThenUint8(*WorkOfIntThenUint8)
	PutReturnOfUint8(*ReturnOfUint8)

	GetChReturnOfUint8() chan *ReturnOfUint8
	PutChReturnOfUint8(chan *ReturnOfUint8)
}

type PoolOfIntThenUint8Impl struct {
	IntArg          sync.Pool
	Uint8Rtn        sync.Pool
	IntWork         sync.Pool
	Uint8Return     sync.Pool
	ChReturnOfUint8 sync.Pool
}

func (__ *PoolOfIntThenUint8Impl) GetIntArg() *int {
	return __.IntArg.Get().(*int)
}
func (__ *PoolOfIntThenUint8Impl) PutIntArg(p *int) {
	__.IntArg.Put(p)
}
func (__ *PoolOfIntThenUint8Impl) GetUint8Return() *uint8 {
	return __.Uint8Rtn.Get().(*uint8)
}
func (__ *PoolOfIntThenUint8Impl) PutUint8Return(p *uint8) {
	__.Uint8Rtn.Put(p)
}

func (__ *PoolOfIntThenUint8Impl) GetWorkOfIntThenUint8() *WorkOfIntThenUint8 {
	return __.IntWork.Get().(*WorkOfIntThenUint8)
}
func (__ *PoolOfIntThenUint8Impl) PutWorkOfIntThenUint8(p *WorkOfIntThenUint8) {
	__.IntWork.Put(p)
}
func (__ *PoolOfIntThenUint8Impl) GetReturnOfUint8() *ReturnOfUint8 {
	return __.Uint8Return.Get().(*ReturnOfUint8)
}
func (__ *PoolOfIntThenUint8Impl) PutReturnOfUint8(p *ReturnOfUint8) {
	__.Uint8Return.Put(p)
}

func (__ *PoolOfIntThenUint8Impl) GetChReturnOfUint8() chan *ReturnOfUint8 {
	return __.ChReturnOfUint8.Get().(chan *ReturnOfUint8)
}
func (__ *PoolOfIntThenUint8Impl) PutChReturnOfUint8(p chan *ReturnOfUint8) {
	__.ChReturnOfUint8.Put(p)
}

func NewPoolOfIntThenUint8Impl() *PoolOfIntThenUint8Impl {
	return &PoolOfIntThenUint8Impl{
		IntArg: sync.Pool{
			New: func() interface{} {
				return new(int)
			},
		},
		IntWork: sync.Pool{
			New: func() interface{} {
				return new(WorkOfIntThenUint8)
			},
		},
		Uint8Rtn: sync.Pool{
			New: func() interface{} {
				return new(uint8)
			},
		},
		Uint8Return: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfUint8)
			},
		},
		ChReturnOfUint8: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfUint8, 1)
			},
		},
	}
}

type ApiDecouplerOfIntThenUint8 struct {
	pool PoolOfIntThenUint8
}

func NewApiDecouplerOfIntThenUint8() *ApiDecouplerOfIntThenUint8 {
	return &ApiDecouplerOfIntThenUint8{
		pool: NewPoolOfIntThenUint8Impl(),
	}
}

func (__ *ApiDecouplerOfIntThenUint8) ReturnError(rtn_ch chan<- *ReturnOfUint8, err error) {
	rtn := __.pool.GetReturnOfUint8()
	var other uint8
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfIntThenUint8) HandleOfIntThenUint8(ctx context.Context, req *WorkOfIntThenUint8, h func(ctx context.Context, arg int) (uint8, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfUint8()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfIntThenUint8) DoOfIntThenUint8(ctx context.Context, worker WorkerOfPushIntThenUint8, arg int) (uint8, error) {
	// ch := make(chan *ReturnOfUint8, 1)
	ch := __.pool.GetChReturnOfUint8()
	defer __.pool.PutChReturnOfUint8(ch)

	req := __.pool.GetWorkOfIntThenUint8()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfIntThenUint8(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfUint8(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfIntThenUint8 = func(ctx context.Context, arg int) (uint8, error)

type WorkerOfIntThenUint8 struct {
	api_syncer *ApiDecouplerOfIntThenUint8
	handler    WorkHandlerOfIntThenUint8

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfIntThenUint8
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfIntThenUint8(ctx context.Context, h WorkHandlerOfIntThenUint8, n int) *WorkerOfIntThenUint8 {
	__ := &WorkerOfIntThenUint8{
		api_syncer: NewApiDecouplerOfIntThenUint8(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfIntThenUint8, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfIntThenUint8{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfIntThenUint8(req.Context, req.WorkOfIntThenUint8, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfIntThenUint8) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfIntThenUint8) Push(ctx context.Context, req *WorkOfIntThenUint8) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfIntThenUint8)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfIntThenUint8 = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfIntThenUint8) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfIntThenUint8) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfIntThenUint8) Call(ctx context.Context, arg int) (uint8, error) {
	return __.api_syncer.DoOfIntThenUint8(ctx, __, arg)
}

type PoolOfIntThenUintptr interface {
	GetIntArg() *int
	PutIntArg(*int)
	GetUintptrReturn() *uintptr
	PutUintptrReturn(*uintptr)

	GetWorkOfIntThenUintptr() *WorkOfIntThenUintptr
	GetReturnOfUintptr() *ReturnOfUintptr
	PutWorkOfIntThenUintptr(*WorkOfIntThenUintptr)
	PutReturnOfUintptr(*ReturnOfUintptr)

	GetChReturnOfUintptr() chan *ReturnOfUintptr
	PutChReturnOfUintptr(chan *ReturnOfUintptr)
}

type PoolOfIntThenUintptrImpl struct {
	IntArg            sync.Pool
	UintptrRtn        sync.Pool
	IntWork           sync.Pool
	UintptrReturn     sync.Pool
	ChReturnOfUintptr sync.Pool
}

func (__ *PoolOfIntThenUintptrImpl) GetIntArg() *int {
	return __.IntArg.Get().(*int)
}
func (__ *PoolOfIntThenUintptrImpl) PutIntArg(p *int) {
	__.IntArg.Put(p)
}
func (__ *PoolOfIntThenUintptrImpl) GetUintptrReturn() *uintptr {
	return __.UintptrRtn.Get().(*uintptr)
}
func (__ *PoolOfIntThenUintptrImpl) PutUintptrReturn(p *uintptr) {
	__.UintptrRtn.Put(p)
}

func (__ *PoolOfIntThenUintptrImpl) GetWorkOfIntThenUintptr() *WorkOfIntThenUintptr {
	return __.IntWork.Get().(*WorkOfIntThenUintptr)
}
func (__ *PoolOfIntThenUintptrImpl) PutWorkOfIntThenUintptr(p *WorkOfIntThenUintptr) {
	__.IntWork.Put(p)
}
func (__ *PoolOfIntThenUintptrImpl) GetReturnOfUintptr() *ReturnOfUintptr {
	return __.UintptrReturn.Get().(*ReturnOfUintptr)
}
func (__ *PoolOfIntThenUintptrImpl) PutReturnOfUintptr(p *ReturnOfUintptr) {
	__.UintptrReturn.Put(p)
}

func (__ *PoolOfIntThenUintptrImpl) GetChReturnOfUintptr() chan *ReturnOfUintptr {
	return __.ChReturnOfUintptr.Get().(chan *ReturnOfUintptr)
}
func (__ *PoolOfIntThenUintptrImpl) PutChReturnOfUintptr(p chan *ReturnOfUintptr) {
	__.ChReturnOfUintptr.Put(p)
}

func NewPoolOfIntThenUintptrImpl() *PoolOfIntThenUintptrImpl {
	return &PoolOfIntThenUintptrImpl{
		IntArg: sync.Pool{
			New: func() interface{} {
				return new(int)
			},
		},
		IntWork: sync.Pool{
			New: func() interface{} {
				return new(WorkOfIntThenUintptr)
			},
		},
		UintptrRtn: sync.Pool{
			New: func() interface{} {
				return new(uintptr)
			},
		},
		UintptrReturn: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfUintptr)
			},
		},
		ChReturnOfUintptr: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfUintptr, 1)
			},
		},
	}
}

type ApiDecouplerOfIntThenUintptr struct {
	pool PoolOfIntThenUintptr
}

func NewApiDecouplerOfIntThenUintptr() *ApiDecouplerOfIntThenUintptr {
	return &ApiDecouplerOfIntThenUintptr{
		pool: NewPoolOfIntThenUintptrImpl(),
	}
}

func (__ *ApiDecouplerOfIntThenUintptr) ReturnError(rtn_ch chan<- *ReturnOfUintptr, err error) {
	rtn := __.pool.GetReturnOfUintptr()
	var other uintptr
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfIntThenUintptr) HandleOfIntThenUintptr(ctx context.Context, req *WorkOfIntThenUintptr, h func(ctx context.Context, arg int) (uintptr, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfUintptr()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfIntThenUintptr) DoOfIntThenUintptr(ctx context.Context, worker WorkerOfPushIntThenUintptr, arg int) (uintptr, error) {
	// ch := make(chan *ReturnOfUintptr, 1)
	ch := __.pool.GetChReturnOfUintptr()
	defer __.pool.PutChReturnOfUintptr(ch)

	req := __.pool.GetWorkOfIntThenUintptr()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfIntThenUintptr(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfUintptr(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfIntThenUintptr = func(ctx context.Context, arg int) (uintptr, error)

type WorkerOfIntThenUintptr struct {
	api_syncer *ApiDecouplerOfIntThenUintptr
	handler    WorkHandlerOfIntThenUintptr

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfIntThenUintptr
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfIntThenUintptr(ctx context.Context, h WorkHandlerOfIntThenUintptr, n int) *WorkerOfIntThenUintptr {
	__ := &WorkerOfIntThenUintptr{
		api_syncer: NewApiDecouplerOfIntThenUintptr(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfIntThenUintptr, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfIntThenUintptr{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfIntThenUintptr(req.Context, req.WorkOfIntThenUintptr, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfIntThenUintptr) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfIntThenUintptr) Push(ctx context.Context, req *WorkOfIntThenUintptr) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfIntThenUintptr)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfIntThenUintptr = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfIntThenUintptr) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfIntThenUintptr) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfIntThenUintptr) Call(ctx context.Context, arg int) (uintptr, error) {
	return __.api_syncer.DoOfIntThenUintptr(ctx, __, arg)
}

type PoolOfIntThenInterface interface {
	GetIntArg() *int
	PutIntArg(*int)
	GetInterfaceReturn() *interface{}
	PutInterfaceReturn(*interface{})

	GetWorkOfIntThenInterface() *WorkOfIntThenInterface
	GetReturnOfInterface() *ReturnOfInterface
	PutWorkOfIntThenInterface(*WorkOfIntThenInterface)
	PutReturnOfInterface(*ReturnOfInterface)

	GetChReturnOfInterface() chan *ReturnOfInterface
	PutChReturnOfInterface(chan *ReturnOfInterface)
}

type PoolOfIntThenInterfaceImpl struct {
	IntArg              sync.Pool
	InterfaceRtn        sync.Pool
	IntWork             sync.Pool
	InterfaceReturn     sync.Pool
	ChReturnOfInterface sync.Pool
}

func (__ *PoolOfIntThenInterfaceImpl) GetIntArg() *int {
	return __.IntArg.Get().(*int)
}
func (__ *PoolOfIntThenInterfaceImpl) PutIntArg(p *int) {
	__.IntArg.Put(p)
}
func (__ *PoolOfIntThenInterfaceImpl) GetInterfaceReturn() *interface{} {
	return __.InterfaceRtn.Get().(*interface{})
}
func (__ *PoolOfIntThenInterfaceImpl) PutInterfaceReturn(p *interface{}) {
	__.InterfaceRtn.Put(p)
}

func (__ *PoolOfIntThenInterfaceImpl) GetWorkOfIntThenInterface() *WorkOfIntThenInterface {
	return __.IntWork.Get().(*WorkOfIntThenInterface)
}
func (__ *PoolOfIntThenInterfaceImpl) PutWorkOfIntThenInterface(p *WorkOfIntThenInterface) {
	__.IntWork.Put(p)
}
func (__ *PoolOfIntThenInterfaceImpl) GetReturnOfInterface() *ReturnOfInterface {
	return __.InterfaceReturn.Get().(*ReturnOfInterface)
}
func (__ *PoolOfIntThenInterfaceImpl) PutReturnOfInterface(p *ReturnOfInterface) {
	__.InterfaceReturn.Put(p)
}

func (__ *PoolOfIntThenInterfaceImpl) GetChReturnOfInterface() chan *ReturnOfInterface {
	return __.ChReturnOfInterface.Get().(chan *ReturnOfInterface)
}
func (__ *PoolOfIntThenInterfaceImpl) PutChReturnOfInterface(p chan *ReturnOfInterface) {
	__.ChReturnOfInterface.Put(p)
}

func NewPoolOfIntThenInterfaceImpl() *PoolOfIntThenInterfaceImpl {
	return &PoolOfIntThenInterfaceImpl{
		IntArg: sync.Pool{
			New: func() interface{} {
				return new(int)
			},
		},
		IntWork: sync.Pool{
			New: func() interface{} {
				return new(WorkOfIntThenInterface)
			},
		},
		InterfaceRtn: sync.Pool{
			New: func() interface{} {
				return new(interface{})
			},
		},
		InterfaceReturn: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfInterface)
			},
		},
		ChReturnOfInterface: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfInterface, 1)
			},
		},
	}
}

type ApiDecouplerOfIntThenInterface struct {
	pool PoolOfIntThenInterface
}

func NewApiDecouplerOfIntThenInterface() *ApiDecouplerOfIntThenInterface {
	return &ApiDecouplerOfIntThenInterface{
		pool: NewPoolOfIntThenInterfaceImpl(),
	}
}

func (__ *ApiDecouplerOfIntThenInterface) ReturnError(rtn_ch chan<- *ReturnOfInterface, err error) {
	rtn := __.pool.GetReturnOfInterface()
	var other interface{}
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfIntThenInterface) HandleOfIntThenInterface(ctx context.Context, req *WorkOfIntThenInterface, h func(ctx context.Context, arg int) (interface{}, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfInterface()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfIntThenInterface) DoOfIntThenInterface(ctx context.Context, worker WorkerOfPushIntThenInterface, arg int) (interface{}, error) {
	// ch := make(chan *ReturnOfInterface, 1)
	ch := __.pool.GetChReturnOfInterface()
	defer __.pool.PutChReturnOfInterface(ch)

	req := __.pool.GetWorkOfIntThenInterface()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfIntThenInterface(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfInterface(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfIntThenInterface = func(ctx context.Context, arg int) (interface{}, error)

type WorkerOfIntThenInterface struct {
	api_syncer *ApiDecouplerOfIntThenInterface
	handler    WorkHandlerOfIntThenInterface

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfIntThenInterface
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfIntThenInterface(ctx context.Context, h WorkHandlerOfIntThenInterface, n int) *WorkerOfIntThenInterface {
	__ := &WorkerOfIntThenInterface{
		api_syncer: NewApiDecouplerOfIntThenInterface(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfIntThenInterface, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfIntThenInterface{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfIntThenInterface(req.Context, req.WorkOfIntThenInterface, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfIntThenInterface) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfIntThenInterface) Push(ctx context.Context, req *WorkOfIntThenInterface) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfIntThenInterface)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfIntThenInterface = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfIntThenInterface) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfIntThenInterface) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfIntThenInterface) Call(ctx context.Context, arg int) (interface{}, error) {
	return __.api_syncer.DoOfIntThenInterface(ctx, __, arg)
}

type PoolOfIntThenStruct interface {
	GetIntArg() *int
	PutIntArg(*int)
	GetStructReturn() *struct{}
	PutStructReturn(*struct{})

	GetWorkOfIntThenStruct() *WorkOfIntThenStruct
	GetReturnOfStruct() *ReturnOfStruct
	PutWorkOfIntThenStruct(*WorkOfIntThenStruct)
	PutReturnOfStruct(*ReturnOfStruct)

	GetChReturnOfStruct() chan *ReturnOfStruct
	PutChReturnOfStruct(chan *ReturnOfStruct)
}

type PoolOfIntThenStructImpl struct {
	IntArg           sync.Pool
	StructRtn        sync.Pool
	IntWork          sync.Pool
	StructReturn     sync.Pool
	ChReturnOfStruct sync.Pool
}

func (__ *PoolOfIntThenStructImpl) GetIntArg() *int {
	return __.IntArg.Get().(*int)
}
func (__ *PoolOfIntThenStructImpl) PutIntArg(p *int) {
	__.IntArg.Put(p)
}
func (__ *PoolOfIntThenStructImpl) GetStructReturn() *struct{} {
	return __.StructRtn.Get().(*struct{})
}
func (__ *PoolOfIntThenStructImpl) PutStructReturn(p *struct{}) {
	__.StructRtn.Put(p)
}

func (__ *PoolOfIntThenStructImpl) GetWorkOfIntThenStruct() *WorkOfIntThenStruct {
	return __.IntWork.Get().(*WorkOfIntThenStruct)
}
func (__ *PoolOfIntThenStructImpl) PutWorkOfIntThenStruct(p *WorkOfIntThenStruct) {
	__.IntWork.Put(p)
}
func (__ *PoolOfIntThenStructImpl) GetReturnOfStruct() *ReturnOfStruct {
	return __.StructReturn.Get().(*ReturnOfStruct)
}
func (__ *PoolOfIntThenStructImpl) PutReturnOfStruct(p *ReturnOfStruct) {
	__.StructReturn.Put(p)
}

func (__ *PoolOfIntThenStructImpl) GetChReturnOfStruct() chan *ReturnOfStruct {
	return __.ChReturnOfStruct.Get().(chan *ReturnOfStruct)
}
func (__ *PoolOfIntThenStructImpl) PutChReturnOfStruct(p chan *ReturnOfStruct) {
	__.ChReturnOfStruct.Put(p)
}

func NewPoolOfIntThenStructImpl() *PoolOfIntThenStructImpl {
	return &PoolOfIntThenStructImpl{
		IntArg: sync.Pool{
			New: func() interface{} {
				return new(int)
			},
		},
		IntWork: sync.Pool{
			New: func() interface{} {
				return new(WorkOfIntThenStruct)
			},
		},
		StructRtn: sync.Pool{
			New: func() interface{} {
				return new(struct{})
			},
		},
		StructReturn: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfStruct)
			},
		},
		ChReturnOfStruct: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfStruct, 1)
			},
		},
	}
}

type ApiDecouplerOfIntThenStruct struct {
	pool PoolOfIntThenStruct
}

func NewApiDecouplerOfIntThenStruct() *ApiDecouplerOfIntThenStruct {
	return &ApiDecouplerOfIntThenStruct{
		pool: NewPoolOfIntThenStructImpl(),
	}
}

func (__ *ApiDecouplerOfIntThenStruct) ReturnError(rtn_ch chan<- *ReturnOfStruct, err error) {
	rtn := __.pool.GetReturnOfStruct()
	var other struct{}
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfIntThenStruct) HandleOfIntThenStruct(ctx context.Context, req *WorkOfIntThenStruct, h func(ctx context.Context, arg int) (struct{}, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfStruct()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfIntThenStruct) DoOfIntThenStruct(ctx context.Context, worker WorkerOfPushIntThenStruct, arg int) (struct{}, error) {
	// ch := make(chan *ReturnOfStruct, 1)
	ch := __.pool.GetChReturnOfStruct()
	defer __.pool.PutChReturnOfStruct(ch)

	req := __.pool.GetWorkOfIntThenStruct()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfIntThenStruct(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfStruct(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfIntThenStruct = func(ctx context.Context, arg int) (struct{}, error)

type WorkerOfIntThenStruct struct {
	api_syncer *ApiDecouplerOfIntThenStruct
	handler    WorkHandlerOfIntThenStruct

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfIntThenStruct
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfIntThenStruct(ctx context.Context, h WorkHandlerOfIntThenStruct, n int) *WorkerOfIntThenStruct {
	__ := &WorkerOfIntThenStruct{
		api_syncer: NewApiDecouplerOfIntThenStruct(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfIntThenStruct, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfIntThenStruct{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfIntThenStruct(req.Context, req.WorkOfIntThenStruct, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfIntThenStruct) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfIntThenStruct) Push(ctx context.Context, req *WorkOfIntThenStruct) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfIntThenStruct)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfIntThenStruct = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfIntThenStruct) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfIntThenStruct) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfIntThenStruct) Call(ctx context.Context, arg int) (struct{}, error) {
	return __.api_syncer.DoOfIntThenStruct(ctx, __, arg)
}

type PoolOfInt16ThenBool interface {
	GetInt16Arg() *int16
	PutInt16Arg(*int16)
	GetBoolReturn() *bool
	PutBoolReturn(*bool)

	GetWorkOfInt16ThenBool() *WorkOfInt16ThenBool
	GetReturnOfBool() *ReturnOfBool
	PutWorkOfInt16ThenBool(*WorkOfInt16ThenBool)
	PutReturnOfBool(*ReturnOfBool)

	GetChReturnOfBool() chan *ReturnOfBool
	PutChReturnOfBool(chan *ReturnOfBool)
}

type PoolOfInt16ThenBoolImpl struct {
	Int16Arg       sync.Pool
	BoolRtn        sync.Pool
	Int16Work      sync.Pool
	BoolReturn     sync.Pool
	ChReturnOfBool sync.Pool
}

func (__ *PoolOfInt16ThenBoolImpl) GetInt16Arg() *int16 {
	return __.Int16Arg.Get().(*int16)
}
func (__ *PoolOfInt16ThenBoolImpl) PutInt16Arg(p *int16) {
	__.Int16Arg.Put(p)
}
func (__ *PoolOfInt16ThenBoolImpl) GetBoolReturn() *bool {
	return __.BoolRtn.Get().(*bool)
}
func (__ *PoolOfInt16ThenBoolImpl) PutBoolReturn(p *bool) {
	__.BoolRtn.Put(p)
}

func (__ *PoolOfInt16ThenBoolImpl) GetWorkOfInt16ThenBool() *WorkOfInt16ThenBool {
	return __.Int16Work.Get().(*WorkOfInt16ThenBool)
}
func (__ *PoolOfInt16ThenBoolImpl) PutWorkOfInt16ThenBool(p *WorkOfInt16ThenBool) {
	__.Int16Work.Put(p)
}
func (__ *PoolOfInt16ThenBoolImpl) GetReturnOfBool() *ReturnOfBool {
	return __.BoolReturn.Get().(*ReturnOfBool)
}
func (__ *PoolOfInt16ThenBoolImpl) PutReturnOfBool(p *ReturnOfBool) {
	__.BoolReturn.Put(p)
}

func (__ *PoolOfInt16ThenBoolImpl) GetChReturnOfBool() chan *ReturnOfBool {
	return __.ChReturnOfBool.Get().(chan *ReturnOfBool)
}
func (__ *PoolOfInt16ThenBoolImpl) PutChReturnOfBool(p chan *ReturnOfBool) {
	__.ChReturnOfBool.Put(p)
}

func NewPoolOfInt16ThenBoolImpl() *PoolOfInt16ThenBoolImpl {
	return &PoolOfInt16ThenBoolImpl{
		Int16Arg: sync.Pool{
			New: func() interface{} {
				return new(int16)
			},
		},
		Int16Work: sync.Pool{
			New: func() interface{} {
				return new(WorkOfInt16ThenBool)
			},
		},
		BoolRtn: sync.Pool{
			New: func() interface{} {
				return new(bool)
			},
		},
		BoolReturn: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfBool)
			},
		},
		ChReturnOfBool: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfBool, 1)
			},
		},
	}
}

type ApiDecouplerOfInt16ThenBool struct {
	pool PoolOfInt16ThenBool
}

func NewApiDecouplerOfInt16ThenBool() *ApiDecouplerOfInt16ThenBool {
	return &ApiDecouplerOfInt16ThenBool{
		pool: NewPoolOfInt16ThenBoolImpl(),
	}
}

func (__ *ApiDecouplerOfInt16ThenBool) ReturnError(rtn_ch chan<- *ReturnOfBool, err error) {
	rtn := __.pool.GetReturnOfBool()
	var other bool
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfInt16ThenBool) HandleOfInt16ThenBool(ctx context.Context, req *WorkOfInt16ThenBool, h func(ctx context.Context, arg int16) (bool, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfBool()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfInt16ThenBool) DoOfInt16ThenBool(ctx context.Context, worker WorkerOfPushInt16ThenBool, arg int16) (bool, error) {
	// ch := make(chan *ReturnOfBool, 1)
	ch := __.pool.GetChReturnOfBool()
	defer __.pool.PutChReturnOfBool(ch)

	req := __.pool.GetWorkOfInt16ThenBool()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfInt16ThenBool(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfBool(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfInt16ThenBool = func(ctx context.Context, arg int16) (bool, error)

type WorkerOfInt16ThenBool struct {
	api_syncer *ApiDecouplerOfInt16ThenBool
	handler    WorkHandlerOfInt16ThenBool

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfInt16ThenBool
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfInt16ThenBool(ctx context.Context, h WorkHandlerOfInt16ThenBool, n int) *WorkerOfInt16ThenBool {
	__ := &WorkerOfInt16ThenBool{
		api_syncer: NewApiDecouplerOfInt16ThenBool(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfInt16ThenBool, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfInt16ThenBool{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfInt16ThenBool(req.Context, req.WorkOfInt16ThenBool, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfInt16ThenBool) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfInt16ThenBool) Push(ctx context.Context, req *WorkOfInt16ThenBool) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfInt16ThenBool)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfInt16ThenBool = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfInt16ThenBool) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfInt16ThenBool) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfInt16ThenBool) Call(ctx context.Context, arg int16) (bool, error) {
	return __.api_syncer.DoOfInt16ThenBool(ctx, __, arg)
}

type PoolOfInt16ThenByte interface {
	GetInt16Arg() *int16
	PutInt16Arg(*int16)
	GetByteReturn() *byte
	PutByteReturn(*byte)

	GetWorkOfInt16ThenByte() *WorkOfInt16ThenByte
	GetReturnOfByte() *ReturnOfByte
	PutWorkOfInt16ThenByte(*WorkOfInt16ThenByte)
	PutReturnOfByte(*ReturnOfByte)

	GetChReturnOfByte() chan *ReturnOfByte
	PutChReturnOfByte(chan *ReturnOfByte)
}

type PoolOfInt16ThenByteImpl struct {
	Int16Arg       sync.Pool
	ByteRtn        sync.Pool
	Int16Work      sync.Pool
	ByteReturn     sync.Pool
	ChReturnOfByte sync.Pool
}

func (__ *PoolOfInt16ThenByteImpl) GetInt16Arg() *int16 {
	return __.Int16Arg.Get().(*int16)
}
func (__ *PoolOfInt16ThenByteImpl) PutInt16Arg(p *int16) {
	__.Int16Arg.Put(p)
}
func (__ *PoolOfInt16ThenByteImpl) GetByteReturn() *byte {
	return __.ByteRtn.Get().(*byte)
}
func (__ *PoolOfInt16ThenByteImpl) PutByteReturn(p *byte) {
	__.ByteRtn.Put(p)
}

func (__ *PoolOfInt16ThenByteImpl) GetWorkOfInt16ThenByte() *WorkOfInt16ThenByte {
	return __.Int16Work.Get().(*WorkOfInt16ThenByte)
}
func (__ *PoolOfInt16ThenByteImpl) PutWorkOfInt16ThenByte(p *WorkOfInt16ThenByte) {
	__.Int16Work.Put(p)
}
func (__ *PoolOfInt16ThenByteImpl) GetReturnOfByte() *ReturnOfByte {
	return __.ByteReturn.Get().(*ReturnOfByte)
}
func (__ *PoolOfInt16ThenByteImpl) PutReturnOfByte(p *ReturnOfByte) {
	__.ByteReturn.Put(p)
}

func (__ *PoolOfInt16ThenByteImpl) GetChReturnOfByte() chan *ReturnOfByte {
	return __.ChReturnOfByte.Get().(chan *ReturnOfByte)
}
func (__ *PoolOfInt16ThenByteImpl) PutChReturnOfByte(p chan *ReturnOfByte) {
	__.ChReturnOfByte.Put(p)
}

func NewPoolOfInt16ThenByteImpl() *PoolOfInt16ThenByteImpl {
	return &PoolOfInt16ThenByteImpl{
		Int16Arg: sync.Pool{
			New: func() interface{} {
				return new(int16)
			},
		},
		Int16Work: sync.Pool{
			New: func() interface{} {
				return new(WorkOfInt16ThenByte)
			},
		},
		ByteRtn: sync.Pool{
			New: func() interface{} {
				return new(byte)
			},
		},
		ByteReturn: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfByte)
			},
		},
		ChReturnOfByte: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfByte, 1)
			},
		},
	}
}

type ApiDecouplerOfInt16ThenByte struct {
	pool PoolOfInt16ThenByte
}

func NewApiDecouplerOfInt16ThenByte() *ApiDecouplerOfInt16ThenByte {
	return &ApiDecouplerOfInt16ThenByte{
		pool: NewPoolOfInt16ThenByteImpl(),
	}
}

func (__ *ApiDecouplerOfInt16ThenByte) ReturnError(rtn_ch chan<- *ReturnOfByte, err error) {
	rtn := __.pool.GetReturnOfByte()
	var other byte
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfInt16ThenByte) HandleOfInt16ThenByte(ctx context.Context, req *WorkOfInt16ThenByte, h func(ctx context.Context, arg int16) (byte, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfByte()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfInt16ThenByte) DoOfInt16ThenByte(ctx context.Context, worker WorkerOfPushInt16ThenByte, arg int16) (byte, error) {
	// ch := make(chan *ReturnOfByte, 1)
	ch := __.pool.GetChReturnOfByte()
	defer __.pool.PutChReturnOfByte(ch)

	req := __.pool.GetWorkOfInt16ThenByte()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfInt16ThenByte(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfByte(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfInt16ThenByte = func(ctx context.Context, arg int16) (byte, error)

type WorkerOfInt16ThenByte struct {
	api_syncer *ApiDecouplerOfInt16ThenByte
	handler    WorkHandlerOfInt16ThenByte

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfInt16ThenByte
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfInt16ThenByte(ctx context.Context, h WorkHandlerOfInt16ThenByte, n int) *WorkerOfInt16ThenByte {
	__ := &WorkerOfInt16ThenByte{
		api_syncer: NewApiDecouplerOfInt16ThenByte(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfInt16ThenByte, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfInt16ThenByte{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfInt16ThenByte(req.Context, req.WorkOfInt16ThenByte, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfInt16ThenByte) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfInt16ThenByte) Push(ctx context.Context, req *WorkOfInt16ThenByte) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfInt16ThenByte)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfInt16ThenByte = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfInt16ThenByte) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfInt16ThenByte) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfInt16ThenByte) Call(ctx context.Context, arg int16) (byte, error) {
	return __.api_syncer.DoOfInt16ThenByte(ctx, __, arg)
}

type PoolOfInt16ThenComplex128 interface {
	GetInt16Arg() *int16
	PutInt16Arg(*int16)
	GetComplex128Return() *complex128
	PutComplex128Return(*complex128)

	GetWorkOfInt16ThenComplex128() *WorkOfInt16ThenComplex128
	GetReturnOfComplex128() *ReturnOfComplex128
	PutWorkOfInt16ThenComplex128(*WorkOfInt16ThenComplex128)
	PutReturnOfComplex128(*ReturnOfComplex128)

	GetChReturnOfComplex128() chan *ReturnOfComplex128
	PutChReturnOfComplex128(chan *ReturnOfComplex128)
}

type PoolOfInt16ThenComplex128Impl struct {
	Int16Arg             sync.Pool
	Complex128Rtn        sync.Pool
	Int16Work            sync.Pool
	Complex128Return     sync.Pool
	ChReturnOfComplex128 sync.Pool
}

func (__ *PoolOfInt16ThenComplex128Impl) GetInt16Arg() *int16 {
	return __.Int16Arg.Get().(*int16)
}
func (__ *PoolOfInt16ThenComplex128Impl) PutInt16Arg(p *int16) {
	__.Int16Arg.Put(p)
}
func (__ *PoolOfInt16ThenComplex128Impl) GetComplex128Return() *complex128 {
	return __.Complex128Rtn.Get().(*complex128)
}
func (__ *PoolOfInt16ThenComplex128Impl) PutComplex128Return(p *complex128) {
	__.Complex128Rtn.Put(p)
}

func (__ *PoolOfInt16ThenComplex128Impl) GetWorkOfInt16ThenComplex128() *WorkOfInt16ThenComplex128 {
	return __.Int16Work.Get().(*WorkOfInt16ThenComplex128)
}
func (__ *PoolOfInt16ThenComplex128Impl) PutWorkOfInt16ThenComplex128(p *WorkOfInt16ThenComplex128) {
	__.Int16Work.Put(p)
}
func (__ *PoolOfInt16ThenComplex128Impl) GetReturnOfComplex128() *ReturnOfComplex128 {
	return __.Complex128Return.Get().(*ReturnOfComplex128)
}
func (__ *PoolOfInt16ThenComplex128Impl) PutReturnOfComplex128(p *ReturnOfComplex128) {
	__.Complex128Return.Put(p)
}

func (__ *PoolOfInt16ThenComplex128Impl) GetChReturnOfComplex128() chan *ReturnOfComplex128 {
	return __.ChReturnOfComplex128.Get().(chan *ReturnOfComplex128)
}
func (__ *PoolOfInt16ThenComplex128Impl) PutChReturnOfComplex128(p chan *ReturnOfComplex128) {
	__.ChReturnOfComplex128.Put(p)
}

func NewPoolOfInt16ThenComplex128Impl() *PoolOfInt16ThenComplex128Impl {
	return &PoolOfInt16ThenComplex128Impl{
		Int16Arg: sync.Pool{
			New: func() interface{} {
				return new(int16)
			},
		},
		Int16Work: sync.Pool{
			New: func() interface{} {
				return new(WorkOfInt16ThenComplex128)
			},
		},
		Complex128Rtn: sync.Pool{
			New: func() interface{} {
				return new(complex128)
			},
		},
		Complex128Return: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfComplex128)
			},
		},
		ChReturnOfComplex128: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfComplex128, 1)
			},
		},
	}
}

type ApiDecouplerOfInt16ThenComplex128 struct {
	pool PoolOfInt16ThenComplex128
}

func NewApiDecouplerOfInt16ThenComplex128() *ApiDecouplerOfInt16ThenComplex128 {
	return &ApiDecouplerOfInt16ThenComplex128{
		pool: NewPoolOfInt16ThenComplex128Impl(),
	}
}

func (__ *ApiDecouplerOfInt16ThenComplex128) ReturnError(rtn_ch chan<- *ReturnOfComplex128, err error) {
	rtn := __.pool.GetReturnOfComplex128()
	var other complex128
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfInt16ThenComplex128) HandleOfInt16ThenComplex128(ctx context.Context, req *WorkOfInt16ThenComplex128, h func(ctx context.Context, arg int16) (complex128, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfComplex128()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfInt16ThenComplex128) DoOfInt16ThenComplex128(ctx context.Context, worker WorkerOfPushInt16ThenComplex128, arg int16) (complex128, error) {
	// ch := make(chan *ReturnOfComplex128, 1)
	ch := __.pool.GetChReturnOfComplex128()
	defer __.pool.PutChReturnOfComplex128(ch)

	req := __.pool.GetWorkOfInt16ThenComplex128()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfInt16ThenComplex128(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfComplex128(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfInt16ThenComplex128 = func(ctx context.Context, arg int16) (complex128, error)

type WorkerOfInt16ThenComplex128 struct {
	api_syncer *ApiDecouplerOfInt16ThenComplex128
	handler    WorkHandlerOfInt16ThenComplex128

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfInt16ThenComplex128
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfInt16ThenComplex128(ctx context.Context, h WorkHandlerOfInt16ThenComplex128, n int) *WorkerOfInt16ThenComplex128 {
	__ := &WorkerOfInt16ThenComplex128{
		api_syncer: NewApiDecouplerOfInt16ThenComplex128(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfInt16ThenComplex128, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfInt16ThenComplex128{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfInt16ThenComplex128(req.Context, req.WorkOfInt16ThenComplex128, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfInt16ThenComplex128) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfInt16ThenComplex128) Push(ctx context.Context, req *WorkOfInt16ThenComplex128) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfInt16ThenComplex128)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfInt16ThenComplex128 = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfInt16ThenComplex128) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfInt16ThenComplex128) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfInt16ThenComplex128) Call(ctx context.Context, arg int16) (complex128, error) {
	return __.api_syncer.DoOfInt16ThenComplex128(ctx, __, arg)
}

type PoolOfInt16ThenComplex64 interface {
	GetInt16Arg() *int16
	PutInt16Arg(*int16)
	GetComplex64Return() *complex64
	PutComplex64Return(*complex64)

	GetWorkOfInt16ThenComplex64() *WorkOfInt16ThenComplex64
	GetReturnOfComplex64() *ReturnOfComplex64
	PutWorkOfInt16ThenComplex64(*WorkOfInt16ThenComplex64)
	PutReturnOfComplex64(*ReturnOfComplex64)

	GetChReturnOfComplex64() chan *ReturnOfComplex64
	PutChReturnOfComplex64(chan *ReturnOfComplex64)
}

type PoolOfInt16ThenComplex64Impl struct {
	Int16Arg            sync.Pool
	Complex64Rtn        sync.Pool
	Int16Work           sync.Pool
	Complex64Return     sync.Pool
	ChReturnOfComplex64 sync.Pool
}

func (__ *PoolOfInt16ThenComplex64Impl) GetInt16Arg() *int16 {
	return __.Int16Arg.Get().(*int16)
}
func (__ *PoolOfInt16ThenComplex64Impl) PutInt16Arg(p *int16) {
	__.Int16Arg.Put(p)
}
func (__ *PoolOfInt16ThenComplex64Impl) GetComplex64Return() *complex64 {
	return __.Complex64Rtn.Get().(*complex64)
}
func (__ *PoolOfInt16ThenComplex64Impl) PutComplex64Return(p *complex64) {
	__.Complex64Rtn.Put(p)
}

func (__ *PoolOfInt16ThenComplex64Impl) GetWorkOfInt16ThenComplex64() *WorkOfInt16ThenComplex64 {
	return __.Int16Work.Get().(*WorkOfInt16ThenComplex64)
}
func (__ *PoolOfInt16ThenComplex64Impl) PutWorkOfInt16ThenComplex64(p *WorkOfInt16ThenComplex64) {
	__.Int16Work.Put(p)
}
func (__ *PoolOfInt16ThenComplex64Impl) GetReturnOfComplex64() *ReturnOfComplex64 {
	return __.Complex64Return.Get().(*ReturnOfComplex64)
}
func (__ *PoolOfInt16ThenComplex64Impl) PutReturnOfComplex64(p *ReturnOfComplex64) {
	__.Complex64Return.Put(p)
}

func (__ *PoolOfInt16ThenComplex64Impl) GetChReturnOfComplex64() chan *ReturnOfComplex64 {
	return __.ChReturnOfComplex64.Get().(chan *ReturnOfComplex64)
}
func (__ *PoolOfInt16ThenComplex64Impl) PutChReturnOfComplex64(p chan *ReturnOfComplex64) {
	__.ChReturnOfComplex64.Put(p)
}

func NewPoolOfInt16ThenComplex64Impl() *PoolOfInt16ThenComplex64Impl {
	return &PoolOfInt16ThenComplex64Impl{
		Int16Arg: sync.Pool{
			New: func() interface{} {
				return new(int16)
			},
		},
		Int16Work: sync.Pool{
			New: func() interface{} {
				return new(WorkOfInt16ThenComplex64)
			},
		},
		Complex64Rtn: sync.Pool{
			New: func() interface{} {
				return new(complex64)
			},
		},
		Complex64Return: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfComplex64)
			},
		},
		ChReturnOfComplex64: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfComplex64, 1)
			},
		},
	}
}

type ApiDecouplerOfInt16ThenComplex64 struct {
	pool PoolOfInt16ThenComplex64
}

func NewApiDecouplerOfInt16ThenComplex64() *ApiDecouplerOfInt16ThenComplex64 {
	return &ApiDecouplerOfInt16ThenComplex64{
		pool: NewPoolOfInt16ThenComplex64Impl(),
	}
}

func (__ *ApiDecouplerOfInt16ThenComplex64) ReturnError(rtn_ch chan<- *ReturnOfComplex64, err error) {
	rtn := __.pool.GetReturnOfComplex64()
	var other complex64
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfInt16ThenComplex64) HandleOfInt16ThenComplex64(ctx context.Context, req *WorkOfInt16ThenComplex64, h func(ctx context.Context, arg int16) (complex64, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfComplex64()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfInt16ThenComplex64) DoOfInt16ThenComplex64(ctx context.Context, worker WorkerOfPushInt16ThenComplex64, arg int16) (complex64, error) {
	// ch := make(chan *ReturnOfComplex64, 1)
	ch := __.pool.GetChReturnOfComplex64()
	defer __.pool.PutChReturnOfComplex64(ch)

	req := __.pool.GetWorkOfInt16ThenComplex64()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfInt16ThenComplex64(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfComplex64(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfInt16ThenComplex64 = func(ctx context.Context, arg int16) (complex64, error)

type WorkerOfInt16ThenComplex64 struct {
	api_syncer *ApiDecouplerOfInt16ThenComplex64
	handler    WorkHandlerOfInt16ThenComplex64

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfInt16ThenComplex64
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfInt16ThenComplex64(ctx context.Context, h WorkHandlerOfInt16ThenComplex64, n int) *WorkerOfInt16ThenComplex64 {
	__ := &WorkerOfInt16ThenComplex64{
		api_syncer: NewApiDecouplerOfInt16ThenComplex64(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfInt16ThenComplex64, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfInt16ThenComplex64{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfInt16ThenComplex64(req.Context, req.WorkOfInt16ThenComplex64, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfInt16ThenComplex64) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfInt16ThenComplex64) Push(ctx context.Context, req *WorkOfInt16ThenComplex64) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfInt16ThenComplex64)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfInt16ThenComplex64 = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfInt16ThenComplex64) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfInt16ThenComplex64) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfInt16ThenComplex64) Call(ctx context.Context, arg int16) (complex64, error) {
	return __.api_syncer.DoOfInt16ThenComplex64(ctx, __, arg)
}

type PoolOfInt16ThenError interface {
	GetInt16Arg() *int16
	PutInt16Arg(*int16)
	GetErrorReturn() *error
	PutErrorReturn(*error)

	GetWorkOfInt16ThenError() *WorkOfInt16ThenError
	GetReturnOfError() *ReturnOfError
	PutWorkOfInt16ThenError(*WorkOfInt16ThenError)
	PutReturnOfError(*ReturnOfError)

	GetChReturnOfError() chan *ReturnOfError
	PutChReturnOfError(chan *ReturnOfError)
}

type PoolOfInt16ThenErrorImpl struct {
	Int16Arg        sync.Pool
	ErrorRtn        sync.Pool
	Int16Work       sync.Pool
	ErrorReturn     sync.Pool
	ChReturnOfError sync.Pool
}

func (__ *PoolOfInt16ThenErrorImpl) GetInt16Arg() *int16 {
	return __.Int16Arg.Get().(*int16)
}
func (__ *PoolOfInt16ThenErrorImpl) PutInt16Arg(p *int16) {
	__.Int16Arg.Put(p)
}
func (__ *PoolOfInt16ThenErrorImpl) GetErrorReturn() *error {
	return __.ErrorRtn.Get().(*error)
}
func (__ *PoolOfInt16ThenErrorImpl) PutErrorReturn(p *error) {
	__.ErrorRtn.Put(p)
}

func (__ *PoolOfInt16ThenErrorImpl) GetWorkOfInt16ThenError() *WorkOfInt16ThenError {
	return __.Int16Work.Get().(*WorkOfInt16ThenError)
}
func (__ *PoolOfInt16ThenErrorImpl) PutWorkOfInt16ThenError(p *WorkOfInt16ThenError) {
	__.Int16Work.Put(p)
}
func (__ *PoolOfInt16ThenErrorImpl) GetReturnOfError() *ReturnOfError {
	return __.ErrorReturn.Get().(*ReturnOfError)
}
func (__ *PoolOfInt16ThenErrorImpl) PutReturnOfError(p *ReturnOfError) {
	__.ErrorReturn.Put(p)
}

func (__ *PoolOfInt16ThenErrorImpl) GetChReturnOfError() chan *ReturnOfError {
	return __.ChReturnOfError.Get().(chan *ReturnOfError)
}
func (__ *PoolOfInt16ThenErrorImpl) PutChReturnOfError(p chan *ReturnOfError) {
	__.ChReturnOfError.Put(p)
}

func NewPoolOfInt16ThenErrorImpl() *PoolOfInt16ThenErrorImpl {
	return &PoolOfInt16ThenErrorImpl{
		Int16Arg: sync.Pool{
			New: func() interface{} {
				return new(int16)
			},
		},
		Int16Work: sync.Pool{
			New: func() interface{} {
				return new(WorkOfInt16ThenError)
			},
		},
		ErrorRtn: sync.Pool{
			New: func() interface{} {
				return new(error)
			},
		},
		ErrorReturn: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfError)
			},
		},
		ChReturnOfError: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfError, 1)
			},
		},
	}
}

type ApiDecouplerOfInt16ThenError struct {
	pool PoolOfInt16ThenError
}

func NewApiDecouplerOfInt16ThenError() *ApiDecouplerOfInt16ThenError {
	return &ApiDecouplerOfInt16ThenError{
		pool: NewPoolOfInt16ThenErrorImpl(),
	}
}

func (__ *ApiDecouplerOfInt16ThenError) ReturnError(rtn_ch chan<- *ReturnOfError, err error) {
	rtn := __.pool.GetReturnOfError()
	var other error
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfInt16ThenError) HandleOfInt16ThenError(ctx context.Context, req *WorkOfInt16ThenError, h func(ctx context.Context, arg int16) (error, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfError()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfInt16ThenError) DoOfInt16ThenError(ctx context.Context, worker WorkerOfPushInt16ThenError, arg int16) (error, error) {
	// ch := make(chan *ReturnOfError, 1)
	ch := __.pool.GetChReturnOfError()
	defer __.pool.PutChReturnOfError(ch)

	req := __.pool.GetWorkOfInt16ThenError()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfInt16ThenError(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfError(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfInt16ThenError = func(ctx context.Context, arg int16) (error, error)

type WorkerOfInt16ThenError struct {
	api_syncer *ApiDecouplerOfInt16ThenError
	handler    WorkHandlerOfInt16ThenError

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfInt16ThenError
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfInt16ThenError(ctx context.Context, h WorkHandlerOfInt16ThenError, n int) *WorkerOfInt16ThenError {
	__ := &WorkerOfInt16ThenError{
		api_syncer: NewApiDecouplerOfInt16ThenError(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfInt16ThenError, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfInt16ThenError{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfInt16ThenError(req.Context, req.WorkOfInt16ThenError, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfInt16ThenError) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfInt16ThenError) Push(ctx context.Context, req *WorkOfInt16ThenError) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfInt16ThenError)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfInt16ThenError = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfInt16ThenError) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfInt16ThenError) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfInt16ThenError) Call(ctx context.Context, arg int16) (error, error) {
	return __.api_syncer.DoOfInt16ThenError(ctx, __, arg)
}

type PoolOfInt16ThenFloat32 interface {
	GetInt16Arg() *int16
	PutInt16Arg(*int16)
	GetFloat32Return() *float32
	PutFloat32Return(*float32)

	GetWorkOfInt16ThenFloat32() *WorkOfInt16ThenFloat32
	GetReturnOfFloat32() *ReturnOfFloat32
	PutWorkOfInt16ThenFloat32(*WorkOfInt16ThenFloat32)
	PutReturnOfFloat32(*ReturnOfFloat32)

	GetChReturnOfFloat32() chan *ReturnOfFloat32
	PutChReturnOfFloat32(chan *ReturnOfFloat32)
}

type PoolOfInt16ThenFloat32Impl struct {
	Int16Arg          sync.Pool
	Float32Rtn        sync.Pool
	Int16Work         sync.Pool
	Float32Return     sync.Pool
	ChReturnOfFloat32 sync.Pool
}

func (__ *PoolOfInt16ThenFloat32Impl) GetInt16Arg() *int16 {
	return __.Int16Arg.Get().(*int16)
}
func (__ *PoolOfInt16ThenFloat32Impl) PutInt16Arg(p *int16) {
	__.Int16Arg.Put(p)
}
func (__ *PoolOfInt16ThenFloat32Impl) GetFloat32Return() *float32 {
	return __.Float32Rtn.Get().(*float32)
}
func (__ *PoolOfInt16ThenFloat32Impl) PutFloat32Return(p *float32) {
	__.Float32Rtn.Put(p)
}

func (__ *PoolOfInt16ThenFloat32Impl) GetWorkOfInt16ThenFloat32() *WorkOfInt16ThenFloat32 {
	return __.Int16Work.Get().(*WorkOfInt16ThenFloat32)
}
func (__ *PoolOfInt16ThenFloat32Impl) PutWorkOfInt16ThenFloat32(p *WorkOfInt16ThenFloat32) {
	__.Int16Work.Put(p)
}
func (__ *PoolOfInt16ThenFloat32Impl) GetReturnOfFloat32() *ReturnOfFloat32 {
	return __.Float32Return.Get().(*ReturnOfFloat32)
}
func (__ *PoolOfInt16ThenFloat32Impl) PutReturnOfFloat32(p *ReturnOfFloat32) {
	__.Float32Return.Put(p)
}

func (__ *PoolOfInt16ThenFloat32Impl) GetChReturnOfFloat32() chan *ReturnOfFloat32 {
	return __.ChReturnOfFloat32.Get().(chan *ReturnOfFloat32)
}
func (__ *PoolOfInt16ThenFloat32Impl) PutChReturnOfFloat32(p chan *ReturnOfFloat32) {
	__.ChReturnOfFloat32.Put(p)
}

func NewPoolOfInt16ThenFloat32Impl() *PoolOfInt16ThenFloat32Impl {
	return &PoolOfInt16ThenFloat32Impl{
		Int16Arg: sync.Pool{
			New: func() interface{} {
				return new(int16)
			},
		},
		Int16Work: sync.Pool{
			New: func() interface{} {
				return new(WorkOfInt16ThenFloat32)
			},
		},
		Float32Rtn: sync.Pool{
			New: func() interface{} {
				return new(float32)
			},
		},
		Float32Return: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfFloat32)
			},
		},
		ChReturnOfFloat32: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfFloat32, 1)
			},
		},
	}
}

type ApiDecouplerOfInt16ThenFloat32 struct {
	pool PoolOfInt16ThenFloat32
}

func NewApiDecouplerOfInt16ThenFloat32() *ApiDecouplerOfInt16ThenFloat32 {
	return &ApiDecouplerOfInt16ThenFloat32{
		pool: NewPoolOfInt16ThenFloat32Impl(),
	}
}

func (__ *ApiDecouplerOfInt16ThenFloat32) ReturnError(rtn_ch chan<- *ReturnOfFloat32, err error) {
	rtn := __.pool.GetReturnOfFloat32()
	var other float32
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfInt16ThenFloat32) HandleOfInt16ThenFloat32(ctx context.Context, req *WorkOfInt16ThenFloat32, h func(ctx context.Context, arg int16) (float32, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfFloat32()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfInt16ThenFloat32) DoOfInt16ThenFloat32(ctx context.Context, worker WorkerOfPushInt16ThenFloat32, arg int16) (float32, error) {
	// ch := make(chan *ReturnOfFloat32, 1)
	ch := __.pool.GetChReturnOfFloat32()
	defer __.pool.PutChReturnOfFloat32(ch)

	req := __.pool.GetWorkOfInt16ThenFloat32()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfInt16ThenFloat32(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfFloat32(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfInt16ThenFloat32 = func(ctx context.Context, arg int16) (float32, error)

type WorkerOfInt16ThenFloat32 struct {
	api_syncer *ApiDecouplerOfInt16ThenFloat32
	handler    WorkHandlerOfInt16ThenFloat32

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfInt16ThenFloat32
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfInt16ThenFloat32(ctx context.Context, h WorkHandlerOfInt16ThenFloat32, n int) *WorkerOfInt16ThenFloat32 {
	__ := &WorkerOfInt16ThenFloat32{
		api_syncer: NewApiDecouplerOfInt16ThenFloat32(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfInt16ThenFloat32, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfInt16ThenFloat32{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfInt16ThenFloat32(req.Context, req.WorkOfInt16ThenFloat32, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfInt16ThenFloat32) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfInt16ThenFloat32) Push(ctx context.Context, req *WorkOfInt16ThenFloat32) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfInt16ThenFloat32)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfInt16ThenFloat32 = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfInt16ThenFloat32) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfInt16ThenFloat32) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfInt16ThenFloat32) Call(ctx context.Context, arg int16) (float32, error) {
	return __.api_syncer.DoOfInt16ThenFloat32(ctx, __, arg)
}

type PoolOfInt16ThenFloat64 interface {
	GetInt16Arg() *int16
	PutInt16Arg(*int16)
	GetFloat64Return() *float64
	PutFloat64Return(*float64)

	GetWorkOfInt16ThenFloat64() *WorkOfInt16ThenFloat64
	GetReturnOfFloat64() *ReturnOfFloat64
	PutWorkOfInt16ThenFloat64(*WorkOfInt16ThenFloat64)
	PutReturnOfFloat64(*ReturnOfFloat64)

	GetChReturnOfFloat64() chan *ReturnOfFloat64
	PutChReturnOfFloat64(chan *ReturnOfFloat64)
}

type PoolOfInt16ThenFloat64Impl struct {
	Int16Arg          sync.Pool
	Float64Rtn        sync.Pool
	Int16Work         sync.Pool
	Float64Return     sync.Pool
	ChReturnOfFloat64 sync.Pool
}

func (__ *PoolOfInt16ThenFloat64Impl) GetInt16Arg() *int16 {
	return __.Int16Arg.Get().(*int16)
}
func (__ *PoolOfInt16ThenFloat64Impl) PutInt16Arg(p *int16) {
	__.Int16Arg.Put(p)
}
func (__ *PoolOfInt16ThenFloat64Impl) GetFloat64Return() *float64 {
	return __.Float64Rtn.Get().(*float64)
}
func (__ *PoolOfInt16ThenFloat64Impl) PutFloat64Return(p *float64) {
	__.Float64Rtn.Put(p)
}

func (__ *PoolOfInt16ThenFloat64Impl) GetWorkOfInt16ThenFloat64() *WorkOfInt16ThenFloat64 {
	return __.Int16Work.Get().(*WorkOfInt16ThenFloat64)
}
func (__ *PoolOfInt16ThenFloat64Impl) PutWorkOfInt16ThenFloat64(p *WorkOfInt16ThenFloat64) {
	__.Int16Work.Put(p)
}
func (__ *PoolOfInt16ThenFloat64Impl) GetReturnOfFloat64() *ReturnOfFloat64 {
	return __.Float64Return.Get().(*ReturnOfFloat64)
}
func (__ *PoolOfInt16ThenFloat64Impl) PutReturnOfFloat64(p *ReturnOfFloat64) {
	__.Float64Return.Put(p)
}

func (__ *PoolOfInt16ThenFloat64Impl) GetChReturnOfFloat64() chan *ReturnOfFloat64 {
	return __.ChReturnOfFloat64.Get().(chan *ReturnOfFloat64)
}
func (__ *PoolOfInt16ThenFloat64Impl) PutChReturnOfFloat64(p chan *ReturnOfFloat64) {
	__.ChReturnOfFloat64.Put(p)
}

func NewPoolOfInt16ThenFloat64Impl() *PoolOfInt16ThenFloat64Impl {
	return &PoolOfInt16ThenFloat64Impl{
		Int16Arg: sync.Pool{
			New: func() interface{} {
				return new(int16)
			},
		},
		Int16Work: sync.Pool{
			New: func() interface{} {
				return new(WorkOfInt16ThenFloat64)
			},
		},
		Float64Rtn: sync.Pool{
			New: func() interface{} {
				return new(float64)
			},
		},
		Float64Return: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfFloat64)
			},
		},
		ChReturnOfFloat64: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfFloat64, 1)
			},
		},
	}
}

type ApiDecouplerOfInt16ThenFloat64 struct {
	pool PoolOfInt16ThenFloat64
}

func NewApiDecouplerOfInt16ThenFloat64() *ApiDecouplerOfInt16ThenFloat64 {
	return &ApiDecouplerOfInt16ThenFloat64{
		pool: NewPoolOfInt16ThenFloat64Impl(),
	}
}

func (__ *ApiDecouplerOfInt16ThenFloat64) ReturnError(rtn_ch chan<- *ReturnOfFloat64, err error) {
	rtn := __.pool.GetReturnOfFloat64()
	var other float64
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfInt16ThenFloat64) HandleOfInt16ThenFloat64(ctx context.Context, req *WorkOfInt16ThenFloat64, h func(ctx context.Context, arg int16) (float64, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfFloat64()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfInt16ThenFloat64) DoOfInt16ThenFloat64(ctx context.Context, worker WorkerOfPushInt16ThenFloat64, arg int16) (float64, error) {
	// ch := make(chan *ReturnOfFloat64, 1)
	ch := __.pool.GetChReturnOfFloat64()
	defer __.pool.PutChReturnOfFloat64(ch)

	req := __.pool.GetWorkOfInt16ThenFloat64()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfInt16ThenFloat64(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfFloat64(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfInt16ThenFloat64 = func(ctx context.Context, arg int16) (float64, error)

type WorkerOfInt16ThenFloat64 struct {
	api_syncer *ApiDecouplerOfInt16ThenFloat64
	handler    WorkHandlerOfInt16ThenFloat64

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfInt16ThenFloat64
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfInt16ThenFloat64(ctx context.Context, h WorkHandlerOfInt16ThenFloat64, n int) *WorkerOfInt16ThenFloat64 {
	__ := &WorkerOfInt16ThenFloat64{
		api_syncer: NewApiDecouplerOfInt16ThenFloat64(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfInt16ThenFloat64, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfInt16ThenFloat64{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfInt16ThenFloat64(req.Context, req.WorkOfInt16ThenFloat64, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfInt16ThenFloat64) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfInt16ThenFloat64) Push(ctx context.Context, req *WorkOfInt16ThenFloat64) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfInt16ThenFloat64)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfInt16ThenFloat64 = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfInt16ThenFloat64) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfInt16ThenFloat64) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfInt16ThenFloat64) Call(ctx context.Context, arg int16) (float64, error) {
	return __.api_syncer.DoOfInt16ThenFloat64(ctx, __, arg)
}

type PoolOfInt16ThenInt interface {
	GetInt16Arg() *int16
	PutInt16Arg(*int16)
	GetIntReturn() *int
	PutIntReturn(*int)

	GetWorkOfInt16ThenInt() *WorkOfInt16ThenInt
	GetReturnOfInt() *ReturnOfInt
	PutWorkOfInt16ThenInt(*WorkOfInt16ThenInt)
	PutReturnOfInt(*ReturnOfInt)

	GetChReturnOfInt() chan *ReturnOfInt
	PutChReturnOfInt(chan *ReturnOfInt)
}

type PoolOfInt16ThenIntImpl struct {
	Int16Arg      sync.Pool
	IntRtn        sync.Pool
	Int16Work     sync.Pool
	IntReturn     sync.Pool
	ChReturnOfInt sync.Pool
}

func (__ *PoolOfInt16ThenIntImpl) GetInt16Arg() *int16 {
	return __.Int16Arg.Get().(*int16)
}
func (__ *PoolOfInt16ThenIntImpl) PutInt16Arg(p *int16) {
	__.Int16Arg.Put(p)
}
func (__ *PoolOfInt16ThenIntImpl) GetIntReturn() *int {
	return __.IntRtn.Get().(*int)
}
func (__ *PoolOfInt16ThenIntImpl) PutIntReturn(p *int) {
	__.IntRtn.Put(p)
}

func (__ *PoolOfInt16ThenIntImpl) GetWorkOfInt16ThenInt() *WorkOfInt16ThenInt {
	return __.Int16Work.Get().(*WorkOfInt16ThenInt)
}
func (__ *PoolOfInt16ThenIntImpl) PutWorkOfInt16ThenInt(p *WorkOfInt16ThenInt) {
	__.Int16Work.Put(p)
}
func (__ *PoolOfInt16ThenIntImpl) GetReturnOfInt() *ReturnOfInt {
	return __.IntReturn.Get().(*ReturnOfInt)
}
func (__ *PoolOfInt16ThenIntImpl) PutReturnOfInt(p *ReturnOfInt) {
	__.IntReturn.Put(p)
}

func (__ *PoolOfInt16ThenIntImpl) GetChReturnOfInt() chan *ReturnOfInt {
	return __.ChReturnOfInt.Get().(chan *ReturnOfInt)
}
func (__ *PoolOfInt16ThenIntImpl) PutChReturnOfInt(p chan *ReturnOfInt) {
	__.ChReturnOfInt.Put(p)
}

func NewPoolOfInt16ThenIntImpl() *PoolOfInt16ThenIntImpl {
	return &PoolOfInt16ThenIntImpl{
		Int16Arg: sync.Pool{
			New: func() interface{} {
				return new(int16)
			},
		},
		Int16Work: sync.Pool{
			New: func() interface{} {
				return new(WorkOfInt16ThenInt)
			},
		},
		IntRtn: sync.Pool{
			New: func() interface{} {
				return new(int)
			},
		},
		IntReturn: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfInt)
			},
		},
		ChReturnOfInt: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfInt, 1)
			},
		},
	}
}

type ApiDecouplerOfInt16ThenInt struct {
	pool PoolOfInt16ThenInt
}

func NewApiDecouplerOfInt16ThenInt() *ApiDecouplerOfInt16ThenInt {
	return &ApiDecouplerOfInt16ThenInt{
		pool: NewPoolOfInt16ThenIntImpl(),
	}
}

func (__ *ApiDecouplerOfInt16ThenInt) ReturnError(rtn_ch chan<- *ReturnOfInt, err error) {
	rtn := __.pool.GetReturnOfInt()
	var other int
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfInt16ThenInt) HandleOfInt16ThenInt(ctx context.Context, req *WorkOfInt16ThenInt, h func(ctx context.Context, arg int16) (int, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfInt()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfInt16ThenInt) DoOfInt16ThenInt(ctx context.Context, worker WorkerOfPushInt16ThenInt, arg int16) (int, error) {
	// ch := make(chan *ReturnOfInt, 1)
	ch := __.pool.GetChReturnOfInt()
	defer __.pool.PutChReturnOfInt(ch)

	req := __.pool.GetWorkOfInt16ThenInt()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfInt16ThenInt(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfInt(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfInt16ThenInt = func(ctx context.Context, arg int16) (int, error)

type WorkerOfInt16ThenInt struct {
	api_syncer *ApiDecouplerOfInt16ThenInt
	handler    WorkHandlerOfInt16ThenInt

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfInt16ThenInt
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfInt16ThenInt(ctx context.Context, h WorkHandlerOfInt16ThenInt, n int) *WorkerOfInt16ThenInt {
	__ := &WorkerOfInt16ThenInt{
		api_syncer: NewApiDecouplerOfInt16ThenInt(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfInt16ThenInt, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfInt16ThenInt{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfInt16ThenInt(req.Context, req.WorkOfInt16ThenInt, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfInt16ThenInt) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfInt16ThenInt) Push(ctx context.Context, req *WorkOfInt16ThenInt) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfInt16ThenInt)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfInt16ThenInt = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfInt16ThenInt) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfInt16ThenInt) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfInt16ThenInt) Call(ctx context.Context, arg int16) (int, error) {
	return __.api_syncer.DoOfInt16ThenInt(ctx, __, arg)
}

type PoolOfInt16ThenInt16 interface {
	GetInt16Arg() *int16
	PutInt16Arg(*int16)
	GetInt16Return() *int16
	PutInt16Return(*int16)

	GetWorkOfInt16ThenInt16() *WorkOfInt16ThenInt16
	GetReturnOfInt16() *ReturnOfInt16
	PutWorkOfInt16ThenInt16(*WorkOfInt16ThenInt16)
	PutReturnOfInt16(*ReturnOfInt16)

	GetChReturnOfInt16() chan *ReturnOfInt16
	PutChReturnOfInt16(chan *ReturnOfInt16)
}

type PoolOfInt16ThenInt16Impl struct {
	Int16Arg        sync.Pool
	Int16Rtn        sync.Pool
	Int16Work       sync.Pool
	Int16Return     sync.Pool
	ChReturnOfInt16 sync.Pool
}

func (__ *PoolOfInt16ThenInt16Impl) GetInt16Arg() *int16 {
	return __.Int16Arg.Get().(*int16)
}
func (__ *PoolOfInt16ThenInt16Impl) PutInt16Arg(p *int16) {
	__.Int16Arg.Put(p)
}
func (__ *PoolOfInt16ThenInt16Impl) GetInt16Return() *int16 {
	return __.Int16Rtn.Get().(*int16)
}
func (__ *PoolOfInt16ThenInt16Impl) PutInt16Return(p *int16) {
	__.Int16Rtn.Put(p)
}

func (__ *PoolOfInt16ThenInt16Impl) GetWorkOfInt16ThenInt16() *WorkOfInt16ThenInt16 {
	return __.Int16Work.Get().(*WorkOfInt16ThenInt16)
}
func (__ *PoolOfInt16ThenInt16Impl) PutWorkOfInt16ThenInt16(p *WorkOfInt16ThenInt16) {
	__.Int16Work.Put(p)
}
func (__ *PoolOfInt16ThenInt16Impl) GetReturnOfInt16() *ReturnOfInt16 {
	return __.Int16Return.Get().(*ReturnOfInt16)
}
func (__ *PoolOfInt16ThenInt16Impl) PutReturnOfInt16(p *ReturnOfInt16) {
	__.Int16Return.Put(p)
}

func (__ *PoolOfInt16ThenInt16Impl) GetChReturnOfInt16() chan *ReturnOfInt16 {
	return __.ChReturnOfInt16.Get().(chan *ReturnOfInt16)
}
func (__ *PoolOfInt16ThenInt16Impl) PutChReturnOfInt16(p chan *ReturnOfInt16) {
	__.ChReturnOfInt16.Put(p)
}

func NewPoolOfInt16ThenInt16Impl() *PoolOfInt16ThenInt16Impl {
	return &PoolOfInt16ThenInt16Impl{
		Int16Arg: sync.Pool{
			New: func() interface{} {
				return new(int16)
			},
		},
		Int16Work: sync.Pool{
			New: func() interface{} {
				return new(WorkOfInt16ThenInt16)
			},
		},
		Int16Rtn: sync.Pool{
			New: func() interface{} {
				return new(int16)
			},
		},
		Int16Return: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfInt16)
			},
		},
		ChReturnOfInt16: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfInt16, 1)
			},
		},
	}
}

type ApiDecouplerOfInt16ThenInt16 struct {
	pool PoolOfInt16ThenInt16
}

func NewApiDecouplerOfInt16ThenInt16() *ApiDecouplerOfInt16ThenInt16 {
	return &ApiDecouplerOfInt16ThenInt16{
		pool: NewPoolOfInt16ThenInt16Impl(),
	}
}

func (__ *ApiDecouplerOfInt16ThenInt16) ReturnError(rtn_ch chan<- *ReturnOfInt16, err error) {
	rtn := __.pool.GetReturnOfInt16()
	var other int16
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfInt16ThenInt16) HandleOfInt16ThenInt16(ctx context.Context, req *WorkOfInt16ThenInt16, h func(ctx context.Context, arg int16) (int16, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfInt16()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfInt16ThenInt16) DoOfInt16ThenInt16(ctx context.Context, worker WorkerOfPushInt16ThenInt16, arg int16) (int16, error) {
	// ch := make(chan *ReturnOfInt16, 1)
	ch := __.pool.GetChReturnOfInt16()
	defer __.pool.PutChReturnOfInt16(ch)

	req := __.pool.GetWorkOfInt16ThenInt16()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfInt16ThenInt16(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfInt16(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfInt16ThenInt16 = func(ctx context.Context, arg int16) (int16, error)

type WorkerOfInt16ThenInt16 struct {
	api_syncer *ApiDecouplerOfInt16ThenInt16
	handler    WorkHandlerOfInt16ThenInt16

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfInt16ThenInt16
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfInt16ThenInt16(ctx context.Context, h WorkHandlerOfInt16ThenInt16, n int) *WorkerOfInt16ThenInt16 {
	__ := &WorkerOfInt16ThenInt16{
		api_syncer: NewApiDecouplerOfInt16ThenInt16(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfInt16ThenInt16, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfInt16ThenInt16{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfInt16ThenInt16(req.Context, req.WorkOfInt16ThenInt16, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfInt16ThenInt16) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfInt16ThenInt16) Push(ctx context.Context, req *WorkOfInt16ThenInt16) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfInt16ThenInt16)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfInt16ThenInt16 = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfInt16ThenInt16) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfInt16ThenInt16) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfInt16ThenInt16) Call(ctx context.Context, arg int16) (int16, error) {
	return __.api_syncer.DoOfInt16ThenInt16(ctx, __, arg)
}

type PoolOfInt16ThenInt32 interface {
	GetInt16Arg() *int16
	PutInt16Arg(*int16)
	GetInt32Return() *int32
	PutInt32Return(*int32)

	GetWorkOfInt16ThenInt32() *WorkOfInt16ThenInt32
	GetReturnOfInt32() *ReturnOfInt32
	PutWorkOfInt16ThenInt32(*WorkOfInt16ThenInt32)
	PutReturnOfInt32(*ReturnOfInt32)

	GetChReturnOfInt32() chan *ReturnOfInt32
	PutChReturnOfInt32(chan *ReturnOfInt32)
}

type PoolOfInt16ThenInt32Impl struct {
	Int16Arg        sync.Pool
	Int32Rtn        sync.Pool
	Int16Work       sync.Pool
	Int32Return     sync.Pool
	ChReturnOfInt32 sync.Pool
}

func (__ *PoolOfInt16ThenInt32Impl) GetInt16Arg() *int16 {
	return __.Int16Arg.Get().(*int16)
}
func (__ *PoolOfInt16ThenInt32Impl) PutInt16Arg(p *int16) {
	__.Int16Arg.Put(p)
}
func (__ *PoolOfInt16ThenInt32Impl) GetInt32Return() *int32 {
	return __.Int32Rtn.Get().(*int32)
}
func (__ *PoolOfInt16ThenInt32Impl) PutInt32Return(p *int32) {
	__.Int32Rtn.Put(p)
}

func (__ *PoolOfInt16ThenInt32Impl) GetWorkOfInt16ThenInt32() *WorkOfInt16ThenInt32 {
	return __.Int16Work.Get().(*WorkOfInt16ThenInt32)
}
func (__ *PoolOfInt16ThenInt32Impl) PutWorkOfInt16ThenInt32(p *WorkOfInt16ThenInt32) {
	__.Int16Work.Put(p)
}
func (__ *PoolOfInt16ThenInt32Impl) GetReturnOfInt32() *ReturnOfInt32 {
	return __.Int32Return.Get().(*ReturnOfInt32)
}
func (__ *PoolOfInt16ThenInt32Impl) PutReturnOfInt32(p *ReturnOfInt32) {
	__.Int32Return.Put(p)
}

func (__ *PoolOfInt16ThenInt32Impl) GetChReturnOfInt32() chan *ReturnOfInt32 {
	return __.ChReturnOfInt32.Get().(chan *ReturnOfInt32)
}
func (__ *PoolOfInt16ThenInt32Impl) PutChReturnOfInt32(p chan *ReturnOfInt32) {
	__.ChReturnOfInt32.Put(p)
}

func NewPoolOfInt16ThenInt32Impl() *PoolOfInt16ThenInt32Impl {
	return &PoolOfInt16ThenInt32Impl{
		Int16Arg: sync.Pool{
			New: func() interface{} {
				return new(int16)
			},
		},
		Int16Work: sync.Pool{
			New: func() interface{} {
				return new(WorkOfInt16ThenInt32)
			},
		},
		Int32Rtn: sync.Pool{
			New: func() interface{} {
				return new(int32)
			},
		},
		Int32Return: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfInt32)
			},
		},
		ChReturnOfInt32: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfInt32, 1)
			},
		},
	}
}

type ApiDecouplerOfInt16ThenInt32 struct {
	pool PoolOfInt16ThenInt32
}

func NewApiDecouplerOfInt16ThenInt32() *ApiDecouplerOfInt16ThenInt32 {
	return &ApiDecouplerOfInt16ThenInt32{
		pool: NewPoolOfInt16ThenInt32Impl(),
	}
}

func (__ *ApiDecouplerOfInt16ThenInt32) ReturnError(rtn_ch chan<- *ReturnOfInt32, err error) {
	rtn := __.pool.GetReturnOfInt32()
	var other int32
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfInt16ThenInt32) HandleOfInt16ThenInt32(ctx context.Context, req *WorkOfInt16ThenInt32, h func(ctx context.Context, arg int16) (int32, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfInt32()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfInt16ThenInt32) DoOfInt16ThenInt32(ctx context.Context, worker WorkerOfPushInt16ThenInt32, arg int16) (int32, error) {
	// ch := make(chan *ReturnOfInt32, 1)
	ch := __.pool.GetChReturnOfInt32()
	defer __.pool.PutChReturnOfInt32(ch)

	req := __.pool.GetWorkOfInt16ThenInt32()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfInt16ThenInt32(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfInt32(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfInt16ThenInt32 = func(ctx context.Context, arg int16) (int32, error)

type WorkerOfInt16ThenInt32 struct {
	api_syncer *ApiDecouplerOfInt16ThenInt32
	handler    WorkHandlerOfInt16ThenInt32

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfInt16ThenInt32
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfInt16ThenInt32(ctx context.Context, h WorkHandlerOfInt16ThenInt32, n int) *WorkerOfInt16ThenInt32 {
	__ := &WorkerOfInt16ThenInt32{
		api_syncer: NewApiDecouplerOfInt16ThenInt32(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfInt16ThenInt32, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfInt16ThenInt32{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfInt16ThenInt32(req.Context, req.WorkOfInt16ThenInt32, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfInt16ThenInt32) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfInt16ThenInt32) Push(ctx context.Context, req *WorkOfInt16ThenInt32) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfInt16ThenInt32)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfInt16ThenInt32 = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfInt16ThenInt32) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfInt16ThenInt32) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfInt16ThenInt32) Call(ctx context.Context, arg int16) (int32, error) {
	return __.api_syncer.DoOfInt16ThenInt32(ctx, __, arg)
}

type PoolOfInt16ThenInt64 interface {
	GetInt16Arg() *int16
	PutInt16Arg(*int16)
	GetInt64Return() *int64
	PutInt64Return(*int64)

	GetWorkOfInt16ThenInt64() *WorkOfInt16ThenInt64
	GetReturnOfInt64() *ReturnOfInt64
	PutWorkOfInt16ThenInt64(*WorkOfInt16ThenInt64)
	PutReturnOfInt64(*ReturnOfInt64)

	GetChReturnOfInt64() chan *ReturnOfInt64
	PutChReturnOfInt64(chan *ReturnOfInt64)
}

type PoolOfInt16ThenInt64Impl struct {
	Int16Arg        sync.Pool
	Int64Rtn        sync.Pool
	Int16Work       sync.Pool
	Int64Return     sync.Pool
	ChReturnOfInt64 sync.Pool
}

func (__ *PoolOfInt16ThenInt64Impl) GetInt16Arg() *int16 {
	return __.Int16Arg.Get().(*int16)
}
func (__ *PoolOfInt16ThenInt64Impl) PutInt16Arg(p *int16) {
	__.Int16Arg.Put(p)
}
func (__ *PoolOfInt16ThenInt64Impl) GetInt64Return() *int64 {
	return __.Int64Rtn.Get().(*int64)
}
func (__ *PoolOfInt16ThenInt64Impl) PutInt64Return(p *int64) {
	__.Int64Rtn.Put(p)
}

func (__ *PoolOfInt16ThenInt64Impl) GetWorkOfInt16ThenInt64() *WorkOfInt16ThenInt64 {
	return __.Int16Work.Get().(*WorkOfInt16ThenInt64)
}
func (__ *PoolOfInt16ThenInt64Impl) PutWorkOfInt16ThenInt64(p *WorkOfInt16ThenInt64) {
	__.Int16Work.Put(p)
}
func (__ *PoolOfInt16ThenInt64Impl) GetReturnOfInt64() *ReturnOfInt64 {
	return __.Int64Return.Get().(*ReturnOfInt64)
}
func (__ *PoolOfInt16ThenInt64Impl) PutReturnOfInt64(p *ReturnOfInt64) {
	__.Int64Return.Put(p)
}

func (__ *PoolOfInt16ThenInt64Impl) GetChReturnOfInt64() chan *ReturnOfInt64 {
	return __.ChReturnOfInt64.Get().(chan *ReturnOfInt64)
}
func (__ *PoolOfInt16ThenInt64Impl) PutChReturnOfInt64(p chan *ReturnOfInt64) {
	__.ChReturnOfInt64.Put(p)
}

func NewPoolOfInt16ThenInt64Impl() *PoolOfInt16ThenInt64Impl {
	return &PoolOfInt16ThenInt64Impl{
		Int16Arg: sync.Pool{
			New: func() interface{} {
				return new(int16)
			},
		},
		Int16Work: sync.Pool{
			New: func() interface{} {
				return new(WorkOfInt16ThenInt64)
			},
		},
		Int64Rtn: sync.Pool{
			New: func() interface{} {
				return new(int64)
			},
		},
		Int64Return: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfInt64)
			},
		},
		ChReturnOfInt64: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfInt64, 1)
			},
		},
	}
}

type ApiDecouplerOfInt16ThenInt64 struct {
	pool PoolOfInt16ThenInt64
}

func NewApiDecouplerOfInt16ThenInt64() *ApiDecouplerOfInt16ThenInt64 {
	return &ApiDecouplerOfInt16ThenInt64{
		pool: NewPoolOfInt16ThenInt64Impl(),
	}
}

func (__ *ApiDecouplerOfInt16ThenInt64) ReturnError(rtn_ch chan<- *ReturnOfInt64, err error) {
	rtn := __.pool.GetReturnOfInt64()
	var other int64
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfInt16ThenInt64) HandleOfInt16ThenInt64(ctx context.Context, req *WorkOfInt16ThenInt64, h func(ctx context.Context, arg int16) (int64, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfInt64()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfInt16ThenInt64) DoOfInt16ThenInt64(ctx context.Context, worker WorkerOfPushInt16ThenInt64, arg int16) (int64, error) {
	// ch := make(chan *ReturnOfInt64, 1)
	ch := __.pool.GetChReturnOfInt64()
	defer __.pool.PutChReturnOfInt64(ch)

	req := __.pool.GetWorkOfInt16ThenInt64()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfInt16ThenInt64(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfInt64(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfInt16ThenInt64 = func(ctx context.Context, arg int16) (int64, error)

type WorkerOfInt16ThenInt64 struct {
	api_syncer *ApiDecouplerOfInt16ThenInt64
	handler    WorkHandlerOfInt16ThenInt64

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfInt16ThenInt64
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfInt16ThenInt64(ctx context.Context, h WorkHandlerOfInt16ThenInt64, n int) *WorkerOfInt16ThenInt64 {
	__ := &WorkerOfInt16ThenInt64{
		api_syncer: NewApiDecouplerOfInt16ThenInt64(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfInt16ThenInt64, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfInt16ThenInt64{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfInt16ThenInt64(req.Context, req.WorkOfInt16ThenInt64, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfInt16ThenInt64) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfInt16ThenInt64) Push(ctx context.Context, req *WorkOfInt16ThenInt64) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfInt16ThenInt64)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfInt16ThenInt64 = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfInt16ThenInt64) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfInt16ThenInt64) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfInt16ThenInt64) Call(ctx context.Context, arg int16) (int64, error) {
	return __.api_syncer.DoOfInt16ThenInt64(ctx, __, arg)
}

type PoolOfInt16ThenInt8 interface {
	GetInt16Arg() *int16
	PutInt16Arg(*int16)
	GetInt8Return() *int8
	PutInt8Return(*int8)

	GetWorkOfInt16ThenInt8() *WorkOfInt16ThenInt8
	GetReturnOfInt8() *ReturnOfInt8
	PutWorkOfInt16ThenInt8(*WorkOfInt16ThenInt8)
	PutReturnOfInt8(*ReturnOfInt8)

	GetChReturnOfInt8() chan *ReturnOfInt8
	PutChReturnOfInt8(chan *ReturnOfInt8)
}

type PoolOfInt16ThenInt8Impl struct {
	Int16Arg       sync.Pool
	Int8Rtn        sync.Pool
	Int16Work      sync.Pool
	Int8Return     sync.Pool
	ChReturnOfInt8 sync.Pool
}

func (__ *PoolOfInt16ThenInt8Impl) GetInt16Arg() *int16 {
	return __.Int16Arg.Get().(*int16)
}
func (__ *PoolOfInt16ThenInt8Impl) PutInt16Arg(p *int16) {
	__.Int16Arg.Put(p)
}
func (__ *PoolOfInt16ThenInt8Impl) GetInt8Return() *int8 {
	return __.Int8Rtn.Get().(*int8)
}
func (__ *PoolOfInt16ThenInt8Impl) PutInt8Return(p *int8) {
	__.Int8Rtn.Put(p)
}

func (__ *PoolOfInt16ThenInt8Impl) GetWorkOfInt16ThenInt8() *WorkOfInt16ThenInt8 {
	return __.Int16Work.Get().(*WorkOfInt16ThenInt8)
}
func (__ *PoolOfInt16ThenInt8Impl) PutWorkOfInt16ThenInt8(p *WorkOfInt16ThenInt8) {
	__.Int16Work.Put(p)
}
func (__ *PoolOfInt16ThenInt8Impl) GetReturnOfInt8() *ReturnOfInt8 {
	return __.Int8Return.Get().(*ReturnOfInt8)
}
func (__ *PoolOfInt16ThenInt8Impl) PutReturnOfInt8(p *ReturnOfInt8) {
	__.Int8Return.Put(p)
}

func (__ *PoolOfInt16ThenInt8Impl) GetChReturnOfInt8() chan *ReturnOfInt8 {
	return __.ChReturnOfInt8.Get().(chan *ReturnOfInt8)
}
func (__ *PoolOfInt16ThenInt8Impl) PutChReturnOfInt8(p chan *ReturnOfInt8) {
	__.ChReturnOfInt8.Put(p)
}

func NewPoolOfInt16ThenInt8Impl() *PoolOfInt16ThenInt8Impl {
	return &PoolOfInt16ThenInt8Impl{
		Int16Arg: sync.Pool{
			New: func() interface{} {
				return new(int16)
			},
		},
		Int16Work: sync.Pool{
			New: func() interface{} {
				return new(WorkOfInt16ThenInt8)
			},
		},
		Int8Rtn: sync.Pool{
			New: func() interface{} {
				return new(int8)
			},
		},
		Int8Return: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfInt8)
			},
		},
		ChReturnOfInt8: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfInt8, 1)
			},
		},
	}
}

type ApiDecouplerOfInt16ThenInt8 struct {
	pool PoolOfInt16ThenInt8
}

func NewApiDecouplerOfInt16ThenInt8() *ApiDecouplerOfInt16ThenInt8 {
	return &ApiDecouplerOfInt16ThenInt8{
		pool: NewPoolOfInt16ThenInt8Impl(),
	}
}

func (__ *ApiDecouplerOfInt16ThenInt8) ReturnError(rtn_ch chan<- *ReturnOfInt8, err error) {
	rtn := __.pool.GetReturnOfInt8()
	var other int8
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfInt16ThenInt8) HandleOfInt16ThenInt8(ctx context.Context, req *WorkOfInt16ThenInt8, h func(ctx context.Context, arg int16) (int8, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfInt8()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfInt16ThenInt8) DoOfInt16ThenInt8(ctx context.Context, worker WorkerOfPushInt16ThenInt8, arg int16) (int8, error) {
	// ch := make(chan *ReturnOfInt8, 1)
	ch := __.pool.GetChReturnOfInt8()
	defer __.pool.PutChReturnOfInt8(ch)

	req := __.pool.GetWorkOfInt16ThenInt8()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfInt16ThenInt8(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfInt8(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfInt16ThenInt8 = func(ctx context.Context, arg int16) (int8, error)

type WorkerOfInt16ThenInt8 struct {
	api_syncer *ApiDecouplerOfInt16ThenInt8
	handler    WorkHandlerOfInt16ThenInt8

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfInt16ThenInt8
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfInt16ThenInt8(ctx context.Context, h WorkHandlerOfInt16ThenInt8, n int) *WorkerOfInt16ThenInt8 {
	__ := &WorkerOfInt16ThenInt8{
		api_syncer: NewApiDecouplerOfInt16ThenInt8(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfInt16ThenInt8, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfInt16ThenInt8{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfInt16ThenInt8(req.Context, req.WorkOfInt16ThenInt8, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfInt16ThenInt8) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfInt16ThenInt8) Push(ctx context.Context, req *WorkOfInt16ThenInt8) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfInt16ThenInt8)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfInt16ThenInt8 = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfInt16ThenInt8) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfInt16ThenInt8) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfInt16ThenInt8) Call(ctx context.Context, arg int16) (int8, error) {
	return __.api_syncer.DoOfInt16ThenInt8(ctx, __, arg)
}

type PoolOfInt16ThenRune interface {
	GetInt16Arg() *int16
	PutInt16Arg(*int16)
	GetRuneReturn() *rune
	PutRuneReturn(*rune)

	GetWorkOfInt16ThenRune() *WorkOfInt16ThenRune
	GetReturnOfRune() *ReturnOfRune
	PutWorkOfInt16ThenRune(*WorkOfInt16ThenRune)
	PutReturnOfRune(*ReturnOfRune)

	GetChReturnOfRune() chan *ReturnOfRune
	PutChReturnOfRune(chan *ReturnOfRune)
}

type PoolOfInt16ThenRuneImpl struct {
	Int16Arg       sync.Pool
	RuneRtn        sync.Pool
	Int16Work      sync.Pool
	RuneReturn     sync.Pool
	ChReturnOfRune sync.Pool
}

func (__ *PoolOfInt16ThenRuneImpl) GetInt16Arg() *int16 {
	return __.Int16Arg.Get().(*int16)
}
func (__ *PoolOfInt16ThenRuneImpl) PutInt16Arg(p *int16) {
	__.Int16Arg.Put(p)
}
func (__ *PoolOfInt16ThenRuneImpl) GetRuneReturn() *rune {
	return __.RuneRtn.Get().(*rune)
}
func (__ *PoolOfInt16ThenRuneImpl) PutRuneReturn(p *rune) {
	__.RuneRtn.Put(p)
}

func (__ *PoolOfInt16ThenRuneImpl) GetWorkOfInt16ThenRune() *WorkOfInt16ThenRune {
	return __.Int16Work.Get().(*WorkOfInt16ThenRune)
}
func (__ *PoolOfInt16ThenRuneImpl) PutWorkOfInt16ThenRune(p *WorkOfInt16ThenRune) {
	__.Int16Work.Put(p)
}
func (__ *PoolOfInt16ThenRuneImpl) GetReturnOfRune() *ReturnOfRune {
	return __.RuneReturn.Get().(*ReturnOfRune)
}
func (__ *PoolOfInt16ThenRuneImpl) PutReturnOfRune(p *ReturnOfRune) {
	__.RuneReturn.Put(p)
}

func (__ *PoolOfInt16ThenRuneImpl) GetChReturnOfRune() chan *ReturnOfRune {
	return __.ChReturnOfRune.Get().(chan *ReturnOfRune)
}
func (__ *PoolOfInt16ThenRuneImpl) PutChReturnOfRune(p chan *ReturnOfRune) {
	__.ChReturnOfRune.Put(p)
}

func NewPoolOfInt16ThenRuneImpl() *PoolOfInt16ThenRuneImpl {
	return &PoolOfInt16ThenRuneImpl{
		Int16Arg: sync.Pool{
			New: func() interface{} {
				return new(int16)
			},
		},
		Int16Work: sync.Pool{
			New: func() interface{} {
				return new(WorkOfInt16ThenRune)
			},
		},
		RuneRtn: sync.Pool{
			New: func() interface{} {
				return new(rune)
			},
		},
		RuneReturn: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfRune)
			},
		},
		ChReturnOfRune: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfRune, 1)
			},
		},
	}
}

type ApiDecouplerOfInt16ThenRune struct {
	pool PoolOfInt16ThenRune
}

func NewApiDecouplerOfInt16ThenRune() *ApiDecouplerOfInt16ThenRune {
	return &ApiDecouplerOfInt16ThenRune{
		pool: NewPoolOfInt16ThenRuneImpl(),
	}
}

func (__ *ApiDecouplerOfInt16ThenRune) ReturnError(rtn_ch chan<- *ReturnOfRune, err error) {
	rtn := __.pool.GetReturnOfRune()
	var other rune
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfInt16ThenRune) HandleOfInt16ThenRune(ctx context.Context, req *WorkOfInt16ThenRune, h func(ctx context.Context, arg int16) (rune, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfRune()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfInt16ThenRune) DoOfInt16ThenRune(ctx context.Context, worker WorkerOfPushInt16ThenRune, arg int16) (rune, error) {
	// ch := make(chan *ReturnOfRune, 1)
	ch := __.pool.GetChReturnOfRune()
	defer __.pool.PutChReturnOfRune(ch)

	req := __.pool.GetWorkOfInt16ThenRune()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfInt16ThenRune(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfRune(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfInt16ThenRune = func(ctx context.Context, arg int16) (rune, error)

type WorkerOfInt16ThenRune struct {
	api_syncer *ApiDecouplerOfInt16ThenRune
	handler    WorkHandlerOfInt16ThenRune

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfInt16ThenRune
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfInt16ThenRune(ctx context.Context, h WorkHandlerOfInt16ThenRune, n int) *WorkerOfInt16ThenRune {
	__ := &WorkerOfInt16ThenRune{
		api_syncer: NewApiDecouplerOfInt16ThenRune(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfInt16ThenRune, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfInt16ThenRune{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfInt16ThenRune(req.Context, req.WorkOfInt16ThenRune, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfInt16ThenRune) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfInt16ThenRune) Push(ctx context.Context, req *WorkOfInt16ThenRune) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfInt16ThenRune)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfInt16ThenRune = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfInt16ThenRune) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfInt16ThenRune) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfInt16ThenRune) Call(ctx context.Context, arg int16) (rune, error) {
	return __.api_syncer.DoOfInt16ThenRune(ctx, __, arg)
}

type PoolOfInt16ThenString interface {
	GetInt16Arg() *int16
	PutInt16Arg(*int16)
	GetStringReturn() *string
	PutStringReturn(*string)

	GetWorkOfInt16ThenString() *WorkOfInt16ThenString
	GetReturnOfString() *ReturnOfString
	PutWorkOfInt16ThenString(*WorkOfInt16ThenString)
	PutReturnOfString(*ReturnOfString)

	GetChReturnOfString() chan *ReturnOfString
	PutChReturnOfString(chan *ReturnOfString)
}

type PoolOfInt16ThenStringImpl struct {
	Int16Arg         sync.Pool
	StringRtn        sync.Pool
	Int16Work        sync.Pool
	StringReturn     sync.Pool
	ChReturnOfString sync.Pool
}

func (__ *PoolOfInt16ThenStringImpl) GetInt16Arg() *int16 {
	return __.Int16Arg.Get().(*int16)
}
func (__ *PoolOfInt16ThenStringImpl) PutInt16Arg(p *int16) {
	__.Int16Arg.Put(p)
}
func (__ *PoolOfInt16ThenStringImpl) GetStringReturn() *string {
	return __.StringRtn.Get().(*string)
}
func (__ *PoolOfInt16ThenStringImpl) PutStringReturn(p *string) {
	__.StringRtn.Put(p)
}

func (__ *PoolOfInt16ThenStringImpl) GetWorkOfInt16ThenString() *WorkOfInt16ThenString {
	return __.Int16Work.Get().(*WorkOfInt16ThenString)
}
func (__ *PoolOfInt16ThenStringImpl) PutWorkOfInt16ThenString(p *WorkOfInt16ThenString) {
	__.Int16Work.Put(p)
}
func (__ *PoolOfInt16ThenStringImpl) GetReturnOfString() *ReturnOfString {
	return __.StringReturn.Get().(*ReturnOfString)
}
func (__ *PoolOfInt16ThenStringImpl) PutReturnOfString(p *ReturnOfString) {
	__.StringReturn.Put(p)
}

func (__ *PoolOfInt16ThenStringImpl) GetChReturnOfString() chan *ReturnOfString {
	return __.ChReturnOfString.Get().(chan *ReturnOfString)
}
func (__ *PoolOfInt16ThenStringImpl) PutChReturnOfString(p chan *ReturnOfString) {
	__.ChReturnOfString.Put(p)
}

func NewPoolOfInt16ThenStringImpl() *PoolOfInt16ThenStringImpl {
	return &PoolOfInt16ThenStringImpl{
		Int16Arg: sync.Pool{
			New: func() interface{} {
				return new(int16)
			},
		},
		Int16Work: sync.Pool{
			New: func() interface{} {
				return new(WorkOfInt16ThenString)
			},
		},
		StringRtn: sync.Pool{
			New: func() interface{} {
				return new(string)
			},
		},
		StringReturn: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfString)
			},
		},
		ChReturnOfString: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfString, 1)
			},
		},
	}
}

type ApiDecouplerOfInt16ThenString struct {
	pool PoolOfInt16ThenString
}

func NewApiDecouplerOfInt16ThenString() *ApiDecouplerOfInt16ThenString {
	return &ApiDecouplerOfInt16ThenString{
		pool: NewPoolOfInt16ThenStringImpl(),
	}
}

func (__ *ApiDecouplerOfInt16ThenString) ReturnError(rtn_ch chan<- *ReturnOfString, err error) {
	rtn := __.pool.GetReturnOfString()
	var other string
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfInt16ThenString) HandleOfInt16ThenString(ctx context.Context, req *WorkOfInt16ThenString, h func(ctx context.Context, arg int16) (string, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfString()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfInt16ThenString) DoOfInt16ThenString(ctx context.Context, worker WorkerOfPushInt16ThenString, arg int16) (string, error) {
	// ch := make(chan *ReturnOfString, 1)
	ch := __.pool.GetChReturnOfString()
	defer __.pool.PutChReturnOfString(ch)

	req := __.pool.GetWorkOfInt16ThenString()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfInt16ThenString(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfString(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfInt16ThenString = func(ctx context.Context, arg int16) (string, error)

type WorkerOfInt16ThenString struct {
	api_syncer *ApiDecouplerOfInt16ThenString
	handler    WorkHandlerOfInt16ThenString

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfInt16ThenString
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfInt16ThenString(ctx context.Context, h WorkHandlerOfInt16ThenString, n int) *WorkerOfInt16ThenString {
	__ := &WorkerOfInt16ThenString{
		api_syncer: NewApiDecouplerOfInt16ThenString(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfInt16ThenString, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfInt16ThenString{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfInt16ThenString(req.Context, req.WorkOfInt16ThenString, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfInt16ThenString) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfInt16ThenString) Push(ctx context.Context, req *WorkOfInt16ThenString) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfInt16ThenString)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfInt16ThenString = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfInt16ThenString) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfInt16ThenString) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfInt16ThenString) Call(ctx context.Context, arg int16) (string, error) {
	return __.api_syncer.DoOfInt16ThenString(ctx, __, arg)
}

type PoolOfInt16ThenUint interface {
	GetInt16Arg() *int16
	PutInt16Arg(*int16)
	GetUintReturn() *uint
	PutUintReturn(*uint)

	GetWorkOfInt16ThenUint() *WorkOfInt16ThenUint
	GetReturnOfUint() *ReturnOfUint
	PutWorkOfInt16ThenUint(*WorkOfInt16ThenUint)
	PutReturnOfUint(*ReturnOfUint)

	GetChReturnOfUint() chan *ReturnOfUint
	PutChReturnOfUint(chan *ReturnOfUint)
}

type PoolOfInt16ThenUintImpl struct {
	Int16Arg       sync.Pool
	UintRtn        sync.Pool
	Int16Work      sync.Pool
	UintReturn     sync.Pool
	ChReturnOfUint sync.Pool
}

func (__ *PoolOfInt16ThenUintImpl) GetInt16Arg() *int16 {
	return __.Int16Arg.Get().(*int16)
}
func (__ *PoolOfInt16ThenUintImpl) PutInt16Arg(p *int16) {
	__.Int16Arg.Put(p)
}
func (__ *PoolOfInt16ThenUintImpl) GetUintReturn() *uint {
	return __.UintRtn.Get().(*uint)
}
func (__ *PoolOfInt16ThenUintImpl) PutUintReturn(p *uint) {
	__.UintRtn.Put(p)
}

func (__ *PoolOfInt16ThenUintImpl) GetWorkOfInt16ThenUint() *WorkOfInt16ThenUint {
	return __.Int16Work.Get().(*WorkOfInt16ThenUint)
}
func (__ *PoolOfInt16ThenUintImpl) PutWorkOfInt16ThenUint(p *WorkOfInt16ThenUint) {
	__.Int16Work.Put(p)
}
func (__ *PoolOfInt16ThenUintImpl) GetReturnOfUint() *ReturnOfUint {
	return __.UintReturn.Get().(*ReturnOfUint)
}
func (__ *PoolOfInt16ThenUintImpl) PutReturnOfUint(p *ReturnOfUint) {
	__.UintReturn.Put(p)
}

func (__ *PoolOfInt16ThenUintImpl) GetChReturnOfUint() chan *ReturnOfUint {
	return __.ChReturnOfUint.Get().(chan *ReturnOfUint)
}
func (__ *PoolOfInt16ThenUintImpl) PutChReturnOfUint(p chan *ReturnOfUint) {
	__.ChReturnOfUint.Put(p)
}

func NewPoolOfInt16ThenUintImpl() *PoolOfInt16ThenUintImpl {
	return &PoolOfInt16ThenUintImpl{
		Int16Arg: sync.Pool{
			New: func() interface{} {
				return new(int16)
			},
		},
		Int16Work: sync.Pool{
			New: func() interface{} {
				return new(WorkOfInt16ThenUint)
			},
		},
		UintRtn: sync.Pool{
			New: func() interface{} {
				return new(uint)
			},
		},
		UintReturn: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfUint)
			},
		},
		ChReturnOfUint: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfUint, 1)
			},
		},
	}
}

type ApiDecouplerOfInt16ThenUint struct {
	pool PoolOfInt16ThenUint
}

func NewApiDecouplerOfInt16ThenUint() *ApiDecouplerOfInt16ThenUint {
	return &ApiDecouplerOfInt16ThenUint{
		pool: NewPoolOfInt16ThenUintImpl(),
	}
}

func (__ *ApiDecouplerOfInt16ThenUint) ReturnError(rtn_ch chan<- *ReturnOfUint, err error) {
	rtn := __.pool.GetReturnOfUint()
	var other uint
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfInt16ThenUint) HandleOfInt16ThenUint(ctx context.Context, req *WorkOfInt16ThenUint, h func(ctx context.Context, arg int16) (uint, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfUint()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfInt16ThenUint) DoOfInt16ThenUint(ctx context.Context, worker WorkerOfPushInt16ThenUint, arg int16) (uint, error) {
	// ch := make(chan *ReturnOfUint, 1)
	ch := __.pool.GetChReturnOfUint()
	defer __.pool.PutChReturnOfUint(ch)

	req := __.pool.GetWorkOfInt16ThenUint()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfInt16ThenUint(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfUint(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfInt16ThenUint = func(ctx context.Context, arg int16) (uint, error)

type WorkerOfInt16ThenUint struct {
	api_syncer *ApiDecouplerOfInt16ThenUint
	handler    WorkHandlerOfInt16ThenUint

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfInt16ThenUint
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfInt16ThenUint(ctx context.Context, h WorkHandlerOfInt16ThenUint, n int) *WorkerOfInt16ThenUint {
	__ := &WorkerOfInt16ThenUint{
		api_syncer: NewApiDecouplerOfInt16ThenUint(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfInt16ThenUint, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfInt16ThenUint{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfInt16ThenUint(req.Context, req.WorkOfInt16ThenUint, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfInt16ThenUint) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfInt16ThenUint) Push(ctx context.Context, req *WorkOfInt16ThenUint) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfInt16ThenUint)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfInt16ThenUint = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfInt16ThenUint) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfInt16ThenUint) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfInt16ThenUint) Call(ctx context.Context, arg int16) (uint, error) {
	return __.api_syncer.DoOfInt16ThenUint(ctx, __, arg)
}

type PoolOfInt16ThenUint16 interface {
	GetInt16Arg() *int16
	PutInt16Arg(*int16)
	GetUint16Return() *uint16
	PutUint16Return(*uint16)

	GetWorkOfInt16ThenUint16() *WorkOfInt16ThenUint16
	GetReturnOfUint16() *ReturnOfUint16
	PutWorkOfInt16ThenUint16(*WorkOfInt16ThenUint16)
	PutReturnOfUint16(*ReturnOfUint16)

	GetChReturnOfUint16() chan *ReturnOfUint16
	PutChReturnOfUint16(chan *ReturnOfUint16)
}

type PoolOfInt16ThenUint16Impl struct {
	Int16Arg         sync.Pool
	Uint16Rtn        sync.Pool
	Int16Work        sync.Pool
	Uint16Return     sync.Pool
	ChReturnOfUint16 sync.Pool
}

func (__ *PoolOfInt16ThenUint16Impl) GetInt16Arg() *int16 {
	return __.Int16Arg.Get().(*int16)
}
func (__ *PoolOfInt16ThenUint16Impl) PutInt16Arg(p *int16) {
	__.Int16Arg.Put(p)
}
func (__ *PoolOfInt16ThenUint16Impl) GetUint16Return() *uint16 {
	return __.Uint16Rtn.Get().(*uint16)
}
func (__ *PoolOfInt16ThenUint16Impl) PutUint16Return(p *uint16) {
	__.Uint16Rtn.Put(p)
}

func (__ *PoolOfInt16ThenUint16Impl) GetWorkOfInt16ThenUint16() *WorkOfInt16ThenUint16 {
	return __.Int16Work.Get().(*WorkOfInt16ThenUint16)
}
func (__ *PoolOfInt16ThenUint16Impl) PutWorkOfInt16ThenUint16(p *WorkOfInt16ThenUint16) {
	__.Int16Work.Put(p)
}
func (__ *PoolOfInt16ThenUint16Impl) GetReturnOfUint16() *ReturnOfUint16 {
	return __.Uint16Return.Get().(*ReturnOfUint16)
}
func (__ *PoolOfInt16ThenUint16Impl) PutReturnOfUint16(p *ReturnOfUint16) {
	__.Uint16Return.Put(p)
}

func (__ *PoolOfInt16ThenUint16Impl) GetChReturnOfUint16() chan *ReturnOfUint16 {
	return __.ChReturnOfUint16.Get().(chan *ReturnOfUint16)
}
func (__ *PoolOfInt16ThenUint16Impl) PutChReturnOfUint16(p chan *ReturnOfUint16) {
	__.ChReturnOfUint16.Put(p)
}

func NewPoolOfInt16ThenUint16Impl() *PoolOfInt16ThenUint16Impl {
	return &PoolOfInt16ThenUint16Impl{
		Int16Arg: sync.Pool{
			New: func() interface{} {
				return new(int16)
			},
		},
		Int16Work: sync.Pool{
			New: func() interface{} {
				return new(WorkOfInt16ThenUint16)
			},
		},
		Uint16Rtn: sync.Pool{
			New: func() interface{} {
				return new(uint16)
			},
		},
		Uint16Return: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfUint16)
			},
		},
		ChReturnOfUint16: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfUint16, 1)
			},
		},
	}
}

type ApiDecouplerOfInt16ThenUint16 struct {
	pool PoolOfInt16ThenUint16
}

func NewApiDecouplerOfInt16ThenUint16() *ApiDecouplerOfInt16ThenUint16 {
	return &ApiDecouplerOfInt16ThenUint16{
		pool: NewPoolOfInt16ThenUint16Impl(),
	}
}

func (__ *ApiDecouplerOfInt16ThenUint16) ReturnError(rtn_ch chan<- *ReturnOfUint16, err error) {
	rtn := __.pool.GetReturnOfUint16()
	var other uint16
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfInt16ThenUint16) HandleOfInt16ThenUint16(ctx context.Context, req *WorkOfInt16ThenUint16, h func(ctx context.Context, arg int16) (uint16, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfUint16()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfInt16ThenUint16) DoOfInt16ThenUint16(ctx context.Context, worker WorkerOfPushInt16ThenUint16, arg int16) (uint16, error) {
	// ch := make(chan *ReturnOfUint16, 1)
	ch := __.pool.GetChReturnOfUint16()
	defer __.pool.PutChReturnOfUint16(ch)

	req := __.pool.GetWorkOfInt16ThenUint16()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfInt16ThenUint16(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfUint16(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfInt16ThenUint16 = func(ctx context.Context, arg int16) (uint16, error)

type WorkerOfInt16ThenUint16 struct {
	api_syncer *ApiDecouplerOfInt16ThenUint16
	handler    WorkHandlerOfInt16ThenUint16

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfInt16ThenUint16
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfInt16ThenUint16(ctx context.Context, h WorkHandlerOfInt16ThenUint16, n int) *WorkerOfInt16ThenUint16 {
	__ := &WorkerOfInt16ThenUint16{
		api_syncer: NewApiDecouplerOfInt16ThenUint16(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfInt16ThenUint16, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfInt16ThenUint16{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfInt16ThenUint16(req.Context, req.WorkOfInt16ThenUint16, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfInt16ThenUint16) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfInt16ThenUint16) Push(ctx context.Context, req *WorkOfInt16ThenUint16) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfInt16ThenUint16)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfInt16ThenUint16 = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfInt16ThenUint16) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfInt16ThenUint16) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfInt16ThenUint16) Call(ctx context.Context, arg int16) (uint16, error) {
	return __.api_syncer.DoOfInt16ThenUint16(ctx, __, arg)
}

type PoolOfInt16ThenUint32 interface {
	GetInt16Arg() *int16
	PutInt16Arg(*int16)
	GetUint32Return() *uint32
	PutUint32Return(*uint32)

	GetWorkOfInt16ThenUint32() *WorkOfInt16ThenUint32
	GetReturnOfUint32() *ReturnOfUint32
	PutWorkOfInt16ThenUint32(*WorkOfInt16ThenUint32)
	PutReturnOfUint32(*ReturnOfUint32)

	GetChReturnOfUint32() chan *ReturnOfUint32
	PutChReturnOfUint32(chan *ReturnOfUint32)
}

type PoolOfInt16ThenUint32Impl struct {
	Int16Arg         sync.Pool
	Uint32Rtn        sync.Pool
	Int16Work        sync.Pool
	Uint32Return     sync.Pool
	ChReturnOfUint32 sync.Pool
}

func (__ *PoolOfInt16ThenUint32Impl) GetInt16Arg() *int16 {
	return __.Int16Arg.Get().(*int16)
}
func (__ *PoolOfInt16ThenUint32Impl) PutInt16Arg(p *int16) {
	__.Int16Arg.Put(p)
}
func (__ *PoolOfInt16ThenUint32Impl) GetUint32Return() *uint32 {
	return __.Uint32Rtn.Get().(*uint32)
}
func (__ *PoolOfInt16ThenUint32Impl) PutUint32Return(p *uint32) {
	__.Uint32Rtn.Put(p)
}

func (__ *PoolOfInt16ThenUint32Impl) GetWorkOfInt16ThenUint32() *WorkOfInt16ThenUint32 {
	return __.Int16Work.Get().(*WorkOfInt16ThenUint32)
}
func (__ *PoolOfInt16ThenUint32Impl) PutWorkOfInt16ThenUint32(p *WorkOfInt16ThenUint32) {
	__.Int16Work.Put(p)
}
func (__ *PoolOfInt16ThenUint32Impl) GetReturnOfUint32() *ReturnOfUint32 {
	return __.Uint32Return.Get().(*ReturnOfUint32)
}
func (__ *PoolOfInt16ThenUint32Impl) PutReturnOfUint32(p *ReturnOfUint32) {
	__.Uint32Return.Put(p)
}

func (__ *PoolOfInt16ThenUint32Impl) GetChReturnOfUint32() chan *ReturnOfUint32 {
	return __.ChReturnOfUint32.Get().(chan *ReturnOfUint32)
}
func (__ *PoolOfInt16ThenUint32Impl) PutChReturnOfUint32(p chan *ReturnOfUint32) {
	__.ChReturnOfUint32.Put(p)
}

func NewPoolOfInt16ThenUint32Impl() *PoolOfInt16ThenUint32Impl {
	return &PoolOfInt16ThenUint32Impl{
		Int16Arg: sync.Pool{
			New: func() interface{} {
				return new(int16)
			},
		},
		Int16Work: sync.Pool{
			New: func() interface{} {
				return new(WorkOfInt16ThenUint32)
			},
		},
		Uint32Rtn: sync.Pool{
			New: func() interface{} {
				return new(uint32)
			},
		},
		Uint32Return: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfUint32)
			},
		},
		ChReturnOfUint32: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfUint32, 1)
			},
		},
	}
}

type ApiDecouplerOfInt16ThenUint32 struct {
	pool PoolOfInt16ThenUint32
}

func NewApiDecouplerOfInt16ThenUint32() *ApiDecouplerOfInt16ThenUint32 {
	return &ApiDecouplerOfInt16ThenUint32{
		pool: NewPoolOfInt16ThenUint32Impl(),
	}
}

func (__ *ApiDecouplerOfInt16ThenUint32) ReturnError(rtn_ch chan<- *ReturnOfUint32, err error) {
	rtn := __.pool.GetReturnOfUint32()
	var other uint32
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfInt16ThenUint32) HandleOfInt16ThenUint32(ctx context.Context, req *WorkOfInt16ThenUint32, h func(ctx context.Context, arg int16) (uint32, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfUint32()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfInt16ThenUint32) DoOfInt16ThenUint32(ctx context.Context, worker WorkerOfPushInt16ThenUint32, arg int16) (uint32, error) {
	// ch := make(chan *ReturnOfUint32, 1)
	ch := __.pool.GetChReturnOfUint32()
	defer __.pool.PutChReturnOfUint32(ch)

	req := __.pool.GetWorkOfInt16ThenUint32()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfInt16ThenUint32(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfUint32(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfInt16ThenUint32 = func(ctx context.Context, arg int16) (uint32, error)

type WorkerOfInt16ThenUint32 struct {
	api_syncer *ApiDecouplerOfInt16ThenUint32
	handler    WorkHandlerOfInt16ThenUint32

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfInt16ThenUint32
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfInt16ThenUint32(ctx context.Context, h WorkHandlerOfInt16ThenUint32, n int) *WorkerOfInt16ThenUint32 {
	__ := &WorkerOfInt16ThenUint32{
		api_syncer: NewApiDecouplerOfInt16ThenUint32(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfInt16ThenUint32, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfInt16ThenUint32{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfInt16ThenUint32(req.Context, req.WorkOfInt16ThenUint32, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfInt16ThenUint32) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfInt16ThenUint32) Push(ctx context.Context, req *WorkOfInt16ThenUint32) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfInt16ThenUint32)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfInt16ThenUint32 = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfInt16ThenUint32) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfInt16ThenUint32) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfInt16ThenUint32) Call(ctx context.Context, arg int16) (uint32, error) {
	return __.api_syncer.DoOfInt16ThenUint32(ctx, __, arg)
}

type PoolOfInt16ThenUint64 interface {
	GetInt16Arg() *int16
	PutInt16Arg(*int16)
	GetUint64Return() *uint64
	PutUint64Return(*uint64)

	GetWorkOfInt16ThenUint64() *WorkOfInt16ThenUint64
	GetReturnOfUint64() *ReturnOfUint64
	PutWorkOfInt16ThenUint64(*WorkOfInt16ThenUint64)
	PutReturnOfUint64(*ReturnOfUint64)

	GetChReturnOfUint64() chan *ReturnOfUint64
	PutChReturnOfUint64(chan *ReturnOfUint64)
}

type PoolOfInt16ThenUint64Impl struct {
	Int16Arg         sync.Pool
	Uint64Rtn        sync.Pool
	Int16Work        sync.Pool
	Uint64Return     sync.Pool
	ChReturnOfUint64 sync.Pool
}

func (__ *PoolOfInt16ThenUint64Impl) GetInt16Arg() *int16 {
	return __.Int16Arg.Get().(*int16)
}
func (__ *PoolOfInt16ThenUint64Impl) PutInt16Arg(p *int16) {
	__.Int16Arg.Put(p)
}
func (__ *PoolOfInt16ThenUint64Impl) GetUint64Return() *uint64 {
	return __.Uint64Rtn.Get().(*uint64)
}
func (__ *PoolOfInt16ThenUint64Impl) PutUint64Return(p *uint64) {
	__.Uint64Rtn.Put(p)
}

func (__ *PoolOfInt16ThenUint64Impl) GetWorkOfInt16ThenUint64() *WorkOfInt16ThenUint64 {
	return __.Int16Work.Get().(*WorkOfInt16ThenUint64)
}
func (__ *PoolOfInt16ThenUint64Impl) PutWorkOfInt16ThenUint64(p *WorkOfInt16ThenUint64) {
	__.Int16Work.Put(p)
}
func (__ *PoolOfInt16ThenUint64Impl) GetReturnOfUint64() *ReturnOfUint64 {
	return __.Uint64Return.Get().(*ReturnOfUint64)
}
func (__ *PoolOfInt16ThenUint64Impl) PutReturnOfUint64(p *ReturnOfUint64) {
	__.Uint64Return.Put(p)
}

func (__ *PoolOfInt16ThenUint64Impl) GetChReturnOfUint64() chan *ReturnOfUint64 {
	return __.ChReturnOfUint64.Get().(chan *ReturnOfUint64)
}
func (__ *PoolOfInt16ThenUint64Impl) PutChReturnOfUint64(p chan *ReturnOfUint64) {
	__.ChReturnOfUint64.Put(p)
}

func NewPoolOfInt16ThenUint64Impl() *PoolOfInt16ThenUint64Impl {
	return &PoolOfInt16ThenUint64Impl{
		Int16Arg: sync.Pool{
			New: func() interface{} {
				return new(int16)
			},
		},
		Int16Work: sync.Pool{
			New: func() interface{} {
				return new(WorkOfInt16ThenUint64)
			},
		},
		Uint64Rtn: sync.Pool{
			New: func() interface{} {
				return new(uint64)
			},
		},
		Uint64Return: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfUint64)
			},
		},
		ChReturnOfUint64: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfUint64, 1)
			},
		},
	}
}

type ApiDecouplerOfInt16ThenUint64 struct {
	pool PoolOfInt16ThenUint64
}

func NewApiDecouplerOfInt16ThenUint64() *ApiDecouplerOfInt16ThenUint64 {
	return &ApiDecouplerOfInt16ThenUint64{
		pool: NewPoolOfInt16ThenUint64Impl(),
	}
}

func (__ *ApiDecouplerOfInt16ThenUint64) ReturnError(rtn_ch chan<- *ReturnOfUint64, err error) {
	rtn := __.pool.GetReturnOfUint64()
	var other uint64
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfInt16ThenUint64) HandleOfInt16ThenUint64(ctx context.Context, req *WorkOfInt16ThenUint64, h func(ctx context.Context, arg int16) (uint64, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfUint64()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfInt16ThenUint64) DoOfInt16ThenUint64(ctx context.Context, worker WorkerOfPushInt16ThenUint64, arg int16) (uint64, error) {
	// ch := make(chan *ReturnOfUint64, 1)
	ch := __.pool.GetChReturnOfUint64()
	defer __.pool.PutChReturnOfUint64(ch)

	req := __.pool.GetWorkOfInt16ThenUint64()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfInt16ThenUint64(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfUint64(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfInt16ThenUint64 = func(ctx context.Context, arg int16) (uint64, error)

type WorkerOfInt16ThenUint64 struct {
	api_syncer *ApiDecouplerOfInt16ThenUint64
	handler    WorkHandlerOfInt16ThenUint64

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfInt16ThenUint64
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfInt16ThenUint64(ctx context.Context, h WorkHandlerOfInt16ThenUint64, n int) *WorkerOfInt16ThenUint64 {
	__ := &WorkerOfInt16ThenUint64{
		api_syncer: NewApiDecouplerOfInt16ThenUint64(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfInt16ThenUint64, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfInt16ThenUint64{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfInt16ThenUint64(req.Context, req.WorkOfInt16ThenUint64, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfInt16ThenUint64) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfInt16ThenUint64) Push(ctx context.Context, req *WorkOfInt16ThenUint64) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfInt16ThenUint64)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfInt16ThenUint64 = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfInt16ThenUint64) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfInt16ThenUint64) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfInt16ThenUint64) Call(ctx context.Context, arg int16) (uint64, error) {
	return __.api_syncer.DoOfInt16ThenUint64(ctx, __, arg)
}

type PoolOfInt16ThenUint8 interface {
	GetInt16Arg() *int16
	PutInt16Arg(*int16)
	GetUint8Return() *uint8
	PutUint8Return(*uint8)

	GetWorkOfInt16ThenUint8() *WorkOfInt16ThenUint8
	GetReturnOfUint8() *ReturnOfUint8
	PutWorkOfInt16ThenUint8(*WorkOfInt16ThenUint8)
	PutReturnOfUint8(*ReturnOfUint8)

	GetChReturnOfUint8() chan *ReturnOfUint8
	PutChReturnOfUint8(chan *ReturnOfUint8)
}

type PoolOfInt16ThenUint8Impl struct {
	Int16Arg        sync.Pool
	Uint8Rtn        sync.Pool
	Int16Work       sync.Pool
	Uint8Return     sync.Pool
	ChReturnOfUint8 sync.Pool
}

func (__ *PoolOfInt16ThenUint8Impl) GetInt16Arg() *int16 {
	return __.Int16Arg.Get().(*int16)
}
func (__ *PoolOfInt16ThenUint8Impl) PutInt16Arg(p *int16) {
	__.Int16Arg.Put(p)
}
func (__ *PoolOfInt16ThenUint8Impl) GetUint8Return() *uint8 {
	return __.Uint8Rtn.Get().(*uint8)
}
func (__ *PoolOfInt16ThenUint8Impl) PutUint8Return(p *uint8) {
	__.Uint8Rtn.Put(p)
}

func (__ *PoolOfInt16ThenUint8Impl) GetWorkOfInt16ThenUint8() *WorkOfInt16ThenUint8 {
	return __.Int16Work.Get().(*WorkOfInt16ThenUint8)
}
func (__ *PoolOfInt16ThenUint8Impl) PutWorkOfInt16ThenUint8(p *WorkOfInt16ThenUint8) {
	__.Int16Work.Put(p)
}
func (__ *PoolOfInt16ThenUint8Impl) GetReturnOfUint8() *ReturnOfUint8 {
	return __.Uint8Return.Get().(*ReturnOfUint8)
}
func (__ *PoolOfInt16ThenUint8Impl) PutReturnOfUint8(p *ReturnOfUint8) {
	__.Uint8Return.Put(p)
}

func (__ *PoolOfInt16ThenUint8Impl) GetChReturnOfUint8() chan *ReturnOfUint8 {
	return __.ChReturnOfUint8.Get().(chan *ReturnOfUint8)
}
func (__ *PoolOfInt16ThenUint8Impl) PutChReturnOfUint8(p chan *ReturnOfUint8) {
	__.ChReturnOfUint8.Put(p)
}

func NewPoolOfInt16ThenUint8Impl() *PoolOfInt16ThenUint8Impl {
	return &PoolOfInt16ThenUint8Impl{
		Int16Arg: sync.Pool{
			New: func() interface{} {
				return new(int16)
			},
		},
		Int16Work: sync.Pool{
			New: func() interface{} {
				return new(WorkOfInt16ThenUint8)
			},
		},
		Uint8Rtn: sync.Pool{
			New: func() interface{} {
				return new(uint8)
			},
		},
		Uint8Return: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfUint8)
			},
		},
		ChReturnOfUint8: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfUint8, 1)
			},
		},
	}
}

type ApiDecouplerOfInt16ThenUint8 struct {
	pool PoolOfInt16ThenUint8
}

func NewApiDecouplerOfInt16ThenUint8() *ApiDecouplerOfInt16ThenUint8 {
	return &ApiDecouplerOfInt16ThenUint8{
		pool: NewPoolOfInt16ThenUint8Impl(),
	}
}

func (__ *ApiDecouplerOfInt16ThenUint8) ReturnError(rtn_ch chan<- *ReturnOfUint8, err error) {
	rtn := __.pool.GetReturnOfUint8()
	var other uint8
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfInt16ThenUint8) HandleOfInt16ThenUint8(ctx context.Context, req *WorkOfInt16ThenUint8, h func(ctx context.Context, arg int16) (uint8, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfUint8()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfInt16ThenUint8) DoOfInt16ThenUint8(ctx context.Context, worker WorkerOfPushInt16ThenUint8, arg int16) (uint8, error) {
	// ch := make(chan *ReturnOfUint8, 1)
	ch := __.pool.GetChReturnOfUint8()
	defer __.pool.PutChReturnOfUint8(ch)

	req := __.pool.GetWorkOfInt16ThenUint8()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfInt16ThenUint8(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfUint8(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfInt16ThenUint8 = func(ctx context.Context, arg int16) (uint8, error)

type WorkerOfInt16ThenUint8 struct {
	api_syncer *ApiDecouplerOfInt16ThenUint8
	handler    WorkHandlerOfInt16ThenUint8

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfInt16ThenUint8
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfInt16ThenUint8(ctx context.Context, h WorkHandlerOfInt16ThenUint8, n int) *WorkerOfInt16ThenUint8 {
	__ := &WorkerOfInt16ThenUint8{
		api_syncer: NewApiDecouplerOfInt16ThenUint8(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfInt16ThenUint8, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfInt16ThenUint8{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfInt16ThenUint8(req.Context, req.WorkOfInt16ThenUint8, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfInt16ThenUint8) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfInt16ThenUint8) Push(ctx context.Context, req *WorkOfInt16ThenUint8) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfInt16ThenUint8)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfInt16ThenUint8 = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfInt16ThenUint8) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfInt16ThenUint8) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfInt16ThenUint8) Call(ctx context.Context, arg int16) (uint8, error) {
	return __.api_syncer.DoOfInt16ThenUint8(ctx, __, arg)
}

type PoolOfInt16ThenUintptr interface {
	GetInt16Arg() *int16
	PutInt16Arg(*int16)
	GetUintptrReturn() *uintptr
	PutUintptrReturn(*uintptr)

	GetWorkOfInt16ThenUintptr() *WorkOfInt16ThenUintptr
	GetReturnOfUintptr() *ReturnOfUintptr
	PutWorkOfInt16ThenUintptr(*WorkOfInt16ThenUintptr)
	PutReturnOfUintptr(*ReturnOfUintptr)

	GetChReturnOfUintptr() chan *ReturnOfUintptr
	PutChReturnOfUintptr(chan *ReturnOfUintptr)
}

type PoolOfInt16ThenUintptrImpl struct {
	Int16Arg          sync.Pool
	UintptrRtn        sync.Pool
	Int16Work         sync.Pool
	UintptrReturn     sync.Pool
	ChReturnOfUintptr sync.Pool
}

func (__ *PoolOfInt16ThenUintptrImpl) GetInt16Arg() *int16 {
	return __.Int16Arg.Get().(*int16)
}
func (__ *PoolOfInt16ThenUintptrImpl) PutInt16Arg(p *int16) {
	__.Int16Arg.Put(p)
}
func (__ *PoolOfInt16ThenUintptrImpl) GetUintptrReturn() *uintptr {
	return __.UintptrRtn.Get().(*uintptr)
}
func (__ *PoolOfInt16ThenUintptrImpl) PutUintptrReturn(p *uintptr) {
	__.UintptrRtn.Put(p)
}

func (__ *PoolOfInt16ThenUintptrImpl) GetWorkOfInt16ThenUintptr() *WorkOfInt16ThenUintptr {
	return __.Int16Work.Get().(*WorkOfInt16ThenUintptr)
}
func (__ *PoolOfInt16ThenUintptrImpl) PutWorkOfInt16ThenUintptr(p *WorkOfInt16ThenUintptr) {
	__.Int16Work.Put(p)
}
func (__ *PoolOfInt16ThenUintptrImpl) GetReturnOfUintptr() *ReturnOfUintptr {
	return __.UintptrReturn.Get().(*ReturnOfUintptr)
}
func (__ *PoolOfInt16ThenUintptrImpl) PutReturnOfUintptr(p *ReturnOfUintptr) {
	__.UintptrReturn.Put(p)
}

func (__ *PoolOfInt16ThenUintptrImpl) GetChReturnOfUintptr() chan *ReturnOfUintptr {
	return __.ChReturnOfUintptr.Get().(chan *ReturnOfUintptr)
}
func (__ *PoolOfInt16ThenUintptrImpl) PutChReturnOfUintptr(p chan *ReturnOfUintptr) {
	__.ChReturnOfUintptr.Put(p)
}

func NewPoolOfInt16ThenUintptrImpl() *PoolOfInt16ThenUintptrImpl {
	return &PoolOfInt16ThenUintptrImpl{
		Int16Arg: sync.Pool{
			New: func() interface{} {
				return new(int16)
			},
		},
		Int16Work: sync.Pool{
			New: func() interface{} {
				return new(WorkOfInt16ThenUintptr)
			},
		},
		UintptrRtn: sync.Pool{
			New: func() interface{} {
				return new(uintptr)
			},
		},
		UintptrReturn: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfUintptr)
			},
		},
		ChReturnOfUintptr: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfUintptr, 1)
			},
		},
	}
}

type ApiDecouplerOfInt16ThenUintptr struct {
	pool PoolOfInt16ThenUintptr
}

func NewApiDecouplerOfInt16ThenUintptr() *ApiDecouplerOfInt16ThenUintptr {
	return &ApiDecouplerOfInt16ThenUintptr{
		pool: NewPoolOfInt16ThenUintptrImpl(),
	}
}

func (__ *ApiDecouplerOfInt16ThenUintptr) ReturnError(rtn_ch chan<- *ReturnOfUintptr, err error) {
	rtn := __.pool.GetReturnOfUintptr()
	var other uintptr
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfInt16ThenUintptr) HandleOfInt16ThenUintptr(ctx context.Context, req *WorkOfInt16ThenUintptr, h func(ctx context.Context, arg int16) (uintptr, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfUintptr()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfInt16ThenUintptr) DoOfInt16ThenUintptr(ctx context.Context, worker WorkerOfPushInt16ThenUintptr, arg int16) (uintptr, error) {
	// ch := make(chan *ReturnOfUintptr, 1)
	ch := __.pool.GetChReturnOfUintptr()
	defer __.pool.PutChReturnOfUintptr(ch)

	req := __.pool.GetWorkOfInt16ThenUintptr()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfInt16ThenUintptr(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfUintptr(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfInt16ThenUintptr = func(ctx context.Context, arg int16) (uintptr, error)

type WorkerOfInt16ThenUintptr struct {
	api_syncer *ApiDecouplerOfInt16ThenUintptr
	handler    WorkHandlerOfInt16ThenUintptr

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfInt16ThenUintptr
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfInt16ThenUintptr(ctx context.Context, h WorkHandlerOfInt16ThenUintptr, n int) *WorkerOfInt16ThenUintptr {
	__ := &WorkerOfInt16ThenUintptr{
		api_syncer: NewApiDecouplerOfInt16ThenUintptr(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfInt16ThenUintptr, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfInt16ThenUintptr{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfInt16ThenUintptr(req.Context, req.WorkOfInt16ThenUintptr, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfInt16ThenUintptr) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfInt16ThenUintptr) Push(ctx context.Context, req *WorkOfInt16ThenUintptr) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfInt16ThenUintptr)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfInt16ThenUintptr = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfInt16ThenUintptr) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfInt16ThenUintptr) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfInt16ThenUintptr) Call(ctx context.Context, arg int16) (uintptr, error) {
	return __.api_syncer.DoOfInt16ThenUintptr(ctx, __, arg)
}

type PoolOfInt16ThenInterface interface {
	GetInt16Arg() *int16
	PutInt16Arg(*int16)
	GetInterfaceReturn() *interface{}
	PutInterfaceReturn(*interface{})

	GetWorkOfInt16ThenInterface() *WorkOfInt16ThenInterface
	GetReturnOfInterface() *ReturnOfInterface
	PutWorkOfInt16ThenInterface(*WorkOfInt16ThenInterface)
	PutReturnOfInterface(*ReturnOfInterface)

	GetChReturnOfInterface() chan *ReturnOfInterface
	PutChReturnOfInterface(chan *ReturnOfInterface)
}

type PoolOfInt16ThenInterfaceImpl struct {
	Int16Arg            sync.Pool
	InterfaceRtn        sync.Pool
	Int16Work           sync.Pool
	InterfaceReturn     sync.Pool
	ChReturnOfInterface sync.Pool
}

func (__ *PoolOfInt16ThenInterfaceImpl) GetInt16Arg() *int16 {
	return __.Int16Arg.Get().(*int16)
}
func (__ *PoolOfInt16ThenInterfaceImpl) PutInt16Arg(p *int16) {
	__.Int16Arg.Put(p)
}
func (__ *PoolOfInt16ThenInterfaceImpl) GetInterfaceReturn() *interface{} {
	return __.InterfaceRtn.Get().(*interface{})
}
func (__ *PoolOfInt16ThenInterfaceImpl) PutInterfaceReturn(p *interface{}) {
	__.InterfaceRtn.Put(p)
}

func (__ *PoolOfInt16ThenInterfaceImpl) GetWorkOfInt16ThenInterface() *WorkOfInt16ThenInterface {
	return __.Int16Work.Get().(*WorkOfInt16ThenInterface)
}
func (__ *PoolOfInt16ThenInterfaceImpl) PutWorkOfInt16ThenInterface(p *WorkOfInt16ThenInterface) {
	__.Int16Work.Put(p)
}
func (__ *PoolOfInt16ThenInterfaceImpl) GetReturnOfInterface() *ReturnOfInterface {
	return __.InterfaceReturn.Get().(*ReturnOfInterface)
}
func (__ *PoolOfInt16ThenInterfaceImpl) PutReturnOfInterface(p *ReturnOfInterface) {
	__.InterfaceReturn.Put(p)
}

func (__ *PoolOfInt16ThenInterfaceImpl) GetChReturnOfInterface() chan *ReturnOfInterface {
	return __.ChReturnOfInterface.Get().(chan *ReturnOfInterface)
}
func (__ *PoolOfInt16ThenInterfaceImpl) PutChReturnOfInterface(p chan *ReturnOfInterface) {
	__.ChReturnOfInterface.Put(p)
}

func NewPoolOfInt16ThenInterfaceImpl() *PoolOfInt16ThenInterfaceImpl {
	return &PoolOfInt16ThenInterfaceImpl{
		Int16Arg: sync.Pool{
			New: func() interface{} {
				return new(int16)
			},
		},
		Int16Work: sync.Pool{
			New: func() interface{} {
				return new(WorkOfInt16ThenInterface)
			},
		},
		InterfaceRtn: sync.Pool{
			New: func() interface{} {
				return new(interface{})
			},
		},
		InterfaceReturn: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfInterface)
			},
		},
		ChReturnOfInterface: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfInterface, 1)
			},
		},
	}
}

type ApiDecouplerOfInt16ThenInterface struct {
	pool PoolOfInt16ThenInterface
}

func NewApiDecouplerOfInt16ThenInterface() *ApiDecouplerOfInt16ThenInterface {
	return &ApiDecouplerOfInt16ThenInterface{
		pool: NewPoolOfInt16ThenInterfaceImpl(),
	}
}

func (__ *ApiDecouplerOfInt16ThenInterface) ReturnError(rtn_ch chan<- *ReturnOfInterface, err error) {
	rtn := __.pool.GetReturnOfInterface()
	var other interface{}
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfInt16ThenInterface) HandleOfInt16ThenInterface(ctx context.Context, req *WorkOfInt16ThenInterface, h func(ctx context.Context, arg int16) (interface{}, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfInterface()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfInt16ThenInterface) DoOfInt16ThenInterface(ctx context.Context, worker WorkerOfPushInt16ThenInterface, arg int16) (interface{}, error) {
	// ch := make(chan *ReturnOfInterface, 1)
	ch := __.pool.GetChReturnOfInterface()
	defer __.pool.PutChReturnOfInterface(ch)

	req := __.pool.GetWorkOfInt16ThenInterface()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfInt16ThenInterface(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfInterface(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfInt16ThenInterface = func(ctx context.Context, arg int16) (interface{}, error)

type WorkerOfInt16ThenInterface struct {
	api_syncer *ApiDecouplerOfInt16ThenInterface
	handler    WorkHandlerOfInt16ThenInterface

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfInt16ThenInterface
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfInt16ThenInterface(ctx context.Context, h WorkHandlerOfInt16ThenInterface, n int) *WorkerOfInt16ThenInterface {
	__ := &WorkerOfInt16ThenInterface{
		api_syncer: NewApiDecouplerOfInt16ThenInterface(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfInt16ThenInterface, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfInt16ThenInterface{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfInt16ThenInterface(req.Context, req.WorkOfInt16ThenInterface, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfInt16ThenInterface) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfInt16ThenInterface) Push(ctx context.Context, req *WorkOfInt16ThenInterface) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfInt16ThenInterface)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfInt16ThenInterface = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfInt16ThenInterface) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfInt16ThenInterface) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfInt16ThenInterface) Call(ctx context.Context, arg int16) (interface{}, error) {
	return __.api_syncer.DoOfInt16ThenInterface(ctx, __, arg)
}

type PoolOfInt16ThenStruct interface {
	GetInt16Arg() *int16
	PutInt16Arg(*int16)
	GetStructReturn() *struct{}
	PutStructReturn(*struct{})

	GetWorkOfInt16ThenStruct() *WorkOfInt16ThenStruct
	GetReturnOfStruct() *ReturnOfStruct
	PutWorkOfInt16ThenStruct(*WorkOfInt16ThenStruct)
	PutReturnOfStruct(*ReturnOfStruct)

	GetChReturnOfStruct() chan *ReturnOfStruct
	PutChReturnOfStruct(chan *ReturnOfStruct)
}

type PoolOfInt16ThenStructImpl struct {
	Int16Arg         sync.Pool
	StructRtn        sync.Pool
	Int16Work        sync.Pool
	StructReturn     sync.Pool
	ChReturnOfStruct sync.Pool
}

func (__ *PoolOfInt16ThenStructImpl) GetInt16Arg() *int16 {
	return __.Int16Arg.Get().(*int16)
}
func (__ *PoolOfInt16ThenStructImpl) PutInt16Arg(p *int16) {
	__.Int16Arg.Put(p)
}
func (__ *PoolOfInt16ThenStructImpl) GetStructReturn() *struct{} {
	return __.StructRtn.Get().(*struct{})
}
func (__ *PoolOfInt16ThenStructImpl) PutStructReturn(p *struct{}) {
	__.StructRtn.Put(p)
}

func (__ *PoolOfInt16ThenStructImpl) GetWorkOfInt16ThenStruct() *WorkOfInt16ThenStruct {
	return __.Int16Work.Get().(*WorkOfInt16ThenStruct)
}
func (__ *PoolOfInt16ThenStructImpl) PutWorkOfInt16ThenStruct(p *WorkOfInt16ThenStruct) {
	__.Int16Work.Put(p)
}
func (__ *PoolOfInt16ThenStructImpl) GetReturnOfStruct() *ReturnOfStruct {
	return __.StructReturn.Get().(*ReturnOfStruct)
}
func (__ *PoolOfInt16ThenStructImpl) PutReturnOfStruct(p *ReturnOfStruct) {
	__.StructReturn.Put(p)
}

func (__ *PoolOfInt16ThenStructImpl) GetChReturnOfStruct() chan *ReturnOfStruct {
	return __.ChReturnOfStruct.Get().(chan *ReturnOfStruct)
}
func (__ *PoolOfInt16ThenStructImpl) PutChReturnOfStruct(p chan *ReturnOfStruct) {
	__.ChReturnOfStruct.Put(p)
}

func NewPoolOfInt16ThenStructImpl() *PoolOfInt16ThenStructImpl {
	return &PoolOfInt16ThenStructImpl{
		Int16Arg: sync.Pool{
			New: func() interface{} {
				return new(int16)
			},
		},
		Int16Work: sync.Pool{
			New: func() interface{} {
				return new(WorkOfInt16ThenStruct)
			},
		},
		StructRtn: sync.Pool{
			New: func() interface{} {
				return new(struct{})
			},
		},
		StructReturn: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfStruct)
			},
		},
		ChReturnOfStruct: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfStruct, 1)
			},
		},
	}
}

type ApiDecouplerOfInt16ThenStruct struct {
	pool PoolOfInt16ThenStruct
}

func NewApiDecouplerOfInt16ThenStruct() *ApiDecouplerOfInt16ThenStruct {
	return &ApiDecouplerOfInt16ThenStruct{
		pool: NewPoolOfInt16ThenStructImpl(),
	}
}

func (__ *ApiDecouplerOfInt16ThenStruct) ReturnError(rtn_ch chan<- *ReturnOfStruct, err error) {
	rtn := __.pool.GetReturnOfStruct()
	var other struct{}
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfInt16ThenStruct) HandleOfInt16ThenStruct(ctx context.Context, req *WorkOfInt16ThenStruct, h func(ctx context.Context, arg int16) (struct{}, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfStruct()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfInt16ThenStruct) DoOfInt16ThenStruct(ctx context.Context, worker WorkerOfPushInt16ThenStruct, arg int16) (struct{}, error) {
	// ch := make(chan *ReturnOfStruct, 1)
	ch := __.pool.GetChReturnOfStruct()
	defer __.pool.PutChReturnOfStruct(ch)

	req := __.pool.GetWorkOfInt16ThenStruct()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfInt16ThenStruct(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfStruct(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfInt16ThenStruct = func(ctx context.Context, arg int16) (struct{}, error)

type WorkerOfInt16ThenStruct struct {
	api_syncer *ApiDecouplerOfInt16ThenStruct
	handler    WorkHandlerOfInt16ThenStruct

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfInt16ThenStruct
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfInt16ThenStruct(ctx context.Context, h WorkHandlerOfInt16ThenStruct, n int) *WorkerOfInt16ThenStruct {
	__ := &WorkerOfInt16ThenStruct{
		api_syncer: NewApiDecouplerOfInt16ThenStruct(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfInt16ThenStruct, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfInt16ThenStruct{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfInt16ThenStruct(req.Context, req.WorkOfInt16ThenStruct, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfInt16ThenStruct) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfInt16ThenStruct) Push(ctx context.Context, req *WorkOfInt16ThenStruct) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfInt16ThenStruct)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfInt16ThenStruct = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfInt16ThenStruct) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfInt16ThenStruct) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfInt16ThenStruct) Call(ctx context.Context, arg int16) (struct{}, error) {
	return __.api_syncer.DoOfInt16ThenStruct(ctx, __, arg)
}

type PoolOfInt32ThenBool interface {
	GetInt32Arg() *int32
	PutInt32Arg(*int32)
	GetBoolReturn() *bool
	PutBoolReturn(*bool)

	GetWorkOfInt32ThenBool() *WorkOfInt32ThenBool
	GetReturnOfBool() *ReturnOfBool
	PutWorkOfInt32ThenBool(*WorkOfInt32ThenBool)
	PutReturnOfBool(*ReturnOfBool)

	GetChReturnOfBool() chan *ReturnOfBool
	PutChReturnOfBool(chan *ReturnOfBool)
}

type PoolOfInt32ThenBoolImpl struct {
	Int32Arg       sync.Pool
	BoolRtn        sync.Pool
	Int32Work      sync.Pool
	BoolReturn     sync.Pool
	ChReturnOfBool sync.Pool
}

func (__ *PoolOfInt32ThenBoolImpl) GetInt32Arg() *int32 {
	return __.Int32Arg.Get().(*int32)
}
func (__ *PoolOfInt32ThenBoolImpl) PutInt32Arg(p *int32) {
	__.Int32Arg.Put(p)
}
func (__ *PoolOfInt32ThenBoolImpl) GetBoolReturn() *bool {
	return __.BoolRtn.Get().(*bool)
}
func (__ *PoolOfInt32ThenBoolImpl) PutBoolReturn(p *bool) {
	__.BoolRtn.Put(p)
}

func (__ *PoolOfInt32ThenBoolImpl) GetWorkOfInt32ThenBool() *WorkOfInt32ThenBool {
	return __.Int32Work.Get().(*WorkOfInt32ThenBool)
}
func (__ *PoolOfInt32ThenBoolImpl) PutWorkOfInt32ThenBool(p *WorkOfInt32ThenBool) {
	__.Int32Work.Put(p)
}
func (__ *PoolOfInt32ThenBoolImpl) GetReturnOfBool() *ReturnOfBool {
	return __.BoolReturn.Get().(*ReturnOfBool)
}
func (__ *PoolOfInt32ThenBoolImpl) PutReturnOfBool(p *ReturnOfBool) {
	__.BoolReturn.Put(p)
}

func (__ *PoolOfInt32ThenBoolImpl) GetChReturnOfBool() chan *ReturnOfBool {
	return __.ChReturnOfBool.Get().(chan *ReturnOfBool)
}
func (__ *PoolOfInt32ThenBoolImpl) PutChReturnOfBool(p chan *ReturnOfBool) {
	__.ChReturnOfBool.Put(p)
}

func NewPoolOfInt32ThenBoolImpl() *PoolOfInt32ThenBoolImpl {
	return &PoolOfInt32ThenBoolImpl{
		Int32Arg: sync.Pool{
			New: func() interface{} {
				return new(int32)
			},
		},
		Int32Work: sync.Pool{
			New: func() interface{} {
				return new(WorkOfInt32ThenBool)
			},
		},
		BoolRtn: sync.Pool{
			New: func() interface{} {
				return new(bool)
			},
		},
		BoolReturn: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfBool)
			},
		},
		ChReturnOfBool: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfBool, 1)
			},
		},
	}
}

type ApiDecouplerOfInt32ThenBool struct {
	pool PoolOfInt32ThenBool
}

func NewApiDecouplerOfInt32ThenBool() *ApiDecouplerOfInt32ThenBool {
	return &ApiDecouplerOfInt32ThenBool{
		pool: NewPoolOfInt32ThenBoolImpl(),
	}
}

func (__ *ApiDecouplerOfInt32ThenBool) ReturnError(rtn_ch chan<- *ReturnOfBool, err error) {
	rtn := __.pool.GetReturnOfBool()
	var other bool
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfInt32ThenBool) HandleOfInt32ThenBool(ctx context.Context, req *WorkOfInt32ThenBool, h func(ctx context.Context, arg int32) (bool, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfBool()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfInt32ThenBool) DoOfInt32ThenBool(ctx context.Context, worker WorkerOfPushInt32ThenBool, arg int32) (bool, error) {
	// ch := make(chan *ReturnOfBool, 1)
	ch := __.pool.GetChReturnOfBool()
	defer __.pool.PutChReturnOfBool(ch)

	req := __.pool.GetWorkOfInt32ThenBool()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfInt32ThenBool(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfBool(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfInt32ThenBool = func(ctx context.Context, arg int32) (bool, error)

type WorkerOfInt32ThenBool struct {
	api_syncer *ApiDecouplerOfInt32ThenBool
	handler    WorkHandlerOfInt32ThenBool

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfInt32ThenBool
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfInt32ThenBool(ctx context.Context, h WorkHandlerOfInt32ThenBool, n int) *WorkerOfInt32ThenBool {
	__ := &WorkerOfInt32ThenBool{
		api_syncer: NewApiDecouplerOfInt32ThenBool(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfInt32ThenBool, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfInt32ThenBool{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfInt32ThenBool(req.Context, req.WorkOfInt32ThenBool, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfInt32ThenBool) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfInt32ThenBool) Push(ctx context.Context, req *WorkOfInt32ThenBool) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfInt32ThenBool)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfInt32ThenBool = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfInt32ThenBool) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfInt32ThenBool) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfInt32ThenBool) Call(ctx context.Context, arg int32) (bool, error) {
	return __.api_syncer.DoOfInt32ThenBool(ctx, __, arg)
}

type PoolOfInt32ThenByte interface {
	GetInt32Arg() *int32
	PutInt32Arg(*int32)
	GetByteReturn() *byte
	PutByteReturn(*byte)

	GetWorkOfInt32ThenByte() *WorkOfInt32ThenByte
	GetReturnOfByte() *ReturnOfByte
	PutWorkOfInt32ThenByte(*WorkOfInt32ThenByte)
	PutReturnOfByte(*ReturnOfByte)

	GetChReturnOfByte() chan *ReturnOfByte
	PutChReturnOfByte(chan *ReturnOfByte)
}

type PoolOfInt32ThenByteImpl struct {
	Int32Arg       sync.Pool
	ByteRtn        sync.Pool
	Int32Work      sync.Pool
	ByteReturn     sync.Pool
	ChReturnOfByte sync.Pool
}

func (__ *PoolOfInt32ThenByteImpl) GetInt32Arg() *int32 {
	return __.Int32Arg.Get().(*int32)
}
func (__ *PoolOfInt32ThenByteImpl) PutInt32Arg(p *int32) {
	__.Int32Arg.Put(p)
}
func (__ *PoolOfInt32ThenByteImpl) GetByteReturn() *byte {
	return __.ByteRtn.Get().(*byte)
}
func (__ *PoolOfInt32ThenByteImpl) PutByteReturn(p *byte) {
	__.ByteRtn.Put(p)
}

func (__ *PoolOfInt32ThenByteImpl) GetWorkOfInt32ThenByte() *WorkOfInt32ThenByte {
	return __.Int32Work.Get().(*WorkOfInt32ThenByte)
}
func (__ *PoolOfInt32ThenByteImpl) PutWorkOfInt32ThenByte(p *WorkOfInt32ThenByte) {
	__.Int32Work.Put(p)
}
func (__ *PoolOfInt32ThenByteImpl) GetReturnOfByte() *ReturnOfByte {
	return __.ByteReturn.Get().(*ReturnOfByte)
}
func (__ *PoolOfInt32ThenByteImpl) PutReturnOfByte(p *ReturnOfByte) {
	__.ByteReturn.Put(p)
}

func (__ *PoolOfInt32ThenByteImpl) GetChReturnOfByte() chan *ReturnOfByte {
	return __.ChReturnOfByte.Get().(chan *ReturnOfByte)
}
func (__ *PoolOfInt32ThenByteImpl) PutChReturnOfByte(p chan *ReturnOfByte) {
	__.ChReturnOfByte.Put(p)
}

func NewPoolOfInt32ThenByteImpl() *PoolOfInt32ThenByteImpl {
	return &PoolOfInt32ThenByteImpl{
		Int32Arg: sync.Pool{
			New: func() interface{} {
				return new(int32)
			},
		},
		Int32Work: sync.Pool{
			New: func() interface{} {
				return new(WorkOfInt32ThenByte)
			},
		},
		ByteRtn: sync.Pool{
			New: func() interface{} {
				return new(byte)
			},
		},
		ByteReturn: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfByte)
			},
		},
		ChReturnOfByte: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfByte, 1)
			},
		},
	}
}

type ApiDecouplerOfInt32ThenByte struct {
	pool PoolOfInt32ThenByte
}

func NewApiDecouplerOfInt32ThenByte() *ApiDecouplerOfInt32ThenByte {
	return &ApiDecouplerOfInt32ThenByte{
		pool: NewPoolOfInt32ThenByteImpl(),
	}
}

func (__ *ApiDecouplerOfInt32ThenByte) ReturnError(rtn_ch chan<- *ReturnOfByte, err error) {
	rtn := __.pool.GetReturnOfByte()
	var other byte
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfInt32ThenByte) HandleOfInt32ThenByte(ctx context.Context, req *WorkOfInt32ThenByte, h func(ctx context.Context, arg int32) (byte, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfByte()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfInt32ThenByte) DoOfInt32ThenByte(ctx context.Context, worker WorkerOfPushInt32ThenByte, arg int32) (byte, error) {
	// ch := make(chan *ReturnOfByte, 1)
	ch := __.pool.GetChReturnOfByte()
	defer __.pool.PutChReturnOfByte(ch)

	req := __.pool.GetWorkOfInt32ThenByte()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfInt32ThenByte(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfByte(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfInt32ThenByte = func(ctx context.Context, arg int32) (byte, error)

type WorkerOfInt32ThenByte struct {
	api_syncer *ApiDecouplerOfInt32ThenByte
	handler    WorkHandlerOfInt32ThenByte

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfInt32ThenByte
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfInt32ThenByte(ctx context.Context, h WorkHandlerOfInt32ThenByte, n int) *WorkerOfInt32ThenByte {
	__ := &WorkerOfInt32ThenByte{
		api_syncer: NewApiDecouplerOfInt32ThenByte(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfInt32ThenByte, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfInt32ThenByte{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfInt32ThenByte(req.Context, req.WorkOfInt32ThenByte, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfInt32ThenByte) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfInt32ThenByte) Push(ctx context.Context, req *WorkOfInt32ThenByte) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfInt32ThenByte)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfInt32ThenByte = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfInt32ThenByte) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfInt32ThenByte) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfInt32ThenByte) Call(ctx context.Context, arg int32) (byte, error) {
	return __.api_syncer.DoOfInt32ThenByte(ctx, __, arg)
}

type PoolOfInt32ThenComplex128 interface {
	GetInt32Arg() *int32
	PutInt32Arg(*int32)
	GetComplex128Return() *complex128
	PutComplex128Return(*complex128)

	GetWorkOfInt32ThenComplex128() *WorkOfInt32ThenComplex128
	GetReturnOfComplex128() *ReturnOfComplex128
	PutWorkOfInt32ThenComplex128(*WorkOfInt32ThenComplex128)
	PutReturnOfComplex128(*ReturnOfComplex128)

	GetChReturnOfComplex128() chan *ReturnOfComplex128
	PutChReturnOfComplex128(chan *ReturnOfComplex128)
}

type PoolOfInt32ThenComplex128Impl struct {
	Int32Arg             sync.Pool
	Complex128Rtn        sync.Pool
	Int32Work            sync.Pool
	Complex128Return     sync.Pool
	ChReturnOfComplex128 sync.Pool
}

func (__ *PoolOfInt32ThenComplex128Impl) GetInt32Arg() *int32 {
	return __.Int32Arg.Get().(*int32)
}
func (__ *PoolOfInt32ThenComplex128Impl) PutInt32Arg(p *int32) {
	__.Int32Arg.Put(p)
}
func (__ *PoolOfInt32ThenComplex128Impl) GetComplex128Return() *complex128 {
	return __.Complex128Rtn.Get().(*complex128)
}
func (__ *PoolOfInt32ThenComplex128Impl) PutComplex128Return(p *complex128) {
	__.Complex128Rtn.Put(p)
}

func (__ *PoolOfInt32ThenComplex128Impl) GetWorkOfInt32ThenComplex128() *WorkOfInt32ThenComplex128 {
	return __.Int32Work.Get().(*WorkOfInt32ThenComplex128)
}
func (__ *PoolOfInt32ThenComplex128Impl) PutWorkOfInt32ThenComplex128(p *WorkOfInt32ThenComplex128) {
	__.Int32Work.Put(p)
}
func (__ *PoolOfInt32ThenComplex128Impl) GetReturnOfComplex128() *ReturnOfComplex128 {
	return __.Complex128Return.Get().(*ReturnOfComplex128)
}
func (__ *PoolOfInt32ThenComplex128Impl) PutReturnOfComplex128(p *ReturnOfComplex128) {
	__.Complex128Return.Put(p)
}

func (__ *PoolOfInt32ThenComplex128Impl) GetChReturnOfComplex128() chan *ReturnOfComplex128 {
	return __.ChReturnOfComplex128.Get().(chan *ReturnOfComplex128)
}
func (__ *PoolOfInt32ThenComplex128Impl) PutChReturnOfComplex128(p chan *ReturnOfComplex128) {
	__.ChReturnOfComplex128.Put(p)
}

func NewPoolOfInt32ThenComplex128Impl() *PoolOfInt32ThenComplex128Impl {
	return &PoolOfInt32ThenComplex128Impl{
		Int32Arg: sync.Pool{
			New: func() interface{} {
				return new(int32)
			},
		},
		Int32Work: sync.Pool{
			New: func() interface{} {
				return new(WorkOfInt32ThenComplex128)
			},
		},
		Complex128Rtn: sync.Pool{
			New: func() interface{} {
				return new(complex128)
			},
		},
		Complex128Return: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfComplex128)
			},
		},
		ChReturnOfComplex128: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfComplex128, 1)
			},
		},
	}
}

type ApiDecouplerOfInt32ThenComplex128 struct {
	pool PoolOfInt32ThenComplex128
}

func NewApiDecouplerOfInt32ThenComplex128() *ApiDecouplerOfInt32ThenComplex128 {
	return &ApiDecouplerOfInt32ThenComplex128{
		pool: NewPoolOfInt32ThenComplex128Impl(),
	}
}

func (__ *ApiDecouplerOfInt32ThenComplex128) ReturnError(rtn_ch chan<- *ReturnOfComplex128, err error) {
	rtn := __.pool.GetReturnOfComplex128()
	var other complex128
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfInt32ThenComplex128) HandleOfInt32ThenComplex128(ctx context.Context, req *WorkOfInt32ThenComplex128, h func(ctx context.Context, arg int32) (complex128, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfComplex128()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfInt32ThenComplex128) DoOfInt32ThenComplex128(ctx context.Context, worker WorkerOfPushInt32ThenComplex128, arg int32) (complex128, error) {
	// ch := make(chan *ReturnOfComplex128, 1)
	ch := __.pool.GetChReturnOfComplex128()
	defer __.pool.PutChReturnOfComplex128(ch)

	req := __.pool.GetWorkOfInt32ThenComplex128()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfInt32ThenComplex128(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfComplex128(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfInt32ThenComplex128 = func(ctx context.Context, arg int32) (complex128, error)

type WorkerOfInt32ThenComplex128 struct {
	api_syncer *ApiDecouplerOfInt32ThenComplex128
	handler    WorkHandlerOfInt32ThenComplex128

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfInt32ThenComplex128
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfInt32ThenComplex128(ctx context.Context, h WorkHandlerOfInt32ThenComplex128, n int) *WorkerOfInt32ThenComplex128 {
	__ := &WorkerOfInt32ThenComplex128{
		api_syncer: NewApiDecouplerOfInt32ThenComplex128(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfInt32ThenComplex128, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfInt32ThenComplex128{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfInt32ThenComplex128(req.Context, req.WorkOfInt32ThenComplex128, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfInt32ThenComplex128) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfInt32ThenComplex128) Push(ctx context.Context, req *WorkOfInt32ThenComplex128) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfInt32ThenComplex128)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfInt32ThenComplex128 = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfInt32ThenComplex128) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfInt32ThenComplex128) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfInt32ThenComplex128) Call(ctx context.Context, arg int32) (complex128, error) {
	return __.api_syncer.DoOfInt32ThenComplex128(ctx, __, arg)
}

type PoolOfInt32ThenComplex64 interface {
	GetInt32Arg() *int32
	PutInt32Arg(*int32)
	GetComplex64Return() *complex64
	PutComplex64Return(*complex64)

	GetWorkOfInt32ThenComplex64() *WorkOfInt32ThenComplex64
	GetReturnOfComplex64() *ReturnOfComplex64
	PutWorkOfInt32ThenComplex64(*WorkOfInt32ThenComplex64)
	PutReturnOfComplex64(*ReturnOfComplex64)

	GetChReturnOfComplex64() chan *ReturnOfComplex64
	PutChReturnOfComplex64(chan *ReturnOfComplex64)
}

type PoolOfInt32ThenComplex64Impl struct {
	Int32Arg            sync.Pool
	Complex64Rtn        sync.Pool
	Int32Work           sync.Pool
	Complex64Return     sync.Pool
	ChReturnOfComplex64 sync.Pool
}

func (__ *PoolOfInt32ThenComplex64Impl) GetInt32Arg() *int32 {
	return __.Int32Arg.Get().(*int32)
}
func (__ *PoolOfInt32ThenComplex64Impl) PutInt32Arg(p *int32) {
	__.Int32Arg.Put(p)
}
func (__ *PoolOfInt32ThenComplex64Impl) GetComplex64Return() *complex64 {
	return __.Complex64Rtn.Get().(*complex64)
}
func (__ *PoolOfInt32ThenComplex64Impl) PutComplex64Return(p *complex64) {
	__.Complex64Rtn.Put(p)
}

func (__ *PoolOfInt32ThenComplex64Impl) GetWorkOfInt32ThenComplex64() *WorkOfInt32ThenComplex64 {
	return __.Int32Work.Get().(*WorkOfInt32ThenComplex64)
}
func (__ *PoolOfInt32ThenComplex64Impl) PutWorkOfInt32ThenComplex64(p *WorkOfInt32ThenComplex64) {
	__.Int32Work.Put(p)
}
func (__ *PoolOfInt32ThenComplex64Impl) GetReturnOfComplex64() *ReturnOfComplex64 {
	return __.Complex64Return.Get().(*ReturnOfComplex64)
}
func (__ *PoolOfInt32ThenComplex64Impl) PutReturnOfComplex64(p *ReturnOfComplex64) {
	__.Complex64Return.Put(p)
}

func (__ *PoolOfInt32ThenComplex64Impl) GetChReturnOfComplex64() chan *ReturnOfComplex64 {
	return __.ChReturnOfComplex64.Get().(chan *ReturnOfComplex64)
}
func (__ *PoolOfInt32ThenComplex64Impl) PutChReturnOfComplex64(p chan *ReturnOfComplex64) {
	__.ChReturnOfComplex64.Put(p)
}

func NewPoolOfInt32ThenComplex64Impl() *PoolOfInt32ThenComplex64Impl {
	return &PoolOfInt32ThenComplex64Impl{
		Int32Arg: sync.Pool{
			New: func() interface{} {
				return new(int32)
			},
		},
		Int32Work: sync.Pool{
			New: func() interface{} {
				return new(WorkOfInt32ThenComplex64)
			},
		},
		Complex64Rtn: sync.Pool{
			New: func() interface{} {
				return new(complex64)
			},
		},
		Complex64Return: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfComplex64)
			},
		},
		ChReturnOfComplex64: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfComplex64, 1)
			},
		},
	}
}

type ApiDecouplerOfInt32ThenComplex64 struct {
	pool PoolOfInt32ThenComplex64
}

func NewApiDecouplerOfInt32ThenComplex64() *ApiDecouplerOfInt32ThenComplex64 {
	return &ApiDecouplerOfInt32ThenComplex64{
		pool: NewPoolOfInt32ThenComplex64Impl(),
	}
}

func (__ *ApiDecouplerOfInt32ThenComplex64) ReturnError(rtn_ch chan<- *ReturnOfComplex64, err error) {
	rtn := __.pool.GetReturnOfComplex64()
	var other complex64
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfInt32ThenComplex64) HandleOfInt32ThenComplex64(ctx context.Context, req *WorkOfInt32ThenComplex64, h func(ctx context.Context, arg int32) (complex64, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfComplex64()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfInt32ThenComplex64) DoOfInt32ThenComplex64(ctx context.Context, worker WorkerOfPushInt32ThenComplex64, arg int32) (complex64, error) {
	// ch := make(chan *ReturnOfComplex64, 1)
	ch := __.pool.GetChReturnOfComplex64()
	defer __.pool.PutChReturnOfComplex64(ch)

	req := __.pool.GetWorkOfInt32ThenComplex64()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfInt32ThenComplex64(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfComplex64(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfInt32ThenComplex64 = func(ctx context.Context, arg int32) (complex64, error)

type WorkerOfInt32ThenComplex64 struct {
	api_syncer *ApiDecouplerOfInt32ThenComplex64
	handler    WorkHandlerOfInt32ThenComplex64

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfInt32ThenComplex64
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfInt32ThenComplex64(ctx context.Context, h WorkHandlerOfInt32ThenComplex64, n int) *WorkerOfInt32ThenComplex64 {
	__ := &WorkerOfInt32ThenComplex64{
		api_syncer: NewApiDecouplerOfInt32ThenComplex64(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfInt32ThenComplex64, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfInt32ThenComplex64{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfInt32ThenComplex64(req.Context, req.WorkOfInt32ThenComplex64, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfInt32ThenComplex64) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfInt32ThenComplex64) Push(ctx context.Context, req *WorkOfInt32ThenComplex64) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfInt32ThenComplex64)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfInt32ThenComplex64 = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfInt32ThenComplex64) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfInt32ThenComplex64) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfInt32ThenComplex64) Call(ctx context.Context, arg int32) (complex64, error) {
	return __.api_syncer.DoOfInt32ThenComplex64(ctx, __, arg)
}

type PoolOfInt32ThenError interface {
	GetInt32Arg() *int32
	PutInt32Arg(*int32)
	GetErrorReturn() *error
	PutErrorReturn(*error)

	GetWorkOfInt32ThenError() *WorkOfInt32ThenError
	GetReturnOfError() *ReturnOfError
	PutWorkOfInt32ThenError(*WorkOfInt32ThenError)
	PutReturnOfError(*ReturnOfError)

	GetChReturnOfError() chan *ReturnOfError
	PutChReturnOfError(chan *ReturnOfError)
}

type PoolOfInt32ThenErrorImpl struct {
	Int32Arg        sync.Pool
	ErrorRtn        sync.Pool
	Int32Work       sync.Pool
	ErrorReturn     sync.Pool
	ChReturnOfError sync.Pool
}

func (__ *PoolOfInt32ThenErrorImpl) GetInt32Arg() *int32 {
	return __.Int32Arg.Get().(*int32)
}
func (__ *PoolOfInt32ThenErrorImpl) PutInt32Arg(p *int32) {
	__.Int32Arg.Put(p)
}
func (__ *PoolOfInt32ThenErrorImpl) GetErrorReturn() *error {
	return __.ErrorRtn.Get().(*error)
}
func (__ *PoolOfInt32ThenErrorImpl) PutErrorReturn(p *error) {
	__.ErrorRtn.Put(p)
}

func (__ *PoolOfInt32ThenErrorImpl) GetWorkOfInt32ThenError() *WorkOfInt32ThenError {
	return __.Int32Work.Get().(*WorkOfInt32ThenError)
}
func (__ *PoolOfInt32ThenErrorImpl) PutWorkOfInt32ThenError(p *WorkOfInt32ThenError) {
	__.Int32Work.Put(p)
}
func (__ *PoolOfInt32ThenErrorImpl) GetReturnOfError() *ReturnOfError {
	return __.ErrorReturn.Get().(*ReturnOfError)
}
func (__ *PoolOfInt32ThenErrorImpl) PutReturnOfError(p *ReturnOfError) {
	__.ErrorReturn.Put(p)
}

func (__ *PoolOfInt32ThenErrorImpl) GetChReturnOfError() chan *ReturnOfError {
	return __.ChReturnOfError.Get().(chan *ReturnOfError)
}
func (__ *PoolOfInt32ThenErrorImpl) PutChReturnOfError(p chan *ReturnOfError) {
	__.ChReturnOfError.Put(p)
}

func NewPoolOfInt32ThenErrorImpl() *PoolOfInt32ThenErrorImpl {
	return &PoolOfInt32ThenErrorImpl{
		Int32Arg: sync.Pool{
			New: func() interface{} {
				return new(int32)
			},
		},
		Int32Work: sync.Pool{
			New: func() interface{} {
				return new(WorkOfInt32ThenError)
			},
		},
		ErrorRtn: sync.Pool{
			New: func() interface{} {
				return new(error)
			},
		},
		ErrorReturn: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfError)
			},
		},
		ChReturnOfError: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfError, 1)
			},
		},
	}
}

type ApiDecouplerOfInt32ThenError struct {
	pool PoolOfInt32ThenError
}

func NewApiDecouplerOfInt32ThenError() *ApiDecouplerOfInt32ThenError {
	return &ApiDecouplerOfInt32ThenError{
		pool: NewPoolOfInt32ThenErrorImpl(),
	}
}

func (__ *ApiDecouplerOfInt32ThenError) ReturnError(rtn_ch chan<- *ReturnOfError, err error) {
	rtn := __.pool.GetReturnOfError()
	var other error
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfInt32ThenError) HandleOfInt32ThenError(ctx context.Context, req *WorkOfInt32ThenError, h func(ctx context.Context, arg int32) (error, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfError()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfInt32ThenError) DoOfInt32ThenError(ctx context.Context, worker WorkerOfPushInt32ThenError, arg int32) (error, error) {
	// ch := make(chan *ReturnOfError, 1)
	ch := __.pool.GetChReturnOfError()
	defer __.pool.PutChReturnOfError(ch)

	req := __.pool.GetWorkOfInt32ThenError()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfInt32ThenError(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfError(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfInt32ThenError = func(ctx context.Context, arg int32) (error, error)

type WorkerOfInt32ThenError struct {
	api_syncer *ApiDecouplerOfInt32ThenError
	handler    WorkHandlerOfInt32ThenError

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfInt32ThenError
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfInt32ThenError(ctx context.Context, h WorkHandlerOfInt32ThenError, n int) *WorkerOfInt32ThenError {
	__ := &WorkerOfInt32ThenError{
		api_syncer: NewApiDecouplerOfInt32ThenError(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfInt32ThenError, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfInt32ThenError{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfInt32ThenError(req.Context, req.WorkOfInt32ThenError, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfInt32ThenError) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfInt32ThenError) Push(ctx context.Context, req *WorkOfInt32ThenError) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfInt32ThenError)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfInt32ThenError = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfInt32ThenError) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfInt32ThenError) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfInt32ThenError) Call(ctx context.Context, arg int32) (error, error) {
	return __.api_syncer.DoOfInt32ThenError(ctx, __, arg)
}

type PoolOfInt32ThenFloat32 interface {
	GetInt32Arg() *int32
	PutInt32Arg(*int32)
	GetFloat32Return() *float32
	PutFloat32Return(*float32)

	GetWorkOfInt32ThenFloat32() *WorkOfInt32ThenFloat32
	GetReturnOfFloat32() *ReturnOfFloat32
	PutWorkOfInt32ThenFloat32(*WorkOfInt32ThenFloat32)
	PutReturnOfFloat32(*ReturnOfFloat32)

	GetChReturnOfFloat32() chan *ReturnOfFloat32
	PutChReturnOfFloat32(chan *ReturnOfFloat32)
}

type PoolOfInt32ThenFloat32Impl struct {
	Int32Arg          sync.Pool
	Float32Rtn        sync.Pool
	Int32Work         sync.Pool
	Float32Return     sync.Pool
	ChReturnOfFloat32 sync.Pool
}

func (__ *PoolOfInt32ThenFloat32Impl) GetInt32Arg() *int32 {
	return __.Int32Arg.Get().(*int32)
}
func (__ *PoolOfInt32ThenFloat32Impl) PutInt32Arg(p *int32) {
	__.Int32Arg.Put(p)
}
func (__ *PoolOfInt32ThenFloat32Impl) GetFloat32Return() *float32 {
	return __.Float32Rtn.Get().(*float32)
}
func (__ *PoolOfInt32ThenFloat32Impl) PutFloat32Return(p *float32) {
	__.Float32Rtn.Put(p)
}

func (__ *PoolOfInt32ThenFloat32Impl) GetWorkOfInt32ThenFloat32() *WorkOfInt32ThenFloat32 {
	return __.Int32Work.Get().(*WorkOfInt32ThenFloat32)
}
func (__ *PoolOfInt32ThenFloat32Impl) PutWorkOfInt32ThenFloat32(p *WorkOfInt32ThenFloat32) {
	__.Int32Work.Put(p)
}
func (__ *PoolOfInt32ThenFloat32Impl) GetReturnOfFloat32() *ReturnOfFloat32 {
	return __.Float32Return.Get().(*ReturnOfFloat32)
}
func (__ *PoolOfInt32ThenFloat32Impl) PutReturnOfFloat32(p *ReturnOfFloat32) {
	__.Float32Return.Put(p)
}

func (__ *PoolOfInt32ThenFloat32Impl) GetChReturnOfFloat32() chan *ReturnOfFloat32 {
	return __.ChReturnOfFloat32.Get().(chan *ReturnOfFloat32)
}
func (__ *PoolOfInt32ThenFloat32Impl) PutChReturnOfFloat32(p chan *ReturnOfFloat32) {
	__.ChReturnOfFloat32.Put(p)
}

func NewPoolOfInt32ThenFloat32Impl() *PoolOfInt32ThenFloat32Impl {
	return &PoolOfInt32ThenFloat32Impl{
		Int32Arg: sync.Pool{
			New: func() interface{} {
				return new(int32)
			},
		},
		Int32Work: sync.Pool{
			New: func() interface{} {
				return new(WorkOfInt32ThenFloat32)
			},
		},
		Float32Rtn: sync.Pool{
			New: func() interface{} {
				return new(float32)
			},
		},
		Float32Return: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfFloat32)
			},
		},
		ChReturnOfFloat32: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfFloat32, 1)
			},
		},
	}
}

type ApiDecouplerOfInt32ThenFloat32 struct {
	pool PoolOfInt32ThenFloat32
}

func NewApiDecouplerOfInt32ThenFloat32() *ApiDecouplerOfInt32ThenFloat32 {
	return &ApiDecouplerOfInt32ThenFloat32{
		pool: NewPoolOfInt32ThenFloat32Impl(),
	}
}

func (__ *ApiDecouplerOfInt32ThenFloat32) ReturnError(rtn_ch chan<- *ReturnOfFloat32, err error) {
	rtn := __.pool.GetReturnOfFloat32()
	var other float32
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfInt32ThenFloat32) HandleOfInt32ThenFloat32(ctx context.Context, req *WorkOfInt32ThenFloat32, h func(ctx context.Context, arg int32) (float32, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfFloat32()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfInt32ThenFloat32) DoOfInt32ThenFloat32(ctx context.Context, worker WorkerOfPushInt32ThenFloat32, arg int32) (float32, error) {
	// ch := make(chan *ReturnOfFloat32, 1)
	ch := __.pool.GetChReturnOfFloat32()
	defer __.pool.PutChReturnOfFloat32(ch)

	req := __.pool.GetWorkOfInt32ThenFloat32()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfInt32ThenFloat32(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfFloat32(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfInt32ThenFloat32 = func(ctx context.Context, arg int32) (float32, error)

type WorkerOfInt32ThenFloat32 struct {
	api_syncer *ApiDecouplerOfInt32ThenFloat32
	handler    WorkHandlerOfInt32ThenFloat32

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfInt32ThenFloat32
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfInt32ThenFloat32(ctx context.Context, h WorkHandlerOfInt32ThenFloat32, n int) *WorkerOfInt32ThenFloat32 {
	__ := &WorkerOfInt32ThenFloat32{
		api_syncer: NewApiDecouplerOfInt32ThenFloat32(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfInt32ThenFloat32, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfInt32ThenFloat32{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfInt32ThenFloat32(req.Context, req.WorkOfInt32ThenFloat32, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfInt32ThenFloat32) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfInt32ThenFloat32) Push(ctx context.Context, req *WorkOfInt32ThenFloat32) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfInt32ThenFloat32)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfInt32ThenFloat32 = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfInt32ThenFloat32) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfInt32ThenFloat32) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfInt32ThenFloat32) Call(ctx context.Context, arg int32) (float32, error) {
	return __.api_syncer.DoOfInt32ThenFloat32(ctx, __, arg)
}

type PoolOfInt32ThenFloat64 interface {
	GetInt32Arg() *int32
	PutInt32Arg(*int32)
	GetFloat64Return() *float64
	PutFloat64Return(*float64)

	GetWorkOfInt32ThenFloat64() *WorkOfInt32ThenFloat64
	GetReturnOfFloat64() *ReturnOfFloat64
	PutWorkOfInt32ThenFloat64(*WorkOfInt32ThenFloat64)
	PutReturnOfFloat64(*ReturnOfFloat64)

	GetChReturnOfFloat64() chan *ReturnOfFloat64
	PutChReturnOfFloat64(chan *ReturnOfFloat64)
}

type PoolOfInt32ThenFloat64Impl struct {
	Int32Arg          sync.Pool
	Float64Rtn        sync.Pool
	Int32Work         sync.Pool
	Float64Return     sync.Pool
	ChReturnOfFloat64 sync.Pool
}

func (__ *PoolOfInt32ThenFloat64Impl) GetInt32Arg() *int32 {
	return __.Int32Arg.Get().(*int32)
}
func (__ *PoolOfInt32ThenFloat64Impl) PutInt32Arg(p *int32) {
	__.Int32Arg.Put(p)
}
func (__ *PoolOfInt32ThenFloat64Impl) GetFloat64Return() *float64 {
	return __.Float64Rtn.Get().(*float64)
}
func (__ *PoolOfInt32ThenFloat64Impl) PutFloat64Return(p *float64) {
	__.Float64Rtn.Put(p)
}

func (__ *PoolOfInt32ThenFloat64Impl) GetWorkOfInt32ThenFloat64() *WorkOfInt32ThenFloat64 {
	return __.Int32Work.Get().(*WorkOfInt32ThenFloat64)
}
func (__ *PoolOfInt32ThenFloat64Impl) PutWorkOfInt32ThenFloat64(p *WorkOfInt32ThenFloat64) {
	__.Int32Work.Put(p)
}
func (__ *PoolOfInt32ThenFloat64Impl) GetReturnOfFloat64() *ReturnOfFloat64 {
	return __.Float64Return.Get().(*ReturnOfFloat64)
}
func (__ *PoolOfInt32ThenFloat64Impl) PutReturnOfFloat64(p *ReturnOfFloat64) {
	__.Float64Return.Put(p)
}

func (__ *PoolOfInt32ThenFloat64Impl) GetChReturnOfFloat64() chan *ReturnOfFloat64 {
	return __.ChReturnOfFloat64.Get().(chan *ReturnOfFloat64)
}
func (__ *PoolOfInt32ThenFloat64Impl) PutChReturnOfFloat64(p chan *ReturnOfFloat64) {
	__.ChReturnOfFloat64.Put(p)
}

func NewPoolOfInt32ThenFloat64Impl() *PoolOfInt32ThenFloat64Impl {
	return &PoolOfInt32ThenFloat64Impl{
		Int32Arg: sync.Pool{
			New: func() interface{} {
				return new(int32)
			},
		},
		Int32Work: sync.Pool{
			New: func() interface{} {
				return new(WorkOfInt32ThenFloat64)
			},
		},
		Float64Rtn: sync.Pool{
			New: func() interface{} {
				return new(float64)
			},
		},
		Float64Return: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfFloat64)
			},
		},
		ChReturnOfFloat64: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfFloat64, 1)
			},
		},
	}
}

type ApiDecouplerOfInt32ThenFloat64 struct {
	pool PoolOfInt32ThenFloat64
}

func NewApiDecouplerOfInt32ThenFloat64() *ApiDecouplerOfInt32ThenFloat64 {
	return &ApiDecouplerOfInt32ThenFloat64{
		pool: NewPoolOfInt32ThenFloat64Impl(),
	}
}

func (__ *ApiDecouplerOfInt32ThenFloat64) ReturnError(rtn_ch chan<- *ReturnOfFloat64, err error) {
	rtn := __.pool.GetReturnOfFloat64()
	var other float64
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfInt32ThenFloat64) HandleOfInt32ThenFloat64(ctx context.Context, req *WorkOfInt32ThenFloat64, h func(ctx context.Context, arg int32) (float64, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfFloat64()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfInt32ThenFloat64) DoOfInt32ThenFloat64(ctx context.Context, worker WorkerOfPushInt32ThenFloat64, arg int32) (float64, error) {
	// ch := make(chan *ReturnOfFloat64, 1)
	ch := __.pool.GetChReturnOfFloat64()
	defer __.pool.PutChReturnOfFloat64(ch)

	req := __.pool.GetWorkOfInt32ThenFloat64()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfInt32ThenFloat64(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfFloat64(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfInt32ThenFloat64 = func(ctx context.Context, arg int32) (float64, error)

type WorkerOfInt32ThenFloat64 struct {
	api_syncer *ApiDecouplerOfInt32ThenFloat64
	handler    WorkHandlerOfInt32ThenFloat64

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfInt32ThenFloat64
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfInt32ThenFloat64(ctx context.Context, h WorkHandlerOfInt32ThenFloat64, n int) *WorkerOfInt32ThenFloat64 {
	__ := &WorkerOfInt32ThenFloat64{
		api_syncer: NewApiDecouplerOfInt32ThenFloat64(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfInt32ThenFloat64, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfInt32ThenFloat64{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfInt32ThenFloat64(req.Context, req.WorkOfInt32ThenFloat64, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfInt32ThenFloat64) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfInt32ThenFloat64) Push(ctx context.Context, req *WorkOfInt32ThenFloat64) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfInt32ThenFloat64)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfInt32ThenFloat64 = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfInt32ThenFloat64) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfInt32ThenFloat64) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfInt32ThenFloat64) Call(ctx context.Context, arg int32) (float64, error) {
	return __.api_syncer.DoOfInt32ThenFloat64(ctx, __, arg)
}

type PoolOfInt32ThenInt interface {
	GetInt32Arg() *int32
	PutInt32Arg(*int32)
	GetIntReturn() *int
	PutIntReturn(*int)

	GetWorkOfInt32ThenInt() *WorkOfInt32ThenInt
	GetReturnOfInt() *ReturnOfInt
	PutWorkOfInt32ThenInt(*WorkOfInt32ThenInt)
	PutReturnOfInt(*ReturnOfInt)

	GetChReturnOfInt() chan *ReturnOfInt
	PutChReturnOfInt(chan *ReturnOfInt)
}

type PoolOfInt32ThenIntImpl struct {
	Int32Arg      sync.Pool
	IntRtn        sync.Pool
	Int32Work     sync.Pool
	IntReturn     sync.Pool
	ChReturnOfInt sync.Pool
}

func (__ *PoolOfInt32ThenIntImpl) GetInt32Arg() *int32 {
	return __.Int32Arg.Get().(*int32)
}
func (__ *PoolOfInt32ThenIntImpl) PutInt32Arg(p *int32) {
	__.Int32Arg.Put(p)
}
func (__ *PoolOfInt32ThenIntImpl) GetIntReturn() *int {
	return __.IntRtn.Get().(*int)
}
func (__ *PoolOfInt32ThenIntImpl) PutIntReturn(p *int) {
	__.IntRtn.Put(p)
}

func (__ *PoolOfInt32ThenIntImpl) GetWorkOfInt32ThenInt() *WorkOfInt32ThenInt {
	return __.Int32Work.Get().(*WorkOfInt32ThenInt)
}
func (__ *PoolOfInt32ThenIntImpl) PutWorkOfInt32ThenInt(p *WorkOfInt32ThenInt) {
	__.Int32Work.Put(p)
}
func (__ *PoolOfInt32ThenIntImpl) GetReturnOfInt() *ReturnOfInt {
	return __.IntReturn.Get().(*ReturnOfInt)
}
func (__ *PoolOfInt32ThenIntImpl) PutReturnOfInt(p *ReturnOfInt) {
	__.IntReturn.Put(p)
}

func (__ *PoolOfInt32ThenIntImpl) GetChReturnOfInt() chan *ReturnOfInt {
	return __.ChReturnOfInt.Get().(chan *ReturnOfInt)
}
func (__ *PoolOfInt32ThenIntImpl) PutChReturnOfInt(p chan *ReturnOfInt) {
	__.ChReturnOfInt.Put(p)
}

func NewPoolOfInt32ThenIntImpl() *PoolOfInt32ThenIntImpl {
	return &PoolOfInt32ThenIntImpl{
		Int32Arg: sync.Pool{
			New: func() interface{} {
				return new(int32)
			},
		},
		Int32Work: sync.Pool{
			New: func() interface{} {
				return new(WorkOfInt32ThenInt)
			},
		},
		IntRtn: sync.Pool{
			New: func() interface{} {
				return new(int)
			},
		},
		IntReturn: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfInt)
			},
		},
		ChReturnOfInt: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfInt, 1)
			},
		},
	}
}

type ApiDecouplerOfInt32ThenInt struct {
	pool PoolOfInt32ThenInt
}

func NewApiDecouplerOfInt32ThenInt() *ApiDecouplerOfInt32ThenInt {
	return &ApiDecouplerOfInt32ThenInt{
		pool: NewPoolOfInt32ThenIntImpl(),
	}
}

func (__ *ApiDecouplerOfInt32ThenInt) ReturnError(rtn_ch chan<- *ReturnOfInt, err error) {
	rtn := __.pool.GetReturnOfInt()
	var other int
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfInt32ThenInt) HandleOfInt32ThenInt(ctx context.Context, req *WorkOfInt32ThenInt, h func(ctx context.Context, arg int32) (int, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfInt()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfInt32ThenInt) DoOfInt32ThenInt(ctx context.Context, worker WorkerOfPushInt32ThenInt, arg int32) (int, error) {
	// ch := make(chan *ReturnOfInt, 1)
	ch := __.pool.GetChReturnOfInt()
	defer __.pool.PutChReturnOfInt(ch)

	req := __.pool.GetWorkOfInt32ThenInt()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfInt32ThenInt(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfInt(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfInt32ThenInt = func(ctx context.Context, arg int32) (int, error)

type WorkerOfInt32ThenInt struct {
	api_syncer *ApiDecouplerOfInt32ThenInt
	handler    WorkHandlerOfInt32ThenInt

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfInt32ThenInt
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfInt32ThenInt(ctx context.Context, h WorkHandlerOfInt32ThenInt, n int) *WorkerOfInt32ThenInt {
	__ := &WorkerOfInt32ThenInt{
		api_syncer: NewApiDecouplerOfInt32ThenInt(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfInt32ThenInt, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfInt32ThenInt{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfInt32ThenInt(req.Context, req.WorkOfInt32ThenInt, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfInt32ThenInt) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfInt32ThenInt) Push(ctx context.Context, req *WorkOfInt32ThenInt) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfInt32ThenInt)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfInt32ThenInt = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfInt32ThenInt) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfInt32ThenInt) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfInt32ThenInt) Call(ctx context.Context, arg int32) (int, error) {
	return __.api_syncer.DoOfInt32ThenInt(ctx, __, arg)
}

type PoolOfInt32ThenInt16 interface {
	GetInt32Arg() *int32
	PutInt32Arg(*int32)
	GetInt16Return() *int16
	PutInt16Return(*int16)

	GetWorkOfInt32ThenInt16() *WorkOfInt32ThenInt16
	GetReturnOfInt16() *ReturnOfInt16
	PutWorkOfInt32ThenInt16(*WorkOfInt32ThenInt16)
	PutReturnOfInt16(*ReturnOfInt16)

	GetChReturnOfInt16() chan *ReturnOfInt16
	PutChReturnOfInt16(chan *ReturnOfInt16)
}

type PoolOfInt32ThenInt16Impl struct {
	Int32Arg        sync.Pool
	Int16Rtn        sync.Pool
	Int32Work       sync.Pool
	Int16Return     sync.Pool
	ChReturnOfInt16 sync.Pool
}

func (__ *PoolOfInt32ThenInt16Impl) GetInt32Arg() *int32 {
	return __.Int32Arg.Get().(*int32)
}
func (__ *PoolOfInt32ThenInt16Impl) PutInt32Arg(p *int32) {
	__.Int32Arg.Put(p)
}
func (__ *PoolOfInt32ThenInt16Impl) GetInt16Return() *int16 {
	return __.Int16Rtn.Get().(*int16)
}
func (__ *PoolOfInt32ThenInt16Impl) PutInt16Return(p *int16) {
	__.Int16Rtn.Put(p)
}

func (__ *PoolOfInt32ThenInt16Impl) GetWorkOfInt32ThenInt16() *WorkOfInt32ThenInt16 {
	return __.Int32Work.Get().(*WorkOfInt32ThenInt16)
}
func (__ *PoolOfInt32ThenInt16Impl) PutWorkOfInt32ThenInt16(p *WorkOfInt32ThenInt16) {
	__.Int32Work.Put(p)
}
func (__ *PoolOfInt32ThenInt16Impl) GetReturnOfInt16() *ReturnOfInt16 {
	return __.Int16Return.Get().(*ReturnOfInt16)
}
func (__ *PoolOfInt32ThenInt16Impl) PutReturnOfInt16(p *ReturnOfInt16) {
	__.Int16Return.Put(p)
}

func (__ *PoolOfInt32ThenInt16Impl) GetChReturnOfInt16() chan *ReturnOfInt16 {
	return __.ChReturnOfInt16.Get().(chan *ReturnOfInt16)
}
func (__ *PoolOfInt32ThenInt16Impl) PutChReturnOfInt16(p chan *ReturnOfInt16) {
	__.ChReturnOfInt16.Put(p)
}

func NewPoolOfInt32ThenInt16Impl() *PoolOfInt32ThenInt16Impl {
	return &PoolOfInt32ThenInt16Impl{
		Int32Arg: sync.Pool{
			New: func() interface{} {
				return new(int32)
			},
		},
		Int32Work: sync.Pool{
			New: func() interface{} {
				return new(WorkOfInt32ThenInt16)
			},
		},
		Int16Rtn: sync.Pool{
			New: func() interface{} {
				return new(int16)
			},
		},
		Int16Return: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfInt16)
			},
		},
		ChReturnOfInt16: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfInt16, 1)
			},
		},
	}
}

type ApiDecouplerOfInt32ThenInt16 struct {
	pool PoolOfInt32ThenInt16
}

func NewApiDecouplerOfInt32ThenInt16() *ApiDecouplerOfInt32ThenInt16 {
	return &ApiDecouplerOfInt32ThenInt16{
		pool: NewPoolOfInt32ThenInt16Impl(),
	}
}

func (__ *ApiDecouplerOfInt32ThenInt16) ReturnError(rtn_ch chan<- *ReturnOfInt16, err error) {
	rtn := __.pool.GetReturnOfInt16()
	var other int16
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfInt32ThenInt16) HandleOfInt32ThenInt16(ctx context.Context, req *WorkOfInt32ThenInt16, h func(ctx context.Context, arg int32) (int16, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfInt16()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfInt32ThenInt16) DoOfInt32ThenInt16(ctx context.Context, worker WorkerOfPushInt32ThenInt16, arg int32) (int16, error) {
	// ch := make(chan *ReturnOfInt16, 1)
	ch := __.pool.GetChReturnOfInt16()
	defer __.pool.PutChReturnOfInt16(ch)

	req := __.pool.GetWorkOfInt32ThenInt16()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfInt32ThenInt16(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfInt16(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfInt32ThenInt16 = func(ctx context.Context, arg int32) (int16, error)

type WorkerOfInt32ThenInt16 struct {
	api_syncer *ApiDecouplerOfInt32ThenInt16
	handler    WorkHandlerOfInt32ThenInt16

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfInt32ThenInt16
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfInt32ThenInt16(ctx context.Context, h WorkHandlerOfInt32ThenInt16, n int) *WorkerOfInt32ThenInt16 {
	__ := &WorkerOfInt32ThenInt16{
		api_syncer: NewApiDecouplerOfInt32ThenInt16(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfInt32ThenInt16, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfInt32ThenInt16{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfInt32ThenInt16(req.Context, req.WorkOfInt32ThenInt16, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfInt32ThenInt16) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfInt32ThenInt16) Push(ctx context.Context, req *WorkOfInt32ThenInt16) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfInt32ThenInt16)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfInt32ThenInt16 = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfInt32ThenInt16) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfInt32ThenInt16) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfInt32ThenInt16) Call(ctx context.Context, arg int32) (int16, error) {
	return __.api_syncer.DoOfInt32ThenInt16(ctx, __, arg)
}

type PoolOfInt32ThenInt32 interface {
	GetInt32Arg() *int32
	PutInt32Arg(*int32)
	GetInt32Return() *int32
	PutInt32Return(*int32)

	GetWorkOfInt32ThenInt32() *WorkOfInt32ThenInt32
	GetReturnOfInt32() *ReturnOfInt32
	PutWorkOfInt32ThenInt32(*WorkOfInt32ThenInt32)
	PutReturnOfInt32(*ReturnOfInt32)

	GetChReturnOfInt32() chan *ReturnOfInt32
	PutChReturnOfInt32(chan *ReturnOfInt32)
}

type PoolOfInt32ThenInt32Impl struct {
	Int32Arg        sync.Pool
	Int32Rtn        sync.Pool
	Int32Work       sync.Pool
	Int32Return     sync.Pool
	ChReturnOfInt32 sync.Pool
}

func (__ *PoolOfInt32ThenInt32Impl) GetInt32Arg() *int32 {
	return __.Int32Arg.Get().(*int32)
}
func (__ *PoolOfInt32ThenInt32Impl) PutInt32Arg(p *int32) {
	__.Int32Arg.Put(p)
}
func (__ *PoolOfInt32ThenInt32Impl) GetInt32Return() *int32 {
	return __.Int32Rtn.Get().(*int32)
}
func (__ *PoolOfInt32ThenInt32Impl) PutInt32Return(p *int32) {
	__.Int32Rtn.Put(p)
}

func (__ *PoolOfInt32ThenInt32Impl) GetWorkOfInt32ThenInt32() *WorkOfInt32ThenInt32 {
	return __.Int32Work.Get().(*WorkOfInt32ThenInt32)
}
func (__ *PoolOfInt32ThenInt32Impl) PutWorkOfInt32ThenInt32(p *WorkOfInt32ThenInt32) {
	__.Int32Work.Put(p)
}
func (__ *PoolOfInt32ThenInt32Impl) GetReturnOfInt32() *ReturnOfInt32 {
	return __.Int32Return.Get().(*ReturnOfInt32)
}
func (__ *PoolOfInt32ThenInt32Impl) PutReturnOfInt32(p *ReturnOfInt32) {
	__.Int32Return.Put(p)
}

func (__ *PoolOfInt32ThenInt32Impl) GetChReturnOfInt32() chan *ReturnOfInt32 {
	return __.ChReturnOfInt32.Get().(chan *ReturnOfInt32)
}
func (__ *PoolOfInt32ThenInt32Impl) PutChReturnOfInt32(p chan *ReturnOfInt32) {
	__.ChReturnOfInt32.Put(p)
}

func NewPoolOfInt32ThenInt32Impl() *PoolOfInt32ThenInt32Impl {
	return &PoolOfInt32ThenInt32Impl{
		Int32Arg: sync.Pool{
			New: func() interface{} {
				return new(int32)
			},
		},
		Int32Work: sync.Pool{
			New: func() interface{} {
				return new(WorkOfInt32ThenInt32)
			},
		},
		Int32Rtn: sync.Pool{
			New: func() interface{} {
				return new(int32)
			},
		},
		Int32Return: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfInt32)
			},
		},
		ChReturnOfInt32: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfInt32, 1)
			},
		},
	}
}

type ApiDecouplerOfInt32ThenInt32 struct {
	pool PoolOfInt32ThenInt32
}

func NewApiDecouplerOfInt32ThenInt32() *ApiDecouplerOfInt32ThenInt32 {
	return &ApiDecouplerOfInt32ThenInt32{
		pool: NewPoolOfInt32ThenInt32Impl(),
	}
}

func (__ *ApiDecouplerOfInt32ThenInt32) ReturnError(rtn_ch chan<- *ReturnOfInt32, err error) {
	rtn := __.pool.GetReturnOfInt32()
	var other int32
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfInt32ThenInt32) HandleOfInt32ThenInt32(ctx context.Context, req *WorkOfInt32ThenInt32, h func(ctx context.Context, arg int32) (int32, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfInt32()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfInt32ThenInt32) DoOfInt32ThenInt32(ctx context.Context, worker WorkerOfPushInt32ThenInt32, arg int32) (int32, error) {
	// ch := make(chan *ReturnOfInt32, 1)
	ch := __.pool.GetChReturnOfInt32()
	defer __.pool.PutChReturnOfInt32(ch)

	req := __.pool.GetWorkOfInt32ThenInt32()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfInt32ThenInt32(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfInt32(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfInt32ThenInt32 = func(ctx context.Context, arg int32) (int32, error)

type WorkerOfInt32ThenInt32 struct {
	api_syncer *ApiDecouplerOfInt32ThenInt32
	handler    WorkHandlerOfInt32ThenInt32

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfInt32ThenInt32
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfInt32ThenInt32(ctx context.Context, h WorkHandlerOfInt32ThenInt32, n int) *WorkerOfInt32ThenInt32 {
	__ := &WorkerOfInt32ThenInt32{
		api_syncer: NewApiDecouplerOfInt32ThenInt32(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfInt32ThenInt32, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfInt32ThenInt32{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfInt32ThenInt32(req.Context, req.WorkOfInt32ThenInt32, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfInt32ThenInt32) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfInt32ThenInt32) Push(ctx context.Context, req *WorkOfInt32ThenInt32) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfInt32ThenInt32)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfInt32ThenInt32 = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfInt32ThenInt32) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfInt32ThenInt32) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfInt32ThenInt32) Call(ctx context.Context, arg int32) (int32, error) {
	return __.api_syncer.DoOfInt32ThenInt32(ctx, __, arg)
}

type PoolOfInt32ThenInt64 interface {
	GetInt32Arg() *int32
	PutInt32Arg(*int32)
	GetInt64Return() *int64
	PutInt64Return(*int64)

	GetWorkOfInt32ThenInt64() *WorkOfInt32ThenInt64
	GetReturnOfInt64() *ReturnOfInt64
	PutWorkOfInt32ThenInt64(*WorkOfInt32ThenInt64)
	PutReturnOfInt64(*ReturnOfInt64)

	GetChReturnOfInt64() chan *ReturnOfInt64
	PutChReturnOfInt64(chan *ReturnOfInt64)
}

type PoolOfInt32ThenInt64Impl struct {
	Int32Arg        sync.Pool
	Int64Rtn        sync.Pool
	Int32Work       sync.Pool
	Int64Return     sync.Pool
	ChReturnOfInt64 sync.Pool
}

func (__ *PoolOfInt32ThenInt64Impl) GetInt32Arg() *int32 {
	return __.Int32Arg.Get().(*int32)
}
func (__ *PoolOfInt32ThenInt64Impl) PutInt32Arg(p *int32) {
	__.Int32Arg.Put(p)
}
func (__ *PoolOfInt32ThenInt64Impl) GetInt64Return() *int64 {
	return __.Int64Rtn.Get().(*int64)
}
func (__ *PoolOfInt32ThenInt64Impl) PutInt64Return(p *int64) {
	__.Int64Rtn.Put(p)
}

func (__ *PoolOfInt32ThenInt64Impl) GetWorkOfInt32ThenInt64() *WorkOfInt32ThenInt64 {
	return __.Int32Work.Get().(*WorkOfInt32ThenInt64)
}
func (__ *PoolOfInt32ThenInt64Impl) PutWorkOfInt32ThenInt64(p *WorkOfInt32ThenInt64) {
	__.Int32Work.Put(p)
}
func (__ *PoolOfInt32ThenInt64Impl) GetReturnOfInt64() *ReturnOfInt64 {
	return __.Int64Return.Get().(*ReturnOfInt64)
}
func (__ *PoolOfInt32ThenInt64Impl) PutReturnOfInt64(p *ReturnOfInt64) {
	__.Int64Return.Put(p)
}

func (__ *PoolOfInt32ThenInt64Impl) GetChReturnOfInt64() chan *ReturnOfInt64 {
	return __.ChReturnOfInt64.Get().(chan *ReturnOfInt64)
}
func (__ *PoolOfInt32ThenInt64Impl) PutChReturnOfInt64(p chan *ReturnOfInt64) {
	__.ChReturnOfInt64.Put(p)
}

func NewPoolOfInt32ThenInt64Impl() *PoolOfInt32ThenInt64Impl {
	return &PoolOfInt32ThenInt64Impl{
		Int32Arg: sync.Pool{
			New: func() interface{} {
				return new(int32)
			},
		},
		Int32Work: sync.Pool{
			New: func() interface{} {
				return new(WorkOfInt32ThenInt64)
			},
		},
		Int64Rtn: sync.Pool{
			New: func() interface{} {
				return new(int64)
			},
		},
		Int64Return: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfInt64)
			},
		},
		ChReturnOfInt64: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfInt64, 1)
			},
		},
	}
}

type ApiDecouplerOfInt32ThenInt64 struct {
	pool PoolOfInt32ThenInt64
}

func NewApiDecouplerOfInt32ThenInt64() *ApiDecouplerOfInt32ThenInt64 {
	return &ApiDecouplerOfInt32ThenInt64{
		pool: NewPoolOfInt32ThenInt64Impl(),
	}
}

func (__ *ApiDecouplerOfInt32ThenInt64) ReturnError(rtn_ch chan<- *ReturnOfInt64, err error) {
	rtn := __.pool.GetReturnOfInt64()
	var other int64
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfInt32ThenInt64) HandleOfInt32ThenInt64(ctx context.Context, req *WorkOfInt32ThenInt64, h func(ctx context.Context, arg int32) (int64, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfInt64()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfInt32ThenInt64) DoOfInt32ThenInt64(ctx context.Context, worker WorkerOfPushInt32ThenInt64, arg int32) (int64, error) {
	// ch := make(chan *ReturnOfInt64, 1)
	ch := __.pool.GetChReturnOfInt64()
	defer __.pool.PutChReturnOfInt64(ch)

	req := __.pool.GetWorkOfInt32ThenInt64()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfInt32ThenInt64(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfInt64(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfInt32ThenInt64 = func(ctx context.Context, arg int32) (int64, error)

type WorkerOfInt32ThenInt64 struct {
	api_syncer *ApiDecouplerOfInt32ThenInt64
	handler    WorkHandlerOfInt32ThenInt64

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfInt32ThenInt64
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfInt32ThenInt64(ctx context.Context, h WorkHandlerOfInt32ThenInt64, n int) *WorkerOfInt32ThenInt64 {
	__ := &WorkerOfInt32ThenInt64{
		api_syncer: NewApiDecouplerOfInt32ThenInt64(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfInt32ThenInt64, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfInt32ThenInt64{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfInt32ThenInt64(req.Context, req.WorkOfInt32ThenInt64, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfInt32ThenInt64) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfInt32ThenInt64) Push(ctx context.Context, req *WorkOfInt32ThenInt64) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfInt32ThenInt64)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfInt32ThenInt64 = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfInt32ThenInt64) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfInt32ThenInt64) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfInt32ThenInt64) Call(ctx context.Context, arg int32) (int64, error) {
	return __.api_syncer.DoOfInt32ThenInt64(ctx, __, arg)
}

type PoolOfInt32ThenInt8 interface {
	GetInt32Arg() *int32
	PutInt32Arg(*int32)
	GetInt8Return() *int8
	PutInt8Return(*int8)

	GetWorkOfInt32ThenInt8() *WorkOfInt32ThenInt8
	GetReturnOfInt8() *ReturnOfInt8
	PutWorkOfInt32ThenInt8(*WorkOfInt32ThenInt8)
	PutReturnOfInt8(*ReturnOfInt8)

	GetChReturnOfInt8() chan *ReturnOfInt8
	PutChReturnOfInt8(chan *ReturnOfInt8)
}

type PoolOfInt32ThenInt8Impl struct {
	Int32Arg       sync.Pool
	Int8Rtn        sync.Pool
	Int32Work      sync.Pool
	Int8Return     sync.Pool
	ChReturnOfInt8 sync.Pool
}

func (__ *PoolOfInt32ThenInt8Impl) GetInt32Arg() *int32 {
	return __.Int32Arg.Get().(*int32)
}
func (__ *PoolOfInt32ThenInt8Impl) PutInt32Arg(p *int32) {
	__.Int32Arg.Put(p)
}
func (__ *PoolOfInt32ThenInt8Impl) GetInt8Return() *int8 {
	return __.Int8Rtn.Get().(*int8)
}
func (__ *PoolOfInt32ThenInt8Impl) PutInt8Return(p *int8) {
	__.Int8Rtn.Put(p)
}

func (__ *PoolOfInt32ThenInt8Impl) GetWorkOfInt32ThenInt8() *WorkOfInt32ThenInt8 {
	return __.Int32Work.Get().(*WorkOfInt32ThenInt8)
}
func (__ *PoolOfInt32ThenInt8Impl) PutWorkOfInt32ThenInt8(p *WorkOfInt32ThenInt8) {
	__.Int32Work.Put(p)
}
func (__ *PoolOfInt32ThenInt8Impl) GetReturnOfInt8() *ReturnOfInt8 {
	return __.Int8Return.Get().(*ReturnOfInt8)
}
func (__ *PoolOfInt32ThenInt8Impl) PutReturnOfInt8(p *ReturnOfInt8) {
	__.Int8Return.Put(p)
}

func (__ *PoolOfInt32ThenInt8Impl) GetChReturnOfInt8() chan *ReturnOfInt8 {
	return __.ChReturnOfInt8.Get().(chan *ReturnOfInt8)
}
func (__ *PoolOfInt32ThenInt8Impl) PutChReturnOfInt8(p chan *ReturnOfInt8) {
	__.ChReturnOfInt8.Put(p)
}

func NewPoolOfInt32ThenInt8Impl() *PoolOfInt32ThenInt8Impl {
	return &PoolOfInt32ThenInt8Impl{
		Int32Arg: sync.Pool{
			New: func() interface{} {
				return new(int32)
			},
		},
		Int32Work: sync.Pool{
			New: func() interface{} {
				return new(WorkOfInt32ThenInt8)
			},
		},
		Int8Rtn: sync.Pool{
			New: func() interface{} {
				return new(int8)
			},
		},
		Int8Return: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfInt8)
			},
		},
		ChReturnOfInt8: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfInt8, 1)
			},
		},
	}
}

type ApiDecouplerOfInt32ThenInt8 struct {
	pool PoolOfInt32ThenInt8
}

func NewApiDecouplerOfInt32ThenInt8() *ApiDecouplerOfInt32ThenInt8 {
	return &ApiDecouplerOfInt32ThenInt8{
		pool: NewPoolOfInt32ThenInt8Impl(),
	}
}

func (__ *ApiDecouplerOfInt32ThenInt8) ReturnError(rtn_ch chan<- *ReturnOfInt8, err error) {
	rtn := __.pool.GetReturnOfInt8()
	var other int8
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfInt32ThenInt8) HandleOfInt32ThenInt8(ctx context.Context, req *WorkOfInt32ThenInt8, h func(ctx context.Context, arg int32) (int8, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfInt8()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfInt32ThenInt8) DoOfInt32ThenInt8(ctx context.Context, worker WorkerOfPushInt32ThenInt8, arg int32) (int8, error) {
	// ch := make(chan *ReturnOfInt8, 1)
	ch := __.pool.GetChReturnOfInt8()
	defer __.pool.PutChReturnOfInt8(ch)

	req := __.pool.GetWorkOfInt32ThenInt8()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfInt32ThenInt8(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfInt8(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfInt32ThenInt8 = func(ctx context.Context, arg int32) (int8, error)

type WorkerOfInt32ThenInt8 struct {
	api_syncer *ApiDecouplerOfInt32ThenInt8
	handler    WorkHandlerOfInt32ThenInt8

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfInt32ThenInt8
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfInt32ThenInt8(ctx context.Context, h WorkHandlerOfInt32ThenInt8, n int) *WorkerOfInt32ThenInt8 {
	__ := &WorkerOfInt32ThenInt8{
		api_syncer: NewApiDecouplerOfInt32ThenInt8(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfInt32ThenInt8, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfInt32ThenInt8{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfInt32ThenInt8(req.Context, req.WorkOfInt32ThenInt8, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfInt32ThenInt8) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfInt32ThenInt8) Push(ctx context.Context, req *WorkOfInt32ThenInt8) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfInt32ThenInt8)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfInt32ThenInt8 = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfInt32ThenInt8) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfInt32ThenInt8) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfInt32ThenInt8) Call(ctx context.Context, arg int32) (int8, error) {
	return __.api_syncer.DoOfInt32ThenInt8(ctx, __, arg)
}

type PoolOfInt32ThenRune interface {
	GetInt32Arg() *int32
	PutInt32Arg(*int32)
	GetRuneReturn() *rune
	PutRuneReturn(*rune)

	GetWorkOfInt32ThenRune() *WorkOfInt32ThenRune
	GetReturnOfRune() *ReturnOfRune
	PutWorkOfInt32ThenRune(*WorkOfInt32ThenRune)
	PutReturnOfRune(*ReturnOfRune)

	GetChReturnOfRune() chan *ReturnOfRune
	PutChReturnOfRune(chan *ReturnOfRune)
}

type PoolOfInt32ThenRuneImpl struct {
	Int32Arg       sync.Pool
	RuneRtn        sync.Pool
	Int32Work      sync.Pool
	RuneReturn     sync.Pool
	ChReturnOfRune sync.Pool
}

func (__ *PoolOfInt32ThenRuneImpl) GetInt32Arg() *int32 {
	return __.Int32Arg.Get().(*int32)
}
func (__ *PoolOfInt32ThenRuneImpl) PutInt32Arg(p *int32) {
	__.Int32Arg.Put(p)
}
func (__ *PoolOfInt32ThenRuneImpl) GetRuneReturn() *rune {
	return __.RuneRtn.Get().(*rune)
}
func (__ *PoolOfInt32ThenRuneImpl) PutRuneReturn(p *rune) {
	__.RuneRtn.Put(p)
}

func (__ *PoolOfInt32ThenRuneImpl) GetWorkOfInt32ThenRune() *WorkOfInt32ThenRune {
	return __.Int32Work.Get().(*WorkOfInt32ThenRune)
}
func (__ *PoolOfInt32ThenRuneImpl) PutWorkOfInt32ThenRune(p *WorkOfInt32ThenRune) {
	__.Int32Work.Put(p)
}
func (__ *PoolOfInt32ThenRuneImpl) GetReturnOfRune() *ReturnOfRune {
	return __.RuneReturn.Get().(*ReturnOfRune)
}
func (__ *PoolOfInt32ThenRuneImpl) PutReturnOfRune(p *ReturnOfRune) {
	__.RuneReturn.Put(p)
}

func (__ *PoolOfInt32ThenRuneImpl) GetChReturnOfRune() chan *ReturnOfRune {
	return __.ChReturnOfRune.Get().(chan *ReturnOfRune)
}
func (__ *PoolOfInt32ThenRuneImpl) PutChReturnOfRune(p chan *ReturnOfRune) {
	__.ChReturnOfRune.Put(p)
}

func NewPoolOfInt32ThenRuneImpl() *PoolOfInt32ThenRuneImpl {
	return &PoolOfInt32ThenRuneImpl{
		Int32Arg: sync.Pool{
			New: func() interface{} {
				return new(int32)
			},
		},
		Int32Work: sync.Pool{
			New: func() interface{} {
				return new(WorkOfInt32ThenRune)
			},
		},
		RuneRtn: sync.Pool{
			New: func() interface{} {
				return new(rune)
			},
		},
		RuneReturn: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfRune)
			},
		},
		ChReturnOfRune: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfRune, 1)
			},
		},
	}
}

type ApiDecouplerOfInt32ThenRune struct {
	pool PoolOfInt32ThenRune
}

func NewApiDecouplerOfInt32ThenRune() *ApiDecouplerOfInt32ThenRune {
	return &ApiDecouplerOfInt32ThenRune{
		pool: NewPoolOfInt32ThenRuneImpl(),
	}
}

func (__ *ApiDecouplerOfInt32ThenRune) ReturnError(rtn_ch chan<- *ReturnOfRune, err error) {
	rtn := __.pool.GetReturnOfRune()
	var other rune
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfInt32ThenRune) HandleOfInt32ThenRune(ctx context.Context, req *WorkOfInt32ThenRune, h func(ctx context.Context, arg int32) (rune, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfRune()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfInt32ThenRune) DoOfInt32ThenRune(ctx context.Context, worker WorkerOfPushInt32ThenRune, arg int32) (rune, error) {
	// ch := make(chan *ReturnOfRune, 1)
	ch := __.pool.GetChReturnOfRune()
	defer __.pool.PutChReturnOfRune(ch)

	req := __.pool.GetWorkOfInt32ThenRune()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfInt32ThenRune(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfRune(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfInt32ThenRune = func(ctx context.Context, arg int32) (rune, error)

type WorkerOfInt32ThenRune struct {
	api_syncer *ApiDecouplerOfInt32ThenRune
	handler    WorkHandlerOfInt32ThenRune

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfInt32ThenRune
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfInt32ThenRune(ctx context.Context, h WorkHandlerOfInt32ThenRune, n int) *WorkerOfInt32ThenRune {
	__ := &WorkerOfInt32ThenRune{
		api_syncer: NewApiDecouplerOfInt32ThenRune(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfInt32ThenRune, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfInt32ThenRune{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfInt32ThenRune(req.Context, req.WorkOfInt32ThenRune, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfInt32ThenRune) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfInt32ThenRune) Push(ctx context.Context, req *WorkOfInt32ThenRune) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfInt32ThenRune)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfInt32ThenRune = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfInt32ThenRune) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfInt32ThenRune) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfInt32ThenRune) Call(ctx context.Context, arg int32) (rune, error) {
	return __.api_syncer.DoOfInt32ThenRune(ctx, __, arg)
}

type PoolOfInt32ThenString interface {
	GetInt32Arg() *int32
	PutInt32Arg(*int32)
	GetStringReturn() *string
	PutStringReturn(*string)

	GetWorkOfInt32ThenString() *WorkOfInt32ThenString
	GetReturnOfString() *ReturnOfString
	PutWorkOfInt32ThenString(*WorkOfInt32ThenString)
	PutReturnOfString(*ReturnOfString)

	GetChReturnOfString() chan *ReturnOfString
	PutChReturnOfString(chan *ReturnOfString)
}

type PoolOfInt32ThenStringImpl struct {
	Int32Arg         sync.Pool
	StringRtn        sync.Pool
	Int32Work        sync.Pool
	StringReturn     sync.Pool
	ChReturnOfString sync.Pool
}

func (__ *PoolOfInt32ThenStringImpl) GetInt32Arg() *int32 {
	return __.Int32Arg.Get().(*int32)
}
func (__ *PoolOfInt32ThenStringImpl) PutInt32Arg(p *int32) {
	__.Int32Arg.Put(p)
}
func (__ *PoolOfInt32ThenStringImpl) GetStringReturn() *string {
	return __.StringRtn.Get().(*string)
}
func (__ *PoolOfInt32ThenStringImpl) PutStringReturn(p *string) {
	__.StringRtn.Put(p)
}

func (__ *PoolOfInt32ThenStringImpl) GetWorkOfInt32ThenString() *WorkOfInt32ThenString {
	return __.Int32Work.Get().(*WorkOfInt32ThenString)
}
func (__ *PoolOfInt32ThenStringImpl) PutWorkOfInt32ThenString(p *WorkOfInt32ThenString) {
	__.Int32Work.Put(p)
}
func (__ *PoolOfInt32ThenStringImpl) GetReturnOfString() *ReturnOfString {
	return __.StringReturn.Get().(*ReturnOfString)
}
func (__ *PoolOfInt32ThenStringImpl) PutReturnOfString(p *ReturnOfString) {
	__.StringReturn.Put(p)
}

func (__ *PoolOfInt32ThenStringImpl) GetChReturnOfString() chan *ReturnOfString {
	return __.ChReturnOfString.Get().(chan *ReturnOfString)
}
func (__ *PoolOfInt32ThenStringImpl) PutChReturnOfString(p chan *ReturnOfString) {
	__.ChReturnOfString.Put(p)
}

func NewPoolOfInt32ThenStringImpl() *PoolOfInt32ThenStringImpl {
	return &PoolOfInt32ThenStringImpl{
		Int32Arg: sync.Pool{
			New: func() interface{} {
				return new(int32)
			},
		},
		Int32Work: sync.Pool{
			New: func() interface{} {
				return new(WorkOfInt32ThenString)
			},
		},
		StringRtn: sync.Pool{
			New: func() interface{} {
				return new(string)
			},
		},
		StringReturn: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfString)
			},
		},
		ChReturnOfString: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfString, 1)
			},
		},
	}
}

type ApiDecouplerOfInt32ThenString struct {
	pool PoolOfInt32ThenString
}

func NewApiDecouplerOfInt32ThenString() *ApiDecouplerOfInt32ThenString {
	return &ApiDecouplerOfInt32ThenString{
		pool: NewPoolOfInt32ThenStringImpl(),
	}
}

func (__ *ApiDecouplerOfInt32ThenString) ReturnError(rtn_ch chan<- *ReturnOfString, err error) {
	rtn := __.pool.GetReturnOfString()
	var other string
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfInt32ThenString) HandleOfInt32ThenString(ctx context.Context, req *WorkOfInt32ThenString, h func(ctx context.Context, arg int32) (string, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfString()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfInt32ThenString) DoOfInt32ThenString(ctx context.Context, worker WorkerOfPushInt32ThenString, arg int32) (string, error) {
	// ch := make(chan *ReturnOfString, 1)
	ch := __.pool.GetChReturnOfString()
	defer __.pool.PutChReturnOfString(ch)

	req := __.pool.GetWorkOfInt32ThenString()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfInt32ThenString(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfString(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfInt32ThenString = func(ctx context.Context, arg int32) (string, error)

type WorkerOfInt32ThenString struct {
	api_syncer *ApiDecouplerOfInt32ThenString
	handler    WorkHandlerOfInt32ThenString

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfInt32ThenString
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfInt32ThenString(ctx context.Context, h WorkHandlerOfInt32ThenString, n int) *WorkerOfInt32ThenString {
	__ := &WorkerOfInt32ThenString{
		api_syncer: NewApiDecouplerOfInt32ThenString(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfInt32ThenString, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfInt32ThenString{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfInt32ThenString(req.Context, req.WorkOfInt32ThenString, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfInt32ThenString) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfInt32ThenString) Push(ctx context.Context, req *WorkOfInt32ThenString) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfInt32ThenString)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfInt32ThenString = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfInt32ThenString) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfInt32ThenString) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfInt32ThenString) Call(ctx context.Context, arg int32) (string, error) {
	return __.api_syncer.DoOfInt32ThenString(ctx, __, arg)
}

type PoolOfInt32ThenUint interface {
	GetInt32Arg() *int32
	PutInt32Arg(*int32)
	GetUintReturn() *uint
	PutUintReturn(*uint)

	GetWorkOfInt32ThenUint() *WorkOfInt32ThenUint
	GetReturnOfUint() *ReturnOfUint
	PutWorkOfInt32ThenUint(*WorkOfInt32ThenUint)
	PutReturnOfUint(*ReturnOfUint)

	GetChReturnOfUint() chan *ReturnOfUint
	PutChReturnOfUint(chan *ReturnOfUint)
}

type PoolOfInt32ThenUintImpl struct {
	Int32Arg       sync.Pool
	UintRtn        sync.Pool
	Int32Work      sync.Pool
	UintReturn     sync.Pool
	ChReturnOfUint sync.Pool
}

func (__ *PoolOfInt32ThenUintImpl) GetInt32Arg() *int32 {
	return __.Int32Arg.Get().(*int32)
}
func (__ *PoolOfInt32ThenUintImpl) PutInt32Arg(p *int32) {
	__.Int32Arg.Put(p)
}
func (__ *PoolOfInt32ThenUintImpl) GetUintReturn() *uint {
	return __.UintRtn.Get().(*uint)
}
func (__ *PoolOfInt32ThenUintImpl) PutUintReturn(p *uint) {
	__.UintRtn.Put(p)
}

func (__ *PoolOfInt32ThenUintImpl) GetWorkOfInt32ThenUint() *WorkOfInt32ThenUint {
	return __.Int32Work.Get().(*WorkOfInt32ThenUint)
}
func (__ *PoolOfInt32ThenUintImpl) PutWorkOfInt32ThenUint(p *WorkOfInt32ThenUint) {
	__.Int32Work.Put(p)
}
func (__ *PoolOfInt32ThenUintImpl) GetReturnOfUint() *ReturnOfUint {
	return __.UintReturn.Get().(*ReturnOfUint)
}
func (__ *PoolOfInt32ThenUintImpl) PutReturnOfUint(p *ReturnOfUint) {
	__.UintReturn.Put(p)
}

func (__ *PoolOfInt32ThenUintImpl) GetChReturnOfUint() chan *ReturnOfUint {
	return __.ChReturnOfUint.Get().(chan *ReturnOfUint)
}
func (__ *PoolOfInt32ThenUintImpl) PutChReturnOfUint(p chan *ReturnOfUint) {
	__.ChReturnOfUint.Put(p)
}

func NewPoolOfInt32ThenUintImpl() *PoolOfInt32ThenUintImpl {
	return &PoolOfInt32ThenUintImpl{
		Int32Arg: sync.Pool{
			New: func() interface{} {
				return new(int32)
			},
		},
		Int32Work: sync.Pool{
			New: func() interface{} {
				return new(WorkOfInt32ThenUint)
			},
		},
		UintRtn: sync.Pool{
			New: func() interface{} {
				return new(uint)
			},
		},
		UintReturn: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfUint)
			},
		},
		ChReturnOfUint: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfUint, 1)
			},
		},
	}
}

type ApiDecouplerOfInt32ThenUint struct {
	pool PoolOfInt32ThenUint
}

func NewApiDecouplerOfInt32ThenUint() *ApiDecouplerOfInt32ThenUint {
	return &ApiDecouplerOfInt32ThenUint{
		pool: NewPoolOfInt32ThenUintImpl(),
	}
}

func (__ *ApiDecouplerOfInt32ThenUint) ReturnError(rtn_ch chan<- *ReturnOfUint, err error) {
	rtn := __.pool.GetReturnOfUint()
	var other uint
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfInt32ThenUint) HandleOfInt32ThenUint(ctx context.Context, req *WorkOfInt32ThenUint, h func(ctx context.Context, arg int32) (uint, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfUint()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfInt32ThenUint) DoOfInt32ThenUint(ctx context.Context, worker WorkerOfPushInt32ThenUint, arg int32) (uint, error) {
	// ch := make(chan *ReturnOfUint, 1)
	ch := __.pool.GetChReturnOfUint()
	defer __.pool.PutChReturnOfUint(ch)

	req := __.pool.GetWorkOfInt32ThenUint()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfInt32ThenUint(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfUint(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfInt32ThenUint = func(ctx context.Context, arg int32) (uint, error)

type WorkerOfInt32ThenUint struct {
	api_syncer *ApiDecouplerOfInt32ThenUint
	handler    WorkHandlerOfInt32ThenUint

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfInt32ThenUint
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfInt32ThenUint(ctx context.Context, h WorkHandlerOfInt32ThenUint, n int) *WorkerOfInt32ThenUint {
	__ := &WorkerOfInt32ThenUint{
		api_syncer: NewApiDecouplerOfInt32ThenUint(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfInt32ThenUint, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfInt32ThenUint{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfInt32ThenUint(req.Context, req.WorkOfInt32ThenUint, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfInt32ThenUint) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfInt32ThenUint) Push(ctx context.Context, req *WorkOfInt32ThenUint) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfInt32ThenUint)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfInt32ThenUint = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfInt32ThenUint) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfInt32ThenUint) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfInt32ThenUint) Call(ctx context.Context, arg int32) (uint, error) {
	return __.api_syncer.DoOfInt32ThenUint(ctx, __, arg)
}

type PoolOfInt32ThenUint16 interface {
	GetInt32Arg() *int32
	PutInt32Arg(*int32)
	GetUint16Return() *uint16
	PutUint16Return(*uint16)

	GetWorkOfInt32ThenUint16() *WorkOfInt32ThenUint16
	GetReturnOfUint16() *ReturnOfUint16
	PutWorkOfInt32ThenUint16(*WorkOfInt32ThenUint16)
	PutReturnOfUint16(*ReturnOfUint16)

	GetChReturnOfUint16() chan *ReturnOfUint16
	PutChReturnOfUint16(chan *ReturnOfUint16)
}

type PoolOfInt32ThenUint16Impl struct {
	Int32Arg         sync.Pool
	Uint16Rtn        sync.Pool
	Int32Work        sync.Pool
	Uint16Return     sync.Pool
	ChReturnOfUint16 sync.Pool
}

func (__ *PoolOfInt32ThenUint16Impl) GetInt32Arg() *int32 {
	return __.Int32Arg.Get().(*int32)
}
func (__ *PoolOfInt32ThenUint16Impl) PutInt32Arg(p *int32) {
	__.Int32Arg.Put(p)
}
func (__ *PoolOfInt32ThenUint16Impl) GetUint16Return() *uint16 {
	return __.Uint16Rtn.Get().(*uint16)
}
func (__ *PoolOfInt32ThenUint16Impl) PutUint16Return(p *uint16) {
	__.Uint16Rtn.Put(p)
}

func (__ *PoolOfInt32ThenUint16Impl) GetWorkOfInt32ThenUint16() *WorkOfInt32ThenUint16 {
	return __.Int32Work.Get().(*WorkOfInt32ThenUint16)
}
func (__ *PoolOfInt32ThenUint16Impl) PutWorkOfInt32ThenUint16(p *WorkOfInt32ThenUint16) {
	__.Int32Work.Put(p)
}
func (__ *PoolOfInt32ThenUint16Impl) GetReturnOfUint16() *ReturnOfUint16 {
	return __.Uint16Return.Get().(*ReturnOfUint16)
}
func (__ *PoolOfInt32ThenUint16Impl) PutReturnOfUint16(p *ReturnOfUint16) {
	__.Uint16Return.Put(p)
}

func (__ *PoolOfInt32ThenUint16Impl) GetChReturnOfUint16() chan *ReturnOfUint16 {
	return __.ChReturnOfUint16.Get().(chan *ReturnOfUint16)
}
func (__ *PoolOfInt32ThenUint16Impl) PutChReturnOfUint16(p chan *ReturnOfUint16) {
	__.ChReturnOfUint16.Put(p)
}

func NewPoolOfInt32ThenUint16Impl() *PoolOfInt32ThenUint16Impl {
	return &PoolOfInt32ThenUint16Impl{
		Int32Arg: sync.Pool{
			New: func() interface{} {
				return new(int32)
			},
		},
		Int32Work: sync.Pool{
			New: func() interface{} {
				return new(WorkOfInt32ThenUint16)
			},
		},
		Uint16Rtn: sync.Pool{
			New: func() interface{} {
				return new(uint16)
			},
		},
		Uint16Return: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfUint16)
			},
		},
		ChReturnOfUint16: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfUint16, 1)
			},
		},
	}
}

type ApiDecouplerOfInt32ThenUint16 struct {
	pool PoolOfInt32ThenUint16
}

func NewApiDecouplerOfInt32ThenUint16() *ApiDecouplerOfInt32ThenUint16 {
	return &ApiDecouplerOfInt32ThenUint16{
		pool: NewPoolOfInt32ThenUint16Impl(),
	}
}

func (__ *ApiDecouplerOfInt32ThenUint16) ReturnError(rtn_ch chan<- *ReturnOfUint16, err error) {
	rtn := __.pool.GetReturnOfUint16()
	var other uint16
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfInt32ThenUint16) HandleOfInt32ThenUint16(ctx context.Context, req *WorkOfInt32ThenUint16, h func(ctx context.Context, arg int32) (uint16, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfUint16()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfInt32ThenUint16) DoOfInt32ThenUint16(ctx context.Context, worker WorkerOfPushInt32ThenUint16, arg int32) (uint16, error) {
	// ch := make(chan *ReturnOfUint16, 1)
	ch := __.pool.GetChReturnOfUint16()
	defer __.pool.PutChReturnOfUint16(ch)

	req := __.pool.GetWorkOfInt32ThenUint16()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfInt32ThenUint16(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfUint16(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfInt32ThenUint16 = func(ctx context.Context, arg int32) (uint16, error)

type WorkerOfInt32ThenUint16 struct {
	api_syncer *ApiDecouplerOfInt32ThenUint16
	handler    WorkHandlerOfInt32ThenUint16

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfInt32ThenUint16
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfInt32ThenUint16(ctx context.Context, h WorkHandlerOfInt32ThenUint16, n int) *WorkerOfInt32ThenUint16 {
	__ := &WorkerOfInt32ThenUint16{
		api_syncer: NewApiDecouplerOfInt32ThenUint16(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfInt32ThenUint16, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfInt32ThenUint16{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfInt32ThenUint16(req.Context, req.WorkOfInt32ThenUint16, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfInt32ThenUint16) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfInt32ThenUint16) Push(ctx context.Context, req *WorkOfInt32ThenUint16) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfInt32ThenUint16)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfInt32ThenUint16 = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfInt32ThenUint16) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfInt32ThenUint16) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfInt32ThenUint16) Call(ctx context.Context, arg int32) (uint16, error) {
	return __.api_syncer.DoOfInt32ThenUint16(ctx, __, arg)
}

type PoolOfInt32ThenUint32 interface {
	GetInt32Arg() *int32
	PutInt32Arg(*int32)
	GetUint32Return() *uint32
	PutUint32Return(*uint32)

	GetWorkOfInt32ThenUint32() *WorkOfInt32ThenUint32
	GetReturnOfUint32() *ReturnOfUint32
	PutWorkOfInt32ThenUint32(*WorkOfInt32ThenUint32)
	PutReturnOfUint32(*ReturnOfUint32)

	GetChReturnOfUint32() chan *ReturnOfUint32
	PutChReturnOfUint32(chan *ReturnOfUint32)
}

type PoolOfInt32ThenUint32Impl struct {
	Int32Arg         sync.Pool
	Uint32Rtn        sync.Pool
	Int32Work        sync.Pool
	Uint32Return     sync.Pool
	ChReturnOfUint32 sync.Pool
}

func (__ *PoolOfInt32ThenUint32Impl) GetInt32Arg() *int32 {
	return __.Int32Arg.Get().(*int32)
}
func (__ *PoolOfInt32ThenUint32Impl) PutInt32Arg(p *int32) {
	__.Int32Arg.Put(p)
}
func (__ *PoolOfInt32ThenUint32Impl) GetUint32Return() *uint32 {
	return __.Uint32Rtn.Get().(*uint32)
}
func (__ *PoolOfInt32ThenUint32Impl) PutUint32Return(p *uint32) {
	__.Uint32Rtn.Put(p)
}

func (__ *PoolOfInt32ThenUint32Impl) GetWorkOfInt32ThenUint32() *WorkOfInt32ThenUint32 {
	return __.Int32Work.Get().(*WorkOfInt32ThenUint32)
}
func (__ *PoolOfInt32ThenUint32Impl) PutWorkOfInt32ThenUint32(p *WorkOfInt32ThenUint32) {
	__.Int32Work.Put(p)
}
func (__ *PoolOfInt32ThenUint32Impl) GetReturnOfUint32() *ReturnOfUint32 {
	return __.Uint32Return.Get().(*ReturnOfUint32)
}
func (__ *PoolOfInt32ThenUint32Impl) PutReturnOfUint32(p *ReturnOfUint32) {
	__.Uint32Return.Put(p)
}

func (__ *PoolOfInt32ThenUint32Impl) GetChReturnOfUint32() chan *ReturnOfUint32 {
	return __.ChReturnOfUint32.Get().(chan *ReturnOfUint32)
}
func (__ *PoolOfInt32ThenUint32Impl) PutChReturnOfUint32(p chan *ReturnOfUint32) {
	__.ChReturnOfUint32.Put(p)
}

func NewPoolOfInt32ThenUint32Impl() *PoolOfInt32ThenUint32Impl {
	return &PoolOfInt32ThenUint32Impl{
		Int32Arg: sync.Pool{
			New: func() interface{} {
				return new(int32)
			},
		},
		Int32Work: sync.Pool{
			New: func() interface{} {
				return new(WorkOfInt32ThenUint32)
			},
		},
		Uint32Rtn: sync.Pool{
			New: func() interface{} {
				return new(uint32)
			},
		},
		Uint32Return: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfUint32)
			},
		},
		ChReturnOfUint32: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfUint32, 1)
			},
		},
	}
}

type ApiDecouplerOfInt32ThenUint32 struct {
	pool PoolOfInt32ThenUint32
}

func NewApiDecouplerOfInt32ThenUint32() *ApiDecouplerOfInt32ThenUint32 {
	return &ApiDecouplerOfInt32ThenUint32{
		pool: NewPoolOfInt32ThenUint32Impl(),
	}
}

func (__ *ApiDecouplerOfInt32ThenUint32) ReturnError(rtn_ch chan<- *ReturnOfUint32, err error) {
	rtn := __.pool.GetReturnOfUint32()
	var other uint32
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfInt32ThenUint32) HandleOfInt32ThenUint32(ctx context.Context, req *WorkOfInt32ThenUint32, h func(ctx context.Context, arg int32) (uint32, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfUint32()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfInt32ThenUint32) DoOfInt32ThenUint32(ctx context.Context, worker WorkerOfPushInt32ThenUint32, arg int32) (uint32, error) {
	// ch := make(chan *ReturnOfUint32, 1)
	ch := __.pool.GetChReturnOfUint32()
	defer __.pool.PutChReturnOfUint32(ch)

	req := __.pool.GetWorkOfInt32ThenUint32()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfInt32ThenUint32(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfUint32(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfInt32ThenUint32 = func(ctx context.Context, arg int32) (uint32, error)

type WorkerOfInt32ThenUint32 struct {
	api_syncer *ApiDecouplerOfInt32ThenUint32
	handler    WorkHandlerOfInt32ThenUint32

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfInt32ThenUint32
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfInt32ThenUint32(ctx context.Context, h WorkHandlerOfInt32ThenUint32, n int) *WorkerOfInt32ThenUint32 {
	__ := &WorkerOfInt32ThenUint32{
		api_syncer: NewApiDecouplerOfInt32ThenUint32(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfInt32ThenUint32, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfInt32ThenUint32{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfInt32ThenUint32(req.Context, req.WorkOfInt32ThenUint32, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfInt32ThenUint32) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfInt32ThenUint32) Push(ctx context.Context, req *WorkOfInt32ThenUint32) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfInt32ThenUint32)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfInt32ThenUint32 = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfInt32ThenUint32) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfInt32ThenUint32) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfInt32ThenUint32) Call(ctx context.Context, arg int32) (uint32, error) {
	return __.api_syncer.DoOfInt32ThenUint32(ctx, __, arg)
}

type PoolOfInt32ThenUint64 interface {
	GetInt32Arg() *int32
	PutInt32Arg(*int32)
	GetUint64Return() *uint64
	PutUint64Return(*uint64)

	GetWorkOfInt32ThenUint64() *WorkOfInt32ThenUint64
	GetReturnOfUint64() *ReturnOfUint64
	PutWorkOfInt32ThenUint64(*WorkOfInt32ThenUint64)
	PutReturnOfUint64(*ReturnOfUint64)

	GetChReturnOfUint64() chan *ReturnOfUint64
	PutChReturnOfUint64(chan *ReturnOfUint64)
}

type PoolOfInt32ThenUint64Impl struct {
	Int32Arg         sync.Pool
	Uint64Rtn        sync.Pool
	Int32Work        sync.Pool
	Uint64Return     sync.Pool
	ChReturnOfUint64 sync.Pool
}

func (__ *PoolOfInt32ThenUint64Impl) GetInt32Arg() *int32 {
	return __.Int32Arg.Get().(*int32)
}
func (__ *PoolOfInt32ThenUint64Impl) PutInt32Arg(p *int32) {
	__.Int32Arg.Put(p)
}
func (__ *PoolOfInt32ThenUint64Impl) GetUint64Return() *uint64 {
	return __.Uint64Rtn.Get().(*uint64)
}
func (__ *PoolOfInt32ThenUint64Impl) PutUint64Return(p *uint64) {
	__.Uint64Rtn.Put(p)
}

func (__ *PoolOfInt32ThenUint64Impl) GetWorkOfInt32ThenUint64() *WorkOfInt32ThenUint64 {
	return __.Int32Work.Get().(*WorkOfInt32ThenUint64)
}
func (__ *PoolOfInt32ThenUint64Impl) PutWorkOfInt32ThenUint64(p *WorkOfInt32ThenUint64) {
	__.Int32Work.Put(p)
}
func (__ *PoolOfInt32ThenUint64Impl) GetReturnOfUint64() *ReturnOfUint64 {
	return __.Uint64Return.Get().(*ReturnOfUint64)
}
func (__ *PoolOfInt32ThenUint64Impl) PutReturnOfUint64(p *ReturnOfUint64) {
	__.Uint64Return.Put(p)
}

func (__ *PoolOfInt32ThenUint64Impl) GetChReturnOfUint64() chan *ReturnOfUint64 {
	return __.ChReturnOfUint64.Get().(chan *ReturnOfUint64)
}
func (__ *PoolOfInt32ThenUint64Impl) PutChReturnOfUint64(p chan *ReturnOfUint64) {
	__.ChReturnOfUint64.Put(p)
}

func NewPoolOfInt32ThenUint64Impl() *PoolOfInt32ThenUint64Impl {
	return &PoolOfInt32ThenUint64Impl{
		Int32Arg: sync.Pool{
			New: func() interface{} {
				return new(int32)
			},
		},
		Int32Work: sync.Pool{
			New: func() interface{} {
				return new(WorkOfInt32ThenUint64)
			},
		},
		Uint64Rtn: sync.Pool{
			New: func() interface{} {
				return new(uint64)
			},
		},
		Uint64Return: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfUint64)
			},
		},
		ChReturnOfUint64: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfUint64, 1)
			},
		},
	}
}

type ApiDecouplerOfInt32ThenUint64 struct {
	pool PoolOfInt32ThenUint64
}

func NewApiDecouplerOfInt32ThenUint64() *ApiDecouplerOfInt32ThenUint64 {
	return &ApiDecouplerOfInt32ThenUint64{
		pool: NewPoolOfInt32ThenUint64Impl(),
	}
}

func (__ *ApiDecouplerOfInt32ThenUint64) ReturnError(rtn_ch chan<- *ReturnOfUint64, err error) {
	rtn := __.pool.GetReturnOfUint64()
	var other uint64
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfInt32ThenUint64) HandleOfInt32ThenUint64(ctx context.Context, req *WorkOfInt32ThenUint64, h func(ctx context.Context, arg int32) (uint64, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfUint64()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfInt32ThenUint64) DoOfInt32ThenUint64(ctx context.Context, worker WorkerOfPushInt32ThenUint64, arg int32) (uint64, error) {
	// ch := make(chan *ReturnOfUint64, 1)
	ch := __.pool.GetChReturnOfUint64()
	defer __.pool.PutChReturnOfUint64(ch)

	req := __.pool.GetWorkOfInt32ThenUint64()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfInt32ThenUint64(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfUint64(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfInt32ThenUint64 = func(ctx context.Context, arg int32) (uint64, error)

type WorkerOfInt32ThenUint64 struct {
	api_syncer *ApiDecouplerOfInt32ThenUint64
	handler    WorkHandlerOfInt32ThenUint64

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfInt32ThenUint64
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfInt32ThenUint64(ctx context.Context, h WorkHandlerOfInt32ThenUint64, n int) *WorkerOfInt32ThenUint64 {
	__ := &WorkerOfInt32ThenUint64{
		api_syncer: NewApiDecouplerOfInt32ThenUint64(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfInt32ThenUint64, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfInt32ThenUint64{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfInt32ThenUint64(req.Context, req.WorkOfInt32ThenUint64, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfInt32ThenUint64) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfInt32ThenUint64) Push(ctx context.Context, req *WorkOfInt32ThenUint64) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfInt32ThenUint64)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfInt32ThenUint64 = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfInt32ThenUint64) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfInt32ThenUint64) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfInt32ThenUint64) Call(ctx context.Context, arg int32) (uint64, error) {
	return __.api_syncer.DoOfInt32ThenUint64(ctx, __, arg)
}

type PoolOfInt32ThenUint8 interface {
	GetInt32Arg() *int32
	PutInt32Arg(*int32)
	GetUint8Return() *uint8
	PutUint8Return(*uint8)

	GetWorkOfInt32ThenUint8() *WorkOfInt32ThenUint8
	GetReturnOfUint8() *ReturnOfUint8
	PutWorkOfInt32ThenUint8(*WorkOfInt32ThenUint8)
	PutReturnOfUint8(*ReturnOfUint8)

	GetChReturnOfUint8() chan *ReturnOfUint8
	PutChReturnOfUint8(chan *ReturnOfUint8)
}

type PoolOfInt32ThenUint8Impl struct {
	Int32Arg        sync.Pool
	Uint8Rtn        sync.Pool
	Int32Work       sync.Pool
	Uint8Return     sync.Pool
	ChReturnOfUint8 sync.Pool
}

func (__ *PoolOfInt32ThenUint8Impl) GetInt32Arg() *int32 {
	return __.Int32Arg.Get().(*int32)
}
func (__ *PoolOfInt32ThenUint8Impl) PutInt32Arg(p *int32) {
	__.Int32Arg.Put(p)
}
func (__ *PoolOfInt32ThenUint8Impl) GetUint8Return() *uint8 {
	return __.Uint8Rtn.Get().(*uint8)
}
func (__ *PoolOfInt32ThenUint8Impl) PutUint8Return(p *uint8) {
	__.Uint8Rtn.Put(p)
}

func (__ *PoolOfInt32ThenUint8Impl) GetWorkOfInt32ThenUint8() *WorkOfInt32ThenUint8 {
	return __.Int32Work.Get().(*WorkOfInt32ThenUint8)
}
func (__ *PoolOfInt32ThenUint8Impl) PutWorkOfInt32ThenUint8(p *WorkOfInt32ThenUint8) {
	__.Int32Work.Put(p)
}
func (__ *PoolOfInt32ThenUint8Impl) GetReturnOfUint8() *ReturnOfUint8 {
	return __.Uint8Return.Get().(*ReturnOfUint8)
}
func (__ *PoolOfInt32ThenUint8Impl) PutReturnOfUint8(p *ReturnOfUint8) {
	__.Uint8Return.Put(p)
}

func (__ *PoolOfInt32ThenUint8Impl) GetChReturnOfUint8() chan *ReturnOfUint8 {
	return __.ChReturnOfUint8.Get().(chan *ReturnOfUint8)
}
func (__ *PoolOfInt32ThenUint8Impl) PutChReturnOfUint8(p chan *ReturnOfUint8) {
	__.ChReturnOfUint8.Put(p)
}

func NewPoolOfInt32ThenUint8Impl() *PoolOfInt32ThenUint8Impl {
	return &PoolOfInt32ThenUint8Impl{
		Int32Arg: sync.Pool{
			New: func() interface{} {
				return new(int32)
			},
		},
		Int32Work: sync.Pool{
			New: func() interface{} {
				return new(WorkOfInt32ThenUint8)
			},
		},
		Uint8Rtn: sync.Pool{
			New: func() interface{} {
				return new(uint8)
			},
		},
		Uint8Return: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfUint8)
			},
		},
		ChReturnOfUint8: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfUint8, 1)
			},
		},
	}
}

type ApiDecouplerOfInt32ThenUint8 struct {
	pool PoolOfInt32ThenUint8
}

func NewApiDecouplerOfInt32ThenUint8() *ApiDecouplerOfInt32ThenUint8 {
	return &ApiDecouplerOfInt32ThenUint8{
		pool: NewPoolOfInt32ThenUint8Impl(),
	}
}

func (__ *ApiDecouplerOfInt32ThenUint8) ReturnError(rtn_ch chan<- *ReturnOfUint8, err error) {
	rtn := __.pool.GetReturnOfUint8()
	var other uint8
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfInt32ThenUint8) HandleOfInt32ThenUint8(ctx context.Context, req *WorkOfInt32ThenUint8, h func(ctx context.Context, arg int32) (uint8, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfUint8()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfInt32ThenUint8) DoOfInt32ThenUint8(ctx context.Context, worker WorkerOfPushInt32ThenUint8, arg int32) (uint8, error) {
	// ch := make(chan *ReturnOfUint8, 1)
	ch := __.pool.GetChReturnOfUint8()
	defer __.pool.PutChReturnOfUint8(ch)

	req := __.pool.GetWorkOfInt32ThenUint8()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfInt32ThenUint8(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfUint8(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfInt32ThenUint8 = func(ctx context.Context, arg int32) (uint8, error)

type WorkerOfInt32ThenUint8 struct {
	api_syncer *ApiDecouplerOfInt32ThenUint8
	handler    WorkHandlerOfInt32ThenUint8

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfInt32ThenUint8
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfInt32ThenUint8(ctx context.Context, h WorkHandlerOfInt32ThenUint8, n int) *WorkerOfInt32ThenUint8 {
	__ := &WorkerOfInt32ThenUint8{
		api_syncer: NewApiDecouplerOfInt32ThenUint8(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfInt32ThenUint8, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfInt32ThenUint8{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfInt32ThenUint8(req.Context, req.WorkOfInt32ThenUint8, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfInt32ThenUint8) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfInt32ThenUint8) Push(ctx context.Context, req *WorkOfInt32ThenUint8) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfInt32ThenUint8)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfInt32ThenUint8 = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfInt32ThenUint8) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfInt32ThenUint8) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfInt32ThenUint8) Call(ctx context.Context, arg int32) (uint8, error) {
	return __.api_syncer.DoOfInt32ThenUint8(ctx, __, arg)
}

type PoolOfInt32ThenUintptr interface {
	GetInt32Arg() *int32
	PutInt32Arg(*int32)
	GetUintptrReturn() *uintptr
	PutUintptrReturn(*uintptr)

	GetWorkOfInt32ThenUintptr() *WorkOfInt32ThenUintptr
	GetReturnOfUintptr() *ReturnOfUintptr
	PutWorkOfInt32ThenUintptr(*WorkOfInt32ThenUintptr)
	PutReturnOfUintptr(*ReturnOfUintptr)

	GetChReturnOfUintptr() chan *ReturnOfUintptr
	PutChReturnOfUintptr(chan *ReturnOfUintptr)
}

type PoolOfInt32ThenUintptrImpl struct {
	Int32Arg          sync.Pool
	UintptrRtn        sync.Pool
	Int32Work         sync.Pool
	UintptrReturn     sync.Pool
	ChReturnOfUintptr sync.Pool
}

func (__ *PoolOfInt32ThenUintptrImpl) GetInt32Arg() *int32 {
	return __.Int32Arg.Get().(*int32)
}
func (__ *PoolOfInt32ThenUintptrImpl) PutInt32Arg(p *int32) {
	__.Int32Arg.Put(p)
}
func (__ *PoolOfInt32ThenUintptrImpl) GetUintptrReturn() *uintptr {
	return __.UintptrRtn.Get().(*uintptr)
}
func (__ *PoolOfInt32ThenUintptrImpl) PutUintptrReturn(p *uintptr) {
	__.UintptrRtn.Put(p)
}

func (__ *PoolOfInt32ThenUintptrImpl) GetWorkOfInt32ThenUintptr() *WorkOfInt32ThenUintptr {
	return __.Int32Work.Get().(*WorkOfInt32ThenUintptr)
}
func (__ *PoolOfInt32ThenUintptrImpl) PutWorkOfInt32ThenUintptr(p *WorkOfInt32ThenUintptr) {
	__.Int32Work.Put(p)
}
func (__ *PoolOfInt32ThenUintptrImpl) GetReturnOfUintptr() *ReturnOfUintptr {
	return __.UintptrReturn.Get().(*ReturnOfUintptr)
}
func (__ *PoolOfInt32ThenUintptrImpl) PutReturnOfUintptr(p *ReturnOfUintptr) {
	__.UintptrReturn.Put(p)
}

func (__ *PoolOfInt32ThenUintptrImpl) GetChReturnOfUintptr() chan *ReturnOfUintptr {
	return __.ChReturnOfUintptr.Get().(chan *ReturnOfUintptr)
}
func (__ *PoolOfInt32ThenUintptrImpl) PutChReturnOfUintptr(p chan *ReturnOfUintptr) {
	__.ChReturnOfUintptr.Put(p)
}

func NewPoolOfInt32ThenUintptrImpl() *PoolOfInt32ThenUintptrImpl {
	return &PoolOfInt32ThenUintptrImpl{
		Int32Arg: sync.Pool{
			New: func() interface{} {
				return new(int32)
			},
		},
		Int32Work: sync.Pool{
			New: func() interface{} {
				return new(WorkOfInt32ThenUintptr)
			},
		},
		UintptrRtn: sync.Pool{
			New: func() interface{} {
				return new(uintptr)
			},
		},
		UintptrReturn: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfUintptr)
			},
		},
		ChReturnOfUintptr: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfUintptr, 1)
			},
		},
	}
}

type ApiDecouplerOfInt32ThenUintptr struct {
	pool PoolOfInt32ThenUintptr
}

func NewApiDecouplerOfInt32ThenUintptr() *ApiDecouplerOfInt32ThenUintptr {
	return &ApiDecouplerOfInt32ThenUintptr{
		pool: NewPoolOfInt32ThenUintptrImpl(),
	}
}

func (__ *ApiDecouplerOfInt32ThenUintptr) ReturnError(rtn_ch chan<- *ReturnOfUintptr, err error) {
	rtn := __.pool.GetReturnOfUintptr()
	var other uintptr
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfInt32ThenUintptr) HandleOfInt32ThenUintptr(ctx context.Context, req *WorkOfInt32ThenUintptr, h func(ctx context.Context, arg int32) (uintptr, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfUintptr()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfInt32ThenUintptr) DoOfInt32ThenUintptr(ctx context.Context, worker WorkerOfPushInt32ThenUintptr, arg int32) (uintptr, error) {
	// ch := make(chan *ReturnOfUintptr, 1)
	ch := __.pool.GetChReturnOfUintptr()
	defer __.pool.PutChReturnOfUintptr(ch)

	req := __.pool.GetWorkOfInt32ThenUintptr()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfInt32ThenUintptr(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfUintptr(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfInt32ThenUintptr = func(ctx context.Context, arg int32) (uintptr, error)

type WorkerOfInt32ThenUintptr struct {
	api_syncer *ApiDecouplerOfInt32ThenUintptr
	handler    WorkHandlerOfInt32ThenUintptr

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfInt32ThenUintptr
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfInt32ThenUintptr(ctx context.Context, h WorkHandlerOfInt32ThenUintptr, n int) *WorkerOfInt32ThenUintptr {
	__ := &WorkerOfInt32ThenUintptr{
		api_syncer: NewApiDecouplerOfInt32ThenUintptr(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfInt32ThenUintptr, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfInt32ThenUintptr{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfInt32ThenUintptr(req.Context, req.WorkOfInt32ThenUintptr, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfInt32ThenUintptr) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfInt32ThenUintptr) Push(ctx context.Context, req *WorkOfInt32ThenUintptr) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfInt32ThenUintptr)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfInt32ThenUintptr = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfInt32ThenUintptr) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfInt32ThenUintptr) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfInt32ThenUintptr) Call(ctx context.Context, arg int32) (uintptr, error) {
	return __.api_syncer.DoOfInt32ThenUintptr(ctx, __, arg)
}

type PoolOfInt32ThenInterface interface {
	GetInt32Arg() *int32
	PutInt32Arg(*int32)
	GetInterfaceReturn() *interface{}
	PutInterfaceReturn(*interface{})

	GetWorkOfInt32ThenInterface() *WorkOfInt32ThenInterface
	GetReturnOfInterface() *ReturnOfInterface
	PutWorkOfInt32ThenInterface(*WorkOfInt32ThenInterface)
	PutReturnOfInterface(*ReturnOfInterface)

	GetChReturnOfInterface() chan *ReturnOfInterface
	PutChReturnOfInterface(chan *ReturnOfInterface)
}

type PoolOfInt32ThenInterfaceImpl struct {
	Int32Arg            sync.Pool
	InterfaceRtn        sync.Pool
	Int32Work           sync.Pool
	InterfaceReturn     sync.Pool
	ChReturnOfInterface sync.Pool
}

func (__ *PoolOfInt32ThenInterfaceImpl) GetInt32Arg() *int32 {
	return __.Int32Arg.Get().(*int32)
}
func (__ *PoolOfInt32ThenInterfaceImpl) PutInt32Arg(p *int32) {
	__.Int32Arg.Put(p)
}
func (__ *PoolOfInt32ThenInterfaceImpl) GetInterfaceReturn() *interface{} {
	return __.InterfaceRtn.Get().(*interface{})
}
func (__ *PoolOfInt32ThenInterfaceImpl) PutInterfaceReturn(p *interface{}) {
	__.InterfaceRtn.Put(p)
}

func (__ *PoolOfInt32ThenInterfaceImpl) GetWorkOfInt32ThenInterface() *WorkOfInt32ThenInterface {
	return __.Int32Work.Get().(*WorkOfInt32ThenInterface)
}
func (__ *PoolOfInt32ThenInterfaceImpl) PutWorkOfInt32ThenInterface(p *WorkOfInt32ThenInterface) {
	__.Int32Work.Put(p)
}
func (__ *PoolOfInt32ThenInterfaceImpl) GetReturnOfInterface() *ReturnOfInterface {
	return __.InterfaceReturn.Get().(*ReturnOfInterface)
}
func (__ *PoolOfInt32ThenInterfaceImpl) PutReturnOfInterface(p *ReturnOfInterface) {
	__.InterfaceReturn.Put(p)
}

func (__ *PoolOfInt32ThenInterfaceImpl) GetChReturnOfInterface() chan *ReturnOfInterface {
	return __.ChReturnOfInterface.Get().(chan *ReturnOfInterface)
}
func (__ *PoolOfInt32ThenInterfaceImpl) PutChReturnOfInterface(p chan *ReturnOfInterface) {
	__.ChReturnOfInterface.Put(p)
}

func NewPoolOfInt32ThenInterfaceImpl() *PoolOfInt32ThenInterfaceImpl {
	return &PoolOfInt32ThenInterfaceImpl{
		Int32Arg: sync.Pool{
			New: func() interface{} {
				return new(int32)
			},
		},
		Int32Work: sync.Pool{
			New: func() interface{} {
				return new(WorkOfInt32ThenInterface)
			},
		},
		InterfaceRtn: sync.Pool{
			New: func() interface{} {
				return new(interface{})
			},
		},
		InterfaceReturn: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfInterface)
			},
		},
		ChReturnOfInterface: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfInterface, 1)
			},
		},
	}
}

type ApiDecouplerOfInt32ThenInterface struct {
	pool PoolOfInt32ThenInterface
}

func NewApiDecouplerOfInt32ThenInterface() *ApiDecouplerOfInt32ThenInterface {
	return &ApiDecouplerOfInt32ThenInterface{
		pool: NewPoolOfInt32ThenInterfaceImpl(),
	}
}

func (__ *ApiDecouplerOfInt32ThenInterface) ReturnError(rtn_ch chan<- *ReturnOfInterface, err error) {
	rtn := __.pool.GetReturnOfInterface()
	var other interface{}
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfInt32ThenInterface) HandleOfInt32ThenInterface(ctx context.Context, req *WorkOfInt32ThenInterface, h func(ctx context.Context, arg int32) (interface{}, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfInterface()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfInt32ThenInterface) DoOfInt32ThenInterface(ctx context.Context, worker WorkerOfPushInt32ThenInterface, arg int32) (interface{}, error) {
	// ch := make(chan *ReturnOfInterface, 1)
	ch := __.pool.GetChReturnOfInterface()
	defer __.pool.PutChReturnOfInterface(ch)

	req := __.pool.GetWorkOfInt32ThenInterface()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfInt32ThenInterface(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfInterface(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfInt32ThenInterface = func(ctx context.Context, arg int32) (interface{}, error)

type WorkerOfInt32ThenInterface struct {
	api_syncer *ApiDecouplerOfInt32ThenInterface
	handler    WorkHandlerOfInt32ThenInterface

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfInt32ThenInterface
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfInt32ThenInterface(ctx context.Context, h WorkHandlerOfInt32ThenInterface, n int) *WorkerOfInt32ThenInterface {
	__ := &WorkerOfInt32ThenInterface{
		api_syncer: NewApiDecouplerOfInt32ThenInterface(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfInt32ThenInterface, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfInt32ThenInterface{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfInt32ThenInterface(req.Context, req.WorkOfInt32ThenInterface, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfInt32ThenInterface) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfInt32ThenInterface) Push(ctx context.Context, req *WorkOfInt32ThenInterface) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfInt32ThenInterface)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfInt32ThenInterface = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfInt32ThenInterface) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfInt32ThenInterface) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfInt32ThenInterface) Call(ctx context.Context, arg int32) (interface{}, error) {
	return __.api_syncer.DoOfInt32ThenInterface(ctx, __, arg)
}

type PoolOfInt32ThenStruct interface {
	GetInt32Arg() *int32
	PutInt32Arg(*int32)
	GetStructReturn() *struct{}
	PutStructReturn(*struct{})

	GetWorkOfInt32ThenStruct() *WorkOfInt32ThenStruct
	GetReturnOfStruct() *ReturnOfStruct
	PutWorkOfInt32ThenStruct(*WorkOfInt32ThenStruct)
	PutReturnOfStruct(*ReturnOfStruct)

	GetChReturnOfStruct() chan *ReturnOfStruct
	PutChReturnOfStruct(chan *ReturnOfStruct)
}

type PoolOfInt32ThenStructImpl struct {
	Int32Arg         sync.Pool
	StructRtn        sync.Pool
	Int32Work        sync.Pool
	StructReturn     sync.Pool
	ChReturnOfStruct sync.Pool
}

func (__ *PoolOfInt32ThenStructImpl) GetInt32Arg() *int32 {
	return __.Int32Arg.Get().(*int32)
}
func (__ *PoolOfInt32ThenStructImpl) PutInt32Arg(p *int32) {
	__.Int32Arg.Put(p)
}
func (__ *PoolOfInt32ThenStructImpl) GetStructReturn() *struct{} {
	return __.StructRtn.Get().(*struct{})
}
func (__ *PoolOfInt32ThenStructImpl) PutStructReturn(p *struct{}) {
	__.StructRtn.Put(p)
}

func (__ *PoolOfInt32ThenStructImpl) GetWorkOfInt32ThenStruct() *WorkOfInt32ThenStruct {
	return __.Int32Work.Get().(*WorkOfInt32ThenStruct)
}
func (__ *PoolOfInt32ThenStructImpl) PutWorkOfInt32ThenStruct(p *WorkOfInt32ThenStruct) {
	__.Int32Work.Put(p)
}
func (__ *PoolOfInt32ThenStructImpl) GetReturnOfStruct() *ReturnOfStruct {
	return __.StructReturn.Get().(*ReturnOfStruct)
}
func (__ *PoolOfInt32ThenStructImpl) PutReturnOfStruct(p *ReturnOfStruct) {
	__.StructReturn.Put(p)
}

func (__ *PoolOfInt32ThenStructImpl) GetChReturnOfStruct() chan *ReturnOfStruct {
	return __.ChReturnOfStruct.Get().(chan *ReturnOfStruct)
}
func (__ *PoolOfInt32ThenStructImpl) PutChReturnOfStruct(p chan *ReturnOfStruct) {
	__.ChReturnOfStruct.Put(p)
}

func NewPoolOfInt32ThenStructImpl() *PoolOfInt32ThenStructImpl {
	return &PoolOfInt32ThenStructImpl{
		Int32Arg: sync.Pool{
			New: func() interface{} {
				return new(int32)
			},
		},
		Int32Work: sync.Pool{
			New: func() interface{} {
				return new(WorkOfInt32ThenStruct)
			},
		},
		StructRtn: sync.Pool{
			New: func() interface{} {
				return new(struct{})
			},
		},
		StructReturn: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfStruct)
			},
		},
		ChReturnOfStruct: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfStruct, 1)
			},
		},
	}
}

type ApiDecouplerOfInt32ThenStruct struct {
	pool PoolOfInt32ThenStruct
}

func NewApiDecouplerOfInt32ThenStruct() *ApiDecouplerOfInt32ThenStruct {
	return &ApiDecouplerOfInt32ThenStruct{
		pool: NewPoolOfInt32ThenStructImpl(),
	}
}

func (__ *ApiDecouplerOfInt32ThenStruct) ReturnError(rtn_ch chan<- *ReturnOfStruct, err error) {
	rtn := __.pool.GetReturnOfStruct()
	var other struct{}
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfInt32ThenStruct) HandleOfInt32ThenStruct(ctx context.Context, req *WorkOfInt32ThenStruct, h func(ctx context.Context, arg int32) (struct{}, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfStruct()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfInt32ThenStruct) DoOfInt32ThenStruct(ctx context.Context, worker WorkerOfPushInt32ThenStruct, arg int32) (struct{}, error) {
	// ch := make(chan *ReturnOfStruct, 1)
	ch := __.pool.GetChReturnOfStruct()
	defer __.pool.PutChReturnOfStruct(ch)

	req := __.pool.GetWorkOfInt32ThenStruct()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfInt32ThenStruct(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfStruct(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfInt32ThenStruct = func(ctx context.Context, arg int32) (struct{}, error)

type WorkerOfInt32ThenStruct struct {
	api_syncer *ApiDecouplerOfInt32ThenStruct
	handler    WorkHandlerOfInt32ThenStruct

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfInt32ThenStruct
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfInt32ThenStruct(ctx context.Context, h WorkHandlerOfInt32ThenStruct, n int) *WorkerOfInt32ThenStruct {
	__ := &WorkerOfInt32ThenStruct{
		api_syncer: NewApiDecouplerOfInt32ThenStruct(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfInt32ThenStruct, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfInt32ThenStruct{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfInt32ThenStruct(req.Context, req.WorkOfInt32ThenStruct, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfInt32ThenStruct) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfInt32ThenStruct) Push(ctx context.Context, req *WorkOfInt32ThenStruct) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfInt32ThenStruct)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfInt32ThenStruct = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfInt32ThenStruct) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfInt32ThenStruct) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfInt32ThenStruct) Call(ctx context.Context, arg int32) (struct{}, error) {
	return __.api_syncer.DoOfInt32ThenStruct(ctx, __, arg)
}

type PoolOfInt64ThenBool interface {
	GetInt64Arg() *int64
	PutInt64Arg(*int64)
	GetBoolReturn() *bool
	PutBoolReturn(*bool)

	GetWorkOfInt64ThenBool() *WorkOfInt64ThenBool
	GetReturnOfBool() *ReturnOfBool
	PutWorkOfInt64ThenBool(*WorkOfInt64ThenBool)
	PutReturnOfBool(*ReturnOfBool)

	GetChReturnOfBool() chan *ReturnOfBool
	PutChReturnOfBool(chan *ReturnOfBool)
}

type PoolOfInt64ThenBoolImpl struct {
	Int64Arg       sync.Pool
	BoolRtn        sync.Pool
	Int64Work      sync.Pool
	BoolReturn     sync.Pool
	ChReturnOfBool sync.Pool
}

func (__ *PoolOfInt64ThenBoolImpl) GetInt64Arg() *int64 {
	return __.Int64Arg.Get().(*int64)
}
func (__ *PoolOfInt64ThenBoolImpl) PutInt64Arg(p *int64) {
	__.Int64Arg.Put(p)
}
func (__ *PoolOfInt64ThenBoolImpl) GetBoolReturn() *bool {
	return __.BoolRtn.Get().(*bool)
}
func (__ *PoolOfInt64ThenBoolImpl) PutBoolReturn(p *bool) {
	__.BoolRtn.Put(p)
}

func (__ *PoolOfInt64ThenBoolImpl) GetWorkOfInt64ThenBool() *WorkOfInt64ThenBool {
	return __.Int64Work.Get().(*WorkOfInt64ThenBool)
}
func (__ *PoolOfInt64ThenBoolImpl) PutWorkOfInt64ThenBool(p *WorkOfInt64ThenBool) {
	__.Int64Work.Put(p)
}
func (__ *PoolOfInt64ThenBoolImpl) GetReturnOfBool() *ReturnOfBool {
	return __.BoolReturn.Get().(*ReturnOfBool)
}
func (__ *PoolOfInt64ThenBoolImpl) PutReturnOfBool(p *ReturnOfBool) {
	__.BoolReturn.Put(p)
}

func (__ *PoolOfInt64ThenBoolImpl) GetChReturnOfBool() chan *ReturnOfBool {
	return __.ChReturnOfBool.Get().(chan *ReturnOfBool)
}
func (__ *PoolOfInt64ThenBoolImpl) PutChReturnOfBool(p chan *ReturnOfBool) {
	__.ChReturnOfBool.Put(p)
}

func NewPoolOfInt64ThenBoolImpl() *PoolOfInt64ThenBoolImpl {
	return &PoolOfInt64ThenBoolImpl{
		Int64Arg: sync.Pool{
			New: func() interface{} {
				return new(int64)
			},
		},
		Int64Work: sync.Pool{
			New: func() interface{} {
				return new(WorkOfInt64ThenBool)
			},
		},
		BoolRtn: sync.Pool{
			New: func() interface{} {
				return new(bool)
			},
		},
		BoolReturn: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfBool)
			},
		},
		ChReturnOfBool: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfBool, 1)
			},
		},
	}
}

type ApiDecouplerOfInt64ThenBool struct {
	pool PoolOfInt64ThenBool
}

func NewApiDecouplerOfInt64ThenBool() *ApiDecouplerOfInt64ThenBool {
	return &ApiDecouplerOfInt64ThenBool{
		pool: NewPoolOfInt64ThenBoolImpl(),
	}
}

func (__ *ApiDecouplerOfInt64ThenBool) ReturnError(rtn_ch chan<- *ReturnOfBool, err error) {
	rtn := __.pool.GetReturnOfBool()
	var other bool
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfInt64ThenBool) HandleOfInt64ThenBool(ctx context.Context, req *WorkOfInt64ThenBool, h func(ctx context.Context, arg int64) (bool, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfBool()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfInt64ThenBool) DoOfInt64ThenBool(ctx context.Context, worker WorkerOfPushInt64ThenBool, arg int64) (bool, error) {
	// ch := make(chan *ReturnOfBool, 1)
	ch := __.pool.GetChReturnOfBool()
	defer __.pool.PutChReturnOfBool(ch)

	req := __.pool.GetWorkOfInt64ThenBool()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfInt64ThenBool(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfBool(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfInt64ThenBool = func(ctx context.Context, arg int64) (bool, error)

type WorkerOfInt64ThenBool struct {
	api_syncer *ApiDecouplerOfInt64ThenBool
	handler    WorkHandlerOfInt64ThenBool

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfInt64ThenBool
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfInt64ThenBool(ctx context.Context, h WorkHandlerOfInt64ThenBool, n int) *WorkerOfInt64ThenBool {
	__ := &WorkerOfInt64ThenBool{
		api_syncer: NewApiDecouplerOfInt64ThenBool(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfInt64ThenBool, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfInt64ThenBool{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfInt64ThenBool(req.Context, req.WorkOfInt64ThenBool, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfInt64ThenBool) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfInt64ThenBool) Push(ctx context.Context, req *WorkOfInt64ThenBool) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfInt64ThenBool)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfInt64ThenBool = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfInt64ThenBool) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfInt64ThenBool) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfInt64ThenBool) Call(ctx context.Context, arg int64) (bool, error) {
	return __.api_syncer.DoOfInt64ThenBool(ctx, __, arg)
}

type PoolOfInt64ThenByte interface {
	GetInt64Arg() *int64
	PutInt64Arg(*int64)
	GetByteReturn() *byte
	PutByteReturn(*byte)

	GetWorkOfInt64ThenByte() *WorkOfInt64ThenByte
	GetReturnOfByte() *ReturnOfByte
	PutWorkOfInt64ThenByte(*WorkOfInt64ThenByte)
	PutReturnOfByte(*ReturnOfByte)

	GetChReturnOfByte() chan *ReturnOfByte
	PutChReturnOfByte(chan *ReturnOfByte)
}

type PoolOfInt64ThenByteImpl struct {
	Int64Arg       sync.Pool
	ByteRtn        sync.Pool
	Int64Work      sync.Pool
	ByteReturn     sync.Pool
	ChReturnOfByte sync.Pool
}

func (__ *PoolOfInt64ThenByteImpl) GetInt64Arg() *int64 {
	return __.Int64Arg.Get().(*int64)
}
func (__ *PoolOfInt64ThenByteImpl) PutInt64Arg(p *int64) {
	__.Int64Arg.Put(p)
}
func (__ *PoolOfInt64ThenByteImpl) GetByteReturn() *byte {
	return __.ByteRtn.Get().(*byte)
}
func (__ *PoolOfInt64ThenByteImpl) PutByteReturn(p *byte) {
	__.ByteRtn.Put(p)
}

func (__ *PoolOfInt64ThenByteImpl) GetWorkOfInt64ThenByte() *WorkOfInt64ThenByte {
	return __.Int64Work.Get().(*WorkOfInt64ThenByte)
}
func (__ *PoolOfInt64ThenByteImpl) PutWorkOfInt64ThenByte(p *WorkOfInt64ThenByte) {
	__.Int64Work.Put(p)
}
func (__ *PoolOfInt64ThenByteImpl) GetReturnOfByte() *ReturnOfByte {
	return __.ByteReturn.Get().(*ReturnOfByte)
}
func (__ *PoolOfInt64ThenByteImpl) PutReturnOfByte(p *ReturnOfByte) {
	__.ByteReturn.Put(p)
}

func (__ *PoolOfInt64ThenByteImpl) GetChReturnOfByte() chan *ReturnOfByte {
	return __.ChReturnOfByte.Get().(chan *ReturnOfByte)
}
func (__ *PoolOfInt64ThenByteImpl) PutChReturnOfByte(p chan *ReturnOfByte) {
	__.ChReturnOfByte.Put(p)
}

func NewPoolOfInt64ThenByteImpl() *PoolOfInt64ThenByteImpl {
	return &PoolOfInt64ThenByteImpl{
		Int64Arg: sync.Pool{
			New: func() interface{} {
				return new(int64)
			},
		},
		Int64Work: sync.Pool{
			New: func() interface{} {
				return new(WorkOfInt64ThenByte)
			},
		},
		ByteRtn: sync.Pool{
			New: func() interface{} {
				return new(byte)
			},
		},
		ByteReturn: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfByte)
			},
		},
		ChReturnOfByte: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfByte, 1)
			},
		},
	}
}

type ApiDecouplerOfInt64ThenByte struct {
	pool PoolOfInt64ThenByte
}

func NewApiDecouplerOfInt64ThenByte() *ApiDecouplerOfInt64ThenByte {
	return &ApiDecouplerOfInt64ThenByte{
		pool: NewPoolOfInt64ThenByteImpl(),
	}
}

func (__ *ApiDecouplerOfInt64ThenByte) ReturnError(rtn_ch chan<- *ReturnOfByte, err error) {
	rtn := __.pool.GetReturnOfByte()
	var other byte
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfInt64ThenByte) HandleOfInt64ThenByte(ctx context.Context, req *WorkOfInt64ThenByte, h func(ctx context.Context, arg int64) (byte, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfByte()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfInt64ThenByte) DoOfInt64ThenByte(ctx context.Context, worker WorkerOfPushInt64ThenByte, arg int64) (byte, error) {
	// ch := make(chan *ReturnOfByte, 1)
	ch := __.pool.GetChReturnOfByte()
	defer __.pool.PutChReturnOfByte(ch)

	req := __.pool.GetWorkOfInt64ThenByte()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfInt64ThenByte(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfByte(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfInt64ThenByte = func(ctx context.Context, arg int64) (byte, error)

type WorkerOfInt64ThenByte struct {
	api_syncer *ApiDecouplerOfInt64ThenByte
	handler    WorkHandlerOfInt64ThenByte

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfInt64ThenByte
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfInt64ThenByte(ctx context.Context, h WorkHandlerOfInt64ThenByte, n int) *WorkerOfInt64ThenByte {
	__ := &WorkerOfInt64ThenByte{
		api_syncer: NewApiDecouplerOfInt64ThenByte(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfInt64ThenByte, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfInt64ThenByte{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfInt64ThenByte(req.Context, req.WorkOfInt64ThenByte, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfInt64ThenByte) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfInt64ThenByte) Push(ctx context.Context, req *WorkOfInt64ThenByte) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfInt64ThenByte)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfInt64ThenByte = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfInt64ThenByte) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfInt64ThenByte) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfInt64ThenByte) Call(ctx context.Context, arg int64) (byte, error) {
	return __.api_syncer.DoOfInt64ThenByte(ctx, __, arg)
}

type PoolOfInt64ThenComplex128 interface {
	GetInt64Arg() *int64
	PutInt64Arg(*int64)
	GetComplex128Return() *complex128
	PutComplex128Return(*complex128)

	GetWorkOfInt64ThenComplex128() *WorkOfInt64ThenComplex128
	GetReturnOfComplex128() *ReturnOfComplex128
	PutWorkOfInt64ThenComplex128(*WorkOfInt64ThenComplex128)
	PutReturnOfComplex128(*ReturnOfComplex128)

	GetChReturnOfComplex128() chan *ReturnOfComplex128
	PutChReturnOfComplex128(chan *ReturnOfComplex128)
}

type PoolOfInt64ThenComplex128Impl struct {
	Int64Arg             sync.Pool
	Complex128Rtn        sync.Pool
	Int64Work            sync.Pool
	Complex128Return     sync.Pool
	ChReturnOfComplex128 sync.Pool
}

func (__ *PoolOfInt64ThenComplex128Impl) GetInt64Arg() *int64 {
	return __.Int64Arg.Get().(*int64)
}
func (__ *PoolOfInt64ThenComplex128Impl) PutInt64Arg(p *int64) {
	__.Int64Arg.Put(p)
}
func (__ *PoolOfInt64ThenComplex128Impl) GetComplex128Return() *complex128 {
	return __.Complex128Rtn.Get().(*complex128)
}
func (__ *PoolOfInt64ThenComplex128Impl) PutComplex128Return(p *complex128) {
	__.Complex128Rtn.Put(p)
}

func (__ *PoolOfInt64ThenComplex128Impl) GetWorkOfInt64ThenComplex128() *WorkOfInt64ThenComplex128 {
	return __.Int64Work.Get().(*WorkOfInt64ThenComplex128)
}
func (__ *PoolOfInt64ThenComplex128Impl) PutWorkOfInt64ThenComplex128(p *WorkOfInt64ThenComplex128) {
	__.Int64Work.Put(p)
}
func (__ *PoolOfInt64ThenComplex128Impl) GetReturnOfComplex128() *ReturnOfComplex128 {
	return __.Complex128Return.Get().(*ReturnOfComplex128)
}
func (__ *PoolOfInt64ThenComplex128Impl) PutReturnOfComplex128(p *ReturnOfComplex128) {
	__.Complex128Return.Put(p)
}

func (__ *PoolOfInt64ThenComplex128Impl) GetChReturnOfComplex128() chan *ReturnOfComplex128 {
	return __.ChReturnOfComplex128.Get().(chan *ReturnOfComplex128)
}
func (__ *PoolOfInt64ThenComplex128Impl) PutChReturnOfComplex128(p chan *ReturnOfComplex128) {
	__.ChReturnOfComplex128.Put(p)
}

func NewPoolOfInt64ThenComplex128Impl() *PoolOfInt64ThenComplex128Impl {
	return &PoolOfInt64ThenComplex128Impl{
		Int64Arg: sync.Pool{
			New: func() interface{} {
				return new(int64)
			},
		},
		Int64Work: sync.Pool{
			New: func() interface{} {
				return new(WorkOfInt64ThenComplex128)
			},
		},
		Complex128Rtn: sync.Pool{
			New: func() interface{} {
				return new(complex128)
			},
		},
		Complex128Return: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfComplex128)
			},
		},
		ChReturnOfComplex128: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfComplex128, 1)
			},
		},
	}
}

type ApiDecouplerOfInt64ThenComplex128 struct {
	pool PoolOfInt64ThenComplex128
}

func NewApiDecouplerOfInt64ThenComplex128() *ApiDecouplerOfInt64ThenComplex128 {
	return &ApiDecouplerOfInt64ThenComplex128{
		pool: NewPoolOfInt64ThenComplex128Impl(),
	}
}

func (__ *ApiDecouplerOfInt64ThenComplex128) ReturnError(rtn_ch chan<- *ReturnOfComplex128, err error) {
	rtn := __.pool.GetReturnOfComplex128()
	var other complex128
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfInt64ThenComplex128) HandleOfInt64ThenComplex128(ctx context.Context, req *WorkOfInt64ThenComplex128, h func(ctx context.Context, arg int64) (complex128, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfComplex128()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfInt64ThenComplex128) DoOfInt64ThenComplex128(ctx context.Context, worker WorkerOfPushInt64ThenComplex128, arg int64) (complex128, error) {
	// ch := make(chan *ReturnOfComplex128, 1)
	ch := __.pool.GetChReturnOfComplex128()
	defer __.pool.PutChReturnOfComplex128(ch)

	req := __.pool.GetWorkOfInt64ThenComplex128()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfInt64ThenComplex128(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfComplex128(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfInt64ThenComplex128 = func(ctx context.Context, arg int64) (complex128, error)

type WorkerOfInt64ThenComplex128 struct {
	api_syncer *ApiDecouplerOfInt64ThenComplex128
	handler    WorkHandlerOfInt64ThenComplex128

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfInt64ThenComplex128
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfInt64ThenComplex128(ctx context.Context, h WorkHandlerOfInt64ThenComplex128, n int) *WorkerOfInt64ThenComplex128 {
	__ := &WorkerOfInt64ThenComplex128{
		api_syncer: NewApiDecouplerOfInt64ThenComplex128(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfInt64ThenComplex128, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfInt64ThenComplex128{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfInt64ThenComplex128(req.Context, req.WorkOfInt64ThenComplex128, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfInt64ThenComplex128) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfInt64ThenComplex128) Push(ctx context.Context, req *WorkOfInt64ThenComplex128) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfInt64ThenComplex128)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfInt64ThenComplex128 = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfInt64ThenComplex128) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfInt64ThenComplex128) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfInt64ThenComplex128) Call(ctx context.Context, arg int64) (complex128, error) {
	return __.api_syncer.DoOfInt64ThenComplex128(ctx, __, arg)
}

type PoolOfInt64ThenComplex64 interface {
	GetInt64Arg() *int64
	PutInt64Arg(*int64)
	GetComplex64Return() *complex64
	PutComplex64Return(*complex64)

	GetWorkOfInt64ThenComplex64() *WorkOfInt64ThenComplex64
	GetReturnOfComplex64() *ReturnOfComplex64
	PutWorkOfInt64ThenComplex64(*WorkOfInt64ThenComplex64)
	PutReturnOfComplex64(*ReturnOfComplex64)

	GetChReturnOfComplex64() chan *ReturnOfComplex64
	PutChReturnOfComplex64(chan *ReturnOfComplex64)
}

type PoolOfInt64ThenComplex64Impl struct {
	Int64Arg            sync.Pool
	Complex64Rtn        sync.Pool
	Int64Work           sync.Pool
	Complex64Return     sync.Pool
	ChReturnOfComplex64 sync.Pool
}

func (__ *PoolOfInt64ThenComplex64Impl) GetInt64Arg() *int64 {
	return __.Int64Arg.Get().(*int64)
}
func (__ *PoolOfInt64ThenComplex64Impl) PutInt64Arg(p *int64) {
	__.Int64Arg.Put(p)
}
func (__ *PoolOfInt64ThenComplex64Impl) GetComplex64Return() *complex64 {
	return __.Complex64Rtn.Get().(*complex64)
}
func (__ *PoolOfInt64ThenComplex64Impl) PutComplex64Return(p *complex64) {
	__.Complex64Rtn.Put(p)
}

func (__ *PoolOfInt64ThenComplex64Impl) GetWorkOfInt64ThenComplex64() *WorkOfInt64ThenComplex64 {
	return __.Int64Work.Get().(*WorkOfInt64ThenComplex64)
}
func (__ *PoolOfInt64ThenComplex64Impl) PutWorkOfInt64ThenComplex64(p *WorkOfInt64ThenComplex64) {
	__.Int64Work.Put(p)
}
func (__ *PoolOfInt64ThenComplex64Impl) GetReturnOfComplex64() *ReturnOfComplex64 {
	return __.Complex64Return.Get().(*ReturnOfComplex64)
}
func (__ *PoolOfInt64ThenComplex64Impl) PutReturnOfComplex64(p *ReturnOfComplex64) {
	__.Complex64Return.Put(p)
}

func (__ *PoolOfInt64ThenComplex64Impl) GetChReturnOfComplex64() chan *ReturnOfComplex64 {
	return __.ChReturnOfComplex64.Get().(chan *ReturnOfComplex64)
}
func (__ *PoolOfInt64ThenComplex64Impl) PutChReturnOfComplex64(p chan *ReturnOfComplex64) {
	__.ChReturnOfComplex64.Put(p)
}

func NewPoolOfInt64ThenComplex64Impl() *PoolOfInt64ThenComplex64Impl {
	return &PoolOfInt64ThenComplex64Impl{
		Int64Arg: sync.Pool{
			New: func() interface{} {
				return new(int64)
			},
		},
		Int64Work: sync.Pool{
			New: func() interface{} {
				return new(WorkOfInt64ThenComplex64)
			},
		},
		Complex64Rtn: sync.Pool{
			New: func() interface{} {
				return new(complex64)
			},
		},
		Complex64Return: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfComplex64)
			},
		},
		ChReturnOfComplex64: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfComplex64, 1)
			},
		},
	}
}

type ApiDecouplerOfInt64ThenComplex64 struct {
	pool PoolOfInt64ThenComplex64
}

func NewApiDecouplerOfInt64ThenComplex64() *ApiDecouplerOfInt64ThenComplex64 {
	return &ApiDecouplerOfInt64ThenComplex64{
		pool: NewPoolOfInt64ThenComplex64Impl(),
	}
}

func (__ *ApiDecouplerOfInt64ThenComplex64) ReturnError(rtn_ch chan<- *ReturnOfComplex64, err error) {
	rtn := __.pool.GetReturnOfComplex64()
	var other complex64
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfInt64ThenComplex64) HandleOfInt64ThenComplex64(ctx context.Context, req *WorkOfInt64ThenComplex64, h func(ctx context.Context, arg int64) (complex64, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfComplex64()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfInt64ThenComplex64) DoOfInt64ThenComplex64(ctx context.Context, worker WorkerOfPushInt64ThenComplex64, arg int64) (complex64, error) {
	// ch := make(chan *ReturnOfComplex64, 1)
	ch := __.pool.GetChReturnOfComplex64()
	defer __.pool.PutChReturnOfComplex64(ch)

	req := __.pool.GetWorkOfInt64ThenComplex64()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfInt64ThenComplex64(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfComplex64(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfInt64ThenComplex64 = func(ctx context.Context, arg int64) (complex64, error)

type WorkerOfInt64ThenComplex64 struct {
	api_syncer *ApiDecouplerOfInt64ThenComplex64
	handler    WorkHandlerOfInt64ThenComplex64

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfInt64ThenComplex64
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfInt64ThenComplex64(ctx context.Context, h WorkHandlerOfInt64ThenComplex64, n int) *WorkerOfInt64ThenComplex64 {
	__ := &WorkerOfInt64ThenComplex64{
		api_syncer: NewApiDecouplerOfInt64ThenComplex64(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfInt64ThenComplex64, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfInt64ThenComplex64{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfInt64ThenComplex64(req.Context, req.WorkOfInt64ThenComplex64, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfInt64ThenComplex64) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfInt64ThenComplex64) Push(ctx context.Context, req *WorkOfInt64ThenComplex64) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfInt64ThenComplex64)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfInt64ThenComplex64 = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfInt64ThenComplex64) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfInt64ThenComplex64) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfInt64ThenComplex64) Call(ctx context.Context, arg int64) (complex64, error) {
	return __.api_syncer.DoOfInt64ThenComplex64(ctx, __, arg)
}

type PoolOfInt64ThenError interface {
	GetInt64Arg() *int64
	PutInt64Arg(*int64)
	GetErrorReturn() *error
	PutErrorReturn(*error)

	GetWorkOfInt64ThenError() *WorkOfInt64ThenError
	GetReturnOfError() *ReturnOfError
	PutWorkOfInt64ThenError(*WorkOfInt64ThenError)
	PutReturnOfError(*ReturnOfError)

	GetChReturnOfError() chan *ReturnOfError
	PutChReturnOfError(chan *ReturnOfError)
}

type PoolOfInt64ThenErrorImpl struct {
	Int64Arg        sync.Pool
	ErrorRtn        sync.Pool
	Int64Work       sync.Pool
	ErrorReturn     sync.Pool
	ChReturnOfError sync.Pool
}

func (__ *PoolOfInt64ThenErrorImpl) GetInt64Arg() *int64 {
	return __.Int64Arg.Get().(*int64)
}
func (__ *PoolOfInt64ThenErrorImpl) PutInt64Arg(p *int64) {
	__.Int64Arg.Put(p)
}
func (__ *PoolOfInt64ThenErrorImpl) GetErrorReturn() *error {
	return __.ErrorRtn.Get().(*error)
}
func (__ *PoolOfInt64ThenErrorImpl) PutErrorReturn(p *error) {
	__.ErrorRtn.Put(p)
}

func (__ *PoolOfInt64ThenErrorImpl) GetWorkOfInt64ThenError() *WorkOfInt64ThenError {
	return __.Int64Work.Get().(*WorkOfInt64ThenError)
}
func (__ *PoolOfInt64ThenErrorImpl) PutWorkOfInt64ThenError(p *WorkOfInt64ThenError) {
	__.Int64Work.Put(p)
}
func (__ *PoolOfInt64ThenErrorImpl) GetReturnOfError() *ReturnOfError {
	return __.ErrorReturn.Get().(*ReturnOfError)
}
func (__ *PoolOfInt64ThenErrorImpl) PutReturnOfError(p *ReturnOfError) {
	__.ErrorReturn.Put(p)
}

func (__ *PoolOfInt64ThenErrorImpl) GetChReturnOfError() chan *ReturnOfError {
	return __.ChReturnOfError.Get().(chan *ReturnOfError)
}
func (__ *PoolOfInt64ThenErrorImpl) PutChReturnOfError(p chan *ReturnOfError) {
	__.ChReturnOfError.Put(p)
}

func NewPoolOfInt64ThenErrorImpl() *PoolOfInt64ThenErrorImpl {
	return &PoolOfInt64ThenErrorImpl{
		Int64Arg: sync.Pool{
			New: func() interface{} {
				return new(int64)
			},
		},
		Int64Work: sync.Pool{
			New: func() interface{} {
				return new(WorkOfInt64ThenError)
			},
		},
		ErrorRtn: sync.Pool{
			New: func() interface{} {
				return new(error)
			},
		},
		ErrorReturn: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfError)
			},
		},
		ChReturnOfError: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfError, 1)
			},
		},
	}
}

type ApiDecouplerOfInt64ThenError struct {
	pool PoolOfInt64ThenError
}

func NewApiDecouplerOfInt64ThenError() *ApiDecouplerOfInt64ThenError {
	return &ApiDecouplerOfInt64ThenError{
		pool: NewPoolOfInt64ThenErrorImpl(),
	}
}

func (__ *ApiDecouplerOfInt64ThenError) ReturnError(rtn_ch chan<- *ReturnOfError, err error) {
	rtn := __.pool.GetReturnOfError()
	var other error
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfInt64ThenError) HandleOfInt64ThenError(ctx context.Context, req *WorkOfInt64ThenError, h func(ctx context.Context, arg int64) (error, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfError()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfInt64ThenError) DoOfInt64ThenError(ctx context.Context, worker WorkerOfPushInt64ThenError, arg int64) (error, error) {
	// ch := make(chan *ReturnOfError, 1)
	ch := __.pool.GetChReturnOfError()
	defer __.pool.PutChReturnOfError(ch)

	req := __.pool.GetWorkOfInt64ThenError()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfInt64ThenError(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfError(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfInt64ThenError = func(ctx context.Context, arg int64) (error, error)

type WorkerOfInt64ThenError struct {
	api_syncer *ApiDecouplerOfInt64ThenError
	handler    WorkHandlerOfInt64ThenError

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfInt64ThenError
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfInt64ThenError(ctx context.Context, h WorkHandlerOfInt64ThenError, n int) *WorkerOfInt64ThenError {
	__ := &WorkerOfInt64ThenError{
		api_syncer: NewApiDecouplerOfInt64ThenError(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfInt64ThenError, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfInt64ThenError{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfInt64ThenError(req.Context, req.WorkOfInt64ThenError, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfInt64ThenError) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfInt64ThenError) Push(ctx context.Context, req *WorkOfInt64ThenError) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfInt64ThenError)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfInt64ThenError = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfInt64ThenError) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfInt64ThenError) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfInt64ThenError) Call(ctx context.Context, arg int64) (error, error) {
	return __.api_syncer.DoOfInt64ThenError(ctx, __, arg)
}

type PoolOfInt64ThenFloat32 interface {
	GetInt64Arg() *int64
	PutInt64Arg(*int64)
	GetFloat32Return() *float32
	PutFloat32Return(*float32)

	GetWorkOfInt64ThenFloat32() *WorkOfInt64ThenFloat32
	GetReturnOfFloat32() *ReturnOfFloat32
	PutWorkOfInt64ThenFloat32(*WorkOfInt64ThenFloat32)
	PutReturnOfFloat32(*ReturnOfFloat32)

	GetChReturnOfFloat32() chan *ReturnOfFloat32
	PutChReturnOfFloat32(chan *ReturnOfFloat32)
}

type PoolOfInt64ThenFloat32Impl struct {
	Int64Arg          sync.Pool
	Float32Rtn        sync.Pool
	Int64Work         sync.Pool
	Float32Return     sync.Pool
	ChReturnOfFloat32 sync.Pool
}

func (__ *PoolOfInt64ThenFloat32Impl) GetInt64Arg() *int64 {
	return __.Int64Arg.Get().(*int64)
}
func (__ *PoolOfInt64ThenFloat32Impl) PutInt64Arg(p *int64) {
	__.Int64Arg.Put(p)
}
func (__ *PoolOfInt64ThenFloat32Impl) GetFloat32Return() *float32 {
	return __.Float32Rtn.Get().(*float32)
}
func (__ *PoolOfInt64ThenFloat32Impl) PutFloat32Return(p *float32) {
	__.Float32Rtn.Put(p)
}

func (__ *PoolOfInt64ThenFloat32Impl) GetWorkOfInt64ThenFloat32() *WorkOfInt64ThenFloat32 {
	return __.Int64Work.Get().(*WorkOfInt64ThenFloat32)
}
func (__ *PoolOfInt64ThenFloat32Impl) PutWorkOfInt64ThenFloat32(p *WorkOfInt64ThenFloat32) {
	__.Int64Work.Put(p)
}
func (__ *PoolOfInt64ThenFloat32Impl) GetReturnOfFloat32() *ReturnOfFloat32 {
	return __.Float32Return.Get().(*ReturnOfFloat32)
}
func (__ *PoolOfInt64ThenFloat32Impl) PutReturnOfFloat32(p *ReturnOfFloat32) {
	__.Float32Return.Put(p)
}

func (__ *PoolOfInt64ThenFloat32Impl) GetChReturnOfFloat32() chan *ReturnOfFloat32 {
	return __.ChReturnOfFloat32.Get().(chan *ReturnOfFloat32)
}
func (__ *PoolOfInt64ThenFloat32Impl) PutChReturnOfFloat32(p chan *ReturnOfFloat32) {
	__.ChReturnOfFloat32.Put(p)
}

func NewPoolOfInt64ThenFloat32Impl() *PoolOfInt64ThenFloat32Impl {
	return &PoolOfInt64ThenFloat32Impl{
		Int64Arg: sync.Pool{
			New: func() interface{} {
				return new(int64)
			},
		},
		Int64Work: sync.Pool{
			New: func() interface{} {
				return new(WorkOfInt64ThenFloat32)
			},
		},
		Float32Rtn: sync.Pool{
			New: func() interface{} {
				return new(float32)
			},
		},
		Float32Return: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfFloat32)
			},
		},
		ChReturnOfFloat32: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfFloat32, 1)
			},
		},
	}
}

type ApiDecouplerOfInt64ThenFloat32 struct {
	pool PoolOfInt64ThenFloat32
}

func NewApiDecouplerOfInt64ThenFloat32() *ApiDecouplerOfInt64ThenFloat32 {
	return &ApiDecouplerOfInt64ThenFloat32{
		pool: NewPoolOfInt64ThenFloat32Impl(),
	}
}

func (__ *ApiDecouplerOfInt64ThenFloat32) ReturnError(rtn_ch chan<- *ReturnOfFloat32, err error) {
	rtn := __.pool.GetReturnOfFloat32()
	var other float32
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfInt64ThenFloat32) HandleOfInt64ThenFloat32(ctx context.Context, req *WorkOfInt64ThenFloat32, h func(ctx context.Context, arg int64) (float32, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfFloat32()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfInt64ThenFloat32) DoOfInt64ThenFloat32(ctx context.Context, worker WorkerOfPushInt64ThenFloat32, arg int64) (float32, error) {
	// ch := make(chan *ReturnOfFloat32, 1)
	ch := __.pool.GetChReturnOfFloat32()
	defer __.pool.PutChReturnOfFloat32(ch)

	req := __.pool.GetWorkOfInt64ThenFloat32()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfInt64ThenFloat32(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfFloat32(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfInt64ThenFloat32 = func(ctx context.Context, arg int64) (float32, error)

type WorkerOfInt64ThenFloat32 struct {
	api_syncer *ApiDecouplerOfInt64ThenFloat32
	handler    WorkHandlerOfInt64ThenFloat32

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfInt64ThenFloat32
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfInt64ThenFloat32(ctx context.Context, h WorkHandlerOfInt64ThenFloat32, n int) *WorkerOfInt64ThenFloat32 {
	__ := &WorkerOfInt64ThenFloat32{
		api_syncer: NewApiDecouplerOfInt64ThenFloat32(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfInt64ThenFloat32, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfInt64ThenFloat32{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfInt64ThenFloat32(req.Context, req.WorkOfInt64ThenFloat32, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfInt64ThenFloat32) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfInt64ThenFloat32) Push(ctx context.Context, req *WorkOfInt64ThenFloat32) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfInt64ThenFloat32)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfInt64ThenFloat32 = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfInt64ThenFloat32) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfInt64ThenFloat32) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfInt64ThenFloat32) Call(ctx context.Context, arg int64) (float32, error) {
	return __.api_syncer.DoOfInt64ThenFloat32(ctx, __, arg)
}

type PoolOfInt64ThenFloat64 interface {
	GetInt64Arg() *int64
	PutInt64Arg(*int64)
	GetFloat64Return() *float64
	PutFloat64Return(*float64)

	GetWorkOfInt64ThenFloat64() *WorkOfInt64ThenFloat64
	GetReturnOfFloat64() *ReturnOfFloat64
	PutWorkOfInt64ThenFloat64(*WorkOfInt64ThenFloat64)
	PutReturnOfFloat64(*ReturnOfFloat64)

	GetChReturnOfFloat64() chan *ReturnOfFloat64
	PutChReturnOfFloat64(chan *ReturnOfFloat64)
}

type PoolOfInt64ThenFloat64Impl struct {
	Int64Arg          sync.Pool
	Float64Rtn        sync.Pool
	Int64Work         sync.Pool
	Float64Return     sync.Pool
	ChReturnOfFloat64 sync.Pool
}

func (__ *PoolOfInt64ThenFloat64Impl) GetInt64Arg() *int64 {
	return __.Int64Arg.Get().(*int64)
}
func (__ *PoolOfInt64ThenFloat64Impl) PutInt64Arg(p *int64) {
	__.Int64Arg.Put(p)
}
func (__ *PoolOfInt64ThenFloat64Impl) GetFloat64Return() *float64 {
	return __.Float64Rtn.Get().(*float64)
}
func (__ *PoolOfInt64ThenFloat64Impl) PutFloat64Return(p *float64) {
	__.Float64Rtn.Put(p)
}

func (__ *PoolOfInt64ThenFloat64Impl) GetWorkOfInt64ThenFloat64() *WorkOfInt64ThenFloat64 {
	return __.Int64Work.Get().(*WorkOfInt64ThenFloat64)
}
func (__ *PoolOfInt64ThenFloat64Impl) PutWorkOfInt64ThenFloat64(p *WorkOfInt64ThenFloat64) {
	__.Int64Work.Put(p)
}
func (__ *PoolOfInt64ThenFloat64Impl) GetReturnOfFloat64() *ReturnOfFloat64 {
	return __.Float64Return.Get().(*ReturnOfFloat64)
}
func (__ *PoolOfInt64ThenFloat64Impl) PutReturnOfFloat64(p *ReturnOfFloat64) {
	__.Float64Return.Put(p)
}

func (__ *PoolOfInt64ThenFloat64Impl) GetChReturnOfFloat64() chan *ReturnOfFloat64 {
	return __.ChReturnOfFloat64.Get().(chan *ReturnOfFloat64)
}
func (__ *PoolOfInt64ThenFloat64Impl) PutChReturnOfFloat64(p chan *ReturnOfFloat64) {
	__.ChReturnOfFloat64.Put(p)
}

func NewPoolOfInt64ThenFloat64Impl() *PoolOfInt64ThenFloat64Impl {
	return &PoolOfInt64ThenFloat64Impl{
		Int64Arg: sync.Pool{
			New: func() interface{} {
				return new(int64)
			},
		},
		Int64Work: sync.Pool{
			New: func() interface{} {
				return new(WorkOfInt64ThenFloat64)
			},
		},
		Float64Rtn: sync.Pool{
			New: func() interface{} {
				return new(float64)
			},
		},
		Float64Return: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfFloat64)
			},
		},
		ChReturnOfFloat64: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfFloat64, 1)
			},
		},
	}
}

type ApiDecouplerOfInt64ThenFloat64 struct {
	pool PoolOfInt64ThenFloat64
}

func NewApiDecouplerOfInt64ThenFloat64() *ApiDecouplerOfInt64ThenFloat64 {
	return &ApiDecouplerOfInt64ThenFloat64{
		pool: NewPoolOfInt64ThenFloat64Impl(),
	}
}

func (__ *ApiDecouplerOfInt64ThenFloat64) ReturnError(rtn_ch chan<- *ReturnOfFloat64, err error) {
	rtn := __.pool.GetReturnOfFloat64()
	var other float64
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfInt64ThenFloat64) HandleOfInt64ThenFloat64(ctx context.Context, req *WorkOfInt64ThenFloat64, h func(ctx context.Context, arg int64) (float64, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfFloat64()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfInt64ThenFloat64) DoOfInt64ThenFloat64(ctx context.Context, worker WorkerOfPushInt64ThenFloat64, arg int64) (float64, error) {
	// ch := make(chan *ReturnOfFloat64, 1)
	ch := __.pool.GetChReturnOfFloat64()
	defer __.pool.PutChReturnOfFloat64(ch)

	req := __.pool.GetWorkOfInt64ThenFloat64()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfInt64ThenFloat64(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfFloat64(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfInt64ThenFloat64 = func(ctx context.Context, arg int64) (float64, error)

type WorkerOfInt64ThenFloat64 struct {
	api_syncer *ApiDecouplerOfInt64ThenFloat64
	handler    WorkHandlerOfInt64ThenFloat64

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfInt64ThenFloat64
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfInt64ThenFloat64(ctx context.Context, h WorkHandlerOfInt64ThenFloat64, n int) *WorkerOfInt64ThenFloat64 {
	__ := &WorkerOfInt64ThenFloat64{
		api_syncer: NewApiDecouplerOfInt64ThenFloat64(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfInt64ThenFloat64, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfInt64ThenFloat64{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfInt64ThenFloat64(req.Context, req.WorkOfInt64ThenFloat64, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfInt64ThenFloat64) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfInt64ThenFloat64) Push(ctx context.Context, req *WorkOfInt64ThenFloat64) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfInt64ThenFloat64)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfInt64ThenFloat64 = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfInt64ThenFloat64) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfInt64ThenFloat64) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfInt64ThenFloat64) Call(ctx context.Context, arg int64) (float64, error) {
	return __.api_syncer.DoOfInt64ThenFloat64(ctx, __, arg)
}

type PoolOfInt64ThenInt interface {
	GetInt64Arg() *int64
	PutInt64Arg(*int64)
	GetIntReturn() *int
	PutIntReturn(*int)

	GetWorkOfInt64ThenInt() *WorkOfInt64ThenInt
	GetReturnOfInt() *ReturnOfInt
	PutWorkOfInt64ThenInt(*WorkOfInt64ThenInt)
	PutReturnOfInt(*ReturnOfInt)

	GetChReturnOfInt() chan *ReturnOfInt
	PutChReturnOfInt(chan *ReturnOfInt)
}

type PoolOfInt64ThenIntImpl struct {
	Int64Arg      sync.Pool
	IntRtn        sync.Pool
	Int64Work     sync.Pool
	IntReturn     sync.Pool
	ChReturnOfInt sync.Pool
}

func (__ *PoolOfInt64ThenIntImpl) GetInt64Arg() *int64 {
	return __.Int64Arg.Get().(*int64)
}
func (__ *PoolOfInt64ThenIntImpl) PutInt64Arg(p *int64) {
	__.Int64Arg.Put(p)
}
func (__ *PoolOfInt64ThenIntImpl) GetIntReturn() *int {
	return __.IntRtn.Get().(*int)
}
func (__ *PoolOfInt64ThenIntImpl) PutIntReturn(p *int) {
	__.IntRtn.Put(p)
}

func (__ *PoolOfInt64ThenIntImpl) GetWorkOfInt64ThenInt() *WorkOfInt64ThenInt {
	return __.Int64Work.Get().(*WorkOfInt64ThenInt)
}
func (__ *PoolOfInt64ThenIntImpl) PutWorkOfInt64ThenInt(p *WorkOfInt64ThenInt) {
	__.Int64Work.Put(p)
}
func (__ *PoolOfInt64ThenIntImpl) GetReturnOfInt() *ReturnOfInt {
	return __.IntReturn.Get().(*ReturnOfInt)
}
func (__ *PoolOfInt64ThenIntImpl) PutReturnOfInt(p *ReturnOfInt) {
	__.IntReturn.Put(p)
}

func (__ *PoolOfInt64ThenIntImpl) GetChReturnOfInt() chan *ReturnOfInt {
	return __.ChReturnOfInt.Get().(chan *ReturnOfInt)
}
func (__ *PoolOfInt64ThenIntImpl) PutChReturnOfInt(p chan *ReturnOfInt) {
	__.ChReturnOfInt.Put(p)
}

func NewPoolOfInt64ThenIntImpl() *PoolOfInt64ThenIntImpl {
	return &PoolOfInt64ThenIntImpl{
		Int64Arg: sync.Pool{
			New: func() interface{} {
				return new(int64)
			},
		},
		Int64Work: sync.Pool{
			New: func() interface{} {
				return new(WorkOfInt64ThenInt)
			},
		},
		IntRtn: sync.Pool{
			New: func() interface{} {
				return new(int)
			},
		},
		IntReturn: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfInt)
			},
		},
		ChReturnOfInt: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfInt, 1)
			},
		},
	}
}

type ApiDecouplerOfInt64ThenInt struct {
	pool PoolOfInt64ThenInt
}

func NewApiDecouplerOfInt64ThenInt() *ApiDecouplerOfInt64ThenInt {
	return &ApiDecouplerOfInt64ThenInt{
		pool: NewPoolOfInt64ThenIntImpl(),
	}
}

func (__ *ApiDecouplerOfInt64ThenInt) ReturnError(rtn_ch chan<- *ReturnOfInt, err error) {
	rtn := __.pool.GetReturnOfInt()
	var other int
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfInt64ThenInt) HandleOfInt64ThenInt(ctx context.Context, req *WorkOfInt64ThenInt, h func(ctx context.Context, arg int64) (int, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfInt()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfInt64ThenInt) DoOfInt64ThenInt(ctx context.Context, worker WorkerOfPushInt64ThenInt, arg int64) (int, error) {
	// ch := make(chan *ReturnOfInt, 1)
	ch := __.pool.GetChReturnOfInt()
	defer __.pool.PutChReturnOfInt(ch)

	req := __.pool.GetWorkOfInt64ThenInt()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfInt64ThenInt(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfInt(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfInt64ThenInt = func(ctx context.Context, arg int64) (int, error)

type WorkerOfInt64ThenInt struct {
	api_syncer *ApiDecouplerOfInt64ThenInt
	handler    WorkHandlerOfInt64ThenInt

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfInt64ThenInt
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfInt64ThenInt(ctx context.Context, h WorkHandlerOfInt64ThenInt, n int) *WorkerOfInt64ThenInt {
	__ := &WorkerOfInt64ThenInt{
		api_syncer: NewApiDecouplerOfInt64ThenInt(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfInt64ThenInt, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfInt64ThenInt{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfInt64ThenInt(req.Context, req.WorkOfInt64ThenInt, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfInt64ThenInt) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfInt64ThenInt) Push(ctx context.Context, req *WorkOfInt64ThenInt) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfInt64ThenInt)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfInt64ThenInt = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfInt64ThenInt) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfInt64ThenInt) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfInt64ThenInt) Call(ctx context.Context, arg int64) (int, error) {
	return __.api_syncer.DoOfInt64ThenInt(ctx, __, arg)
}

type PoolOfInt64ThenInt16 interface {
	GetInt64Arg() *int64
	PutInt64Arg(*int64)
	GetInt16Return() *int16
	PutInt16Return(*int16)

	GetWorkOfInt64ThenInt16() *WorkOfInt64ThenInt16
	GetReturnOfInt16() *ReturnOfInt16
	PutWorkOfInt64ThenInt16(*WorkOfInt64ThenInt16)
	PutReturnOfInt16(*ReturnOfInt16)

	GetChReturnOfInt16() chan *ReturnOfInt16
	PutChReturnOfInt16(chan *ReturnOfInt16)
}

type PoolOfInt64ThenInt16Impl struct {
	Int64Arg        sync.Pool
	Int16Rtn        sync.Pool
	Int64Work       sync.Pool
	Int16Return     sync.Pool
	ChReturnOfInt16 sync.Pool
}

func (__ *PoolOfInt64ThenInt16Impl) GetInt64Arg() *int64 {
	return __.Int64Arg.Get().(*int64)
}
func (__ *PoolOfInt64ThenInt16Impl) PutInt64Arg(p *int64) {
	__.Int64Arg.Put(p)
}
func (__ *PoolOfInt64ThenInt16Impl) GetInt16Return() *int16 {
	return __.Int16Rtn.Get().(*int16)
}
func (__ *PoolOfInt64ThenInt16Impl) PutInt16Return(p *int16) {
	__.Int16Rtn.Put(p)
}

func (__ *PoolOfInt64ThenInt16Impl) GetWorkOfInt64ThenInt16() *WorkOfInt64ThenInt16 {
	return __.Int64Work.Get().(*WorkOfInt64ThenInt16)
}
func (__ *PoolOfInt64ThenInt16Impl) PutWorkOfInt64ThenInt16(p *WorkOfInt64ThenInt16) {
	__.Int64Work.Put(p)
}
func (__ *PoolOfInt64ThenInt16Impl) GetReturnOfInt16() *ReturnOfInt16 {
	return __.Int16Return.Get().(*ReturnOfInt16)
}
func (__ *PoolOfInt64ThenInt16Impl) PutReturnOfInt16(p *ReturnOfInt16) {
	__.Int16Return.Put(p)
}

func (__ *PoolOfInt64ThenInt16Impl) GetChReturnOfInt16() chan *ReturnOfInt16 {
	return __.ChReturnOfInt16.Get().(chan *ReturnOfInt16)
}
func (__ *PoolOfInt64ThenInt16Impl) PutChReturnOfInt16(p chan *ReturnOfInt16) {
	__.ChReturnOfInt16.Put(p)
}

func NewPoolOfInt64ThenInt16Impl() *PoolOfInt64ThenInt16Impl {
	return &PoolOfInt64ThenInt16Impl{
		Int64Arg: sync.Pool{
			New: func() interface{} {
				return new(int64)
			},
		},
		Int64Work: sync.Pool{
			New: func() interface{} {
				return new(WorkOfInt64ThenInt16)
			},
		},
		Int16Rtn: sync.Pool{
			New: func() interface{} {
				return new(int16)
			},
		},
		Int16Return: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfInt16)
			},
		},
		ChReturnOfInt16: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfInt16, 1)
			},
		},
	}
}

type ApiDecouplerOfInt64ThenInt16 struct {
	pool PoolOfInt64ThenInt16
}

func NewApiDecouplerOfInt64ThenInt16() *ApiDecouplerOfInt64ThenInt16 {
	return &ApiDecouplerOfInt64ThenInt16{
		pool: NewPoolOfInt64ThenInt16Impl(),
	}
}

func (__ *ApiDecouplerOfInt64ThenInt16) ReturnError(rtn_ch chan<- *ReturnOfInt16, err error) {
	rtn := __.pool.GetReturnOfInt16()
	var other int16
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfInt64ThenInt16) HandleOfInt64ThenInt16(ctx context.Context, req *WorkOfInt64ThenInt16, h func(ctx context.Context, arg int64) (int16, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfInt16()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfInt64ThenInt16) DoOfInt64ThenInt16(ctx context.Context, worker WorkerOfPushInt64ThenInt16, arg int64) (int16, error) {
	// ch := make(chan *ReturnOfInt16, 1)
	ch := __.pool.GetChReturnOfInt16()
	defer __.pool.PutChReturnOfInt16(ch)

	req := __.pool.GetWorkOfInt64ThenInt16()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfInt64ThenInt16(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfInt16(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfInt64ThenInt16 = func(ctx context.Context, arg int64) (int16, error)

type WorkerOfInt64ThenInt16 struct {
	api_syncer *ApiDecouplerOfInt64ThenInt16
	handler    WorkHandlerOfInt64ThenInt16

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfInt64ThenInt16
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfInt64ThenInt16(ctx context.Context, h WorkHandlerOfInt64ThenInt16, n int) *WorkerOfInt64ThenInt16 {
	__ := &WorkerOfInt64ThenInt16{
		api_syncer: NewApiDecouplerOfInt64ThenInt16(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfInt64ThenInt16, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfInt64ThenInt16{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfInt64ThenInt16(req.Context, req.WorkOfInt64ThenInt16, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfInt64ThenInt16) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfInt64ThenInt16) Push(ctx context.Context, req *WorkOfInt64ThenInt16) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfInt64ThenInt16)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfInt64ThenInt16 = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfInt64ThenInt16) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfInt64ThenInt16) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfInt64ThenInt16) Call(ctx context.Context, arg int64) (int16, error) {
	return __.api_syncer.DoOfInt64ThenInt16(ctx, __, arg)
}

type PoolOfInt64ThenInt32 interface {
	GetInt64Arg() *int64
	PutInt64Arg(*int64)
	GetInt32Return() *int32
	PutInt32Return(*int32)

	GetWorkOfInt64ThenInt32() *WorkOfInt64ThenInt32
	GetReturnOfInt32() *ReturnOfInt32
	PutWorkOfInt64ThenInt32(*WorkOfInt64ThenInt32)
	PutReturnOfInt32(*ReturnOfInt32)

	GetChReturnOfInt32() chan *ReturnOfInt32
	PutChReturnOfInt32(chan *ReturnOfInt32)
}

type PoolOfInt64ThenInt32Impl struct {
	Int64Arg        sync.Pool
	Int32Rtn        sync.Pool
	Int64Work       sync.Pool
	Int32Return     sync.Pool
	ChReturnOfInt32 sync.Pool
}

func (__ *PoolOfInt64ThenInt32Impl) GetInt64Arg() *int64 {
	return __.Int64Arg.Get().(*int64)
}
func (__ *PoolOfInt64ThenInt32Impl) PutInt64Arg(p *int64) {
	__.Int64Arg.Put(p)
}
func (__ *PoolOfInt64ThenInt32Impl) GetInt32Return() *int32 {
	return __.Int32Rtn.Get().(*int32)
}
func (__ *PoolOfInt64ThenInt32Impl) PutInt32Return(p *int32) {
	__.Int32Rtn.Put(p)
}

func (__ *PoolOfInt64ThenInt32Impl) GetWorkOfInt64ThenInt32() *WorkOfInt64ThenInt32 {
	return __.Int64Work.Get().(*WorkOfInt64ThenInt32)
}
func (__ *PoolOfInt64ThenInt32Impl) PutWorkOfInt64ThenInt32(p *WorkOfInt64ThenInt32) {
	__.Int64Work.Put(p)
}
func (__ *PoolOfInt64ThenInt32Impl) GetReturnOfInt32() *ReturnOfInt32 {
	return __.Int32Return.Get().(*ReturnOfInt32)
}
func (__ *PoolOfInt64ThenInt32Impl) PutReturnOfInt32(p *ReturnOfInt32) {
	__.Int32Return.Put(p)
}

func (__ *PoolOfInt64ThenInt32Impl) GetChReturnOfInt32() chan *ReturnOfInt32 {
	return __.ChReturnOfInt32.Get().(chan *ReturnOfInt32)
}
func (__ *PoolOfInt64ThenInt32Impl) PutChReturnOfInt32(p chan *ReturnOfInt32) {
	__.ChReturnOfInt32.Put(p)
}

func NewPoolOfInt64ThenInt32Impl() *PoolOfInt64ThenInt32Impl {
	return &PoolOfInt64ThenInt32Impl{
		Int64Arg: sync.Pool{
			New: func() interface{} {
				return new(int64)
			},
		},
		Int64Work: sync.Pool{
			New: func() interface{} {
				return new(WorkOfInt64ThenInt32)
			},
		},
		Int32Rtn: sync.Pool{
			New: func() interface{} {
				return new(int32)
			},
		},
		Int32Return: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfInt32)
			},
		},
		ChReturnOfInt32: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfInt32, 1)
			},
		},
	}
}

type ApiDecouplerOfInt64ThenInt32 struct {
	pool PoolOfInt64ThenInt32
}

func NewApiDecouplerOfInt64ThenInt32() *ApiDecouplerOfInt64ThenInt32 {
	return &ApiDecouplerOfInt64ThenInt32{
		pool: NewPoolOfInt64ThenInt32Impl(),
	}
}

func (__ *ApiDecouplerOfInt64ThenInt32) ReturnError(rtn_ch chan<- *ReturnOfInt32, err error) {
	rtn := __.pool.GetReturnOfInt32()
	var other int32
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfInt64ThenInt32) HandleOfInt64ThenInt32(ctx context.Context, req *WorkOfInt64ThenInt32, h func(ctx context.Context, arg int64) (int32, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfInt32()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfInt64ThenInt32) DoOfInt64ThenInt32(ctx context.Context, worker WorkerOfPushInt64ThenInt32, arg int64) (int32, error) {
	// ch := make(chan *ReturnOfInt32, 1)
	ch := __.pool.GetChReturnOfInt32()
	defer __.pool.PutChReturnOfInt32(ch)

	req := __.pool.GetWorkOfInt64ThenInt32()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfInt64ThenInt32(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfInt32(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfInt64ThenInt32 = func(ctx context.Context, arg int64) (int32, error)

type WorkerOfInt64ThenInt32 struct {
	api_syncer *ApiDecouplerOfInt64ThenInt32
	handler    WorkHandlerOfInt64ThenInt32

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfInt64ThenInt32
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfInt64ThenInt32(ctx context.Context, h WorkHandlerOfInt64ThenInt32, n int) *WorkerOfInt64ThenInt32 {
	__ := &WorkerOfInt64ThenInt32{
		api_syncer: NewApiDecouplerOfInt64ThenInt32(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfInt64ThenInt32, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfInt64ThenInt32{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfInt64ThenInt32(req.Context, req.WorkOfInt64ThenInt32, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfInt64ThenInt32) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfInt64ThenInt32) Push(ctx context.Context, req *WorkOfInt64ThenInt32) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfInt64ThenInt32)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfInt64ThenInt32 = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfInt64ThenInt32) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfInt64ThenInt32) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfInt64ThenInt32) Call(ctx context.Context, arg int64) (int32, error) {
	return __.api_syncer.DoOfInt64ThenInt32(ctx, __, arg)
}

type PoolOfInt64ThenInt64 interface {
	GetInt64Arg() *int64
	PutInt64Arg(*int64)
	GetInt64Return() *int64
	PutInt64Return(*int64)

	GetWorkOfInt64ThenInt64() *WorkOfInt64ThenInt64
	GetReturnOfInt64() *ReturnOfInt64
	PutWorkOfInt64ThenInt64(*WorkOfInt64ThenInt64)
	PutReturnOfInt64(*ReturnOfInt64)

	GetChReturnOfInt64() chan *ReturnOfInt64
	PutChReturnOfInt64(chan *ReturnOfInt64)
}

type PoolOfInt64ThenInt64Impl struct {
	Int64Arg        sync.Pool
	Int64Rtn        sync.Pool
	Int64Work       sync.Pool
	Int64Return     sync.Pool
	ChReturnOfInt64 sync.Pool
}

func (__ *PoolOfInt64ThenInt64Impl) GetInt64Arg() *int64 {
	return __.Int64Arg.Get().(*int64)
}
func (__ *PoolOfInt64ThenInt64Impl) PutInt64Arg(p *int64) {
	__.Int64Arg.Put(p)
}
func (__ *PoolOfInt64ThenInt64Impl) GetInt64Return() *int64 {
	return __.Int64Rtn.Get().(*int64)
}
func (__ *PoolOfInt64ThenInt64Impl) PutInt64Return(p *int64) {
	__.Int64Rtn.Put(p)
}

func (__ *PoolOfInt64ThenInt64Impl) GetWorkOfInt64ThenInt64() *WorkOfInt64ThenInt64 {
	return __.Int64Work.Get().(*WorkOfInt64ThenInt64)
}
func (__ *PoolOfInt64ThenInt64Impl) PutWorkOfInt64ThenInt64(p *WorkOfInt64ThenInt64) {
	__.Int64Work.Put(p)
}
func (__ *PoolOfInt64ThenInt64Impl) GetReturnOfInt64() *ReturnOfInt64 {
	return __.Int64Return.Get().(*ReturnOfInt64)
}
func (__ *PoolOfInt64ThenInt64Impl) PutReturnOfInt64(p *ReturnOfInt64) {
	__.Int64Return.Put(p)
}

func (__ *PoolOfInt64ThenInt64Impl) GetChReturnOfInt64() chan *ReturnOfInt64 {
	return __.ChReturnOfInt64.Get().(chan *ReturnOfInt64)
}
func (__ *PoolOfInt64ThenInt64Impl) PutChReturnOfInt64(p chan *ReturnOfInt64) {
	__.ChReturnOfInt64.Put(p)
}

func NewPoolOfInt64ThenInt64Impl() *PoolOfInt64ThenInt64Impl {
	return &PoolOfInt64ThenInt64Impl{
		Int64Arg: sync.Pool{
			New: func() interface{} {
				return new(int64)
			},
		},
		Int64Work: sync.Pool{
			New: func() interface{} {
				return new(WorkOfInt64ThenInt64)
			},
		},
		Int64Rtn: sync.Pool{
			New: func() interface{} {
				return new(int64)
			},
		},
		Int64Return: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfInt64)
			},
		},
		ChReturnOfInt64: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfInt64, 1)
			},
		},
	}
}

type ApiDecouplerOfInt64ThenInt64 struct {
	pool PoolOfInt64ThenInt64
}

func NewApiDecouplerOfInt64ThenInt64() *ApiDecouplerOfInt64ThenInt64 {
	return &ApiDecouplerOfInt64ThenInt64{
		pool: NewPoolOfInt64ThenInt64Impl(),
	}
}

func (__ *ApiDecouplerOfInt64ThenInt64) ReturnError(rtn_ch chan<- *ReturnOfInt64, err error) {
	rtn := __.pool.GetReturnOfInt64()
	var other int64
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfInt64ThenInt64) HandleOfInt64ThenInt64(ctx context.Context, req *WorkOfInt64ThenInt64, h func(ctx context.Context, arg int64) (int64, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfInt64()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfInt64ThenInt64) DoOfInt64ThenInt64(ctx context.Context, worker WorkerOfPushInt64ThenInt64, arg int64) (int64, error) {
	// ch := make(chan *ReturnOfInt64, 1)
	ch := __.pool.GetChReturnOfInt64()
	defer __.pool.PutChReturnOfInt64(ch)

	req := __.pool.GetWorkOfInt64ThenInt64()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfInt64ThenInt64(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfInt64(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfInt64ThenInt64 = func(ctx context.Context, arg int64) (int64, error)

type WorkerOfInt64ThenInt64 struct {
	api_syncer *ApiDecouplerOfInt64ThenInt64
	handler    WorkHandlerOfInt64ThenInt64

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfInt64ThenInt64
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfInt64ThenInt64(ctx context.Context, h WorkHandlerOfInt64ThenInt64, n int) *WorkerOfInt64ThenInt64 {
	__ := &WorkerOfInt64ThenInt64{
		api_syncer: NewApiDecouplerOfInt64ThenInt64(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfInt64ThenInt64, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfInt64ThenInt64{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfInt64ThenInt64(req.Context, req.WorkOfInt64ThenInt64, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfInt64ThenInt64) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfInt64ThenInt64) Push(ctx context.Context, req *WorkOfInt64ThenInt64) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfInt64ThenInt64)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfInt64ThenInt64 = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfInt64ThenInt64) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfInt64ThenInt64) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfInt64ThenInt64) Call(ctx context.Context, arg int64) (int64, error) {
	return __.api_syncer.DoOfInt64ThenInt64(ctx, __, arg)
}

type PoolOfInt64ThenInt8 interface {
	GetInt64Arg() *int64
	PutInt64Arg(*int64)
	GetInt8Return() *int8
	PutInt8Return(*int8)

	GetWorkOfInt64ThenInt8() *WorkOfInt64ThenInt8
	GetReturnOfInt8() *ReturnOfInt8
	PutWorkOfInt64ThenInt8(*WorkOfInt64ThenInt8)
	PutReturnOfInt8(*ReturnOfInt8)

	GetChReturnOfInt8() chan *ReturnOfInt8
	PutChReturnOfInt8(chan *ReturnOfInt8)
}

type PoolOfInt64ThenInt8Impl struct {
	Int64Arg       sync.Pool
	Int8Rtn        sync.Pool
	Int64Work      sync.Pool
	Int8Return     sync.Pool
	ChReturnOfInt8 sync.Pool
}

func (__ *PoolOfInt64ThenInt8Impl) GetInt64Arg() *int64 {
	return __.Int64Arg.Get().(*int64)
}
func (__ *PoolOfInt64ThenInt8Impl) PutInt64Arg(p *int64) {
	__.Int64Arg.Put(p)
}
func (__ *PoolOfInt64ThenInt8Impl) GetInt8Return() *int8 {
	return __.Int8Rtn.Get().(*int8)
}
func (__ *PoolOfInt64ThenInt8Impl) PutInt8Return(p *int8) {
	__.Int8Rtn.Put(p)
}

func (__ *PoolOfInt64ThenInt8Impl) GetWorkOfInt64ThenInt8() *WorkOfInt64ThenInt8 {
	return __.Int64Work.Get().(*WorkOfInt64ThenInt8)
}
func (__ *PoolOfInt64ThenInt8Impl) PutWorkOfInt64ThenInt8(p *WorkOfInt64ThenInt8) {
	__.Int64Work.Put(p)
}
func (__ *PoolOfInt64ThenInt8Impl) GetReturnOfInt8() *ReturnOfInt8 {
	return __.Int8Return.Get().(*ReturnOfInt8)
}
func (__ *PoolOfInt64ThenInt8Impl) PutReturnOfInt8(p *ReturnOfInt8) {
	__.Int8Return.Put(p)
}

func (__ *PoolOfInt64ThenInt8Impl) GetChReturnOfInt8() chan *ReturnOfInt8 {
	return __.ChReturnOfInt8.Get().(chan *ReturnOfInt8)
}
func (__ *PoolOfInt64ThenInt8Impl) PutChReturnOfInt8(p chan *ReturnOfInt8) {
	__.ChReturnOfInt8.Put(p)
}

func NewPoolOfInt64ThenInt8Impl() *PoolOfInt64ThenInt8Impl {
	return &PoolOfInt64ThenInt8Impl{
		Int64Arg: sync.Pool{
			New: func() interface{} {
				return new(int64)
			},
		},
		Int64Work: sync.Pool{
			New: func() interface{} {
				return new(WorkOfInt64ThenInt8)
			},
		},
		Int8Rtn: sync.Pool{
			New: func() interface{} {
				return new(int8)
			},
		},
		Int8Return: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfInt8)
			},
		},
		ChReturnOfInt8: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfInt8, 1)
			},
		},
	}
}

type ApiDecouplerOfInt64ThenInt8 struct {
	pool PoolOfInt64ThenInt8
}

func NewApiDecouplerOfInt64ThenInt8() *ApiDecouplerOfInt64ThenInt8 {
	return &ApiDecouplerOfInt64ThenInt8{
		pool: NewPoolOfInt64ThenInt8Impl(),
	}
}

func (__ *ApiDecouplerOfInt64ThenInt8) ReturnError(rtn_ch chan<- *ReturnOfInt8, err error) {
	rtn := __.pool.GetReturnOfInt8()
	var other int8
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfInt64ThenInt8) HandleOfInt64ThenInt8(ctx context.Context, req *WorkOfInt64ThenInt8, h func(ctx context.Context, arg int64) (int8, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfInt8()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfInt64ThenInt8) DoOfInt64ThenInt8(ctx context.Context, worker WorkerOfPushInt64ThenInt8, arg int64) (int8, error) {
	// ch := make(chan *ReturnOfInt8, 1)
	ch := __.pool.GetChReturnOfInt8()
	defer __.pool.PutChReturnOfInt8(ch)

	req := __.pool.GetWorkOfInt64ThenInt8()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfInt64ThenInt8(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfInt8(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfInt64ThenInt8 = func(ctx context.Context, arg int64) (int8, error)

type WorkerOfInt64ThenInt8 struct {
	api_syncer *ApiDecouplerOfInt64ThenInt8
	handler    WorkHandlerOfInt64ThenInt8

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfInt64ThenInt8
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfInt64ThenInt8(ctx context.Context, h WorkHandlerOfInt64ThenInt8, n int) *WorkerOfInt64ThenInt8 {
	__ := &WorkerOfInt64ThenInt8{
		api_syncer: NewApiDecouplerOfInt64ThenInt8(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfInt64ThenInt8, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfInt64ThenInt8{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfInt64ThenInt8(req.Context, req.WorkOfInt64ThenInt8, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfInt64ThenInt8) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfInt64ThenInt8) Push(ctx context.Context, req *WorkOfInt64ThenInt8) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfInt64ThenInt8)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfInt64ThenInt8 = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfInt64ThenInt8) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfInt64ThenInt8) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfInt64ThenInt8) Call(ctx context.Context, arg int64) (int8, error) {
	return __.api_syncer.DoOfInt64ThenInt8(ctx, __, arg)
}

type PoolOfInt64ThenRune interface {
	GetInt64Arg() *int64
	PutInt64Arg(*int64)
	GetRuneReturn() *rune
	PutRuneReturn(*rune)

	GetWorkOfInt64ThenRune() *WorkOfInt64ThenRune
	GetReturnOfRune() *ReturnOfRune
	PutWorkOfInt64ThenRune(*WorkOfInt64ThenRune)
	PutReturnOfRune(*ReturnOfRune)

	GetChReturnOfRune() chan *ReturnOfRune
	PutChReturnOfRune(chan *ReturnOfRune)
}

type PoolOfInt64ThenRuneImpl struct {
	Int64Arg       sync.Pool
	RuneRtn        sync.Pool
	Int64Work      sync.Pool
	RuneReturn     sync.Pool
	ChReturnOfRune sync.Pool
}

func (__ *PoolOfInt64ThenRuneImpl) GetInt64Arg() *int64 {
	return __.Int64Arg.Get().(*int64)
}
func (__ *PoolOfInt64ThenRuneImpl) PutInt64Arg(p *int64) {
	__.Int64Arg.Put(p)
}
func (__ *PoolOfInt64ThenRuneImpl) GetRuneReturn() *rune {
	return __.RuneRtn.Get().(*rune)
}
func (__ *PoolOfInt64ThenRuneImpl) PutRuneReturn(p *rune) {
	__.RuneRtn.Put(p)
}

func (__ *PoolOfInt64ThenRuneImpl) GetWorkOfInt64ThenRune() *WorkOfInt64ThenRune {
	return __.Int64Work.Get().(*WorkOfInt64ThenRune)
}
func (__ *PoolOfInt64ThenRuneImpl) PutWorkOfInt64ThenRune(p *WorkOfInt64ThenRune) {
	__.Int64Work.Put(p)
}
func (__ *PoolOfInt64ThenRuneImpl) GetReturnOfRune() *ReturnOfRune {
	return __.RuneReturn.Get().(*ReturnOfRune)
}
func (__ *PoolOfInt64ThenRuneImpl) PutReturnOfRune(p *ReturnOfRune) {
	__.RuneReturn.Put(p)
}

func (__ *PoolOfInt64ThenRuneImpl) GetChReturnOfRune() chan *ReturnOfRune {
	return __.ChReturnOfRune.Get().(chan *ReturnOfRune)
}
func (__ *PoolOfInt64ThenRuneImpl) PutChReturnOfRune(p chan *ReturnOfRune) {
	__.ChReturnOfRune.Put(p)
}

func NewPoolOfInt64ThenRuneImpl() *PoolOfInt64ThenRuneImpl {
	return &PoolOfInt64ThenRuneImpl{
		Int64Arg: sync.Pool{
			New: func() interface{} {
				return new(int64)
			},
		},
		Int64Work: sync.Pool{
			New: func() interface{} {
				return new(WorkOfInt64ThenRune)
			},
		},
		RuneRtn: sync.Pool{
			New: func() interface{} {
				return new(rune)
			},
		},
		RuneReturn: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfRune)
			},
		},
		ChReturnOfRune: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfRune, 1)
			},
		},
	}
}

type ApiDecouplerOfInt64ThenRune struct {
	pool PoolOfInt64ThenRune
}

func NewApiDecouplerOfInt64ThenRune() *ApiDecouplerOfInt64ThenRune {
	return &ApiDecouplerOfInt64ThenRune{
		pool: NewPoolOfInt64ThenRuneImpl(),
	}
}

func (__ *ApiDecouplerOfInt64ThenRune) ReturnError(rtn_ch chan<- *ReturnOfRune, err error) {
	rtn := __.pool.GetReturnOfRune()
	var other rune
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfInt64ThenRune) HandleOfInt64ThenRune(ctx context.Context, req *WorkOfInt64ThenRune, h func(ctx context.Context, arg int64) (rune, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfRune()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfInt64ThenRune) DoOfInt64ThenRune(ctx context.Context, worker WorkerOfPushInt64ThenRune, arg int64) (rune, error) {
	// ch := make(chan *ReturnOfRune, 1)
	ch := __.pool.GetChReturnOfRune()
	defer __.pool.PutChReturnOfRune(ch)

	req := __.pool.GetWorkOfInt64ThenRune()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfInt64ThenRune(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfRune(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfInt64ThenRune = func(ctx context.Context, arg int64) (rune, error)

type WorkerOfInt64ThenRune struct {
	api_syncer *ApiDecouplerOfInt64ThenRune
	handler    WorkHandlerOfInt64ThenRune

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfInt64ThenRune
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfInt64ThenRune(ctx context.Context, h WorkHandlerOfInt64ThenRune, n int) *WorkerOfInt64ThenRune {
	__ := &WorkerOfInt64ThenRune{
		api_syncer: NewApiDecouplerOfInt64ThenRune(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfInt64ThenRune, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfInt64ThenRune{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfInt64ThenRune(req.Context, req.WorkOfInt64ThenRune, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfInt64ThenRune) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfInt64ThenRune) Push(ctx context.Context, req *WorkOfInt64ThenRune) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfInt64ThenRune)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfInt64ThenRune = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfInt64ThenRune) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfInt64ThenRune) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfInt64ThenRune) Call(ctx context.Context, arg int64) (rune, error) {
	return __.api_syncer.DoOfInt64ThenRune(ctx, __, arg)
}

type PoolOfInt64ThenString interface {
	GetInt64Arg() *int64
	PutInt64Arg(*int64)
	GetStringReturn() *string
	PutStringReturn(*string)

	GetWorkOfInt64ThenString() *WorkOfInt64ThenString
	GetReturnOfString() *ReturnOfString
	PutWorkOfInt64ThenString(*WorkOfInt64ThenString)
	PutReturnOfString(*ReturnOfString)

	GetChReturnOfString() chan *ReturnOfString
	PutChReturnOfString(chan *ReturnOfString)
}

type PoolOfInt64ThenStringImpl struct {
	Int64Arg         sync.Pool
	StringRtn        sync.Pool
	Int64Work        sync.Pool
	StringReturn     sync.Pool
	ChReturnOfString sync.Pool
}

func (__ *PoolOfInt64ThenStringImpl) GetInt64Arg() *int64 {
	return __.Int64Arg.Get().(*int64)
}
func (__ *PoolOfInt64ThenStringImpl) PutInt64Arg(p *int64) {
	__.Int64Arg.Put(p)
}
func (__ *PoolOfInt64ThenStringImpl) GetStringReturn() *string {
	return __.StringRtn.Get().(*string)
}
func (__ *PoolOfInt64ThenStringImpl) PutStringReturn(p *string) {
	__.StringRtn.Put(p)
}

func (__ *PoolOfInt64ThenStringImpl) GetWorkOfInt64ThenString() *WorkOfInt64ThenString {
	return __.Int64Work.Get().(*WorkOfInt64ThenString)
}
func (__ *PoolOfInt64ThenStringImpl) PutWorkOfInt64ThenString(p *WorkOfInt64ThenString) {
	__.Int64Work.Put(p)
}
func (__ *PoolOfInt64ThenStringImpl) GetReturnOfString() *ReturnOfString {
	return __.StringReturn.Get().(*ReturnOfString)
}
func (__ *PoolOfInt64ThenStringImpl) PutReturnOfString(p *ReturnOfString) {
	__.StringReturn.Put(p)
}

func (__ *PoolOfInt64ThenStringImpl) GetChReturnOfString() chan *ReturnOfString {
	return __.ChReturnOfString.Get().(chan *ReturnOfString)
}
func (__ *PoolOfInt64ThenStringImpl) PutChReturnOfString(p chan *ReturnOfString) {
	__.ChReturnOfString.Put(p)
}

func NewPoolOfInt64ThenStringImpl() *PoolOfInt64ThenStringImpl {
	return &PoolOfInt64ThenStringImpl{
		Int64Arg: sync.Pool{
			New: func() interface{} {
				return new(int64)
			},
		},
		Int64Work: sync.Pool{
			New: func() interface{} {
				return new(WorkOfInt64ThenString)
			},
		},
		StringRtn: sync.Pool{
			New: func() interface{} {
				return new(string)
			},
		},
		StringReturn: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfString)
			},
		},
		ChReturnOfString: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfString, 1)
			},
		},
	}
}

type ApiDecouplerOfInt64ThenString struct {
	pool PoolOfInt64ThenString
}

func NewApiDecouplerOfInt64ThenString() *ApiDecouplerOfInt64ThenString {
	return &ApiDecouplerOfInt64ThenString{
		pool: NewPoolOfInt64ThenStringImpl(),
	}
}

func (__ *ApiDecouplerOfInt64ThenString) ReturnError(rtn_ch chan<- *ReturnOfString, err error) {
	rtn := __.pool.GetReturnOfString()
	var other string
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfInt64ThenString) HandleOfInt64ThenString(ctx context.Context, req *WorkOfInt64ThenString, h func(ctx context.Context, arg int64) (string, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfString()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfInt64ThenString) DoOfInt64ThenString(ctx context.Context, worker WorkerOfPushInt64ThenString, arg int64) (string, error) {
	// ch := make(chan *ReturnOfString, 1)
	ch := __.pool.GetChReturnOfString()
	defer __.pool.PutChReturnOfString(ch)

	req := __.pool.GetWorkOfInt64ThenString()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfInt64ThenString(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfString(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfInt64ThenString = func(ctx context.Context, arg int64) (string, error)

type WorkerOfInt64ThenString struct {
	api_syncer *ApiDecouplerOfInt64ThenString
	handler    WorkHandlerOfInt64ThenString

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfInt64ThenString
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfInt64ThenString(ctx context.Context, h WorkHandlerOfInt64ThenString, n int) *WorkerOfInt64ThenString {
	__ := &WorkerOfInt64ThenString{
		api_syncer: NewApiDecouplerOfInt64ThenString(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfInt64ThenString, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfInt64ThenString{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfInt64ThenString(req.Context, req.WorkOfInt64ThenString, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfInt64ThenString) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfInt64ThenString) Push(ctx context.Context, req *WorkOfInt64ThenString) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfInt64ThenString)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfInt64ThenString = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfInt64ThenString) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfInt64ThenString) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfInt64ThenString) Call(ctx context.Context, arg int64) (string, error) {
	return __.api_syncer.DoOfInt64ThenString(ctx, __, arg)
}

type PoolOfInt64ThenUint interface {
	GetInt64Arg() *int64
	PutInt64Arg(*int64)
	GetUintReturn() *uint
	PutUintReturn(*uint)

	GetWorkOfInt64ThenUint() *WorkOfInt64ThenUint
	GetReturnOfUint() *ReturnOfUint
	PutWorkOfInt64ThenUint(*WorkOfInt64ThenUint)
	PutReturnOfUint(*ReturnOfUint)

	GetChReturnOfUint() chan *ReturnOfUint
	PutChReturnOfUint(chan *ReturnOfUint)
}

type PoolOfInt64ThenUintImpl struct {
	Int64Arg       sync.Pool
	UintRtn        sync.Pool
	Int64Work      sync.Pool
	UintReturn     sync.Pool
	ChReturnOfUint sync.Pool
}

func (__ *PoolOfInt64ThenUintImpl) GetInt64Arg() *int64 {
	return __.Int64Arg.Get().(*int64)
}
func (__ *PoolOfInt64ThenUintImpl) PutInt64Arg(p *int64) {
	__.Int64Arg.Put(p)
}
func (__ *PoolOfInt64ThenUintImpl) GetUintReturn() *uint {
	return __.UintRtn.Get().(*uint)
}
func (__ *PoolOfInt64ThenUintImpl) PutUintReturn(p *uint) {
	__.UintRtn.Put(p)
}

func (__ *PoolOfInt64ThenUintImpl) GetWorkOfInt64ThenUint() *WorkOfInt64ThenUint {
	return __.Int64Work.Get().(*WorkOfInt64ThenUint)
}
func (__ *PoolOfInt64ThenUintImpl) PutWorkOfInt64ThenUint(p *WorkOfInt64ThenUint) {
	__.Int64Work.Put(p)
}
func (__ *PoolOfInt64ThenUintImpl) GetReturnOfUint() *ReturnOfUint {
	return __.UintReturn.Get().(*ReturnOfUint)
}
func (__ *PoolOfInt64ThenUintImpl) PutReturnOfUint(p *ReturnOfUint) {
	__.UintReturn.Put(p)
}

func (__ *PoolOfInt64ThenUintImpl) GetChReturnOfUint() chan *ReturnOfUint {
	return __.ChReturnOfUint.Get().(chan *ReturnOfUint)
}
func (__ *PoolOfInt64ThenUintImpl) PutChReturnOfUint(p chan *ReturnOfUint) {
	__.ChReturnOfUint.Put(p)
}

func NewPoolOfInt64ThenUintImpl() *PoolOfInt64ThenUintImpl {
	return &PoolOfInt64ThenUintImpl{
		Int64Arg: sync.Pool{
			New: func() interface{} {
				return new(int64)
			},
		},
		Int64Work: sync.Pool{
			New: func() interface{} {
				return new(WorkOfInt64ThenUint)
			},
		},
		UintRtn: sync.Pool{
			New: func() interface{} {
				return new(uint)
			},
		},
		UintReturn: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfUint)
			},
		},
		ChReturnOfUint: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfUint, 1)
			},
		},
	}
}

type ApiDecouplerOfInt64ThenUint struct {
	pool PoolOfInt64ThenUint
}

func NewApiDecouplerOfInt64ThenUint() *ApiDecouplerOfInt64ThenUint {
	return &ApiDecouplerOfInt64ThenUint{
		pool: NewPoolOfInt64ThenUintImpl(),
	}
}

func (__ *ApiDecouplerOfInt64ThenUint) ReturnError(rtn_ch chan<- *ReturnOfUint, err error) {
	rtn := __.pool.GetReturnOfUint()
	var other uint
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfInt64ThenUint) HandleOfInt64ThenUint(ctx context.Context, req *WorkOfInt64ThenUint, h func(ctx context.Context, arg int64) (uint, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfUint()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfInt64ThenUint) DoOfInt64ThenUint(ctx context.Context, worker WorkerOfPushInt64ThenUint, arg int64) (uint, error) {
	// ch := make(chan *ReturnOfUint, 1)
	ch := __.pool.GetChReturnOfUint()
	defer __.pool.PutChReturnOfUint(ch)

	req := __.pool.GetWorkOfInt64ThenUint()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfInt64ThenUint(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfUint(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfInt64ThenUint = func(ctx context.Context, arg int64) (uint, error)

type WorkerOfInt64ThenUint struct {
	api_syncer *ApiDecouplerOfInt64ThenUint
	handler    WorkHandlerOfInt64ThenUint

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfInt64ThenUint
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfInt64ThenUint(ctx context.Context, h WorkHandlerOfInt64ThenUint, n int) *WorkerOfInt64ThenUint {
	__ := &WorkerOfInt64ThenUint{
		api_syncer: NewApiDecouplerOfInt64ThenUint(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfInt64ThenUint, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfInt64ThenUint{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfInt64ThenUint(req.Context, req.WorkOfInt64ThenUint, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfInt64ThenUint) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfInt64ThenUint) Push(ctx context.Context, req *WorkOfInt64ThenUint) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfInt64ThenUint)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfInt64ThenUint = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfInt64ThenUint) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfInt64ThenUint) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfInt64ThenUint) Call(ctx context.Context, arg int64) (uint, error) {
	return __.api_syncer.DoOfInt64ThenUint(ctx, __, arg)
}

type PoolOfInt64ThenUint16 interface {
	GetInt64Arg() *int64
	PutInt64Arg(*int64)
	GetUint16Return() *uint16
	PutUint16Return(*uint16)

	GetWorkOfInt64ThenUint16() *WorkOfInt64ThenUint16
	GetReturnOfUint16() *ReturnOfUint16
	PutWorkOfInt64ThenUint16(*WorkOfInt64ThenUint16)
	PutReturnOfUint16(*ReturnOfUint16)

	GetChReturnOfUint16() chan *ReturnOfUint16
	PutChReturnOfUint16(chan *ReturnOfUint16)
}

type PoolOfInt64ThenUint16Impl struct {
	Int64Arg         sync.Pool
	Uint16Rtn        sync.Pool
	Int64Work        sync.Pool
	Uint16Return     sync.Pool
	ChReturnOfUint16 sync.Pool
}

func (__ *PoolOfInt64ThenUint16Impl) GetInt64Arg() *int64 {
	return __.Int64Arg.Get().(*int64)
}
func (__ *PoolOfInt64ThenUint16Impl) PutInt64Arg(p *int64) {
	__.Int64Arg.Put(p)
}
func (__ *PoolOfInt64ThenUint16Impl) GetUint16Return() *uint16 {
	return __.Uint16Rtn.Get().(*uint16)
}
func (__ *PoolOfInt64ThenUint16Impl) PutUint16Return(p *uint16) {
	__.Uint16Rtn.Put(p)
}

func (__ *PoolOfInt64ThenUint16Impl) GetWorkOfInt64ThenUint16() *WorkOfInt64ThenUint16 {
	return __.Int64Work.Get().(*WorkOfInt64ThenUint16)
}
func (__ *PoolOfInt64ThenUint16Impl) PutWorkOfInt64ThenUint16(p *WorkOfInt64ThenUint16) {
	__.Int64Work.Put(p)
}
func (__ *PoolOfInt64ThenUint16Impl) GetReturnOfUint16() *ReturnOfUint16 {
	return __.Uint16Return.Get().(*ReturnOfUint16)
}
func (__ *PoolOfInt64ThenUint16Impl) PutReturnOfUint16(p *ReturnOfUint16) {
	__.Uint16Return.Put(p)
}

func (__ *PoolOfInt64ThenUint16Impl) GetChReturnOfUint16() chan *ReturnOfUint16 {
	return __.ChReturnOfUint16.Get().(chan *ReturnOfUint16)
}
func (__ *PoolOfInt64ThenUint16Impl) PutChReturnOfUint16(p chan *ReturnOfUint16) {
	__.ChReturnOfUint16.Put(p)
}

func NewPoolOfInt64ThenUint16Impl() *PoolOfInt64ThenUint16Impl {
	return &PoolOfInt64ThenUint16Impl{
		Int64Arg: sync.Pool{
			New: func() interface{} {
				return new(int64)
			},
		},
		Int64Work: sync.Pool{
			New: func() interface{} {
				return new(WorkOfInt64ThenUint16)
			},
		},
		Uint16Rtn: sync.Pool{
			New: func() interface{} {
				return new(uint16)
			},
		},
		Uint16Return: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfUint16)
			},
		},
		ChReturnOfUint16: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfUint16, 1)
			},
		},
	}
}

type ApiDecouplerOfInt64ThenUint16 struct {
	pool PoolOfInt64ThenUint16
}

func NewApiDecouplerOfInt64ThenUint16() *ApiDecouplerOfInt64ThenUint16 {
	return &ApiDecouplerOfInt64ThenUint16{
		pool: NewPoolOfInt64ThenUint16Impl(),
	}
}

func (__ *ApiDecouplerOfInt64ThenUint16) ReturnError(rtn_ch chan<- *ReturnOfUint16, err error) {
	rtn := __.pool.GetReturnOfUint16()
	var other uint16
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfInt64ThenUint16) HandleOfInt64ThenUint16(ctx context.Context, req *WorkOfInt64ThenUint16, h func(ctx context.Context, arg int64) (uint16, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfUint16()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfInt64ThenUint16) DoOfInt64ThenUint16(ctx context.Context, worker WorkerOfPushInt64ThenUint16, arg int64) (uint16, error) {
	// ch := make(chan *ReturnOfUint16, 1)
	ch := __.pool.GetChReturnOfUint16()
	defer __.pool.PutChReturnOfUint16(ch)

	req := __.pool.GetWorkOfInt64ThenUint16()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfInt64ThenUint16(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfUint16(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfInt64ThenUint16 = func(ctx context.Context, arg int64) (uint16, error)

type WorkerOfInt64ThenUint16 struct {
	api_syncer *ApiDecouplerOfInt64ThenUint16
	handler    WorkHandlerOfInt64ThenUint16

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfInt64ThenUint16
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfInt64ThenUint16(ctx context.Context, h WorkHandlerOfInt64ThenUint16, n int) *WorkerOfInt64ThenUint16 {
	__ := &WorkerOfInt64ThenUint16{
		api_syncer: NewApiDecouplerOfInt64ThenUint16(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfInt64ThenUint16, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfInt64ThenUint16{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfInt64ThenUint16(req.Context, req.WorkOfInt64ThenUint16, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfInt64ThenUint16) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfInt64ThenUint16) Push(ctx context.Context, req *WorkOfInt64ThenUint16) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfInt64ThenUint16)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfInt64ThenUint16 = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfInt64ThenUint16) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfInt64ThenUint16) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfInt64ThenUint16) Call(ctx context.Context, arg int64) (uint16, error) {
	return __.api_syncer.DoOfInt64ThenUint16(ctx, __, arg)
}

type PoolOfInt64ThenUint32 interface {
	GetInt64Arg() *int64
	PutInt64Arg(*int64)
	GetUint32Return() *uint32
	PutUint32Return(*uint32)

	GetWorkOfInt64ThenUint32() *WorkOfInt64ThenUint32
	GetReturnOfUint32() *ReturnOfUint32
	PutWorkOfInt64ThenUint32(*WorkOfInt64ThenUint32)
	PutReturnOfUint32(*ReturnOfUint32)

	GetChReturnOfUint32() chan *ReturnOfUint32
	PutChReturnOfUint32(chan *ReturnOfUint32)
}

type PoolOfInt64ThenUint32Impl struct {
	Int64Arg         sync.Pool
	Uint32Rtn        sync.Pool
	Int64Work        sync.Pool
	Uint32Return     sync.Pool
	ChReturnOfUint32 sync.Pool
}

func (__ *PoolOfInt64ThenUint32Impl) GetInt64Arg() *int64 {
	return __.Int64Arg.Get().(*int64)
}
func (__ *PoolOfInt64ThenUint32Impl) PutInt64Arg(p *int64) {
	__.Int64Arg.Put(p)
}
func (__ *PoolOfInt64ThenUint32Impl) GetUint32Return() *uint32 {
	return __.Uint32Rtn.Get().(*uint32)
}
func (__ *PoolOfInt64ThenUint32Impl) PutUint32Return(p *uint32) {
	__.Uint32Rtn.Put(p)
}

func (__ *PoolOfInt64ThenUint32Impl) GetWorkOfInt64ThenUint32() *WorkOfInt64ThenUint32 {
	return __.Int64Work.Get().(*WorkOfInt64ThenUint32)
}
func (__ *PoolOfInt64ThenUint32Impl) PutWorkOfInt64ThenUint32(p *WorkOfInt64ThenUint32) {
	__.Int64Work.Put(p)
}
func (__ *PoolOfInt64ThenUint32Impl) GetReturnOfUint32() *ReturnOfUint32 {
	return __.Uint32Return.Get().(*ReturnOfUint32)
}
func (__ *PoolOfInt64ThenUint32Impl) PutReturnOfUint32(p *ReturnOfUint32) {
	__.Uint32Return.Put(p)
}

func (__ *PoolOfInt64ThenUint32Impl) GetChReturnOfUint32() chan *ReturnOfUint32 {
	return __.ChReturnOfUint32.Get().(chan *ReturnOfUint32)
}
func (__ *PoolOfInt64ThenUint32Impl) PutChReturnOfUint32(p chan *ReturnOfUint32) {
	__.ChReturnOfUint32.Put(p)
}

func NewPoolOfInt64ThenUint32Impl() *PoolOfInt64ThenUint32Impl {
	return &PoolOfInt64ThenUint32Impl{
		Int64Arg: sync.Pool{
			New: func() interface{} {
				return new(int64)
			},
		},
		Int64Work: sync.Pool{
			New: func() interface{} {
				return new(WorkOfInt64ThenUint32)
			},
		},
		Uint32Rtn: sync.Pool{
			New: func() interface{} {
				return new(uint32)
			},
		},
		Uint32Return: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfUint32)
			},
		},
		ChReturnOfUint32: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfUint32, 1)
			},
		},
	}
}

type ApiDecouplerOfInt64ThenUint32 struct {
	pool PoolOfInt64ThenUint32
}

func NewApiDecouplerOfInt64ThenUint32() *ApiDecouplerOfInt64ThenUint32 {
	return &ApiDecouplerOfInt64ThenUint32{
		pool: NewPoolOfInt64ThenUint32Impl(),
	}
}

func (__ *ApiDecouplerOfInt64ThenUint32) ReturnError(rtn_ch chan<- *ReturnOfUint32, err error) {
	rtn := __.pool.GetReturnOfUint32()
	var other uint32
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfInt64ThenUint32) HandleOfInt64ThenUint32(ctx context.Context, req *WorkOfInt64ThenUint32, h func(ctx context.Context, arg int64) (uint32, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfUint32()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfInt64ThenUint32) DoOfInt64ThenUint32(ctx context.Context, worker WorkerOfPushInt64ThenUint32, arg int64) (uint32, error) {
	// ch := make(chan *ReturnOfUint32, 1)
	ch := __.pool.GetChReturnOfUint32()
	defer __.pool.PutChReturnOfUint32(ch)

	req := __.pool.GetWorkOfInt64ThenUint32()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfInt64ThenUint32(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfUint32(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfInt64ThenUint32 = func(ctx context.Context, arg int64) (uint32, error)

type WorkerOfInt64ThenUint32 struct {
	api_syncer *ApiDecouplerOfInt64ThenUint32
	handler    WorkHandlerOfInt64ThenUint32

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfInt64ThenUint32
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfInt64ThenUint32(ctx context.Context, h WorkHandlerOfInt64ThenUint32, n int) *WorkerOfInt64ThenUint32 {
	__ := &WorkerOfInt64ThenUint32{
		api_syncer: NewApiDecouplerOfInt64ThenUint32(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfInt64ThenUint32, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfInt64ThenUint32{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfInt64ThenUint32(req.Context, req.WorkOfInt64ThenUint32, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfInt64ThenUint32) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfInt64ThenUint32) Push(ctx context.Context, req *WorkOfInt64ThenUint32) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfInt64ThenUint32)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfInt64ThenUint32 = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfInt64ThenUint32) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfInt64ThenUint32) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfInt64ThenUint32) Call(ctx context.Context, arg int64) (uint32, error) {
	return __.api_syncer.DoOfInt64ThenUint32(ctx, __, arg)
}

type PoolOfInt64ThenUint64 interface {
	GetInt64Arg() *int64
	PutInt64Arg(*int64)
	GetUint64Return() *uint64
	PutUint64Return(*uint64)

	GetWorkOfInt64ThenUint64() *WorkOfInt64ThenUint64
	GetReturnOfUint64() *ReturnOfUint64
	PutWorkOfInt64ThenUint64(*WorkOfInt64ThenUint64)
	PutReturnOfUint64(*ReturnOfUint64)

	GetChReturnOfUint64() chan *ReturnOfUint64
	PutChReturnOfUint64(chan *ReturnOfUint64)
}

type PoolOfInt64ThenUint64Impl struct {
	Int64Arg         sync.Pool
	Uint64Rtn        sync.Pool
	Int64Work        sync.Pool
	Uint64Return     sync.Pool
	ChReturnOfUint64 sync.Pool
}

func (__ *PoolOfInt64ThenUint64Impl) GetInt64Arg() *int64 {
	return __.Int64Arg.Get().(*int64)
}
func (__ *PoolOfInt64ThenUint64Impl) PutInt64Arg(p *int64) {
	__.Int64Arg.Put(p)
}
func (__ *PoolOfInt64ThenUint64Impl) GetUint64Return() *uint64 {
	return __.Uint64Rtn.Get().(*uint64)
}
func (__ *PoolOfInt64ThenUint64Impl) PutUint64Return(p *uint64) {
	__.Uint64Rtn.Put(p)
}

func (__ *PoolOfInt64ThenUint64Impl) GetWorkOfInt64ThenUint64() *WorkOfInt64ThenUint64 {
	return __.Int64Work.Get().(*WorkOfInt64ThenUint64)
}
func (__ *PoolOfInt64ThenUint64Impl) PutWorkOfInt64ThenUint64(p *WorkOfInt64ThenUint64) {
	__.Int64Work.Put(p)
}
func (__ *PoolOfInt64ThenUint64Impl) GetReturnOfUint64() *ReturnOfUint64 {
	return __.Uint64Return.Get().(*ReturnOfUint64)
}
func (__ *PoolOfInt64ThenUint64Impl) PutReturnOfUint64(p *ReturnOfUint64) {
	__.Uint64Return.Put(p)
}

func (__ *PoolOfInt64ThenUint64Impl) GetChReturnOfUint64() chan *ReturnOfUint64 {
	return __.ChReturnOfUint64.Get().(chan *ReturnOfUint64)
}
func (__ *PoolOfInt64ThenUint64Impl) PutChReturnOfUint64(p chan *ReturnOfUint64) {
	__.ChReturnOfUint64.Put(p)
}

func NewPoolOfInt64ThenUint64Impl() *PoolOfInt64ThenUint64Impl {
	return &PoolOfInt64ThenUint64Impl{
		Int64Arg: sync.Pool{
			New: func() interface{} {
				return new(int64)
			},
		},
		Int64Work: sync.Pool{
			New: func() interface{} {
				return new(WorkOfInt64ThenUint64)
			},
		},
		Uint64Rtn: sync.Pool{
			New: func() interface{} {
				return new(uint64)
			},
		},
		Uint64Return: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfUint64)
			},
		},
		ChReturnOfUint64: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfUint64, 1)
			},
		},
	}
}

type ApiDecouplerOfInt64ThenUint64 struct {
	pool PoolOfInt64ThenUint64
}

func NewApiDecouplerOfInt64ThenUint64() *ApiDecouplerOfInt64ThenUint64 {
	return &ApiDecouplerOfInt64ThenUint64{
		pool: NewPoolOfInt64ThenUint64Impl(),
	}
}

func (__ *ApiDecouplerOfInt64ThenUint64) ReturnError(rtn_ch chan<- *ReturnOfUint64, err error) {
	rtn := __.pool.GetReturnOfUint64()
	var other uint64
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfInt64ThenUint64) HandleOfInt64ThenUint64(ctx context.Context, req *WorkOfInt64ThenUint64, h func(ctx context.Context, arg int64) (uint64, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfUint64()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfInt64ThenUint64) DoOfInt64ThenUint64(ctx context.Context, worker WorkerOfPushInt64ThenUint64, arg int64) (uint64, error) {
	// ch := make(chan *ReturnOfUint64, 1)
	ch := __.pool.GetChReturnOfUint64()
	defer __.pool.PutChReturnOfUint64(ch)

	req := __.pool.GetWorkOfInt64ThenUint64()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfInt64ThenUint64(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfUint64(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfInt64ThenUint64 = func(ctx context.Context, arg int64) (uint64, error)

type WorkerOfInt64ThenUint64 struct {
	api_syncer *ApiDecouplerOfInt64ThenUint64
	handler    WorkHandlerOfInt64ThenUint64

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfInt64ThenUint64
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfInt64ThenUint64(ctx context.Context, h WorkHandlerOfInt64ThenUint64, n int) *WorkerOfInt64ThenUint64 {
	__ := &WorkerOfInt64ThenUint64{
		api_syncer: NewApiDecouplerOfInt64ThenUint64(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfInt64ThenUint64, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfInt64ThenUint64{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfInt64ThenUint64(req.Context, req.WorkOfInt64ThenUint64, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfInt64ThenUint64) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfInt64ThenUint64) Push(ctx context.Context, req *WorkOfInt64ThenUint64) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfInt64ThenUint64)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfInt64ThenUint64 = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfInt64ThenUint64) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfInt64ThenUint64) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfInt64ThenUint64) Call(ctx context.Context, arg int64) (uint64, error) {
	return __.api_syncer.DoOfInt64ThenUint64(ctx, __, arg)
}

type PoolOfInt64ThenUint8 interface {
	GetInt64Arg() *int64
	PutInt64Arg(*int64)
	GetUint8Return() *uint8
	PutUint8Return(*uint8)

	GetWorkOfInt64ThenUint8() *WorkOfInt64ThenUint8
	GetReturnOfUint8() *ReturnOfUint8
	PutWorkOfInt64ThenUint8(*WorkOfInt64ThenUint8)
	PutReturnOfUint8(*ReturnOfUint8)

	GetChReturnOfUint8() chan *ReturnOfUint8
	PutChReturnOfUint8(chan *ReturnOfUint8)
}

type PoolOfInt64ThenUint8Impl struct {
	Int64Arg        sync.Pool
	Uint8Rtn        sync.Pool
	Int64Work       sync.Pool
	Uint8Return     sync.Pool
	ChReturnOfUint8 sync.Pool
}

func (__ *PoolOfInt64ThenUint8Impl) GetInt64Arg() *int64 {
	return __.Int64Arg.Get().(*int64)
}
func (__ *PoolOfInt64ThenUint8Impl) PutInt64Arg(p *int64) {
	__.Int64Arg.Put(p)
}
func (__ *PoolOfInt64ThenUint8Impl) GetUint8Return() *uint8 {
	return __.Uint8Rtn.Get().(*uint8)
}
func (__ *PoolOfInt64ThenUint8Impl) PutUint8Return(p *uint8) {
	__.Uint8Rtn.Put(p)
}

func (__ *PoolOfInt64ThenUint8Impl) GetWorkOfInt64ThenUint8() *WorkOfInt64ThenUint8 {
	return __.Int64Work.Get().(*WorkOfInt64ThenUint8)
}
func (__ *PoolOfInt64ThenUint8Impl) PutWorkOfInt64ThenUint8(p *WorkOfInt64ThenUint8) {
	__.Int64Work.Put(p)
}
func (__ *PoolOfInt64ThenUint8Impl) GetReturnOfUint8() *ReturnOfUint8 {
	return __.Uint8Return.Get().(*ReturnOfUint8)
}
func (__ *PoolOfInt64ThenUint8Impl) PutReturnOfUint8(p *ReturnOfUint8) {
	__.Uint8Return.Put(p)
}

func (__ *PoolOfInt64ThenUint8Impl) GetChReturnOfUint8() chan *ReturnOfUint8 {
	return __.ChReturnOfUint8.Get().(chan *ReturnOfUint8)
}
func (__ *PoolOfInt64ThenUint8Impl) PutChReturnOfUint8(p chan *ReturnOfUint8) {
	__.ChReturnOfUint8.Put(p)
}

func NewPoolOfInt64ThenUint8Impl() *PoolOfInt64ThenUint8Impl {
	return &PoolOfInt64ThenUint8Impl{
		Int64Arg: sync.Pool{
			New: func() interface{} {
				return new(int64)
			},
		},
		Int64Work: sync.Pool{
			New: func() interface{} {
				return new(WorkOfInt64ThenUint8)
			},
		},
		Uint8Rtn: sync.Pool{
			New: func() interface{} {
				return new(uint8)
			},
		},
		Uint8Return: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfUint8)
			},
		},
		ChReturnOfUint8: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfUint8, 1)
			},
		},
	}
}

type ApiDecouplerOfInt64ThenUint8 struct {
	pool PoolOfInt64ThenUint8
}

func NewApiDecouplerOfInt64ThenUint8() *ApiDecouplerOfInt64ThenUint8 {
	return &ApiDecouplerOfInt64ThenUint8{
		pool: NewPoolOfInt64ThenUint8Impl(),
	}
}

func (__ *ApiDecouplerOfInt64ThenUint8) ReturnError(rtn_ch chan<- *ReturnOfUint8, err error) {
	rtn := __.pool.GetReturnOfUint8()
	var other uint8
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfInt64ThenUint8) HandleOfInt64ThenUint8(ctx context.Context, req *WorkOfInt64ThenUint8, h func(ctx context.Context, arg int64) (uint8, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfUint8()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfInt64ThenUint8) DoOfInt64ThenUint8(ctx context.Context, worker WorkerOfPushInt64ThenUint8, arg int64) (uint8, error) {
	// ch := make(chan *ReturnOfUint8, 1)
	ch := __.pool.GetChReturnOfUint8()
	defer __.pool.PutChReturnOfUint8(ch)

	req := __.pool.GetWorkOfInt64ThenUint8()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfInt64ThenUint8(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfUint8(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfInt64ThenUint8 = func(ctx context.Context, arg int64) (uint8, error)

type WorkerOfInt64ThenUint8 struct {
	api_syncer *ApiDecouplerOfInt64ThenUint8
	handler    WorkHandlerOfInt64ThenUint8

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfInt64ThenUint8
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfInt64ThenUint8(ctx context.Context, h WorkHandlerOfInt64ThenUint8, n int) *WorkerOfInt64ThenUint8 {
	__ := &WorkerOfInt64ThenUint8{
		api_syncer: NewApiDecouplerOfInt64ThenUint8(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfInt64ThenUint8, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfInt64ThenUint8{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfInt64ThenUint8(req.Context, req.WorkOfInt64ThenUint8, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfInt64ThenUint8) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfInt64ThenUint8) Push(ctx context.Context, req *WorkOfInt64ThenUint8) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfInt64ThenUint8)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfInt64ThenUint8 = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfInt64ThenUint8) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfInt64ThenUint8) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfInt64ThenUint8) Call(ctx context.Context, arg int64) (uint8, error) {
	return __.api_syncer.DoOfInt64ThenUint8(ctx, __, arg)
}

type PoolOfInt64ThenUintptr interface {
	GetInt64Arg() *int64
	PutInt64Arg(*int64)
	GetUintptrReturn() *uintptr
	PutUintptrReturn(*uintptr)

	GetWorkOfInt64ThenUintptr() *WorkOfInt64ThenUintptr
	GetReturnOfUintptr() *ReturnOfUintptr
	PutWorkOfInt64ThenUintptr(*WorkOfInt64ThenUintptr)
	PutReturnOfUintptr(*ReturnOfUintptr)

	GetChReturnOfUintptr() chan *ReturnOfUintptr
	PutChReturnOfUintptr(chan *ReturnOfUintptr)
}

type PoolOfInt64ThenUintptrImpl struct {
	Int64Arg          sync.Pool
	UintptrRtn        sync.Pool
	Int64Work         sync.Pool
	UintptrReturn     sync.Pool
	ChReturnOfUintptr sync.Pool
}

func (__ *PoolOfInt64ThenUintptrImpl) GetInt64Arg() *int64 {
	return __.Int64Arg.Get().(*int64)
}
func (__ *PoolOfInt64ThenUintptrImpl) PutInt64Arg(p *int64) {
	__.Int64Arg.Put(p)
}
func (__ *PoolOfInt64ThenUintptrImpl) GetUintptrReturn() *uintptr {
	return __.UintptrRtn.Get().(*uintptr)
}
func (__ *PoolOfInt64ThenUintptrImpl) PutUintptrReturn(p *uintptr) {
	__.UintptrRtn.Put(p)
}

func (__ *PoolOfInt64ThenUintptrImpl) GetWorkOfInt64ThenUintptr() *WorkOfInt64ThenUintptr {
	return __.Int64Work.Get().(*WorkOfInt64ThenUintptr)
}
func (__ *PoolOfInt64ThenUintptrImpl) PutWorkOfInt64ThenUintptr(p *WorkOfInt64ThenUintptr) {
	__.Int64Work.Put(p)
}
func (__ *PoolOfInt64ThenUintptrImpl) GetReturnOfUintptr() *ReturnOfUintptr {
	return __.UintptrReturn.Get().(*ReturnOfUintptr)
}
func (__ *PoolOfInt64ThenUintptrImpl) PutReturnOfUintptr(p *ReturnOfUintptr) {
	__.UintptrReturn.Put(p)
}

func (__ *PoolOfInt64ThenUintptrImpl) GetChReturnOfUintptr() chan *ReturnOfUintptr {
	return __.ChReturnOfUintptr.Get().(chan *ReturnOfUintptr)
}
func (__ *PoolOfInt64ThenUintptrImpl) PutChReturnOfUintptr(p chan *ReturnOfUintptr) {
	__.ChReturnOfUintptr.Put(p)
}

func NewPoolOfInt64ThenUintptrImpl() *PoolOfInt64ThenUintptrImpl {
	return &PoolOfInt64ThenUintptrImpl{
		Int64Arg: sync.Pool{
			New: func() interface{} {
				return new(int64)
			},
		},
		Int64Work: sync.Pool{
			New: func() interface{} {
				return new(WorkOfInt64ThenUintptr)
			},
		},
		UintptrRtn: sync.Pool{
			New: func() interface{} {
				return new(uintptr)
			},
		},
		UintptrReturn: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfUintptr)
			},
		},
		ChReturnOfUintptr: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfUintptr, 1)
			},
		},
	}
}

type ApiDecouplerOfInt64ThenUintptr struct {
	pool PoolOfInt64ThenUintptr
}

func NewApiDecouplerOfInt64ThenUintptr() *ApiDecouplerOfInt64ThenUintptr {
	return &ApiDecouplerOfInt64ThenUintptr{
		pool: NewPoolOfInt64ThenUintptrImpl(),
	}
}

func (__ *ApiDecouplerOfInt64ThenUintptr) ReturnError(rtn_ch chan<- *ReturnOfUintptr, err error) {
	rtn := __.pool.GetReturnOfUintptr()
	var other uintptr
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfInt64ThenUintptr) HandleOfInt64ThenUintptr(ctx context.Context, req *WorkOfInt64ThenUintptr, h func(ctx context.Context, arg int64) (uintptr, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfUintptr()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfInt64ThenUintptr) DoOfInt64ThenUintptr(ctx context.Context, worker WorkerOfPushInt64ThenUintptr, arg int64) (uintptr, error) {
	// ch := make(chan *ReturnOfUintptr, 1)
	ch := __.pool.GetChReturnOfUintptr()
	defer __.pool.PutChReturnOfUintptr(ch)

	req := __.pool.GetWorkOfInt64ThenUintptr()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfInt64ThenUintptr(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfUintptr(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfInt64ThenUintptr = func(ctx context.Context, arg int64) (uintptr, error)

type WorkerOfInt64ThenUintptr struct {
	api_syncer *ApiDecouplerOfInt64ThenUintptr
	handler    WorkHandlerOfInt64ThenUintptr

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfInt64ThenUintptr
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfInt64ThenUintptr(ctx context.Context, h WorkHandlerOfInt64ThenUintptr, n int) *WorkerOfInt64ThenUintptr {
	__ := &WorkerOfInt64ThenUintptr{
		api_syncer: NewApiDecouplerOfInt64ThenUintptr(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfInt64ThenUintptr, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfInt64ThenUintptr{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfInt64ThenUintptr(req.Context, req.WorkOfInt64ThenUintptr, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfInt64ThenUintptr) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfInt64ThenUintptr) Push(ctx context.Context, req *WorkOfInt64ThenUintptr) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfInt64ThenUintptr)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfInt64ThenUintptr = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfInt64ThenUintptr) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfInt64ThenUintptr) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfInt64ThenUintptr) Call(ctx context.Context, arg int64) (uintptr, error) {
	return __.api_syncer.DoOfInt64ThenUintptr(ctx, __, arg)
}

type PoolOfInt64ThenInterface interface {
	GetInt64Arg() *int64
	PutInt64Arg(*int64)
	GetInterfaceReturn() *interface{}
	PutInterfaceReturn(*interface{})

	GetWorkOfInt64ThenInterface() *WorkOfInt64ThenInterface
	GetReturnOfInterface() *ReturnOfInterface
	PutWorkOfInt64ThenInterface(*WorkOfInt64ThenInterface)
	PutReturnOfInterface(*ReturnOfInterface)

	GetChReturnOfInterface() chan *ReturnOfInterface
	PutChReturnOfInterface(chan *ReturnOfInterface)
}

type PoolOfInt64ThenInterfaceImpl struct {
	Int64Arg            sync.Pool
	InterfaceRtn        sync.Pool
	Int64Work           sync.Pool
	InterfaceReturn     sync.Pool
	ChReturnOfInterface sync.Pool
}

func (__ *PoolOfInt64ThenInterfaceImpl) GetInt64Arg() *int64 {
	return __.Int64Arg.Get().(*int64)
}
func (__ *PoolOfInt64ThenInterfaceImpl) PutInt64Arg(p *int64) {
	__.Int64Arg.Put(p)
}
func (__ *PoolOfInt64ThenInterfaceImpl) GetInterfaceReturn() *interface{} {
	return __.InterfaceRtn.Get().(*interface{})
}
func (__ *PoolOfInt64ThenInterfaceImpl) PutInterfaceReturn(p *interface{}) {
	__.InterfaceRtn.Put(p)
}

func (__ *PoolOfInt64ThenInterfaceImpl) GetWorkOfInt64ThenInterface() *WorkOfInt64ThenInterface {
	return __.Int64Work.Get().(*WorkOfInt64ThenInterface)
}
func (__ *PoolOfInt64ThenInterfaceImpl) PutWorkOfInt64ThenInterface(p *WorkOfInt64ThenInterface) {
	__.Int64Work.Put(p)
}
func (__ *PoolOfInt64ThenInterfaceImpl) GetReturnOfInterface() *ReturnOfInterface {
	return __.InterfaceReturn.Get().(*ReturnOfInterface)
}
func (__ *PoolOfInt64ThenInterfaceImpl) PutReturnOfInterface(p *ReturnOfInterface) {
	__.InterfaceReturn.Put(p)
}

func (__ *PoolOfInt64ThenInterfaceImpl) GetChReturnOfInterface() chan *ReturnOfInterface {
	return __.ChReturnOfInterface.Get().(chan *ReturnOfInterface)
}
func (__ *PoolOfInt64ThenInterfaceImpl) PutChReturnOfInterface(p chan *ReturnOfInterface) {
	__.ChReturnOfInterface.Put(p)
}

func NewPoolOfInt64ThenInterfaceImpl() *PoolOfInt64ThenInterfaceImpl {
	return &PoolOfInt64ThenInterfaceImpl{
		Int64Arg: sync.Pool{
			New: func() interface{} {
				return new(int64)
			},
		},
		Int64Work: sync.Pool{
			New: func() interface{} {
				return new(WorkOfInt64ThenInterface)
			},
		},
		InterfaceRtn: sync.Pool{
			New: func() interface{} {
				return new(interface{})
			},
		},
		InterfaceReturn: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfInterface)
			},
		},
		ChReturnOfInterface: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfInterface, 1)
			},
		},
	}
}

type ApiDecouplerOfInt64ThenInterface struct {
	pool PoolOfInt64ThenInterface
}

func NewApiDecouplerOfInt64ThenInterface() *ApiDecouplerOfInt64ThenInterface {
	return &ApiDecouplerOfInt64ThenInterface{
		pool: NewPoolOfInt64ThenInterfaceImpl(),
	}
}

func (__ *ApiDecouplerOfInt64ThenInterface) ReturnError(rtn_ch chan<- *ReturnOfInterface, err error) {
	rtn := __.pool.GetReturnOfInterface()
	var other interface{}
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfInt64ThenInterface) HandleOfInt64ThenInterface(ctx context.Context, req *WorkOfInt64ThenInterface, h func(ctx context.Context, arg int64) (interface{}, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfInterface()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfInt64ThenInterface) DoOfInt64ThenInterface(ctx context.Context, worker WorkerOfPushInt64ThenInterface, arg int64) (interface{}, error) {
	// ch := make(chan *ReturnOfInterface, 1)
	ch := __.pool.GetChReturnOfInterface()
	defer __.pool.PutChReturnOfInterface(ch)

	req := __.pool.GetWorkOfInt64ThenInterface()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfInt64ThenInterface(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfInterface(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfInt64ThenInterface = func(ctx context.Context, arg int64) (interface{}, error)

type WorkerOfInt64ThenInterface struct {
	api_syncer *ApiDecouplerOfInt64ThenInterface
	handler    WorkHandlerOfInt64ThenInterface

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfInt64ThenInterface
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfInt64ThenInterface(ctx context.Context, h WorkHandlerOfInt64ThenInterface, n int) *WorkerOfInt64ThenInterface {
	__ := &WorkerOfInt64ThenInterface{
		api_syncer: NewApiDecouplerOfInt64ThenInterface(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfInt64ThenInterface, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfInt64ThenInterface{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfInt64ThenInterface(req.Context, req.WorkOfInt64ThenInterface, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfInt64ThenInterface) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfInt64ThenInterface) Push(ctx context.Context, req *WorkOfInt64ThenInterface) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfInt64ThenInterface)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfInt64ThenInterface = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfInt64ThenInterface) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfInt64ThenInterface) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfInt64ThenInterface) Call(ctx context.Context, arg int64) (interface{}, error) {
	return __.api_syncer.DoOfInt64ThenInterface(ctx, __, arg)
}

type PoolOfInt64ThenStruct interface {
	GetInt64Arg() *int64
	PutInt64Arg(*int64)
	GetStructReturn() *struct{}
	PutStructReturn(*struct{})

	GetWorkOfInt64ThenStruct() *WorkOfInt64ThenStruct
	GetReturnOfStruct() *ReturnOfStruct
	PutWorkOfInt64ThenStruct(*WorkOfInt64ThenStruct)
	PutReturnOfStruct(*ReturnOfStruct)

	GetChReturnOfStruct() chan *ReturnOfStruct
	PutChReturnOfStruct(chan *ReturnOfStruct)
}

type PoolOfInt64ThenStructImpl struct {
	Int64Arg         sync.Pool
	StructRtn        sync.Pool
	Int64Work        sync.Pool
	StructReturn     sync.Pool
	ChReturnOfStruct sync.Pool
}

func (__ *PoolOfInt64ThenStructImpl) GetInt64Arg() *int64 {
	return __.Int64Arg.Get().(*int64)
}
func (__ *PoolOfInt64ThenStructImpl) PutInt64Arg(p *int64) {
	__.Int64Arg.Put(p)
}
func (__ *PoolOfInt64ThenStructImpl) GetStructReturn() *struct{} {
	return __.StructRtn.Get().(*struct{})
}
func (__ *PoolOfInt64ThenStructImpl) PutStructReturn(p *struct{}) {
	__.StructRtn.Put(p)
}

func (__ *PoolOfInt64ThenStructImpl) GetWorkOfInt64ThenStruct() *WorkOfInt64ThenStruct {
	return __.Int64Work.Get().(*WorkOfInt64ThenStruct)
}
func (__ *PoolOfInt64ThenStructImpl) PutWorkOfInt64ThenStruct(p *WorkOfInt64ThenStruct) {
	__.Int64Work.Put(p)
}
func (__ *PoolOfInt64ThenStructImpl) GetReturnOfStruct() *ReturnOfStruct {
	return __.StructReturn.Get().(*ReturnOfStruct)
}
func (__ *PoolOfInt64ThenStructImpl) PutReturnOfStruct(p *ReturnOfStruct) {
	__.StructReturn.Put(p)
}

func (__ *PoolOfInt64ThenStructImpl) GetChReturnOfStruct() chan *ReturnOfStruct {
	return __.ChReturnOfStruct.Get().(chan *ReturnOfStruct)
}
func (__ *PoolOfInt64ThenStructImpl) PutChReturnOfStruct(p chan *ReturnOfStruct) {
	__.ChReturnOfStruct.Put(p)
}

func NewPoolOfInt64ThenStructImpl() *PoolOfInt64ThenStructImpl {
	return &PoolOfInt64ThenStructImpl{
		Int64Arg: sync.Pool{
			New: func() interface{} {
				return new(int64)
			},
		},
		Int64Work: sync.Pool{
			New: func() interface{} {
				return new(WorkOfInt64ThenStruct)
			},
		},
		StructRtn: sync.Pool{
			New: func() interface{} {
				return new(struct{})
			},
		},
		StructReturn: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfStruct)
			},
		},
		ChReturnOfStruct: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfStruct, 1)
			},
		},
	}
}

type ApiDecouplerOfInt64ThenStruct struct {
	pool PoolOfInt64ThenStruct
}

func NewApiDecouplerOfInt64ThenStruct() *ApiDecouplerOfInt64ThenStruct {
	return &ApiDecouplerOfInt64ThenStruct{
		pool: NewPoolOfInt64ThenStructImpl(),
	}
}

func (__ *ApiDecouplerOfInt64ThenStruct) ReturnError(rtn_ch chan<- *ReturnOfStruct, err error) {
	rtn := __.pool.GetReturnOfStruct()
	var other struct{}
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfInt64ThenStruct) HandleOfInt64ThenStruct(ctx context.Context, req *WorkOfInt64ThenStruct, h func(ctx context.Context, arg int64) (struct{}, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfStruct()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfInt64ThenStruct) DoOfInt64ThenStruct(ctx context.Context, worker WorkerOfPushInt64ThenStruct, arg int64) (struct{}, error) {
	// ch := make(chan *ReturnOfStruct, 1)
	ch := __.pool.GetChReturnOfStruct()
	defer __.pool.PutChReturnOfStruct(ch)

	req := __.pool.GetWorkOfInt64ThenStruct()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfInt64ThenStruct(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfStruct(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfInt64ThenStruct = func(ctx context.Context, arg int64) (struct{}, error)

type WorkerOfInt64ThenStruct struct {
	api_syncer *ApiDecouplerOfInt64ThenStruct
	handler    WorkHandlerOfInt64ThenStruct

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfInt64ThenStruct
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfInt64ThenStruct(ctx context.Context, h WorkHandlerOfInt64ThenStruct, n int) *WorkerOfInt64ThenStruct {
	__ := &WorkerOfInt64ThenStruct{
		api_syncer: NewApiDecouplerOfInt64ThenStruct(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfInt64ThenStruct, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfInt64ThenStruct{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfInt64ThenStruct(req.Context, req.WorkOfInt64ThenStruct, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfInt64ThenStruct) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfInt64ThenStruct) Push(ctx context.Context, req *WorkOfInt64ThenStruct) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfInt64ThenStruct)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfInt64ThenStruct = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfInt64ThenStruct) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfInt64ThenStruct) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfInt64ThenStruct) Call(ctx context.Context, arg int64) (struct{}, error) {
	return __.api_syncer.DoOfInt64ThenStruct(ctx, __, arg)
}

type PoolOfInt8ThenBool interface {
	GetInt8Arg() *int8
	PutInt8Arg(*int8)
	GetBoolReturn() *bool
	PutBoolReturn(*bool)

	GetWorkOfInt8ThenBool() *WorkOfInt8ThenBool
	GetReturnOfBool() *ReturnOfBool
	PutWorkOfInt8ThenBool(*WorkOfInt8ThenBool)
	PutReturnOfBool(*ReturnOfBool)

	GetChReturnOfBool() chan *ReturnOfBool
	PutChReturnOfBool(chan *ReturnOfBool)
}

type PoolOfInt8ThenBoolImpl struct {
	Int8Arg        sync.Pool
	BoolRtn        sync.Pool
	Int8Work       sync.Pool
	BoolReturn     sync.Pool
	ChReturnOfBool sync.Pool
}

func (__ *PoolOfInt8ThenBoolImpl) GetInt8Arg() *int8 {
	return __.Int8Arg.Get().(*int8)
}
func (__ *PoolOfInt8ThenBoolImpl) PutInt8Arg(p *int8) {
	__.Int8Arg.Put(p)
}
func (__ *PoolOfInt8ThenBoolImpl) GetBoolReturn() *bool {
	return __.BoolRtn.Get().(*bool)
}
func (__ *PoolOfInt8ThenBoolImpl) PutBoolReturn(p *bool) {
	__.BoolRtn.Put(p)
}

func (__ *PoolOfInt8ThenBoolImpl) GetWorkOfInt8ThenBool() *WorkOfInt8ThenBool {
	return __.Int8Work.Get().(*WorkOfInt8ThenBool)
}
func (__ *PoolOfInt8ThenBoolImpl) PutWorkOfInt8ThenBool(p *WorkOfInt8ThenBool) {
	__.Int8Work.Put(p)
}
func (__ *PoolOfInt8ThenBoolImpl) GetReturnOfBool() *ReturnOfBool {
	return __.BoolReturn.Get().(*ReturnOfBool)
}
func (__ *PoolOfInt8ThenBoolImpl) PutReturnOfBool(p *ReturnOfBool) {
	__.BoolReturn.Put(p)
}

func (__ *PoolOfInt8ThenBoolImpl) GetChReturnOfBool() chan *ReturnOfBool {
	return __.ChReturnOfBool.Get().(chan *ReturnOfBool)
}
func (__ *PoolOfInt8ThenBoolImpl) PutChReturnOfBool(p chan *ReturnOfBool) {
	__.ChReturnOfBool.Put(p)
}

func NewPoolOfInt8ThenBoolImpl() *PoolOfInt8ThenBoolImpl {
	return &PoolOfInt8ThenBoolImpl{
		Int8Arg: sync.Pool{
			New: func() interface{} {
				return new(int8)
			},
		},
		Int8Work: sync.Pool{
			New: func() interface{} {
				return new(WorkOfInt8ThenBool)
			},
		},
		BoolRtn: sync.Pool{
			New: func() interface{} {
				return new(bool)
			},
		},
		BoolReturn: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfBool)
			},
		},
		ChReturnOfBool: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfBool, 1)
			},
		},
	}
}

type ApiDecouplerOfInt8ThenBool struct {
	pool PoolOfInt8ThenBool
}

func NewApiDecouplerOfInt8ThenBool() *ApiDecouplerOfInt8ThenBool {
	return &ApiDecouplerOfInt8ThenBool{
		pool: NewPoolOfInt8ThenBoolImpl(),
	}
}

func (__ *ApiDecouplerOfInt8ThenBool) ReturnError(rtn_ch chan<- *ReturnOfBool, err error) {
	rtn := __.pool.GetReturnOfBool()
	var other bool
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfInt8ThenBool) HandleOfInt8ThenBool(ctx context.Context, req *WorkOfInt8ThenBool, h func(ctx context.Context, arg int8) (bool, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfBool()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfInt8ThenBool) DoOfInt8ThenBool(ctx context.Context, worker WorkerOfPushInt8ThenBool, arg int8) (bool, error) {
	// ch := make(chan *ReturnOfBool, 1)
	ch := __.pool.GetChReturnOfBool()
	defer __.pool.PutChReturnOfBool(ch)

	req := __.pool.GetWorkOfInt8ThenBool()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfInt8ThenBool(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfBool(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfInt8ThenBool = func(ctx context.Context, arg int8) (bool, error)

type WorkerOfInt8ThenBool struct {
	api_syncer *ApiDecouplerOfInt8ThenBool
	handler    WorkHandlerOfInt8ThenBool

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfInt8ThenBool
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfInt8ThenBool(ctx context.Context, h WorkHandlerOfInt8ThenBool, n int) *WorkerOfInt8ThenBool {
	__ := &WorkerOfInt8ThenBool{
		api_syncer: NewApiDecouplerOfInt8ThenBool(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfInt8ThenBool, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfInt8ThenBool{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfInt8ThenBool(req.Context, req.WorkOfInt8ThenBool, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfInt8ThenBool) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfInt8ThenBool) Push(ctx context.Context, req *WorkOfInt8ThenBool) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfInt8ThenBool)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfInt8ThenBool = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfInt8ThenBool) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfInt8ThenBool) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfInt8ThenBool) Call(ctx context.Context, arg int8) (bool, error) {
	return __.api_syncer.DoOfInt8ThenBool(ctx, __, arg)
}

type PoolOfInt8ThenByte interface {
	GetInt8Arg() *int8
	PutInt8Arg(*int8)
	GetByteReturn() *byte
	PutByteReturn(*byte)

	GetWorkOfInt8ThenByte() *WorkOfInt8ThenByte
	GetReturnOfByte() *ReturnOfByte
	PutWorkOfInt8ThenByte(*WorkOfInt8ThenByte)
	PutReturnOfByte(*ReturnOfByte)

	GetChReturnOfByte() chan *ReturnOfByte
	PutChReturnOfByte(chan *ReturnOfByte)
}

type PoolOfInt8ThenByteImpl struct {
	Int8Arg        sync.Pool
	ByteRtn        sync.Pool
	Int8Work       sync.Pool
	ByteReturn     sync.Pool
	ChReturnOfByte sync.Pool
}

func (__ *PoolOfInt8ThenByteImpl) GetInt8Arg() *int8 {
	return __.Int8Arg.Get().(*int8)
}
func (__ *PoolOfInt8ThenByteImpl) PutInt8Arg(p *int8) {
	__.Int8Arg.Put(p)
}
func (__ *PoolOfInt8ThenByteImpl) GetByteReturn() *byte {
	return __.ByteRtn.Get().(*byte)
}
func (__ *PoolOfInt8ThenByteImpl) PutByteReturn(p *byte) {
	__.ByteRtn.Put(p)
}

func (__ *PoolOfInt8ThenByteImpl) GetWorkOfInt8ThenByte() *WorkOfInt8ThenByte {
	return __.Int8Work.Get().(*WorkOfInt8ThenByte)
}
func (__ *PoolOfInt8ThenByteImpl) PutWorkOfInt8ThenByte(p *WorkOfInt8ThenByte) {
	__.Int8Work.Put(p)
}
func (__ *PoolOfInt8ThenByteImpl) GetReturnOfByte() *ReturnOfByte {
	return __.ByteReturn.Get().(*ReturnOfByte)
}
func (__ *PoolOfInt8ThenByteImpl) PutReturnOfByte(p *ReturnOfByte) {
	__.ByteReturn.Put(p)
}

func (__ *PoolOfInt8ThenByteImpl) GetChReturnOfByte() chan *ReturnOfByte {
	return __.ChReturnOfByte.Get().(chan *ReturnOfByte)
}
func (__ *PoolOfInt8ThenByteImpl) PutChReturnOfByte(p chan *ReturnOfByte) {
	__.ChReturnOfByte.Put(p)
}

func NewPoolOfInt8ThenByteImpl() *PoolOfInt8ThenByteImpl {
	return &PoolOfInt8ThenByteImpl{
		Int8Arg: sync.Pool{
			New: func() interface{} {
				return new(int8)
			},
		},
		Int8Work: sync.Pool{
			New: func() interface{} {
				return new(WorkOfInt8ThenByte)
			},
		},
		ByteRtn: sync.Pool{
			New: func() interface{} {
				return new(byte)
			},
		},
		ByteReturn: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfByte)
			},
		},
		ChReturnOfByte: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfByte, 1)
			},
		},
	}
}

type ApiDecouplerOfInt8ThenByte struct {
	pool PoolOfInt8ThenByte
}

func NewApiDecouplerOfInt8ThenByte() *ApiDecouplerOfInt8ThenByte {
	return &ApiDecouplerOfInt8ThenByte{
		pool: NewPoolOfInt8ThenByteImpl(),
	}
}

func (__ *ApiDecouplerOfInt8ThenByte) ReturnError(rtn_ch chan<- *ReturnOfByte, err error) {
	rtn := __.pool.GetReturnOfByte()
	var other byte
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfInt8ThenByte) HandleOfInt8ThenByte(ctx context.Context, req *WorkOfInt8ThenByte, h func(ctx context.Context, arg int8) (byte, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfByte()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfInt8ThenByte) DoOfInt8ThenByte(ctx context.Context, worker WorkerOfPushInt8ThenByte, arg int8) (byte, error) {
	// ch := make(chan *ReturnOfByte, 1)
	ch := __.pool.GetChReturnOfByte()
	defer __.pool.PutChReturnOfByte(ch)

	req := __.pool.GetWorkOfInt8ThenByte()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfInt8ThenByte(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfByte(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfInt8ThenByte = func(ctx context.Context, arg int8) (byte, error)

type WorkerOfInt8ThenByte struct {
	api_syncer *ApiDecouplerOfInt8ThenByte
	handler    WorkHandlerOfInt8ThenByte

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfInt8ThenByte
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfInt8ThenByte(ctx context.Context, h WorkHandlerOfInt8ThenByte, n int) *WorkerOfInt8ThenByte {
	__ := &WorkerOfInt8ThenByte{
		api_syncer: NewApiDecouplerOfInt8ThenByte(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfInt8ThenByte, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfInt8ThenByte{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfInt8ThenByte(req.Context, req.WorkOfInt8ThenByte, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfInt8ThenByte) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfInt8ThenByte) Push(ctx context.Context, req *WorkOfInt8ThenByte) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfInt8ThenByte)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfInt8ThenByte = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfInt8ThenByte) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfInt8ThenByte) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfInt8ThenByte) Call(ctx context.Context, arg int8) (byte, error) {
	return __.api_syncer.DoOfInt8ThenByte(ctx, __, arg)
}

type PoolOfInt8ThenComplex128 interface {
	GetInt8Arg() *int8
	PutInt8Arg(*int8)
	GetComplex128Return() *complex128
	PutComplex128Return(*complex128)

	GetWorkOfInt8ThenComplex128() *WorkOfInt8ThenComplex128
	GetReturnOfComplex128() *ReturnOfComplex128
	PutWorkOfInt8ThenComplex128(*WorkOfInt8ThenComplex128)
	PutReturnOfComplex128(*ReturnOfComplex128)

	GetChReturnOfComplex128() chan *ReturnOfComplex128
	PutChReturnOfComplex128(chan *ReturnOfComplex128)
}

type PoolOfInt8ThenComplex128Impl struct {
	Int8Arg              sync.Pool
	Complex128Rtn        sync.Pool
	Int8Work             sync.Pool
	Complex128Return     sync.Pool
	ChReturnOfComplex128 sync.Pool
}

func (__ *PoolOfInt8ThenComplex128Impl) GetInt8Arg() *int8 {
	return __.Int8Arg.Get().(*int8)
}
func (__ *PoolOfInt8ThenComplex128Impl) PutInt8Arg(p *int8) {
	__.Int8Arg.Put(p)
}
func (__ *PoolOfInt8ThenComplex128Impl) GetComplex128Return() *complex128 {
	return __.Complex128Rtn.Get().(*complex128)
}
func (__ *PoolOfInt8ThenComplex128Impl) PutComplex128Return(p *complex128) {
	__.Complex128Rtn.Put(p)
}

func (__ *PoolOfInt8ThenComplex128Impl) GetWorkOfInt8ThenComplex128() *WorkOfInt8ThenComplex128 {
	return __.Int8Work.Get().(*WorkOfInt8ThenComplex128)
}
func (__ *PoolOfInt8ThenComplex128Impl) PutWorkOfInt8ThenComplex128(p *WorkOfInt8ThenComplex128) {
	__.Int8Work.Put(p)
}
func (__ *PoolOfInt8ThenComplex128Impl) GetReturnOfComplex128() *ReturnOfComplex128 {
	return __.Complex128Return.Get().(*ReturnOfComplex128)
}
func (__ *PoolOfInt8ThenComplex128Impl) PutReturnOfComplex128(p *ReturnOfComplex128) {
	__.Complex128Return.Put(p)
}

func (__ *PoolOfInt8ThenComplex128Impl) GetChReturnOfComplex128() chan *ReturnOfComplex128 {
	return __.ChReturnOfComplex128.Get().(chan *ReturnOfComplex128)
}
func (__ *PoolOfInt8ThenComplex128Impl) PutChReturnOfComplex128(p chan *ReturnOfComplex128) {
	__.ChReturnOfComplex128.Put(p)
}

func NewPoolOfInt8ThenComplex128Impl() *PoolOfInt8ThenComplex128Impl {
	return &PoolOfInt8ThenComplex128Impl{
		Int8Arg: sync.Pool{
			New: func() interface{} {
				return new(int8)
			},
		},
		Int8Work: sync.Pool{
			New: func() interface{} {
				return new(WorkOfInt8ThenComplex128)
			},
		},
		Complex128Rtn: sync.Pool{
			New: func() interface{} {
				return new(complex128)
			},
		},
		Complex128Return: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfComplex128)
			},
		},
		ChReturnOfComplex128: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfComplex128, 1)
			},
		},
	}
}

type ApiDecouplerOfInt8ThenComplex128 struct {
	pool PoolOfInt8ThenComplex128
}

func NewApiDecouplerOfInt8ThenComplex128() *ApiDecouplerOfInt8ThenComplex128 {
	return &ApiDecouplerOfInt8ThenComplex128{
		pool: NewPoolOfInt8ThenComplex128Impl(),
	}
}

func (__ *ApiDecouplerOfInt8ThenComplex128) ReturnError(rtn_ch chan<- *ReturnOfComplex128, err error) {
	rtn := __.pool.GetReturnOfComplex128()
	var other complex128
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfInt8ThenComplex128) HandleOfInt8ThenComplex128(ctx context.Context, req *WorkOfInt8ThenComplex128, h func(ctx context.Context, arg int8) (complex128, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfComplex128()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfInt8ThenComplex128) DoOfInt8ThenComplex128(ctx context.Context, worker WorkerOfPushInt8ThenComplex128, arg int8) (complex128, error) {
	// ch := make(chan *ReturnOfComplex128, 1)
	ch := __.pool.GetChReturnOfComplex128()
	defer __.pool.PutChReturnOfComplex128(ch)

	req := __.pool.GetWorkOfInt8ThenComplex128()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfInt8ThenComplex128(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfComplex128(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfInt8ThenComplex128 = func(ctx context.Context, arg int8) (complex128, error)

type WorkerOfInt8ThenComplex128 struct {
	api_syncer *ApiDecouplerOfInt8ThenComplex128
	handler    WorkHandlerOfInt8ThenComplex128

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfInt8ThenComplex128
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfInt8ThenComplex128(ctx context.Context, h WorkHandlerOfInt8ThenComplex128, n int) *WorkerOfInt8ThenComplex128 {
	__ := &WorkerOfInt8ThenComplex128{
		api_syncer: NewApiDecouplerOfInt8ThenComplex128(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfInt8ThenComplex128, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfInt8ThenComplex128{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfInt8ThenComplex128(req.Context, req.WorkOfInt8ThenComplex128, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfInt8ThenComplex128) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfInt8ThenComplex128) Push(ctx context.Context, req *WorkOfInt8ThenComplex128) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfInt8ThenComplex128)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfInt8ThenComplex128 = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfInt8ThenComplex128) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfInt8ThenComplex128) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfInt8ThenComplex128) Call(ctx context.Context, arg int8) (complex128, error) {
	return __.api_syncer.DoOfInt8ThenComplex128(ctx, __, arg)
}

type PoolOfInt8ThenComplex64 interface {
	GetInt8Arg() *int8
	PutInt8Arg(*int8)
	GetComplex64Return() *complex64
	PutComplex64Return(*complex64)

	GetWorkOfInt8ThenComplex64() *WorkOfInt8ThenComplex64
	GetReturnOfComplex64() *ReturnOfComplex64
	PutWorkOfInt8ThenComplex64(*WorkOfInt8ThenComplex64)
	PutReturnOfComplex64(*ReturnOfComplex64)

	GetChReturnOfComplex64() chan *ReturnOfComplex64
	PutChReturnOfComplex64(chan *ReturnOfComplex64)
}

type PoolOfInt8ThenComplex64Impl struct {
	Int8Arg             sync.Pool
	Complex64Rtn        sync.Pool
	Int8Work            sync.Pool
	Complex64Return     sync.Pool
	ChReturnOfComplex64 sync.Pool
}

func (__ *PoolOfInt8ThenComplex64Impl) GetInt8Arg() *int8 {
	return __.Int8Arg.Get().(*int8)
}
func (__ *PoolOfInt8ThenComplex64Impl) PutInt8Arg(p *int8) {
	__.Int8Arg.Put(p)
}
func (__ *PoolOfInt8ThenComplex64Impl) GetComplex64Return() *complex64 {
	return __.Complex64Rtn.Get().(*complex64)
}
func (__ *PoolOfInt8ThenComplex64Impl) PutComplex64Return(p *complex64) {
	__.Complex64Rtn.Put(p)
}

func (__ *PoolOfInt8ThenComplex64Impl) GetWorkOfInt8ThenComplex64() *WorkOfInt8ThenComplex64 {
	return __.Int8Work.Get().(*WorkOfInt8ThenComplex64)
}
func (__ *PoolOfInt8ThenComplex64Impl) PutWorkOfInt8ThenComplex64(p *WorkOfInt8ThenComplex64) {
	__.Int8Work.Put(p)
}
func (__ *PoolOfInt8ThenComplex64Impl) GetReturnOfComplex64() *ReturnOfComplex64 {
	return __.Complex64Return.Get().(*ReturnOfComplex64)
}
func (__ *PoolOfInt8ThenComplex64Impl) PutReturnOfComplex64(p *ReturnOfComplex64) {
	__.Complex64Return.Put(p)
}

func (__ *PoolOfInt8ThenComplex64Impl) GetChReturnOfComplex64() chan *ReturnOfComplex64 {
	return __.ChReturnOfComplex64.Get().(chan *ReturnOfComplex64)
}
func (__ *PoolOfInt8ThenComplex64Impl) PutChReturnOfComplex64(p chan *ReturnOfComplex64) {
	__.ChReturnOfComplex64.Put(p)
}

func NewPoolOfInt8ThenComplex64Impl() *PoolOfInt8ThenComplex64Impl {
	return &PoolOfInt8ThenComplex64Impl{
		Int8Arg: sync.Pool{
			New: func() interface{} {
				return new(int8)
			},
		},
		Int8Work: sync.Pool{
			New: func() interface{} {
				return new(WorkOfInt8ThenComplex64)
			},
		},
		Complex64Rtn: sync.Pool{
			New: func() interface{} {
				return new(complex64)
			},
		},
		Complex64Return: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfComplex64)
			},
		},
		ChReturnOfComplex64: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfComplex64, 1)
			},
		},
	}
}

type ApiDecouplerOfInt8ThenComplex64 struct {
	pool PoolOfInt8ThenComplex64
}

func NewApiDecouplerOfInt8ThenComplex64() *ApiDecouplerOfInt8ThenComplex64 {
	return &ApiDecouplerOfInt8ThenComplex64{
		pool: NewPoolOfInt8ThenComplex64Impl(),
	}
}

func (__ *ApiDecouplerOfInt8ThenComplex64) ReturnError(rtn_ch chan<- *ReturnOfComplex64, err error) {
	rtn := __.pool.GetReturnOfComplex64()
	var other complex64
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfInt8ThenComplex64) HandleOfInt8ThenComplex64(ctx context.Context, req *WorkOfInt8ThenComplex64, h func(ctx context.Context, arg int8) (complex64, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfComplex64()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfInt8ThenComplex64) DoOfInt8ThenComplex64(ctx context.Context, worker WorkerOfPushInt8ThenComplex64, arg int8) (complex64, error) {
	// ch := make(chan *ReturnOfComplex64, 1)
	ch := __.pool.GetChReturnOfComplex64()
	defer __.pool.PutChReturnOfComplex64(ch)

	req := __.pool.GetWorkOfInt8ThenComplex64()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfInt8ThenComplex64(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfComplex64(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfInt8ThenComplex64 = func(ctx context.Context, arg int8) (complex64, error)

type WorkerOfInt8ThenComplex64 struct {
	api_syncer *ApiDecouplerOfInt8ThenComplex64
	handler    WorkHandlerOfInt8ThenComplex64

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfInt8ThenComplex64
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfInt8ThenComplex64(ctx context.Context, h WorkHandlerOfInt8ThenComplex64, n int) *WorkerOfInt8ThenComplex64 {
	__ := &WorkerOfInt8ThenComplex64{
		api_syncer: NewApiDecouplerOfInt8ThenComplex64(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfInt8ThenComplex64, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfInt8ThenComplex64{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfInt8ThenComplex64(req.Context, req.WorkOfInt8ThenComplex64, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfInt8ThenComplex64) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfInt8ThenComplex64) Push(ctx context.Context, req *WorkOfInt8ThenComplex64) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfInt8ThenComplex64)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfInt8ThenComplex64 = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfInt8ThenComplex64) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfInt8ThenComplex64) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfInt8ThenComplex64) Call(ctx context.Context, arg int8) (complex64, error) {
	return __.api_syncer.DoOfInt8ThenComplex64(ctx, __, arg)
}

type PoolOfInt8ThenError interface {
	GetInt8Arg() *int8
	PutInt8Arg(*int8)
	GetErrorReturn() *error
	PutErrorReturn(*error)

	GetWorkOfInt8ThenError() *WorkOfInt8ThenError
	GetReturnOfError() *ReturnOfError
	PutWorkOfInt8ThenError(*WorkOfInt8ThenError)
	PutReturnOfError(*ReturnOfError)

	GetChReturnOfError() chan *ReturnOfError
	PutChReturnOfError(chan *ReturnOfError)
}

type PoolOfInt8ThenErrorImpl struct {
	Int8Arg         sync.Pool
	ErrorRtn        sync.Pool
	Int8Work        sync.Pool
	ErrorReturn     sync.Pool
	ChReturnOfError sync.Pool
}

func (__ *PoolOfInt8ThenErrorImpl) GetInt8Arg() *int8 {
	return __.Int8Arg.Get().(*int8)
}
func (__ *PoolOfInt8ThenErrorImpl) PutInt8Arg(p *int8) {
	__.Int8Arg.Put(p)
}
func (__ *PoolOfInt8ThenErrorImpl) GetErrorReturn() *error {
	return __.ErrorRtn.Get().(*error)
}
func (__ *PoolOfInt8ThenErrorImpl) PutErrorReturn(p *error) {
	__.ErrorRtn.Put(p)
}

func (__ *PoolOfInt8ThenErrorImpl) GetWorkOfInt8ThenError() *WorkOfInt8ThenError {
	return __.Int8Work.Get().(*WorkOfInt8ThenError)
}
func (__ *PoolOfInt8ThenErrorImpl) PutWorkOfInt8ThenError(p *WorkOfInt8ThenError) {
	__.Int8Work.Put(p)
}
func (__ *PoolOfInt8ThenErrorImpl) GetReturnOfError() *ReturnOfError {
	return __.ErrorReturn.Get().(*ReturnOfError)
}
func (__ *PoolOfInt8ThenErrorImpl) PutReturnOfError(p *ReturnOfError) {
	__.ErrorReturn.Put(p)
}

func (__ *PoolOfInt8ThenErrorImpl) GetChReturnOfError() chan *ReturnOfError {
	return __.ChReturnOfError.Get().(chan *ReturnOfError)
}
func (__ *PoolOfInt8ThenErrorImpl) PutChReturnOfError(p chan *ReturnOfError) {
	__.ChReturnOfError.Put(p)
}

func NewPoolOfInt8ThenErrorImpl() *PoolOfInt8ThenErrorImpl {
	return &PoolOfInt8ThenErrorImpl{
		Int8Arg: sync.Pool{
			New: func() interface{} {
				return new(int8)
			},
		},
		Int8Work: sync.Pool{
			New: func() interface{} {
				return new(WorkOfInt8ThenError)
			},
		},
		ErrorRtn: sync.Pool{
			New: func() interface{} {
				return new(error)
			},
		},
		ErrorReturn: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfError)
			},
		},
		ChReturnOfError: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfError, 1)
			},
		},
	}
}

type ApiDecouplerOfInt8ThenError struct {
	pool PoolOfInt8ThenError
}

func NewApiDecouplerOfInt8ThenError() *ApiDecouplerOfInt8ThenError {
	return &ApiDecouplerOfInt8ThenError{
		pool: NewPoolOfInt8ThenErrorImpl(),
	}
}

func (__ *ApiDecouplerOfInt8ThenError) ReturnError(rtn_ch chan<- *ReturnOfError, err error) {
	rtn := __.pool.GetReturnOfError()
	var other error
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfInt8ThenError) HandleOfInt8ThenError(ctx context.Context, req *WorkOfInt8ThenError, h func(ctx context.Context, arg int8) (error, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfError()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfInt8ThenError) DoOfInt8ThenError(ctx context.Context, worker WorkerOfPushInt8ThenError, arg int8) (error, error) {
	// ch := make(chan *ReturnOfError, 1)
	ch := __.pool.GetChReturnOfError()
	defer __.pool.PutChReturnOfError(ch)

	req := __.pool.GetWorkOfInt8ThenError()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfInt8ThenError(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfError(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfInt8ThenError = func(ctx context.Context, arg int8) (error, error)

type WorkerOfInt8ThenError struct {
	api_syncer *ApiDecouplerOfInt8ThenError
	handler    WorkHandlerOfInt8ThenError

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfInt8ThenError
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfInt8ThenError(ctx context.Context, h WorkHandlerOfInt8ThenError, n int) *WorkerOfInt8ThenError {
	__ := &WorkerOfInt8ThenError{
		api_syncer: NewApiDecouplerOfInt8ThenError(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfInt8ThenError, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfInt8ThenError{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfInt8ThenError(req.Context, req.WorkOfInt8ThenError, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfInt8ThenError) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfInt8ThenError) Push(ctx context.Context, req *WorkOfInt8ThenError) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfInt8ThenError)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfInt8ThenError = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfInt8ThenError) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfInt8ThenError) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfInt8ThenError) Call(ctx context.Context, arg int8) (error, error) {
	return __.api_syncer.DoOfInt8ThenError(ctx, __, arg)
}

type PoolOfInt8ThenFloat32 interface {
	GetInt8Arg() *int8
	PutInt8Arg(*int8)
	GetFloat32Return() *float32
	PutFloat32Return(*float32)

	GetWorkOfInt8ThenFloat32() *WorkOfInt8ThenFloat32
	GetReturnOfFloat32() *ReturnOfFloat32
	PutWorkOfInt8ThenFloat32(*WorkOfInt8ThenFloat32)
	PutReturnOfFloat32(*ReturnOfFloat32)

	GetChReturnOfFloat32() chan *ReturnOfFloat32
	PutChReturnOfFloat32(chan *ReturnOfFloat32)
}

type PoolOfInt8ThenFloat32Impl struct {
	Int8Arg           sync.Pool
	Float32Rtn        sync.Pool
	Int8Work          sync.Pool
	Float32Return     sync.Pool
	ChReturnOfFloat32 sync.Pool
}

func (__ *PoolOfInt8ThenFloat32Impl) GetInt8Arg() *int8 {
	return __.Int8Arg.Get().(*int8)
}
func (__ *PoolOfInt8ThenFloat32Impl) PutInt8Arg(p *int8) {
	__.Int8Arg.Put(p)
}
func (__ *PoolOfInt8ThenFloat32Impl) GetFloat32Return() *float32 {
	return __.Float32Rtn.Get().(*float32)
}
func (__ *PoolOfInt8ThenFloat32Impl) PutFloat32Return(p *float32) {
	__.Float32Rtn.Put(p)
}

func (__ *PoolOfInt8ThenFloat32Impl) GetWorkOfInt8ThenFloat32() *WorkOfInt8ThenFloat32 {
	return __.Int8Work.Get().(*WorkOfInt8ThenFloat32)
}
func (__ *PoolOfInt8ThenFloat32Impl) PutWorkOfInt8ThenFloat32(p *WorkOfInt8ThenFloat32) {
	__.Int8Work.Put(p)
}
func (__ *PoolOfInt8ThenFloat32Impl) GetReturnOfFloat32() *ReturnOfFloat32 {
	return __.Float32Return.Get().(*ReturnOfFloat32)
}
func (__ *PoolOfInt8ThenFloat32Impl) PutReturnOfFloat32(p *ReturnOfFloat32) {
	__.Float32Return.Put(p)
}

func (__ *PoolOfInt8ThenFloat32Impl) GetChReturnOfFloat32() chan *ReturnOfFloat32 {
	return __.ChReturnOfFloat32.Get().(chan *ReturnOfFloat32)
}
func (__ *PoolOfInt8ThenFloat32Impl) PutChReturnOfFloat32(p chan *ReturnOfFloat32) {
	__.ChReturnOfFloat32.Put(p)
}

func NewPoolOfInt8ThenFloat32Impl() *PoolOfInt8ThenFloat32Impl {
	return &PoolOfInt8ThenFloat32Impl{
		Int8Arg: sync.Pool{
			New: func() interface{} {
				return new(int8)
			},
		},
		Int8Work: sync.Pool{
			New: func() interface{} {
				return new(WorkOfInt8ThenFloat32)
			},
		},
		Float32Rtn: sync.Pool{
			New: func() interface{} {
				return new(float32)
			},
		},
		Float32Return: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfFloat32)
			},
		},
		ChReturnOfFloat32: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfFloat32, 1)
			},
		},
	}
}

type ApiDecouplerOfInt8ThenFloat32 struct {
	pool PoolOfInt8ThenFloat32
}

func NewApiDecouplerOfInt8ThenFloat32() *ApiDecouplerOfInt8ThenFloat32 {
	return &ApiDecouplerOfInt8ThenFloat32{
		pool: NewPoolOfInt8ThenFloat32Impl(),
	}
}

func (__ *ApiDecouplerOfInt8ThenFloat32) ReturnError(rtn_ch chan<- *ReturnOfFloat32, err error) {
	rtn := __.pool.GetReturnOfFloat32()
	var other float32
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfInt8ThenFloat32) HandleOfInt8ThenFloat32(ctx context.Context, req *WorkOfInt8ThenFloat32, h func(ctx context.Context, arg int8) (float32, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfFloat32()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfInt8ThenFloat32) DoOfInt8ThenFloat32(ctx context.Context, worker WorkerOfPushInt8ThenFloat32, arg int8) (float32, error) {
	// ch := make(chan *ReturnOfFloat32, 1)
	ch := __.pool.GetChReturnOfFloat32()
	defer __.pool.PutChReturnOfFloat32(ch)

	req := __.pool.GetWorkOfInt8ThenFloat32()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfInt8ThenFloat32(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfFloat32(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfInt8ThenFloat32 = func(ctx context.Context, arg int8) (float32, error)

type WorkerOfInt8ThenFloat32 struct {
	api_syncer *ApiDecouplerOfInt8ThenFloat32
	handler    WorkHandlerOfInt8ThenFloat32

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfInt8ThenFloat32
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfInt8ThenFloat32(ctx context.Context, h WorkHandlerOfInt8ThenFloat32, n int) *WorkerOfInt8ThenFloat32 {
	__ := &WorkerOfInt8ThenFloat32{
		api_syncer: NewApiDecouplerOfInt8ThenFloat32(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfInt8ThenFloat32, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfInt8ThenFloat32{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfInt8ThenFloat32(req.Context, req.WorkOfInt8ThenFloat32, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfInt8ThenFloat32) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfInt8ThenFloat32) Push(ctx context.Context, req *WorkOfInt8ThenFloat32) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfInt8ThenFloat32)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfInt8ThenFloat32 = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfInt8ThenFloat32) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfInt8ThenFloat32) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfInt8ThenFloat32) Call(ctx context.Context, arg int8) (float32, error) {
	return __.api_syncer.DoOfInt8ThenFloat32(ctx, __, arg)
}

type PoolOfInt8ThenFloat64 interface {
	GetInt8Arg() *int8
	PutInt8Arg(*int8)
	GetFloat64Return() *float64
	PutFloat64Return(*float64)

	GetWorkOfInt8ThenFloat64() *WorkOfInt8ThenFloat64
	GetReturnOfFloat64() *ReturnOfFloat64
	PutWorkOfInt8ThenFloat64(*WorkOfInt8ThenFloat64)
	PutReturnOfFloat64(*ReturnOfFloat64)

	GetChReturnOfFloat64() chan *ReturnOfFloat64
	PutChReturnOfFloat64(chan *ReturnOfFloat64)
}

type PoolOfInt8ThenFloat64Impl struct {
	Int8Arg           sync.Pool
	Float64Rtn        sync.Pool
	Int8Work          sync.Pool
	Float64Return     sync.Pool
	ChReturnOfFloat64 sync.Pool
}

func (__ *PoolOfInt8ThenFloat64Impl) GetInt8Arg() *int8 {
	return __.Int8Arg.Get().(*int8)
}
func (__ *PoolOfInt8ThenFloat64Impl) PutInt8Arg(p *int8) {
	__.Int8Arg.Put(p)
}
func (__ *PoolOfInt8ThenFloat64Impl) GetFloat64Return() *float64 {
	return __.Float64Rtn.Get().(*float64)
}
func (__ *PoolOfInt8ThenFloat64Impl) PutFloat64Return(p *float64) {
	__.Float64Rtn.Put(p)
}

func (__ *PoolOfInt8ThenFloat64Impl) GetWorkOfInt8ThenFloat64() *WorkOfInt8ThenFloat64 {
	return __.Int8Work.Get().(*WorkOfInt8ThenFloat64)
}
func (__ *PoolOfInt8ThenFloat64Impl) PutWorkOfInt8ThenFloat64(p *WorkOfInt8ThenFloat64) {
	__.Int8Work.Put(p)
}
func (__ *PoolOfInt8ThenFloat64Impl) GetReturnOfFloat64() *ReturnOfFloat64 {
	return __.Float64Return.Get().(*ReturnOfFloat64)
}
func (__ *PoolOfInt8ThenFloat64Impl) PutReturnOfFloat64(p *ReturnOfFloat64) {
	__.Float64Return.Put(p)
}

func (__ *PoolOfInt8ThenFloat64Impl) GetChReturnOfFloat64() chan *ReturnOfFloat64 {
	return __.ChReturnOfFloat64.Get().(chan *ReturnOfFloat64)
}
func (__ *PoolOfInt8ThenFloat64Impl) PutChReturnOfFloat64(p chan *ReturnOfFloat64) {
	__.ChReturnOfFloat64.Put(p)
}

func NewPoolOfInt8ThenFloat64Impl() *PoolOfInt8ThenFloat64Impl {
	return &PoolOfInt8ThenFloat64Impl{
		Int8Arg: sync.Pool{
			New: func() interface{} {
				return new(int8)
			},
		},
		Int8Work: sync.Pool{
			New: func() interface{} {
				return new(WorkOfInt8ThenFloat64)
			},
		},
		Float64Rtn: sync.Pool{
			New: func() interface{} {
				return new(float64)
			},
		},
		Float64Return: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfFloat64)
			},
		},
		ChReturnOfFloat64: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfFloat64, 1)
			},
		},
	}
}

type ApiDecouplerOfInt8ThenFloat64 struct {
	pool PoolOfInt8ThenFloat64
}

func NewApiDecouplerOfInt8ThenFloat64() *ApiDecouplerOfInt8ThenFloat64 {
	return &ApiDecouplerOfInt8ThenFloat64{
		pool: NewPoolOfInt8ThenFloat64Impl(),
	}
}

func (__ *ApiDecouplerOfInt8ThenFloat64) ReturnError(rtn_ch chan<- *ReturnOfFloat64, err error) {
	rtn := __.pool.GetReturnOfFloat64()
	var other float64
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfInt8ThenFloat64) HandleOfInt8ThenFloat64(ctx context.Context, req *WorkOfInt8ThenFloat64, h func(ctx context.Context, arg int8) (float64, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfFloat64()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfInt8ThenFloat64) DoOfInt8ThenFloat64(ctx context.Context, worker WorkerOfPushInt8ThenFloat64, arg int8) (float64, error) {
	// ch := make(chan *ReturnOfFloat64, 1)
	ch := __.pool.GetChReturnOfFloat64()
	defer __.pool.PutChReturnOfFloat64(ch)

	req := __.pool.GetWorkOfInt8ThenFloat64()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfInt8ThenFloat64(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfFloat64(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfInt8ThenFloat64 = func(ctx context.Context, arg int8) (float64, error)

type WorkerOfInt8ThenFloat64 struct {
	api_syncer *ApiDecouplerOfInt8ThenFloat64
	handler    WorkHandlerOfInt8ThenFloat64

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfInt8ThenFloat64
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfInt8ThenFloat64(ctx context.Context, h WorkHandlerOfInt8ThenFloat64, n int) *WorkerOfInt8ThenFloat64 {
	__ := &WorkerOfInt8ThenFloat64{
		api_syncer: NewApiDecouplerOfInt8ThenFloat64(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfInt8ThenFloat64, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfInt8ThenFloat64{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfInt8ThenFloat64(req.Context, req.WorkOfInt8ThenFloat64, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfInt8ThenFloat64) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfInt8ThenFloat64) Push(ctx context.Context, req *WorkOfInt8ThenFloat64) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfInt8ThenFloat64)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfInt8ThenFloat64 = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfInt8ThenFloat64) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfInt8ThenFloat64) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfInt8ThenFloat64) Call(ctx context.Context, arg int8) (float64, error) {
	return __.api_syncer.DoOfInt8ThenFloat64(ctx, __, arg)
}

type PoolOfInt8ThenInt interface {
	GetInt8Arg() *int8
	PutInt8Arg(*int8)
	GetIntReturn() *int
	PutIntReturn(*int)

	GetWorkOfInt8ThenInt() *WorkOfInt8ThenInt
	GetReturnOfInt() *ReturnOfInt
	PutWorkOfInt8ThenInt(*WorkOfInt8ThenInt)
	PutReturnOfInt(*ReturnOfInt)

	GetChReturnOfInt() chan *ReturnOfInt
	PutChReturnOfInt(chan *ReturnOfInt)
}

type PoolOfInt8ThenIntImpl struct {
	Int8Arg       sync.Pool
	IntRtn        sync.Pool
	Int8Work      sync.Pool
	IntReturn     sync.Pool
	ChReturnOfInt sync.Pool
}

func (__ *PoolOfInt8ThenIntImpl) GetInt8Arg() *int8 {
	return __.Int8Arg.Get().(*int8)
}
func (__ *PoolOfInt8ThenIntImpl) PutInt8Arg(p *int8) {
	__.Int8Arg.Put(p)
}
func (__ *PoolOfInt8ThenIntImpl) GetIntReturn() *int {
	return __.IntRtn.Get().(*int)
}
func (__ *PoolOfInt8ThenIntImpl) PutIntReturn(p *int) {
	__.IntRtn.Put(p)
}

func (__ *PoolOfInt8ThenIntImpl) GetWorkOfInt8ThenInt() *WorkOfInt8ThenInt {
	return __.Int8Work.Get().(*WorkOfInt8ThenInt)
}
func (__ *PoolOfInt8ThenIntImpl) PutWorkOfInt8ThenInt(p *WorkOfInt8ThenInt) {
	__.Int8Work.Put(p)
}
func (__ *PoolOfInt8ThenIntImpl) GetReturnOfInt() *ReturnOfInt {
	return __.IntReturn.Get().(*ReturnOfInt)
}
func (__ *PoolOfInt8ThenIntImpl) PutReturnOfInt(p *ReturnOfInt) {
	__.IntReturn.Put(p)
}

func (__ *PoolOfInt8ThenIntImpl) GetChReturnOfInt() chan *ReturnOfInt {
	return __.ChReturnOfInt.Get().(chan *ReturnOfInt)
}
func (__ *PoolOfInt8ThenIntImpl) PutChReturnOfInt(p chan *ReturnOfInt) {
	__.ChReturnOfInt.Put(p)
}

func NewPoolOfInt8ThenIntImpl() *PoolOfInt8ThenIntImpl {
	return &PoolOfInt8ThenIntImpl{
		Int8Arg: sync.Pool{
			New: func() interface{} {
				return new(int8)
			},
		},
		Int8Work: sync.Pool{
			New: func() interface{} {
				return new(WorkOfInt8ThenInt)
			},
		},
		IntRtn: sync.Pool{
			New: func() interface{} {
				return new(int)
			},
		},
		IntReturn: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfInt)
			},
		},
		ChReturnOfInt: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfInt, 1)
			},
		},
	}
}

type ApiDecouplerOfInt8ThenInt struct {
	pool PoolOfInt8ThenInt
}

func NewApiDecouplerOfInt8ThenInt() *ApiDecouplerOfInt8ThenInt {
	return &ApiDecouplerOfInt8ThenInt{
		pool: NewPoolOfInt8ThenIntImpl(),
	}
}

func (__ *ApiDecouplerOfInt8ThenInt) ReturnError(rtn_ch chan<- *ReturnOfInt, err error) {
	rtn := __.pool.GetReturnOfInt()
	var other int
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfInt8ThenInt) HandleOfInt8ThenInt(ctx context.Context, req *WorkOfInt8ThenInt, h func(ctx context.Context, arg int8) (int, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfInt()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfInt8ThenInt) DoOfInt8ThenInt(ctx context.Context, worker WorkerOfPushInt8ThenInt, arg int8) (int, error) {
	// ch := make(chan *ReturnOfInt, 1)
	ch := __.pool.GetChReturnOfInt()
	defer __.pool.PutChReturnOfInt(ch)

	req := __.pool.GetWorkOfInt8ThenInt()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfInt8ThenInt(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfInt(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfInt8ThenInt = func(ctx context.Context, arg int8) (int, error)

type WorkerOfInt8ThenInt struct {
	api_syncer *ApiDecouplerOfInt8ThenInt
	handler    WorkHandlerOfInt8ThenInt

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfInt8ThenInt
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfInt8ThenInt(ctx context.Context, h WorkHandlerOfInt8ThenInt, n int) *WorkerOfInt8ThenInt {
	__ := &WorkerOfInt8ThenInt{
		api_syncer: NewApiDecouplerOfInt8ThenInt(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfInt8ThenInt, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfInt8ThenInt{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfInt8ThenInt(req.Context, req.WorkOfInt8ThenInt, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfInt8ThenInt) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfInt8ThenInt) Push(ctx context.Context, req *WorkOfInt8ThenInt) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfInt8ThenInt)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfInt8ThenInt = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfInt8ThenInt) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfInt8ThenInt) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfInt8ThenInt) Call(ctx context.Context, arg int8) (int, error) {
	return __.api_syncer.DoOfInt8ThenInt(ctx, __, arg)
}

type PoolOfInt8ThenInt16 interface {
	GetInt8Arg() *int8
	PutInt8Arg(*int8)
	GetInt16Return() *int16
	PutInt16Return(*int16)

	GetWorkOfInt8ThenInt16() *WorkOfInt8ThenInt16
	GetReturnOfInt16() *ReturnOfInt16
	PutWorkOfInt8ThenInt16(*WorkOfInt8ThenInt16)
	PutReturnOfInt16(*ReturnOfInt16)

	GetChReturnOfInt16() chan *ReturnOfInt16
	PutChReturnOfInt16(chan *ReturnOfInt16)
}

type PoolOfInt8ThenInt16Impl struct {
	Int8Arg         sync.Pool
	Int16Rtn        sync.Pool
	Int8Work        sync.Pool
	Int16Return     sync.Pool
	ChReturnOfInt16 sync.Pool
}

func (__ *PoolOfInt8ThenInt16Impl) GetInt8Arg() *int8 {
	return __.Int8Arg.Get().(*int8)
}
func (__ *PoolOfInt8ThenInt16Impl) PutInt8Arg(p *int8) {
	__.Int8Arg.Put(p)
}
func (__ *PoolOfInt8ThenInt16Impl) GetInt16Return() *int16 {
	return __.Int16Rtn.Get().(*int16)
}
func (__ *PoolOfInt8ThenInt16Impl) PutInt16Return(p *int16) {
	__.Int16Rtn.Put(p)
}

func (__ *PoolOfInt8ThenInt16Impl) GetWorkOfInt8ThenInt16() *WorkOfInt8ThenInt16 {
	return __.Int8Work.Get().(*WorkOfInt8ThenInt16)
}
func (__ *PoolOfInt8ThenInt16Impl) PutWorkOfInt8ThenInt16(p *WorkOfInt8ThenInt16) {
	__.Int8Work.Put(p)
}
func (__ *PoolOfInt8ThenInt16Impl) GetReturnOfInt16() *ReturnOfInt16 {
	return __.Int16Return.Get().(*ReturnOfInt16)
}
func (__ *PoolOfInt8ThenInt16Impl) PutReturnOfInt16(p *ReturnOfInt16) {
	__.Int16Return.Put(p)
}

func (__ *PoolOfInt8ThenInt16Impl) GetChReturnOfInt16() chan *ReturnOfInt16 {
	return __.ChReturnOfInt16.Get().(chan *ReturnOfInt16)
}
func (__ *PoolOfInt8ThenInt16Impl) PutChReturnOfInt16(p chan *ReturnOfInt16) {
	__.ChReturnOfInt16.Put(p)
}

func NewPoolOfInt8ThenInt16Impl() *PoolOfInt8ThenInt16Impl {
	return &PoolOfInt8ThenInt16Impl{
		Int8Arg: sync.Pool{
			New: func() interface{} {
				return new(int8)
			},
		},
		Int8Work: sync.Pool{
			New: func() interface{} {
				return new(WorkOfInt8ThenInt16)
			},
		},
		Int16Rtn: sync.Pool{
			New: func() interface{} {
				return new(int16)
			},
		},
		Int16Return: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfInt16)
			},
		},
		ChReturnOfInt16: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfInt16, 1)
			},
		},
	}
}

type ApiDecouplerOfInt8ThenInt16 struct {
	pool PoolOfInt8ThenInt16
}

func NewApiDecouplerOfInt8ThenInt16() *ApiDecouplerOfInt8ThenInt16 {
	return &ApiDecouplerOfInt8ThenInt16{
		pool: NewPoolOfInt8ThenInt16Impl(),
	}
}

func (__ *ApiDecouplerOfInt8ThenInt16) ReturnError(rtn_ch chan<- *ReturnOfInt16, err error) {
	rtn := __.pool.GetReturnOfInt16()
	var other int16
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfInt8ThenInt16) HandleOfInt8ThenInt16(ctx context.Context, req *WorkOfInt8ThenInt16, h func(ctx context.Context, arg int8) (int16, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfInt16()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfInt8ThenInt16) DoOfInt8ThenInt16(ctx context.Context, worker WorkerOfPushInt8ThenInt16, arg int8) (int16, error) {
	// ch := make(chan *ReturnOfInt16, 1)
	ch := __.pool.GetChReturnOfInt16()
	defer __.pool.PutChReturnOfInt16(ch)

	req := __.pool.GetWorkOfInt8ThenInt16()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfInt8ThenInt16(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfInt16(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfInt8ThenInt16 = func(ctx context.Context, arg int8) (int16, error)

type WorkerOfInt8ThenInt16 struct {
	api_syncer *ApiDecouplerOfInt8ThenInt16
	handler    WorkHandlerOfInt8ThenInt16

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfInt8ThenInt16
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfInt8ThenInt16(ctx context.Context, h WorkHandlerOfInt8ThenInt16, n int) *WorkerOfInt8ThenInt16 {
	__ := &WorkerOfInt8ThenInt16{
		api_syncer: NewApiDecouplerOfInt8ThenInt16(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfInt8ThenInt16, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfInt8ThenInt16{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfInt8ThenInt16(req.Context, req.WorkOfInt8ThenInt16, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfInt8ThenInt16) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfInt8ThenInt16) Push(ctx context.Context, req *WorkOfInt8ThenInt16) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfInt8ThenInt16)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfInt8ThenInt16 = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfInt8ThenInt16) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfInt8ThenInt16) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfInt8ThenInt16) Call(ctx context.Context, arg int8) (int16, error) {
	return __.api_syncer.DoOfInt8ThenInt16(ctx, __, arg)
}

type PoolOfInt8ThenInt32 interface {
	GetInt8Arg() *int8
	PutInt8Arg(*int8)
	GetInt32Return() *int32
	PutInt32Return(*int32)

	GetWorkOfInt8ThenInt32() *WorkOfInt8ThenInt32
	GetReturnOfInt32() *ReturnOfInt32
	PutWorkOfInt8ThenInt32(*WorkOfInt8ThenInt32)
	PutReturnOfInt32(*ReturnOfInt32)

	GetChReturnOfInt32() chan *ReturnOfInt32
	PutChReturnOfInt32(chan *ReturnOfInt32)
}

type PoolOfInt8ThenInt32Impl struct {
	Int8Arg         sync.Pool
	Int32Rtn        sync.Pool
	Int8Work        sync.Pool
	Int32Return     sync.Pool
	ChReturnOfInt32 sync.Pool
}

func (__ *PoolOfInt8ThenInt32Impl) GetInt8Arg() *int8 {
	return __.Int8Arg.Get().(*int8)
}
func (__ *PoolOfInt8ThenInt32Impl) PutInt8Arg(p *int8) {
	__.Int8Arg.Put(p)
}
func (__ *PoolOfInt8ThenInt32Impl) GetInt32Return() *int32 {
	return __.Int32Rtn.Get().(*int32)
}
func (__ *PoolOfInt8ThenInt32Impl) PutInt32Return(p *int32) {
	__.Int32Rtn.Put(p)
}

func (__ *PoolOfInt8ThenInt32Impl) GetWorkOfInt8ThenInt32() *WorkOfInt8ThenInt32 {
	return __.Int8Work.Get().(*WorkOfInt8ThenInt32)
}
func (__ *PoolOfInt8ThenInt32Impl) PutWorkOfInt8ThenInt32(p *WorkOfInt8ThenInt32) {
	__.Int8Work.Put(p)
}
func (__ *PoolOfInt8ThenInt32Impl) GetReturnOfInt32() *ReturnOfInt32 {
	return __.Int32Return.Get().(*ReturnOfInt32)
}
func (__ *PoolOfInt8ThenInt32Impl) PutReturnOfInt32(p *ReturnOfInt32) {
	__.Int32Return.Put(p)
}

func (__ *PoolOfInt8ThenInt32Impl) GetChReturnOfInt32() chan *ReturnOfInt32 {
	return __.ChReturnOfInt32.Get().(chan *ReturnOfInt32)
}
func (__ *PoolOfInt8ThenInt32Impl) PutChReturnOfInt32(p chan *ReturnOfInt32) {
	__.ChReturnOfInt32.Put(p)
}

func NewPoolOfInt8ThenInt32Impl() *PoolOfInt8ThenInt32Impl {
	return &PoolOfInt8ThenInt32Impl{
		Int8Arg: sync.Pool{
			New: func() interface{} {
				return new(int8)
			},
		},
		Int8Work: sync.Pool{
			New: func() interface{} {
				return new(WorkOfInt8ThenInt32)
			},
		},
		Int32Rtn: sync.Pool{
			New: func() interface{} {
				return new(int32)
			},
		},
		Int32Return: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfInt32)
			},
		},
		ChReturnOfInt32: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfInt32, 1)
			},
		},
	}
}

type ApiDecouplerOfInt8ThenInt32 struct {
	pool PoolOfInt8ThenInt32
}

func NewApiDecouplerOfInt8ThenInt32() *ApiDecouplerOfInt8ThenInt32 {
	return &ApiDecouplerOfInt8ThenInt32{
		pool: NewPoolOfInt8ThenInt32Impl(),
	}
}

func (__ *ApiDecouplerOfInt8ThenInt32) ReturnError(rtn_ch chan<- *ReturnOfInt32, err error) {
	rtn := __.pool.GetReturnOfInt32()
	var other int32
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfInt8ThenInt32) HandleOfInt8ThenInt32(ctx context.Context, req *WorkOfInt8ThenInt32, h func(ctx context.Context, arg int8) (int32, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfInt32()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfInt8ThenInt32) DoOfInt8ThenInt32(ctx context.Context, worker WorkerOfPushInt8ThenInt32, arg int8) (int32, error) {
	// ch := make(chan *ReturnOfInt32, 1)
	ch := __.pool.GetChReturnOfInt32()
	defer __.pool.PutChReturnOfInt32(ch)

	req := __.pool.GetWorkOfInt8ThenInt32()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfInt8ThenInt32(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfInt32(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfInt8ThenInt32 = func(ctx context.Context, arg int8) (int32, error)

type WorkerOfInt8ThenInt32 struct {
	api_syncer *ApiDecouplerOfInt8ThenInt32
	handler    WorkHandlerOfInt8ThenInt32

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfInt8ThenInt32
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfInt8ThenInt32(ctx context.Context, h WorkHandlerOfInt8ThenInt32, n int) *WorkerOfInt8ThenInt32 {
	__ := &WorkerOfInt8ThenInt32{
		api_syncer: NewApiDecouplerOfInt8ThenInt32(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfInt8ThenInt32, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfInt8ThenInt32{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfInt8ThenInt32(req.Context, req.WorkOfInt8ThenInt32, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfInt8ThenInt32) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfInt8ThenInt32) Push(ctx context.Context, req *WorkOfInt8ThenInt32) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfInt8ThenInt32)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfInt8ThenInt32 = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfInt8ThenInt32) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfInt8ThenInt32) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfInt8ThenInt32) Call(ctx context.Context, arg int8) (int32, error) {
	return __.api_syncer.DoOfInt8ThenInt32(ctx, __, arg)
}

type PoolOfInt8ThenInt64 interface {
	GetInt8Arg() *int8
	PutInt8Arg(*int8)
	GetInt64Return() *int64
	PutInt64Return(*int64)

	GetWorkOfInt8ThenInt64() *WorkOfInt8ThenInt64
	GetReturnOfInt64() *ReturnOfInt64
	PutWorkOfInt8ThenInt64(*WorkOfInt8ThenInt64)
	PutReturnOfInt64(*ReturnOfInt64)

	GetChReturnOfInt64() chan *ReturnOfInt64
	PutChReturnOfInt64(chan *ReturnOfInt64)
}

type PoolOfInt8ThenInt64Impl struct {
	Int8Arg         sync.Pool
	Int64Rtn        sync.Pool
	Int8Work        sync.Pool
	Int64Return     sync.Pool
	ChReturnOfInt64 sync.Pool
}

func (__ *PoolOfInt8ThenInt64Impl) GetInt8Arg() *int8 {
	return __.Int8Arg.Get().(*int8)
}
func (__ *PoolOfInt8ThenInt64Impl) PutInt8Arg(p *int8) {
	__.Int8Arg.Put(p)
}
func (__ *PoolOfInt8ThenInt64Impl) GetInt64Return() *int64 {
	return __.Int64Rtn.Get().(*int64)
}
func (__ *PoolOfInt8ThenInt64Impl) PutInt64Return(p *int64) {
	__.Int64Rtn.Put(p)
}

func (__ *PoolOfInt8ThenInt64Impl) GetWorkOfInt8ThenInt64() *WorkOfInt8ThenInt64 {
	return __.Int8Work.Get().(*WorkOfInt8ThenInt64)
}
func (__ *PoolOfInt8ThenInt64Impl) PutWorkOfInt8ThenInt64(p *WorkOfInt8ThenInt64) {
	__.Int8Work.Put(p)
}
func (__ *PoolOfInt8ThenInt64Impl) GetReturnOfInt64() *ReturnOfInt64 {
	return __.Int64Return.Get().(*ReturnOfInt64)
}
func (__ *PoolOfInt8ThenInt64Impl) PutReturnOfInt64(p *ReturnOfInt64) {
	__.Int64Return.Put(p)
}

func (__ *PoolOfInt8ThenInt64Impl) GetChReturnOfInt64() chan *ReturnOfInt64 {
	return __.ChReturnOfInt64.Get().(chan *ReturnOfInt64)
}
func (__ *PoolOfInt8ThenInt64Impl) PutChReturnOfInt64(p chan *ReturnOfInt64) {
	__.ChReturnOfInt64.Put(p)
}

func NewPoolOfInt8ThenInt64Impl() *PoolOfInt8ThenInt64Impl {
	return &PoolOfInt8ThenInt64Impl{
		Int8Arg: sync.Pool{
			New: func() interface{} {
				return new(int8)
			},
		},
		Int8Work: sync.Pool{
			New: func() interface{} {
				return new(WorkOfInt8ThenInt64)
			},
		},
		Int64Rtn: sync.Pool{
			New: func() interface{} {
				return new(int64)
			},
		},
		Int64Return: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfInt64)
			},
		},
		ChReturnOfInt64: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfInt64, 1)
			},
		},
	}
}

type ApiDecouplerOfInt8ThenInt64 struct {
	pool PoolOfInt8ThenInt64
}

func NewApiDecouplerOfInt8ThenInt64() *ApiDecouplerOfInt8ThenInt64 {
	return &ApiDecouplerOfInt8ThenInt64{
		pool: NewPoolOfInt8ThenInt64Impl(),
	}
}

func (__ *ApiDecouplerOfInt8ThenInt64) ReturnError(rtn_ch chan<- *ReturnOfInt64, err error) {
	rtn := __.pool.GetReturnOfInt64()
	var other int64
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfInt8ThenInt64) HandleOfInt8ThenInt64(ctx context.Context, req *WorkOfInt8ThenInt64, h func(ctx context.Context, arg int8) (int64, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfInt64()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfInt8ThenInt64) DoOfInt8ThenInt64(ctx context.Context, worker WorkerOfPushInt8ThenInt64, arg int8) (int64, error) {
	// ch := make(chan *ReturnOfInt64, 1)
	ch := __.pool.GetChReturnOfInt64()
	defer __.pool.PutChReturnOfInt64(ch)

	req := __.pool.GetWorkOfInt8ThenInt64()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfInt8ThenInt64(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfInt64(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfInt8ThenInt64 = func(ctx context.Context, arg int8) (int64, error)

type WorkerOfInt8ThenInt64 struct {
	api_syncer *ApiDecouplerOfInt8ThenInt64
	handler    WorkHandlerOfInt8ThenInt64

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfInt8ThenInt64
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfInt8ThenInt64(ctx context.Context, h WorkHandlerOfInt8ThenInt64, n int) *WorkerOfInt8ThenInt64 {
	__ := &WorkerOfInt8ThenInt64{
		api_syncer: NewApiDecouplerOfInt8ThenInt64(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfInt8ThenInt64, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfInt8ThenInt64{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfInt8ThenInt64(req.Context, req.WorkOfInt8ThenInt64, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfInt8ThenInt64) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfInt8ThenInt64) Push(ctx context.Context, req *WorkOfInt8ThenInt64) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfInt8ThenInt64)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfInt8ThenInt64 = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfInt8ThenInt64) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfInt8ThenInt64) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfInt8ThenInt64) Call(ctx context.Context, arg int8) (int64, error) {
	return __.api_syncer.DoOfInt8ThenInt64(ctx, __, arg)
}

type PoolOfInt8ThenInt8 interface {
	GetInt8Arg() *int8
	PutInt8Arg(*int8)
	GetInt8Return() *int8
	PutInt8Return(*int8)

	GetWorkOfInt8ThenInt8() *WorkOfInt8ThenInt8
	GetReturnOfInt8() *ReturnOfInt8
	PutWorkOfInt8ThenInt8(*WorkOfInt8ThenInt8)
	PutReturnOfInt8(*ReturnOfInt8)

	GetChReturnOfInt8() chan *ReturnOfInt8
	PutChReturnOfInt8(chan *ReturnOfInt8)
}

type PoolOfInt8ThenInt8Impl struct {
	Int8Arg        sync.Pool
	Int8Rtn        sync.Pool
	Int8Work       sync.Pool
	Int8Return     sync.Pool
	ChReturnOfInt8 sync.Pool
}

func (__ *PoolOfInt8ThenInt8Impl) GetInt8Arg() *int8 {
	return __.Int8Arg.Get().(*int8)
}
func (__ *PoolOfInt8ThenInt8Impl) PutInt8Arg(p *int8) {
	__.Int8Arg.Put(p)
}
func (__ *PoolOfInt8ThenInt8Impl) GetInt8Return() *int8 {
	return __.Int8Rtn.Get().(*int8)
}
func (__ *PoolOfInt8ThenInt8Impl) PutInt8Return(p *int8) {
	__.Int8Rtn.Put(p)
}

func (__ *PoolOfInt8ThenInt8Impl) GetWorkOfInt8ThenInt8() *WorkOfInt8ThenInt8 {
	return __.Int8Work.Get().(*WorkOfInt8ThenInt8)
}
func (__ *PoolOfInt8ThenInt8Impl) PutWorkOfInt8ThenInt8(p *WorkOfInt8ThenInt8) {
	__.Int8Work.Put(p)
}
func (__ *PoolOfInt8ThenInt8Impl) GetReturnOfInt8() *ReturnOfInt8 {
	return __.Int8Return.Get().(*ReturnOfInt8)
}
func (__ *PoolOfInt8ThenInt8Impl) PutReturnOfInt8(p *ReturnOfInt8) {
	__.Int8Return.Put(p)
}

func (__ *PoolOfInt8ThenInt8Impl) GetChReturnOfInt8() chan *ReturnOfInt8 {
	return __.ChReturnOfInt8.Get().(chan *ReturnOfInt8)
}
func (__ *PoolOfInt8ThenInt8Impl) PutChReturnOfInt8(p chan *ReturnOfInt8) {
	__.ChReturnOfInt8.Put(p)
}

func NewPoolOfInt8ThenInt8Impl() *PoolOfInt8ThenInt8Impl {
	return &PoolOfInt8ThenInt8Impl{
		Int8Arg: sync.Pool{
			New: func() interface{} {
				return new(int8)
			},
		},
		Int8Work: sync.Pool{
			New: func() interface{} {
				return new(WorkOfInt8ThenInt8)
			},
		},
		Int8Rtn: sync.Pool{
			New: func() interface{} {
				return new(int8)
			},
		},
		Int8Return: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfInt8)
			},
		},
		ChReturnOfInt8: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfInt8, 1)
			},
		},
	}
}

type ApiDecouplerOfInt8ThenInt8 struct {
	pool PoolOfInt8ThenInt8
}

func NewApiDecouplerOfInt8ThenInt8() *ApiDecouplerOfInt8ThenInt8 {
	return &ApiDecouplerOfInt8ThenInt8{
		pool: NewPoolOfInt8ThenInt8Impl(),
	}
}

func (__ *ApiDecouplerOfInt8ThenInt8) ReturnError(rtn_ch chan<- *ReturnOfInt8, err error) {
	rtn := __.pool.GetReturnOfInt8()
	var other int8
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfInt8ThenInt8) HandleOfInt8ThenInt8(ctx context.Context, req *WorkOfInt8ThenInt8, h func(ctx context.Context, arg int8) (int8, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfInt8()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfInt8ThenInt8) DoOfInt8ThenInt8(ctx context.Context, worker WorkerOfPushInt8ThenInt8, arg int8) (int8, error) {
	// ch := make(chan *ReturnOfInt8, 1)
	ch := __.pool.GetChReturnOfInt8()
	defer __.pool.PutChReturnOfInt8(ch)

	req := __.pool.GetWorkOfInt8ThenInt8()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfInt8ThenInt8(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfInt8(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfInt8ThenInt8 = func(ctx context.Context, arg int8) (int8, error)

type WorkerOfInt8ThenInt8 struct {
	api_syncer *ApiDecouplerOfInt8ThenInt8
	handler    WorkHandlerOfInt8ThenInt8

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfInt8ThenInt8
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfInt8ThenInt8(ctx context.Context, h WorkHandlerOfInt8ThenInt8, n int) *WorkerOfInt8ThenInt8 {
	__ := &WorkerOfInt8ThenInt8{
		api_syncer: NewApiDecouplerOfInt8ThenInt8(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfInt8ThenInt8, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfInt8ThenInt8{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfInt8ThenInt8(req.Context, req.WorkOfInt8ThenInt8, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfInt8ThenInt8) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfInt8ThenInt8) Push(ctx context.Context, req *WorkOfInt8ThenInt8) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfInt8ThenInt8)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfInt8ThenInt8 = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfInt8ThenInt8) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfInt8ThenInt8) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfInt8ThenInt8) Call(ctx context.Context, arg int8) (int8, error) {
	return __.api_syncer.DoOfInt8ThenInt8(ctx, __, arg)
}

type PoolOfInt8ThenRune interface {
	GetInt8Arg() *int8
	PutInt8Arg(*int8)
	GetRuneReturn() *rune
	PutRuneReturn(*rune)

	GetWorkOfInt8ThenRune() *WorkOfInt8ThenRune
	GetReturnOfRune() *ReturnOfRune
	PutWorkOfInt8ThenRune(*WorkOfInt8ThenRune)
	PutReturnOfRune(*ReturnOfRune)

	GetChReturnOfRune() chan *ReturnOfRune
	PutChReturnOfRune(chan *ReturnOfRune)
}

type PoolOfInt8ThenRuneImpl struct {
	Int8Arg        sync.Pool
	RuneRtn        sync.Pool
	Int8Work       sync.Pool
	RuneReturn     sync.Pool
	ChReturnOfRune sync.Pool
}

func (__ *PoolOfInt8ThenRuneImpl) GetInt8Arg() *int8 {
	return __.Int8Arg.Get().(*int8)
}
func (__ *PoolOfInt8ThenRuneImpl) PutInt8Arg(p *int8) {
	__.Int8Arg.Put(p)
}
func (__ *PoolOfInt8ThenRuneImpl) GetRuneReturn() *rune {
	return __.RuneRtn.Get().(*rune)
}
func (__ *PoolOfInt8ThenRuneImpl) PutRuneReturn(p *rune) {
	__.RuneRtn.Put(p)
}

func (__ *PoolOfInt8ThenRuneImpl) GetWorkOfInt8ThenRune() *WorkOfInt8ThenRune {
	return __.Int8Work.Get().(*WorkOfInt8ThenRune)
}
func (__ *PoolOfInt8ThenRuneImpl) PutWorkOfInt8ThenRune(p *WorkOfInt8ThenRune) {
	__.Int8Work.Put(p)
}
func (__ *PoolOfInt8ThenRuneImpl) GetReturnOfRune() *ReturnOfRune {
	return __.RuneReturn.Get().(*ReturnOfRune)
}
func (__ *PoolOfInt8ThenRuneImpl) PutReturnOfRune(p *ReturnOfRune) {
	__.RuneReturn.Put(p)
}

func (__ *PoolOfInt8ThenRuneImpl) GetChReturnOfRune() chan *ReturnOfRune {
	return __.ChReturnOfRune.Get().(chan *ReturnOfRune)
}
func (__ *PoolOfInt8ThenRuneImpl) PutChReturnOfRune(p chan *ReturnOfRune) {
	__.ChReturnOfRune.Put(p)
}

func NewPoolOfInt8ThenRuneImpl() *PoolOfInt8ThenRuneImpl {
	return &PoolOfInt8ThenRuneImpl{
		Int8Arg: sync.Pool{
			New: func() interface{} {
				return new(int8)
			},
		},
		Int8Work: sync.Pool{
			New: func() interface{} {
				return new(WorkOfInt8ThenRune)
			},
		},
		RuneRtn: sync.Pool{
			New: func() interface{} {
				return new(rune)
			},
		},
		RuneReturn: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfRune)
			},
		},
		ChReturnOfRune: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfRune, 1)
			},
		},
	}
}

type ApiDecouplerOfInt8ThenRune struct {
	pool PoolOfInt8ThenRune
}

func NewApiDecouplerOfInt8ThenRune() *ApiDecouplerOfInt8ThenRune {
	return &ApiDecouplerOfInt8ThenRune{
		pool: NewPoolOfInt8ThenRuneImpl(),
	}
}

func (__ *ApiDecouplerOfInt8ThenRune) ReturnError(rtn_ch chan<- *ReturnOfRune, err error) {
	rtn := __.pool.GetReturnOfRune()
	var other rune
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfInt8ThenRune) HandleOfInt8ThenRune(ctx context.Context, req *WorkOfInt8ThenRune, h func(ctx context.Context, arg int8) (rune, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfRune()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfInt8ThenRune) DoOfInt8ThenRune(ctx context.Context, worker WorkerOfPushInt8ThenRune, arg int8) (rune, error) {
	// ch := make(chan *ReturnOfRune, 1)
	ch := __.pool.GetChReturnOfRune()
	defer __.pool.PutChReturnOfRune(ch)

	req := __.pool.GetWorkOfInt8ThenRune()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfInt8ThenRune(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfRune(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfInt8ThenRune = func(ctx context.Context, arg int8) (rune, error)

type WorkerOfInt8ThenRune struct {
	api_syncer *ApiDecouplerOfInt8ThenRune
	handler    WorkHandlerOfInt8ThenRune

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfInt8ThenRune
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfInt8ThenRune(ctx context.Context, h WorkHandlerOfInt8ThenRune, n int) *WorkerOfInt8ThenRune {
	__ := &WorkerOfInt8ThenRune{
		api_syncer: NewApiDecouplerOfInt8ThenRune(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfInt8ThenRune, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfInt8ThenRune{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfInt8ThenRune(req.Context, req.WorkOfInt8ThenRune, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfInt8ThenRune) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfInt8ThenRune) Push(ctx context.Context, req *WorkOfInt8ThenRune) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfInt8ThenRune)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfInt8ThenRune = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfInt8ThenRune) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfInt8ThenRune) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfInt8ThenRune) Call(ctx context.Context, arg int8) (rune, error) {
	return __.api_syncer.DoOfInt8ThenRune(ctx, __, arg)
}

type PoolOfInt8ThenString interface {
	GetInt8Arg() *int8
	PutInt8Arg(*int8)
	GetStringReturn() *string
	PutStringReturn(*string)

	GetWorkOfInt8ThenString() *WorkOfInt8ThenString
	GetReturnOfString() *ReturnOfString
	PutWorkOfInt8ThenString(*WorkOfInt8ThenString)
	PutReturnOfString(*ReturnOfString)

	GetChReturnOfString() chan *ReturnOfString
	PutChReturnOfString(chan *ReturnOfString)
}

type PoolOfInt8ThenStringImpl struct {
	Int8Arg          sync.Pool
	StringRtn        sync.Pool
	Int8Work         sync.Pool
	StringReturn     sync.Pool
	ChReturnOfString sync.Pool
}

func (__ *PoolOfInt8ThenStringImpl) GetInt8Arg() *int8 {
	return __.Int8Arg.Get().(*int8)
}
func (__ *PoolOfInt8ThenStringImpl) PutInt8Arg(p *int8) {
	__.Int8Arg.Put(p)
}
func (__ *PoolOfInt8ThenStringImpl) GetStringReturn() *string {
	return __.StringRtn.Get().(*string)
}
func (__ *PoolOfInt8ThenStringImpl) PutStringReturn(p *string) {
	__.StringRtn.Put(p)
}

func (__ *PoolOfInt8ThenStringImpl) GetWorkOfInt8ThenString() *WorkOfInt8ThenString {
	return __.Int8Work.Get().(*WorkOfInt8ThenString)
}
func (__ *PoolOfInt8ThenStringImpl) PutWorkOfInt8ThenString(p *WorkOfInt8ThenString) {
	__.Int8Work.Put(p)
}
func (__ *PoolOfInt8ThenStringImpl) GetReturnOfString() *ReturnOfString {
	return __.StringReturn.Get().(*ReturnOfString)
}
func (__ *PoolOfInt8ThenStringImpl) PutReturnOfString(p *ReturnOfString) {
	__.StringReturn.Put(p)
}

func (__ *PoolOfInt8ThenStringImpl) GetChReturnOfString() chan *ReturnOfString {
	return __.ChReturnOfString.Get().(chan *ReturnOfString)
}
func (__ *PoolOfInt8ThenStringImpl) PutChReturnOfString(p chan *ReturnOfString) {
	__.ChReturnOfString.Put(p)
}

func NewPoolOfInt8ThenStringImpl() *PoolOfInt8ThenStringImpl {
	return &PoolOfInt8ThenStringImpl{
		Int8Arg: sync.Pool{
			New: func() interface{} {
				return new(int8)
			},
		},
		Int8Work: sync.Pool{
			New: func() interface{} {
				return new(WorkOfInt8ThenString)
			},
		},
		StringRtn: sync.Pool{
			New: func() interface{} {
				return new(string)
			},
		},
		StringReturn: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfString)
			},
		},
		ChReturnOfString: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfString, 1)
			},
		},
	}
}

type ApiDecouplerOfInt8ThenString struct {
	pool PoolOfInt8ThenString
}

func NewApiDecouplerOfInt8ThenString() *ApiDecouplerOfInt8ThenString {
	return &ApiDecouplerOfInt8ThenString{
		pool: NewPoolOfInt8ThenStringImpl(),
	}
}

func (__ *ApiDecouplerOfInt8ThenString) ReturnError(rtn_ch chan<- *ReturnOfString, err error) {
	rtn := __.pool.GetReturnOfString()
	var other string
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfInt8ThenString) HandleOfInt8ThenString(ctx context.Context, req *WorkOfInt8ThenString, h func(ctx context.Context, arg int8) (string, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfString()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfInt8ThenString) DoOfInt8ThenString(ctx context.Context, worker WorkerOfPushInt8ThenString, arg int8) (string, error) {
	// ch := make(chan *ReturnOfString, 1)
	ch := __.pool.GetChReturnOfString()
	defer __.pool.PutChReturnOfString(ch)

	req := __.pool.GetWorkOfInt8ThenString()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfInt8ThenString(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfString(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfInt8ThenString = func(ctx context.Context, arg int8) (string, error)

type WorkerOfInt8ThenString struct {
	api_syncer *ApiDecouplerOfInt8ThenString
	handler    WorkHandlerOfInt8ThenString

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfInt8ThenString
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfInt8ThenString(ctx context.Context, h WorkHandlerOfInt8ThenString, n int) *WorkerOfInt8ThenString {
	__ := &WorkerOfInt8ThenString{
		api_syncer: NewApiDecouplerOfInt8ThenString(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfInt8ThenString, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfInt8ThenString{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfInt8ThenString(req.Context, req.WorkOfInt8ThenString, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfInt8ThenString) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfInt8ThenString) Push(ctx context.Context, req *WorkOfInt8ThenString) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfInt8ThenString)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfInt8ThenString = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfInt8ThenString) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfInt8ThenString) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfInt8ThenString) Call(ctx context.Context, arg int8) (string, error) {
	return __.api_syncer.DoOfInt8ThenString(ctx, __, arg)
}

type PoolOfInt8ThenUint interface {
	GetInt8Arg() *int8
	PutInt8Arg(*int8)
	GetUintReturn() *uint
	PutUintReturn(*uint)

	GetWorkOfInt8ThenUint() *WorkOfInt8ThenUint
	GetReturnOfUint() *ReturnOfUint
	PutWorkOfInt8ThenUint(*WorkOfInt8ThenUint)
	PutReturnOfUint(*ReturnOfUint)

	GetChReturnOfUint() chan *ReturnOfUint
	PutChReturnOfUint(chan *ReturnOfUint)
}

type PoolOfInt8ThenUintImpl struct {
	Int8Arg        sync.Pool
	UintRtn        sync.Pool
	Int8Work       sync.Pool
	UintReturn     sync.Pool
	ChReturnOfUint sync.Pool
}

func (__ *PoolOfInt8ThenUintImpl) GetInt8Arg() *int8 {
	return __.Int8Arg.Get().(*int8)
}
func (__ *PoolOfInt8ThenUintImpl) PutInt8Arg(p *int8) {
	__.Int8Arg.Put(p)
}
func (__ *PoolOfInt8ThenUintImpl) GetUintReturn() *uint {
	return __.UintRtn.Get().(*uint)
}
func (__ *PoolOfInt8ThenUintImpl) PutUintReturn(p *uint) {
	__.UintRtn.Put(p)
}

func (__ *PoolOfInt8ThenUintImpl) GetWorkOfInt8ThenUint() *WorkOfInt8ThenUint {
	return __.Int8Work.Get().(*WorkOfInt8ThenUint)
}
func (__ *PoolOfInt8ThenUintImpl) PutWorkOfInt8ThenUint(p *WorkOfInt8ThenUint) {
	__.Int8Work.Put(p)
}
func (__ *PoolOfInt8ThenUintImpl) GetReturnOfUint() *ReturnOfUint {
	return __.UintReturn.Get().(*ReturnOfUint)
}
func (__ *PoolOfInt8ThenUintImpl) PutReturnOfUint(p *ReturnOfUint) {
	__.UintReturn.Put(p)
}

func (__ *PoolOfInt8ThenUintImpl) GetChReturnOfUint() chan *ReturnOfUint {
	return __.ChReturnOfUint.Get().(chan *ReturnOfUint)
}
func (__ *PoolOfInt8ThenUintImpl) PutChReturnOfUint(p chan *ReturnOfUint) {
	__.ChReturnOfUint.Put(p)
}

func NewPoolOfInt8ThenUintImpl() *PoolOfInt8ThenUintImpl {
	return &PoolOfInt8ThenUintImpl{
		Int8Arg: sync.Pool{
			New: func() interface{} {
				return new(int8)
			},
		},
		Int8Work: sync.Pool{
			New: func() interface{} {
				return new(WorkOfInt8ThenUint)
			},
		},
		UintRtn: sync.Pool{
			New: func() interface{} {
				return new(uint)
			},
		},
		UintReturn: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfUint)
			},
		},
		ChReturnOfUint: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfUint, 1)
			},
		},
	}
}

type ApiDecouplerOfInt8ThenUint struct {
	pool PoolOfInt8ThenUint
}

func NewApiDecouplerOfInt8ThenUint() *ApiDecouplerOfInt8ThenUint {
	return &ApiDecouplerOfInt8ThenUint{
		pool: NewPoolOfInt8ThenUintImpl(),
	}
}

func (__ *ApiDecouplerOfInt8ThenUint) ReturnError(rtn_ch chan<- *ReturnOfUint, err error) {
	rtn := __.pool.GetReturnOfUint()
	var other uint
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfInt8ThenUint) HandleOfInt8ThenUint(ctx context.Context, req *WorkOfInt8ThenUint, h func(ctx context.Context, arg int8) (uint, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfUint()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfInt8ThenUint) DoOfInt8ThenUint(ctx context.Context, worker WorkerOfPushInt8ThenUint, arg int8) (uint, error) {
	// ch := make(chan *ReturnOfUint, 1)
	ch := __.pool.GetChReturnOfUint()
	defer __.pool.PutChReturnOfUint(ch)

	req := __.pool.GetWorkOfInt8ThenUint()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfInt8ThenUint(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfUint(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfInt8ThenUint = func(ctx context.Context, arg int8) (uint, error)

type WorkerOfInt8ThenUint struct {
	api_syncer *ApiDecouplerOfInt8ThenUint
	handler    WorkHandlerOfInt8ThenUint

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfInt8ThenUint
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfInt8ThenUint(ctx context.Context, h WorkHandlerOfInt8ThenUint, n int) *WorkerOfInt8ThenUint {
	__ := &WorkerOfInt8ThenUint{
		api_syncer: NewApiDecouplerOfInt8ThenUint(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfInt8ThenUint, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfInt8ThenUint{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfInt8ThenUint(req.Context, req.WorkOfInt8ThenUint, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfInt8ThenUint) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfInt8ThenUint) Push(ctx context.Context, req *WorkOfInt8ThenUint) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfInt8ThenUint)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfInt8ThenUint = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfInt8ThenUint) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfInt8ThenUint) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfInt8ThenUint) Call(ctx context.Context, arg int8) (uint, error) {
	return __.api_syncer.DoOfInt8ThenUint(ctx, __, arg)
}

type PoolOfInt8ThenUint16 interface {
	GetInt8Arg() *int8
	PutInt8Arg(*int8)
	GetUint16Return() *uint16
	PutUint16Return(*uint16)

	GetWorkOfInt8ThenUint16() *WorkOfInt8ThenUint16
	GetReturnOfUint16() *ReturnOfUint16
	PutWorkOfInt8ThenUint16(*WorkOfInt8ThenUint16)
	PutReturnOfUint16(*ReturnOfUint16)

	GetChReturnOfUint16() chan *ReturnOfUint16
	PutChReturnOfUint16(chan *ReturnOfUint16)
}

type PoolOfInt8ThenUint16Impl struct {
	Int8Arg          sync.Pool
	Uint16Rtn        sync.Pool
	Int8Work         sync.Pool
	Uint16Return     sync.Pool
	ChReturnOfUint16 sync.Pool
}

func (__ *PoolOfInt8ThenUint16Impl) GetInt8Arg() *int8 {
	return __.Int8Arg.Get().(*int8)
}
func (__ *PoolOfInt8ThenUint16Impl) PutInt8Arg(p *int8) {
	__.Int8Arg.Put(p)
}
func (__ *PoolOfInt8ThenUint16Impl) GetUint16Return() *uint16 {
	return __.Uint16Rtn.Get().(*uint16)
}
func (__ *PoolOfInt8ThenUint16Impl) PutUint16Return(p *uint16) {
	__.Uint16Rtn.Put(p)
}

func (__ *PoolOfInt8ThenUint16Impl) GetWorkOfInt8ThenUint16() *WorkOfInt8ThenUint16 {
	return __.Int8Work.Get().(*WorkOfInt8ThenUint16)
}
func (__ *PoolOfInt8ThenUint16Impl) PutWorkOfInt8ThenUint16(p *WorkOfInt8ThenUint16) {
	__.Int8Work.Put(p)
}
func (__ *PoolOfInt8ThenUint16Impl) GetReturnOfUint16() *ReturnOfUint16 {
	return __.Uint16Return.Get().(*ReturnOfUint16)
}
func (__ *PoolOfInt8ThenUint16Impl) PutReturnOfUint16(p *ReturnOfUint16) {
	__.Uint16Return.Put(p)
}

func (__ *PoolOfInt8ThenUint16Impl) GetChReturnOfUint16() chan *ReturnOfUint16 {
	return __.ChReturnOfUint16.Get().(chan *ReturnOfUint16)
}
func (__ *PoolOfInt8ThenUint16Impl) PutChReturnOfUint16(p chan *ReturnOfUint16) {
	__.ChReturnOfUint16.Put(p)
}

func NewPoolOfInt8ThenUint16Impl() *PoolOfInt8ThenUint16Impl {
	return &PoolOfInt8ThenUint16Impl{
		Int8Arg: sync.Pool{
			New: func() interface{} {
				return new(int8)
			},
		},
		Int8Work: sync.Pool{
			New: func() interface{} {
				return new(WorkOfInt8ThenUint16)
			},
		},
		Uint16Rtn: sync.Pool{
			New: func() interface{} {
				return new(uint16)
			},
		},
		Uint16Return: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfUint16)
			},
		},
		ChReturnOfUint16: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfUint16, 1)
			},
		},
	}
}

type ApiDecouplerOfInt8ThenUint16 struct {
	pool PoolOfInt8ThenUint16
}

func NewApiDecouplerOfInt8ThenUint16() *ApiDecouplerOfInt8ThenUint16 {
	return &ApiDecouplerOfInt8ThenUint16{
		pool: NewPoolOfInt8ThenUint16Impl(),
	}
}

func (__ *ApiDecouplerOfInt8ThenUint16) ReturnError(rtn_ch chan<- *ReturnOfUint16, err error) {
	rtn := __.pool.GetReturnOfUint16()
	var other uint16
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfInt8ThenUint16) HandleOfInt8ThenUint16(ctx context.Context, req *WorkOfInt8ThenUint16, h func(ctx context.Context, arg int8) (uint16, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfUint16()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfInt8ThenUint16) DoOfInt8ThenUint16(ctx context.Context, worker WorkerOfPushInt8ThenUint16, arg int8) (uint16, error) {
	// ch := make(chan *ReturnOfUint16, 1)
	ch := __.pool.GetChReturnOfUint16()
	defer __.pool.PutChReturnOfUint16(ch)

	req := __.pool.GetWorkOfInt8ThenUint16()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfInt8ThenUint16(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfUint16(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfInt8ThenUint16 = func(ctx context.Context, arg int8) (uint16, error)

type WorkerOfInt8ThenUint16 struct {
	api_syncer *ApiDecouplerOfInt8ThenUint16
	handler    WorkHandlerOfInt8ThenUint16

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfInt8ThenUint16
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfInt8ThenUint16(ctx context.Context, h WorkHandlerOfInt8ThenUint16, n int) *WorkerOfInt8ThenUint16 {
	__ := &WorkerOfInt8ThenUint16{
		api_syncer: NewApiDecouplerOfInt8ThenUint16(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfInt8ThenUint16, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfInt8ThenUint16{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfInt8ThenUint16(req.Context, req.WorkOfInt8ThenUint16, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfInt8ThenUint16) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfInt8ThenUint16) Push(ctx context.Context, req *WorkOfInt8ThenUint16) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfInt8ThenUint16)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfInt8ThenUint16 = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfInt8ThenUint16) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfInt8ThenUint16) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfInt8ThenUint16) Call(ctx context.Context, arg int8) (uint16, error) {
	return __.api_syncer.DoOfInt8ThenUint16(ctx, __, arg)
}

type PoolOfInt8ThenUint32 interface {
	GetInt8Arg() *int8
	PutInt8Arg(*int8)
	GetUint32Return() *uint32
	PutUint32Return(*uint32)

	GetWorkOfInt8ThenUint32() *WorkOfInt8ThenUint32
	GetReturnOfUint32() *ReturnOfUint32
	PutWorkOfInt8ThenUint32(*WorkOfInt8ThenUint32)
	PutReturnOfUint32(*ReturnOfUint32)

	GetChReturnOfUint32() chan *ReturnOfUint32
	PutChReturnOfUint32(chan *ReturnOfUint32)
}

type PoolOfInt8ThenUint32Impl struct {
	Int8Arg          sync.Pool
	Uint32Rtn        sync.Pool
	Int8Work         sync.Pool
	Uint32Return     sync.Pool
	ChReturnOfUint32 sync.Pool
}

func (__ *PoolOfInt8ThenUint32Impl) GetInt8Arg() *int8 {
	return __.Int8Arg.Get().(*int8)
}
func (__ *PoolOfInt8ThenUint32Impl) PutInt8Arg(p *int8) {
	__.Int8Arg.Put(p)
}
func (__ *PoolOfInt8ThenUint32Impl) GetUint32Return() *uint32 {
	return __.Uint32Rtn.Get().(*uint32)
}
func (__ *PoolOfInt8ThenUint32Impl) PutUint32Return(p *uint32) {
	__.Uint32Rtn.Put(p)
}

func (__ *PoolOfInt8ThenUint32Impl) GetWorkOfInt8ThenUint32() *WorkOfInt8ThenUint32 {
	return __.Int8Work.Get().(*WorkOfInt8ThenUint32)
}
func (__ *PoolOfInt8ThenUint32Impl) PutWorkOfInt8ThenUint32(p *WorkOfInt8ThenUint32) {
	__.Int8Work.Put(p)
}
func (__ *PoolOfInt8ThenUint32Impl) GetReturnOfUint32() *ReturnOfUint32 {
	return __.Uint32Return.Get().(*ReturnOfUint32)
}
func (__ *PoolOfInt8ThenUint32Impl) PutReturnOfUint32(p *ReturnOfUint32) {
	__.Uint32Return.Put(p)
}

func (__ *PoolOfInt8ThenUint32Impl) GetChReturnOfUint32() chan *ReturnOfUint32 {
	return __.ChReturnOfUint32.Get().(chan *ReturnOfUint32)
}
func (__ *PoolOfInt8ThenUint32Impl) PutChReturnOfUint32(p chan *ReturnOfUint32) {
	__.ChReturnOfUint32.Put(p)
}

func NewPoolOfInt8ThenUint32Impl() *PoolOfInt8ThenUint32Impl {
	return &PoolOfInt8ThenUint32Impl{
		Int8Arg: sync.Pool{
			New: func() interface{} {
				return new(int8)
			},
		},
		Int8Work: sync.Pool{
			New: func() interface{} {
				return new(WorkOfInt8ThenUint32)
			},
		},
		Uint32Rtn: sync.Pool{
			New: func() interface{} {
				return new(uint32)
			},
		},
		Uint32Return: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfUint32)
			},
		},
		ChReturnOfUint32: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfUint32, 1)
			},
		},
	}
}

type ApiDecouplerOfInt8ThenUint32 struct {
	pool PoolOfInt8ThenUint32
}

func NewApiDecouplerOfInt8ThenUint32() *ApiDecouplerOfInt8ThenUint32 {
	return &ApiDecouplerOfInt8ThenUint32{
		pool: NewPoolOfInt8ThenUint32Impl(),
	}
}

func (__ *ApiDecouplerOfInt8ThenUint32) ReturnError(rtn_ch chan<- *ReturnOfUint32, err error) {
	rtn := __.pool.GetReturnOfUint32()
	var other uint32
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfInt8ThenUint32) HandleOfInt8ThenUint32(ctx context.Context, req *WorkOfInt8ThenUint32, h func(ctx context.Context, arg int8) (uint32, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfUint32()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfInt8ThenUint32) DoOfInt8ThenUint32(ctx context.Context, worker WorkerOfPushInt8ThenUint32, arg int8) (uint32, error) {
	// ch := make(chan *ReturnOfUint32, 1)
	ch := __.pool.GetChReturnOfUint32()
	defer __.pool.PutChReturnOfUint32(ch)

	req := __.pool.GetWorkOfInt8ThenUint32()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfInt8ThenUint32(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfUint32(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfInt8ThenUint32 = func(ctx context.Context, arg int8) (uint32, error)

type WorkerOfInt8ThenUint32 struct {
	api_syncer *ApiDecouplerOfInt8ThenUint32
	handler    WorkHandlerOfInt8ThenUint32

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfInt8ThenUint32
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfInt8ThenUint32(ctx context.Context, h WorkHandlerOfInt8ThenUint32, n int) *WorkerOfInt8ThenUint32 {
	__ := &WorkerOfInt8ThenUint32{
		api_syncer: NewApiDecouplerOfInt8ThenUint32(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfInt8ThenUint32, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfInt8ThenUint32{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfInt8ThenUint32(req.Context, req.WorkOfInt8ThenUint32, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfInt8ThenUint32) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfInt8ThenUint32) Push(ctx context.Context, req *WorkOfInt8ThenUint32) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfInt8ThenUint32)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfInt8ThenUint32 = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfInt8ThenUint32) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfInt8ThenUint32) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfInt8ThenUint32) Call(ctx context.Context, arg int8) (uint32, error) {
	return __.api_syncer.DoOfInt8ThenUint32(ctx, __, arg)
}

type PoolOfInt8ThenUint64 interface {
	GetInt8Arg() *int8
	PutInt8Arg(*int8)
	GetUint64Return() *uint64
	PutUint64Return(*uint64)

	GetWorkOfInt8ThenUint64() *WorkOfInt8ThenUint64
	GetReturnOfUint64() *ReturnOfUint64
	PutWorkOfInt8ThenUint64(*WorkOfInt8ThenUint64)
	PutReturnOfUint64(*ReturnOfUint64)

	GetChReturnOfUint64() chan *ReturnOfUint64
	PutChReturnOfUint64(chan *ReturnOfUint64)
}

type PoolOfInt8ThenUint64Impl struct {
	Int8Arg          sync.Pool
	Uint64Rtn        sync.Pool
	Int8Work         sync.Pool
	Uint64Return     sync.Pool
	ChReturnOfUint64 sync.Pool
}

func (__ *PoolOfInt8ThenUint64Impl) GetInt8Arg() *int8 {
	return __.Int8Arg.Get().(*int8)
}
func (__ *PoolOfInt8ThenUint64Impl) PutInt8Arg(p *int8) {
	__.Int8Arg.Put(p)
}
func (__ *PoolOfInt8ThenUint64Impl) GetUint64Return() *uint64 {
	return __.Uint64Rtn.Get().(*uint64)
}
func (__ *PoolOfInt8ThenUint64Impl) PutUint64Return(p *uint64) {
	__.Uint64Rtn.Put(p)
}

func (__ *PoolOfInt8ThenUint64Impl) GetWorkOfInt8ThenUint64() *WorkOfInt8ThenUint64 {
	return __.Int8Work.Get().(*WorkOfInt8ThenUint64)
}
func (__ *PoolOfInt8ThenUint64Impl) PutWorkOfInt8ThenUint64(p *WorkOfInt8ThenUint64) {
	__.Int8Work.Put(p)
}
func (__ *PoolOfInt8ThenUint64Impl) GetReturnOfUint64() *ReturnOfUint64 {
	return __.Uint64Return.Get().(*ReturnOfUint64)
}
func (__ *PoolOfInt8ThenUint64Impl) PutReturnOfUint64(p *ReturnOfUint64) {
	__.Uint64Return.Put(p)
}

func (__ *PoolOfInt8ThenUint64Impl) GetChReturnOfUint64() chan *ReturnOfUint64 {
	return __.ChReturnOfUint64.Get().(chan *ReturnOfUint64)
}
func (__ *PoolOfInt8ThenUint64Impl) PutChReturnOfUint64(p chan *ReturnOfUint64) {
	__.ChReturnOfUint64.Put(p)
}

func NewPoolOfInt8ThenUint64Impl() *PoolOfInt8ThenUint64Impl {
	return &PoolOfInt8ThenUint64Impl{
		Int8Arg: sync.Pool{
			New: func() interface{} {
				return new(int8)
			},
		},
		Int8Work: sync.Pool{
			New: func() interface{} {
				return new(WorkOfInt8ThenUint64)
			},
		},
		Uint64Rtn: sync.Pool{
			New: func() interface{} {
				return new(uint64)
			},
		},
		Uint64Return: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfUint64)
			},
		},
		ChReturnOfUint64: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfUint64, 1)
			},
		},
	}
}

type ApiDecouplerOfInt8ThenUint64 struct {
	pool PoolOfInt8ThenUint64
}

func NewApiDecouplerOfInt8ThenUint64() *ApiDecouplerOfInt8ThenUint64 {
	return &ApiDecouplerOfInt8ThenUint64{
		pool: NewPoolOfInt8ThenUint64Impl(),
	}
}

func (__ *ApiDecouplerOfInt8ThenUint64) ReturnError(rtn_ch chan<- *ReturnOfUint64, err error) {
	rtn := __.pool.GetReturnOfUint64()
	var other uint64
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfInt8ThenUint64) HandleOfInt8ThenUint64(ctx context.Context, req *WorkOfInt8ThenUint64, h func(ctx context.Context, arg int8) (uint64, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfUint64()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfInt8ThenUint64) DoOfInt8ThenUint64(ctx context.Context, worker WorkerOfPushInt8ThenUint64, arg int8) (uint64, error) {
	// ch := make(chan *ReturnOfUint64, 1)
	ch := __.pool.GetChReturnOfUint64()
	defer __.pool.PutChReturnOfUint64(ch)

	req := __.pool.GetWorkOfInt8ThenUint64()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfInt8ThenUint64(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfUint64(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfInt8ThenUint64 = func(ctx context.Context, arg int8) (uint64, error)

type WorkerOfInt8ThenUint64 struct {
	api_syncer *ApiDecouplerOfInt8ThenUint64
	handler    WorkHandlerOfInt8ThenUint64

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfInt8ThenUint64
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfInt8ThenUint64(ctx context.Context, h WorkHandlerOfInt8ThenUint64, n int) *WorkerOfInt8ThenUint64 {
	__ := &WorkerOfInt8ThenUint64{
		api_syncer: NewApiDecouplerOfInt8ThenUint64(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfInt8ThenUint64, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfInt8ThenUint64{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfInt8ThenUint64(req.Context, req.WorkOfInt8ThenUint64, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfInt8ThenUint64) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfInt8ThenUint64) Push(ctx context.Context, req *WorkOfInt8ThenUint64) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfInt8ThenUint64)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfInt8ThenUint64 = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfInt8ThenUint64) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfInt8ThenUint64) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfInt8ThenUint64) Call(ctx context.Context, arg int8) (uint64, error) {
	return __.api_syncer.DoOfInt8ThenUint64(ctx, __, arg)
}

type PoolOfInt8ThenUint8 interface {
	GetInt8Arg() *int8
	PutInt8Arg(*int8)
	GetUint8Return() *uint8
	PutUint8Return(*uint8)

	GetWorkOfInt8ThenUint8() *WorkOfInt8ThenUint8
	GetReturnOfUint8() *ReturnOfUint8
	PutWorkOfInt8ThenUint8(*WorkOfInt8ThenUint8)
	PutReturnOfUint8(*ReturnOfUint8)

	GetChReturnOfUint8() chan *ReturnOfUint8
	PutChReturnOfUint8(chan *ReturnOfUint8)
}

type PoolOfInt8ThenUint8Impl struct {
	Int8Arg         sync.Pool
	Uint8Rtn        sync.Pool
	Int8Work        sync.Pool
	Uint8Return     sync.Pool
	ChReturnOfUint8 sync.Pool
}

func (__ *PoolOfInt8ThenUint8Impl) GetInt8Arg() *int8 {
	return __.Int8Arg.Get().(*int8)
}
func (__ *PoolOfInt8ThenUint8Impl) PutInt8Arg(p *int8) {
	__.Int8Arg.Put(p)
}
func (__ *PoolOfInt8ThenUint8Impl) GetUint8Return() *uint8 {
	return __.Uint8Rtn.Get().(*uint8)
}
func (__ *PoolOfInt8ThenUint8Impl) PutUint8Return(p *uint8) {
	__.Uint8Rtn.Put(p)
}

func (__ *PoolOfInt8ThenUint8Impl) GetWorkOfInt8ThenUint8() *WorkOfInt8ThenUint8 {
	return __.Int8Work.Get().(*WorkOfInt8ThenUint8)
}
func (__ *PoolOfInt8ThenUint8Impl) PutWorkOfInt8ThenUint8(p *WorkOfInt8ThenUint8) {
	__.Int8Work.Put(p)
}
func (__ *PoolOfInt8ThenUint8Impl) GetReturnOfUint8() *ReturnOfUint8 {
	return __.Uint8Return.Get().(*ReturnOfUint8)
}
func (__ *PoolOfInt8ThenUint8Impl) PutReturnOfUint8(p *ReturnOfUint8) {
	__.Uint8Return.Put(p)
}

func (__ *PoolOfInt8ThenUint8Impl) GetChReturnOfUint8() chan *ReturnOfUint8 {
	return __.ChReturnOfUint8.Get().(chan *ReturnOfUint8)
}
func (__ *PoolOfInt8ThenUint8Impl) PutChReturnOfUint8(p chan *ReturnOfUint8) {
	__.ChReturnOfUint8.Put(p)
}

func NewPoolOfInt8ThenUint8Impl() *PoolOfInt8ThenUint8Impl {
	return &PoolOfInt8ThenUint8Impl{
		Int8Arg: sync.Pool{
			New: func() interface{} {
				return new(int8)
			},
		},
		Int8Work: sync.Pool{
			New: func() interface{} {
				return new(WorkOfInt8ThenUint8)
			},
		},
		Uint8Rtn: sync.Pool{
			New: func() interface{} {
				return new(uint8)
			},
		},
		Uint8Return: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfUint8)
			},
		},
		ChReturnOfUint8: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfUint8, 1)
			},
		},
	}
}

type ApiDecouplerOfInt8ThenUint8 struct {
	pool PoolOfInt8ThenUint8
}

func NewApiDecouplerOfInt8ThenUint8() *ApiDecouplerOfInt8ThenUint8 {
	return &ApiDecouplerOfInt8ThenUint8{
		pool: NewPoolOfInt8ThenUint8Impl(),
	}
}

func (__ *ApiDecouplerOfInt8ThenUint8) ReturnError(rtn_ch chan<- *ReturnOfUint8, err error) {
	rtn := __.pool.GetReturnOfUint8()
	var other uint8
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfInt8ThenUint8) HandleOfInt8ThenUint8(ctx context.Context, req *WorkOfInt8ThenUint8, h func(ctx context.Context, arg int8) (uint8, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfUint8()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfInt8ThenUint8) DoOfInt8ThenUint8(ctx context.Context, worker WorkerOfPushInt8ThenUint8, arg int8) (uint8, error) {
	// ch := make(chan *ReturnOfUint8, 1)
	ch := __.pool.GetChReturnOfUint8()
	defer __.pool.PutChReturnOfUint8(ch)

	req := __.pool.GetWorkOfInt8ThenUint8()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfInt8ThenUint8(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfUint8(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfInt8ThenUint8 = func(ctx context.Context, arg int8) (uint8, error)

type WorkerOfInt8ThenUint8 struct {
	api_syncer *ApiDecouplerOfInt8ThenUint8
	handler    WorkHandlerOfInt8ThenUint8

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfInt8ThenUint8
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfInt8ThenUint8(ctx context.Context, h WorkHandlerOfInt8ThenUint8, n int) *WorkerOfInt8ThenUint8 {
	__ := &WorkerOfInt8ThenUint8{
		api_syncer: NewApiDecouplerOfInt8ThenUint8(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfInt8ThenUint8, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfInt8ThenUint8{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfInt8ThenUint8(req.Context, req.WorkOfInt8ThenUint8, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfInt8ThenUint8) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfInt8ThenUint8) Push(ctx context.Context, req *WorkOfInt8ThenUint8) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfInt8ThenUint8)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfInt8ThenUint8 = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfInt8ThenUint8) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfInt8ThenUint8) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfInt8ThenUint8) Call(ctx context.Context, arg int8) (uint8, error) {
	return __.api_syncer.DoOfInt8ThenUint8(ctx, __, arg)
}

type PoolOfInt8ThenUintptr interface {
	GetInt8Arg() *int8
	PutInt8Arg(*int8)
	GetUintptrReturn() *uintptr
	PutUintptrReturn(*uintptr)

	GetWorkOfInt8ThenUintptr() *WorkOfInt8ThenUintptr
	GetReturnOfUintptr() *ReturnOfUintptr
	PutWorkOfInt8ThenUintptr(*WorkOfInt8ThenUintptr)
	PutReturnOfUintptr(*ReturnOfUintptr)

	GetChReturnOfUintptr() chan *ReturnOfUintptr
	PutChReturnOfUintptr(chan *ReturnOfUintptr)
}

type PoolOfInt8ThenUintptrImpl struct {
	Int8Arg           sync.Pool
	UintptrRtn        sync.Pool
	Int8Work          sync.Pool
	UintptrReturn     sync.Pool
	ChReturnOfUintptr sync.Pool
}

func (__ *PoolOfInt8ThenUintptrImpl) GetInt8Arg() *int8 {
	return __.Int8Arg.Get().(*int8)
}
func (__ *PoolOfInt8ThenUintptrImpl) PutInt8Arg(p *int8) {
	__.Int8Arg.Put(p)
}
func (__ *PoolOfInt8ThenUintptrImpl) GetUintptrReturn() *uintptr {
	return __.UintptrRtn.Get().(*uintptr)
}
func (__ *PoolOfInt8ThenUintptrImpl) PutUintptrReturn(p *uintptr) {
	__.UintptrRtn.Put(p)
}

func (__ *PoolOfInt8ThenUintptrImpl) GetWorkOfInt8ThenUintptr() *WorkOfInt8ThenUintptr {
	return __.Int8Work.Get().(*WorkOfInt8ThenUintptr)
}
func (__ *PoolOfInt8ThenUintptrImpl) PutWorkOfInt8ThenUintptr(p *WorkOfInt8ThenUintptr) {
	__.Int8Work.Put(p)
}
func (__ *PoolOfInt8ThenUintptrImpl) GetReturnOfUintptr() *ReturnOfUintptr {
	return __.UintptrReturn.Get().(*ReturnOfUintptr)
}
func (__ *PoolOfInt8ThenUintptrImpl) PutReturnOfUintptr(p *ReturnOfUintptr) {
	__.UintptrReturn.Put(p)
}

func (__ *PoolOfInt8ThenUintptrImpl) GetChReturnOfUintptr() chan *ReturnOfUintptr {
	return __.ChReturnOfUintptr.Get().(chan *ReturnOfUintptr)
}
func (__ *PoolOfInt8ThenUintptrImpl) PutChReturnOfUintptr(p chan *ReturnOfUintptr) {
	__.ChReturnOfUintptr.Put(p)
}

func NewPoolOfInt8ThenUintptrImpl() *PoolOfInt8ThenUintptrImpl {
	return &PoolOfInt8ThenUintptrImpl{
		Int8Arg: sync.Pool{
			New: func() interface{} {
				return new(int8)
			},
		},
		Int8Work: sync.Pool{
			New: func() interface{} {
				return new(WorkOfInt8ThenUintptr)
			},
		},
		UintptrRtn: sync.Pool{
			New: func() interface{} {
				return new(uintptr)
			},
		},
		UintptrReturn: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfUintptr)
			},
		},
		ChReturnOfUintptr: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfUintptr, 1)
			},
		},
	}
}

type ApiDecouplerOfInt8ThenUintptr struct {
	pool PoolOfInt8ThenUintptr
}

func NewApiDecouplerOfInt8ThenUintptr() *ApiDecouplerOfInt8ThenUintptr {
	return &ApiDecouplerOfInt8ThenUintptr{
		pool: NewPoolOfInt8ThenUintptrImpl(),
	}
}

func (__ *ApiDecouplerOfInt8ThenUintptr) ReturnError(rtn_ch chan<- *ReturnOfUintptr, err error) {
	rtn := __.pool.GetReturnOfUintptr()
	var other uintptr
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfInt8ThenUintptr) HandleOfInt8ThenUintptr(ctx context.Context, req *WorkOfInt8ThenUintptr, h func(ctx context.Context, arg int8) (uintptr, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfUintptr()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfInt8ThenUintptr) DoOfInt8ThenUintptr(ctx context.Context, worker WorkerOfPushInt8ThenUintptr, arg int8) (uintptr, error) {
	// ch := make(chan *ReturnOfUintptr, 1)
	ch := __.pool.GetChReturnOfUintptr()
	defer __.pool.PutChReturnOfUintptr(ch)

	req := __.pool.GetWorkOfInt8ThenUintptr()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfInt8ThenUintptr(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfUintptr(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfInt8ThenUintptr = func(ctx context.Context, arg int8) (uintptr, error)

type WorkerOfInt8ThenUintptr struct {
	api_syncer *ApiDecouplerOfInt8ThenUintptr
	handler    WorkHandlerOfInt8ThenUintptr

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfInt8ThenUintptr
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfInt8ThenUintptr(ctx context.Context, h WorkHandlerOfInt8ThenUintptr, n int) *WorkerOfInt8ThenUintptr {
	__ := &WorkerOfInt8ThenUintptr{
		api_syncer: NewApiDecouplerOfInt8ThenUintptr(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfInt8ThenUintptr, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfInt8ThenUintptr{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfInt8ThenUintptr(req.Context, req.WorkOfInt8ThenUintptr, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfInt8ThenUintptr) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfInt8ThenUintptr) Push(ctx context.Context, req *WorkOfInt8ThenUintptr) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfInt8ThenUintptr)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfInt8ThenUintptr = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfInt8ThenUintptr) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfInt8ThenUintptr) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfInt8ThenUintptr) Call(ctx context.Context, arg int8) (uintptr, error) {
	return __.api_syncer.DoOfInt8ThenUintptr(ctx, __, arg)
}

type PoolOfInt8ThenInterface interface {
	GetInt8Arg() *int8
	PutInt8Arg(*int8)
	GetInterfaceReturn() *interface{}
	PutInterfaceReturn(*interface{})

	GetWorkOfInt8ThenInterface() *WorkOfInt8ThenInterface
	GetReturnOfInterface() *ReturnOfInterface
	PutWorkOfInt8ThenInterface(*WorkOfInt8ThenInterface)
	PutReturnOfInterface(*ReturnOfInterface)

	GetChReturnOfInterface() chan *ReturnOfInterface
	PutChReturnOfInterface(chan *ReturnOfInterface)
}

type PoolOfInt8ThenInterfaceImpl struct {
	Int8Arg             sync.Pool
	InterfaceRtn        sync.Pool
	Int8Work            sync.Pool
	InterfaceReturn     sync.Pool
	ChReturnOfInterface sync.Pool
}

func (__ *PoolOfInt8ThenInterfaceImpl) GetInt8Arg() *int8 {
	return __.Int8Arg.Get().(*int8)
}
func (__ *PoolOfInt8ThenInterfaceImpl) PutInt8Arg(p *int8) {
	__.Int8Arg.Put(p)
}
func (__ *PoolOfInt8ThenInterfaceImpl) GetInterfaceReturn() *interface{} {
	return __.InterfaceRtn.Get().(*interface{})
}
func (__ *PoolOfInt8ThenInterfaceImpl) PutInterfaceReturn(p *interface{}) {
	__.InterfaceRtn.Put(p)
}

func (__ *PoolOfInt8ThenInterfaceImpl) GetWorkOfInt8ThenInterface() *WorkOfInt8ThenInterface {
	return __.Int8Work.Get().(*WorkOfInt8ThenInterface)
}
func (__ *PoolOfInt8ThenInterfaceImpl) PutWorkOfInt8ThenInterface(p *WorkOfInt8ThenInterface) {
	__.Int8Work.Put(p)
}
func (__ *PoolOfInt8ThenInterfaceImpl) GetReturnOfInterface() *ReturnOfInterface {
	return __.InterfaceReturn.Get().(*ReturnOfInterface)
}
func (__ *PoolOfInt8ThenInterfaceImpl) PutReturnOfInterface(p *ReturnOfInterface) {
	__.InterfaceReturn.Put(p)
}

func (__ *PoolOfInt8ThenInterfaceImpl) GetChReturnOfInterface() chan *ReturnOfInterface {
	return __.ChReturnOfInterface.Get().(chan *ReturnOfInterface)
}
func (__ *PoolOfInt8ThenInterfaceImpl) PutChReturnOfInterface(p chan *ReturnOfInterface) {
	__.ChReturnOfInterface.Put(p)
}

func NewPoolOfInt8ThenInterfaceImpl() *PoolOfInt8ThenInterfaceImpl {
	return &PoolOfInt8ThenInterfaceImpl{
		Int8Arg: sync.Pool{
			New: func() interface{} {
				return new(int8)
			},
		},
		Int8Work: sync.Pool{
			New: func() interface{} {
				return new(WorkOfInt8ThenInterface)
			},
		},
		InterfaceRtn: sync.Pool{
			New: func() interface{} {
				return new(interface{})
			},
		},
		InterfaceReturn: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfInterface)
			},
		},
		ChReturnOfInterface: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfInterface, 1)
			},
		},
	}
}

type ApiDecouplerOfInt8ThenInterface struct {
	pool PoolOfInt8ThenInterface
}

func NewApiDecouplerOfInt8ThenInterface() *ApiDecouplerOfInt8ThenInterface {
	return &ApiDecouplerOfInt8ThenInterface{
		pool: NewPoolOfInt8ThenInterfaceImpl(),
	}
}

func (__ *ApiDecouplerOfInt8ThenInterface) ReturnError(rtn_ch chan<- *ReturnOfInterface, err error) {
	rtn := __.pool.GetReturnOfInterface()
	var other interface{}
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfInt8ThenInterface) HandleOfInt8ThenInterface(ctx context.Context, req *WorkOfInt8ThenInterface, h func(ctx context.Context, arg int8) (interface{}, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfInterface()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfInt8ThenInterface) DoOfInt8ThenInterface(ctx context.Context, worker WorkerOfPushInt8ThenInterface, arg int8) (interface{}, error) {
	// ch := make(chan *ReturnOfInterface, 1)
	ch := __.pool.GetChReturnOfInterface()
	defer __.pool.PutChReturnOfInterface(ch)

	req := __.pool.GetWorkOfInt8ThenInterface()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfInt8ThenInterface(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfInterface(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfInt8ThenInterface = func(ctx context.Context, arg int8) (interface{}, error)

type WorkerOfInt8ThenInterface struct {
	api_syncer *ApiDecouplerOfInt8ThenInterface
	handler    WorkHandlerOfInt8ThenInterface

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfInt8ThenInterface
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfInt8ThenInterface(ctx context.Context, h WorkHandlerOfInt8ThenInterface, n int) *WorkerOfInt8ThenInterface {
	__ := &WorkerOfInt8ThenInterface{
		api_syncer: NewApiDecouplerOfInt8ThenInterface(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfInt8ThenInterface, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfInt8ThenInterface{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfInt8ThenInterface(req.Context, req.WorkOfInt8ThenInterface, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfInt8ThenInterface) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfInt8ThenInterface) Push(ctx context.Context, req *WorkOfInt8ThenInterface) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfInt8ThenInterface)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfInt8ThenInterface = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfInt8ThenInterface) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfInt8ThenInterface) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfInt8ThenInterface) Call(ctx context.Context, arg int8) (interface{}, error) {
	return __.api_syncer.DoOfInt8ThenInterface(ctx, __, arg)
}

type PoolOfInt8ThenStruct interface {
	GetInt8Arg() *int8
	PutInt8Arg(*int8)
	GetStructReturn() *struct{}
	PutStructReturn(*struct{})

	GetWorkOfInt8ThenStruct() *WorkOfInt8ThenStruct
	GetReturnOfStruct() *ReturnOfStruct
	PutWorkOfInt8ThenStruct(*WorkOfInt8ThenStruct)
	PutReturnOfStruct(*ReturnOfStruct)

	GetChReturnOfStruct() chan *ReturnOfStruct
	PutChReturnOfStruct(chan *ReturnOfStruct)
}

type PoolOfInt8ThenStructImpl struct {
	Int8Arg          sync.Pool
	StructRtn        sync.Pool
	Int8Work         sync.Pool
	StructReturn     sync.Pool
	ChReturnOfStruct sync.Pool
}

func (__ *PoolOfInt8ThenStructImpl) GetInt8Arg() *int8 {
	return __.Int8Arg.Get().(*int8)
}
func (__ *PoolOfInt8ThenStructImpl) PutInt8Arg(p *int8) {
	__.Int8Arg.Put(p)
}
func (__ *PoolOfInt8ThenStructImpl) GetStructReturn() *struct{} {
	return __.StructRtn.Get().(*struct{})
}
func (__ *PoolOfInt8ThenStructImpl) PutStructReturn(p *struct{}) {
	__.StructRtn.Put(p)
}

func (__ *PoolOfInt8ThenStructImpl) GetWorkOfInt8ThenStruct() *WorkOfInt8ThenStruct {
	return __.Int8Work.Get().(*WorkOfInt8ThenStruct)
}
func (__ *PoolOfInt8ThenStructImpl) PutWorkOfInt8ThenStruct(p *WorkOfInt8ThenStruct) {
	__.Int8Work.Put(p)
}
func (__ *PoolOfInt8ThenStructImpl) GetReturnOfStruct() *ReturnOfStruct {
	return __.StructReturn.Get().(*ReturnOfStruct)
}
func (__ *PoolOfInt8ThenStructImpl) PutReturnOfStruct(p *ReturnOfStruct) {
	__.StructReturn.Put(p)
}

func (__ *PoolOfInt8ThenStructImpl) GetChReturnOfStruct() chan *ReturnOfStruct {
	return __.ChReturnOfStruct.Get().(chan *ReturnOfStruct)
}
func (__ *PoolOfInt8ThenStructImpl) PutChReturnOfStruct(p chan *ReturnOfStruct) {
	__.ChReturnOfStruct.Put(p)
}

func NewPoolOfInt8ThenStructImpl() *PoolOfInt8ThenStructImpl {
	return &PoolOfInt8ThenStructImpl{
		Int8Arg: sync.Pool{
			New: func() interface{} {
				return new(int8)
			},
		},
		Int8Work: sync.Pool{
			New: func() interface{} {
				return new(WorkOfInt8ThenStruct)
			},
		},
		StructRtn: sync.Pool{
			New: func() interface{} {
				return new(struct{})
			},
		},
		StructReturn: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfStruct)
			},
		},
		ChReturnOfStruct: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfStruct, 1)
			},
		},
	}
}

type ApiDecouplerOfInt8ThenStruct struct {
	pool PoolOfInt8ThenStruct
}

func NewApiDecouplerOfInt8ThenStruct() *ApiDecouplerOfInt8ThenStruct {
	return &ApiDecouplerOfInt8ThenStruct{
		pool: NewPoolOfInt8ThenStructImpl(),
	}
}

func (__ *ApiDecouplerOfInt8ThenStruct) ReturnError(rtn_ch chan<- *ReturnOfStruct, err error) {
	rtn := __.pool.GetReturnOfStruct()
	var other struct{}
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfInt8ThenStruct) HandleOfInt8ThenStruct(ctx context.Context, req *WorkOfInt8ThenStruct, h func(ctx context.Context, arg int8) (struct{}, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfStruct()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfInt8ThenStruct) DoOfInt8ThenStruct(ctx context.Context, worker WorkerOfPushInt8ThenStruct, arg int8) (struct{}, error) {
	// ch := make(chan *ReturnOfStruct, 1)
	ch := __.pool.GetChReturnOfStruct()
	defer __.pool.PutChReturnOfStruct(ch)

	req := __.pool.GetWorkOfInt8ThenStruct()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfInt8ThenStruct(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfStruct(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfInt8ThenStruct = func(ctx context.Context, arg int8) (struct{}, error)

type WorkerOfInt8ThenStruct struct {
	api_syncer *ApiDecouplerOfInt8ThenStruct
	handler    WorkHandlerOfInt8ThenStruct

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfInt8ThenStruct
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfInt8ThenStruct(ctx context.Context, h WorkHandlerOfInt8ThenStruct, n int) *WorkerOfInt8ThenStruct {
	__ := &WorkerOfInt8ThenStruct{
		api_syncer: NewApiDecouplerOfInt8ThenStruct(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfInt8ThenStruct, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfInt8ThenStruct{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfInt8ThenStruct(req.Context, req.WorkOfInt8ThenStruct, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfInt8ThenStruct) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfInt8ThenStruct) Push(ctx context.Context, req *WorkOfInt8ThenStruct) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfInt8ThenStruct)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfInt8ThenStruct = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfInt8ThenStruct) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfInt8ThenStruct) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfInt8ThenStruct) Call(ctx context.Context, arg int8) (struct{}, error) {
	return __.api_syncer.DoOfInt8ThenStruct(ctx, __, arg)
}

type PoolOfRuneThenBool interface {
	GetRuneArg() *rune
	PutRuneArg(*rune)
	GetBoolReturn() *bool
	PutBoolReturn(*bool)

	GetWorkOfRuneThenBool() *WorkOfRuneThenBool
	GetReturnOfBool() *ReturnOfBool
	PutWorkOfRuneThenBool(*WorkOfRuneThenBool)
	PutReturnOfBool(*ReturnOfBool)

	GetChReturnOfBool() chan *ReturnOfBool
	PutChReturnOfBool(chan *ReturnOfBool)
}

type PoolOfRuneThenBoolImpl struct {
	RuneArg        sync.Pool
	BoolRtn        sync.Pool
	RuneWork       sync.Pool
	BoolReturn     sync.Pool
	ChReturnOfBool sync.Pool
}

func (__ *PoolOfRuneThenBoolImpl) GetRuneArg() *rune {
	return __.RuneArg.Get().(*rune)
}
func (__ *PoolOfRuneThenBoolImpl) PutRuneArg(p *rune) {
	__.RuneArg.Put(p)
}
func (__ *PoolOfRuneThenBoolImpl) GetBoolReturn() *bool {
	return __.BoolRtn.Get().(*bool)
}
func (__ *PoolOfRuneThenBoolImpl) PutBoolReturn(p *bool) {
	__.BoolRtn.Put(p)
}

func (__ *PoolOfRuneThenBoolImpl) GetWorkOfRuneThenBool() *WorkOfRuneThenBool {
	return __.RuneWork.Get().(*WorkOfRuneThenBool)
}
func (__ *PoolOfRuneThenBoolImpl) PutWorkOfRuneThenBool(p *WorkOfRuneThenBool) {
	__.RuneWork.Put(p)
}
func (__ *PoolOfRuneThenBoolImpl) GetReturnOfBool() *ReturnOfBool {
	return __.BoolReturn.Get().(*ReturnOfBool)
}
func (__ *PoolOfRuneThenBoolImpl) PutReturnOfBool(p *ReturnOfBool) {
	__.BoolReturn.Put(p)
}

func (__ *PoolOfRuneThenBoolImpl) GetChReturnOfBool() chan *ReturnOfBool {
	return __.ChReturnOfBool.Get().(chan *ReturnOfBool)
}
func (__ *PoolOfRuneThenBoolImpl) PutChReturnOfBool(p chan *ReturnOfBool) {
	__.ChReturnOfBool.Put(p)
}

func NewPoolOfRuneThenBoolImpl() *PoolOfRuneThenBoolImpl {
	return &PoolOfRuneThenBoolImpl{
		RuneArg: sync.Pool{
			New: func() interface{} {
				return new(rune)
			},
		},
		RuneWork: sync.Pool{
			New: func() interface{} {
				return new(WorkOfRuneThenBool)
			},
		},
		BoolRtn: sync.Pool{
			New: func() interface{} {
				return new(bool)
			},
		},
		BoolReturn: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfBool)
			},
		},
		ChReturnOfBool: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfBool, 1)
			},
		},
	}
}

type ApiDecouplerOfRuneThenBool struct {
	pool PoolOfRuneThenBool
}

func NewApiDecouplerOfRuneThenBool() *ApiDecouplerOfRuneThenBool {
	return &ApiDecouplerOfRuneThenBool{
		pool: NewPoolOfRuneThenBoolImpl(),
	}
}

func (__ *ApiDecouplerOfRuneThenBool) ReturnError(rtn_ch chan<- *ReturnOfBool, err error) {
	rtn := __.pool.GetReturnOfBool()
	var other bool
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfRuneThenBool) HandleOfRuneThenBool(ctx context.Context, req *WorkOfRuneThenBool, h func(ctx context.Context, arg rune) (bool, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfBool()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfRuneThenBool) DoOfRuneThenBool(ctx context.Context, worker WorkerOfPushRuneThenBool, arg rune) (bool, error) {
	// ch := make(chan *ReturnOfBool, 1)
	ch := __.pool.GetChReturnOfBool()
	defer __.pool.PutChReturnOfBool(ch)

	req := __.pool.GetWorkOfRuneThenBool()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfRuneThenBool(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfBool(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfRuneThenBool = func(ctx context.Context, arg rune) (bool, error)

type WorkerOfRuneThenBool struct {
	api_syncer *ApiDecouplerOfRuneThenBool
	handler    WorkHandlerOfRuneThenBool

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfRuneThenBool
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfRuneThenBool(ctx context.Context, h WorkHandlerOfRuneThenBool, n int) *WorkerOfRuneThenBool {
	__ := &WorkerOfRuneThenBool{
		api_syncer: NewApiDecouplerOfRuneThenBool(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfRuneThenBool, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfRuneThenBool{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfRuneThenBool(req.Context, req.WorkOfRuneThenBool, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfRuneThenBool) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfRuneThenBool) Push(ctx context.Context, req *WorkOfRuneThenBool) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfRuneThenBool)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfRuneThenBool = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfRuneThenBool) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfRuneThenBool) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfRuneThenBool) Call(ctx context.Context, arg rune) (bool, error) {
	return __.api_syncer.DoOfRuneThenBool(ctx, __, arg)
}

type PoolOfRuneThenByte interface {
	GetRuneArg() *rune
	PutRuneArg(*rune)
	GetByteReturn() *byte
	PutByteReturn(*byte)

	GetWorkOfRuneThenByte() *WorkOfRuneThenByte
	GetReturnOfByte() *ReturnOfByte
	PutWorkOfRuneThenByte(*WorkOfRuneThenByte)
	PutReturnOfByte(*ReturnOfByte)

	GetChReturnOfByte() chan *ReturnOfByte
	PutChReturnOfByte(chan *ReturnOfByte)
}

type PoolOfRuneThenByteImpl struct {
	RuneArg        sync.Pool
	ByteRtn        sync.Pool
	RuneWork       sync.Pool
	ByteReturn     sync.Pool
	ChReturnOfByte sync.Pool
}

func (__ *PoolOfRuneThenByteImpl) GetRuneArg() *rune {
	return __.RuneArg.Get().(*rune)
}
func (__ *PoolOfRuneThenByteImpl) PutRuneArg(p *rune) {
	__.RuneArg.Put(p)
}
func (__ *PoolOfRuneThenByteImpl) GetByteReturn() *byte {
	return __.ByteRtn.Get().(*byte)
}
func (__ *PoolOfRuneThenByteImpl) PutByteReturn(p *byte) {
	__.ByteRtn.Put(p)
}

func (__ *PoolOfRuneThenByteImpl) GetWorkOfRuneThenByte() *WorkOfRuneThenByte {
	return __.RuneWork.Get().(*WorkOfRuneThenByte)
}
func (__ *PoolOfRuneThenByteImpl) PutWorkOfRuneThenByte(p *WorkOfRuneThenByte) {
	__.RuneWork.Put(p)
}
func (__ *PoolOfRuneThenByteImpl) GetReturnOfByte() *ReturnOfByte {
	return __.ByteReturn.Get().(*ReturnOfByte)
}
func (__ *PoolOfRuneThenByteImpl) PutReturnOfByte(p *ReturnOfByte) {
	__.ByteReturn.Put(p)
}

func (__ *PoolOfRuneThenByteImpl) GetChReturnOfByte() chan *ReturnOfByte {
	return __.ChReturnOfByte.Get().(chan *ReturnOfByte)
}
func (__ *PoolOfRuneThenByteImpl) PutChReturnOfByte(p chan *ReturnOfByte) {
	__.ChReturnOfByte.Put(p)
}

func NewPoolOfRuneThenByteImpl() *PoolOfRuneThenByteImpl {
	return &PoolOfRuneThenByteImpl{
		RuneArg: sync.Pool{
			New: func() interface{} {
				return new(rune)
			},
		},
		RuneWork: sync.Pool{
			New: func() interface{} {
				return new(WorkOfRuneThenByte)
			},
		},
		ByteRtn: sync.Pool{
			New: func() interface{} {
				return new(byte)
			},
		},
		ByteReturn: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfByte)
			},
		},
		ChReturnOfByte: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfByte, 1)
			},
		},
	}
}

type ApiDecouplerOfRuneThenByte struct {
	pool PoolOfRuneThenByte
}

func NewApiDecouplerOfRuneThenByte() *ApiDecouplerOfRuneThenByte {
	return &ApiDecouplerOfRuneThenByte{
		pool: NewPoolOfRuneThenByteImpl(),
	}
}

func (__ *ApiDecouplerOfRuneThenByte) ReturnError(rtn_ch chan<- *ReturnOfByte, err error) {
	rtn := __.pool.GetReturnOfByte()
	var other byte
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfRuneThenByte) HandleOfRuneThenByte(ctx context.Context, req *WorkOfRuneThenByte, h func(ctx context.Context, arg rune) (byte, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfByte()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfRuneThenByte) DoOfRuneThenByte(ctx context.Context, worker WorkerOfPushRuneThenByte, arg rune) (byte, error) {
	// ch := make(chan *ReturnOfByte, 1)
	ch := __.pool.GetChReturnOfByte()
	defer __.pool.PutChReturnOfByte(ch)

	req := __.pool.GetWorkOfRuneThenByte()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfRuneThenByte(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfByte(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfRuneThenByte = func(ctx context.Context, arg rune) (byte, error)

type WorkerOfRuneThenByte struct {
	api_syncer *ApiDecouplerOfRuneThenByte
	handler    WorkHandlerOfRuneThenByte

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfRuneThenByte
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfRuneThenByte(ctx context.Context, h WorkHandlerOfRuneThenByte, n int) *WorkerOfRuneThenByte {
	__ := &WorkerOfRuneThenByte{
		api_syncer: NewApiDecouplerOfRuneThenByte(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfRuneThenByte, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfRuneThenByte{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfRuneThenByte(req.Context, req.WorkOfRuneThenByte, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfRuneThenByte) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfRuneThenByte) Push(ctx context.Context, req *WorkOfRuneThenByte) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfRuneThenByte)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfRuneThenByte = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfRuneThenByte) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfRuneThenByte) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfRuneThenByte) Call(ctx context.Context, arg rune) (byte, error) {
	return __.api_syncer.DoOfRuneThenByte(ctx, __, arg)
}

type PoolOfRuneThenComplex128 interface {
	GetRuneArg() *rune
	PutRuneArg(*rune)
	GetComplex128Return() *complex128
	PutComplex128Return(*complex128)

	GetWorkOfRuneThenComplex128() *WorkOfRuneThenComplex128
	GetReturnOfComplex128() *ReturnOfComplex128
	PutWorkOfRuneThenComplex128(*WorkOfRuneThenComplex128)
	PutReturnOfComplex128(*ReturnOfComplex128)

	GetChReturnOfComplex128() chan *ReturnOfComplex128
	PutChReturnOfComplex128(chan *ReturnOfComplex128)
}

type PoolOfRuneThenComplex128Impl struct {
	RuneArg              sync.Pool
	Complex128Rtn        sync.Pool
	RuneWork             sync.Pool
	Complex128Return     sync.Pool
	ChReturnOfComplex128 sync.Pool
}

func (__ *PoolOfRuneThenComplex128Impl) GetRuneArg() *rune {
	return __.RuneArg.Get().(*rune)
}
func (__ *PoolOfRuneThenComplex128Impl) PutRuneArg(p *rune) {
	__.RuneArg.Put(p)
}
func (__ *PoolOfRuneThenComplex128Impl) GetComplex128Return() *complex128 {
	return __.Complex128Rtn.Get().(*complex128)
}
func (__ *PoolOfRuneThenComplex128Impl) PutComplex128Return(p *complex128) {
	__.Complex128Rtn.Put(p)
}

func (__ *PoolOfRuneThenComplex128Impl) GetWorkOfRuneThenComplex128() *WorkOfRuneThenComplex128 {
	return __.RuneWork.Get().(*WorkOfRuneThenComplex128)
}
func (__ *PoolOfRuneThenComplex128Impl) PutWorkOfRuneThenComplex128(p *WorkOfRuneThenComplex128) {
	__.RuneWork.Put(p)
}
func (__ *PoolOfRuneThenComplex128Impl) GetReturnOfComplex128() *ReturnOfComplex128 {
	return __.Complex128Return.Get().(*ReturnOfComplex128)
}
func (__ *PoolOfRuneThenComplex128Impl) PutReturnOfComplex128(p *ReturnOfComplex128) {
	__.Complex128Return.Put(p)
}

func (__ *PoolOfRuneThenComplex128Impl) GetChReturnOfComplex128() chan *ReturnOfComplex128 {
	return __.ChReturnOfComplex128.Get().(chan *ReturnOfComplex128)
}
func (__ *PoolOfRuneThenComplex128Impl) PutChReturnOfComplex128(p chan *ReturnOfComplex128) {
	__.ChReturnOfComplex128.Put(p)
}

func NewPoolOfRuneThenComplex128Impl() *PoolOfRuneThenComplex128Impl {
	return &PoolOfRuneThenComplex128Impl{
		RuneArg: sync.Pool{
			New: func() interface{} {
				return new(rune)
			},
		},
		RuneWork: sync.Pool{
			New: func() interface{} {
				return new(WorkOfRuneThenComplex128)
			},
		},
		Complex128Rtn: sync.Pool{
			New: func() interface{} {
				return new(complex128)
			},
		},
		Complex128Return: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfComplex128)
			},
		},
		ChReturnOfComplex128: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfComplex128, 1)
			},
		},
	}
}

type ApiDecouplerOfRuneThenComplex128 struct {
	pool PoolOfRuneThenComplex128
}

func NewApiDecouplerOfRuneThenComplex128() *ApiDecouplerOfRuneThenComplex128 {
	return &ApiDecouplerOfRuneThenComplex128{
		pool: NewPoolOfRuneThenComplex128Impl(),
	}
}

func (__ *ApiDecouplerOfRuneThenComplex128) ReturnError(rtn_ch chan<- *ReturnOfComplex128, err error) {
	rtn := __.pool.GetReturnOfComplex128()
	var other complex128
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfRuneThenComplex128) HandleOfRuneThenComplex128(ctx context.Context, req *WorkOfRuneThenComplex128, h func(ctx context.Context, arg rune) (complex128, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfComplex128()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfRuneThenComplex128) DoOfRuneThenComplex128(ctx context.Context, worker WorkerOfPushRuneThenComplex128, arg rune) (complex128, error) {
	// ch := make(chan *ReturnOfComplex128, 1)
	ch := __.pool.GetChReturnOfComplex128()
	defer __.pool.PutChReturnOfComplex128(ch)

	req := __.pool.GetWorkOfRuneThenComplex128()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfRuneThenComplex128(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfComplex128(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfRuneThenComplex128 = func(ctx context.Context, arg rune) (complex128, error)

type WorkerOfRuneThenComplex128 struct {
	api_syncer *ApiDecouplerOfRuneThenComplex128
	handler    WorkHandlerOfRuneThenComplex128

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfRuneThenComplex128
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfRuneThenComplex128(ctx context.Context, h WorkHandlerOfRuneThenComplex128, n int) *WorkerOfRuneThenComplex128 {
	__ := &WorkerOfRuneThenComplex128{
		api_syncer: NewApiDecouplerOfRuneThenComplex128(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfRuneThenComplex128, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfRuneThenComplex128{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfRuneThenComplex128(req.Context, req.WorkOfRuneThenComplex128, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfRuneThenComplex128) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfRuneThenComplex128) Push(ctx context.Context, req *WorkOfRuneThenComplex128) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfRuneThenComplex128)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfRuneThenComplex128 = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfRuneThenComplex128) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfRuneThenComplex128) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfRuneThenComplex128) Call(ctx context.Context, arg rune) (complex128, error) {
	return __.api_syncer.DoOfRuneThenComplex128(ctx, __, arg)
}

type PoolOfRuneThenComplex64 interface {
	GetRuneArg() *rune
	PutRuneArg(*rune)
	GetComplex64Return() *complex64
	PutComplex64Return(*complex64)

	GetWorkOfRuneThenComplex64() *WorkOfRuneThenComplex64
	GetReturnOfComplex64() *ReturnOfComplex64
	PutWorkOfRuneThenComplex64(*WorkOfRuneThenComplex64)
	PutReturnOfComplex64(*ReturnOfComplex64)

	GetChReturnOfComplex64() chan *ReturnOfComplex64
	PutChReturnOfComplex64(chan *ReturnOfComplex64)
}

type PoolOfRuneThenComplex64Impl struct {
	RuneArg             sync.Pool
	Complex64Rtn        sync.Pool
	RuneWork            sync.Pool
	Complex64Return     sync.Pool
	ChReturnOfComplex64 sync.Pool
}

func (__ *PoolOfRuneThenComplex64Impl) GetRuneArg() *rune {
	return __.RuneArg.Get().(*rune)
}
func (__ *PoolOfRuneThenComplex64Impl) PutRuneArg(p *rune) {
	__.RuneArg.Put(p)
}
func (__ *PoolOfRuneThenComplex64Impl) GetComplex64Return() *complex64 {
	return __.Complex64Rtn.Get().(*complex64)
}
func (__ *PoolOfRuneThenComplex64Impl) PutComplex64Return(p *complex64) {
	__.Complex64Rtn.Put(p)
}

func (__ *PoolOfRuneThenComplex64Impl) GetWorkOfRuneThenComplex64() *WorkOfRuneThenComplex64 {
	return __.RuneWork.Get().(*WorkOfRuneThenComplex64)
}
func (__ *PoolOfRuneThenComplex64Impl) PutWorkOfRuneThenComplex64(p *WorkOfRuneThenComplex64) {
	__.RuneWork.Put(p)
}
func (__ *PoolOfRuneThenComplex64Impl) GetReturnOfComplex64() *ReturnOfComplex64 {
	return __.Complex64Return.Get().(*ReturnOfComplex64)
}
func (__ *PoolOfRuneThenComplex64Impl) PutReturnOfComplex64(p *ReturnOfComplex64) {
	__.Complex64Return.Put(p)
}

func (__ *PoolOfRuneThenComplex64Impl) GetChReturnOfComplex64() chan *ReturnOfComplex64 {
	return __.ChReturnOfComplex64.Get().(chan *ReturnOfComplex64)
}
func (__ *PoolOfRuneThenComplex64Impl) PutChReturnOfComplex64(p chan *ReturnOfComplex64) {
	__.ChReturnOfComplex64.Put(p)
}

func NewPoolOfRuneThenComplex64Impl() *PoolOfRuneThenComplex64Impl {
	return &PoolOfRuneThenComplex64Impl{
		RuneArg: sync.Pool{
			New: func() interface{} {
				return new(rune)
			},
		},
		RuneWork: sync.Pool{
			New: func() interface{} {
				return new(WorkOfRuneThenComplex64)
			},
		},
		Complex64Rtn: sync.Pool{
			New: func() interface{} {
				return new(complex64)
			},
		},
		Complex64Return: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfComplex64)
			},
		},
		ChReturnOfComplex64: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfComplex64, 1)
			},
		},
	}
}

type ApiDecouplerOfRuneThenComplex64 struct {
	pool PoolOfRuneThenComplex64
}

func NewApiDecouplerOfRuneThenComplex64() *ApiDecouplerOfRuneThenComplex64 {
	return &ApiDecouplerOfRuneThenComplex64{
		pool: NewPoolOfRuneThenComplex64Impl(),
	}
}

func (__ *ApiDecouplerOfRuneThenComplex64) ReturnError(rtn_ch chan<- *ReturnOfComplex64, err error) {
	rtn := __.pool.GetReturnOfComplex64()
	var other complex64
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfRuneThenComplex64) HandleOfRuneThenComplex64(ctx context.Context, req *WorkOfRuneThenComplex64, h func(ctx context.Context, arg rune) (complex64, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfComplex64()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfRuneThenComplex64) DoOfRuneThenComplex64(ctx context.Context, worker WorkerOfPushRuneThenComplex64, arg rune) (complex64, error) {
	// ch := make(chan *ReturnOfComplex64, 1)
	ch := __.pool.GetChReturnOfComplex64()
	defer __.pool.PutChReturnOfComplex64(ch)

	req := __.pool.GetWorkOfRuneThenComplex64()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfRuneThenComplex64(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfComplex64(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfRuneThenComplex64 = func(ctx context.Context, arg rune) (complex64, error)

type WorkerOfRuneThenComplex64 struct {
	api_syncer *ApiDecouplerOfRuneThenComplex64
	handler    WorkHandlerOfRuneThenComplex64

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfRuneThenComplex64
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfRuneThenComplex64(ctx context.Context, h WorkHandlerOfRuneThenComplex64, n int) *WorkerOfRuneThenComplex64 {
	__ := &WorkerOfRuneThenComplex64{
		api_syncer: NewApiDecouplerOfRuneThenComplex64(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfRuneThenComplex64, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfRuneThenComplex64{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfRuneThenComplex64(req.Context, req.WorkOfRuneThenComplex64, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfRuneThenComplex64) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfRuneThenComplex64) Push(ctx context.Context, req *WorkOfRuneThenComplex64) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfRuneThenComplex64)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfRuneThenComplex64 = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfRuneThenComplex64) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfRuneThenComplex64) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfRuneThenComplex64) Call(ctx context.Context, arg rune) (complex64, error) {
	return __.api_syncer.DoOfRuneThenComplex64(ctx, __, arg)
}

type PoolOfRuneThenError interface {
	GetRuneArg() *rune
	PutRuneArg(*rune)
	GetErrorReturn() *error
	PutErrorReturn(*error)

	GetWorkOfRuneThenError() *WorkOfRuneThenError
	GetReturnOfError() *ReturnOfError
	PutWorkOfRuneThenError(*WorkOfRuneThenError)
	PutReturnOfError(*ReturnOfError)

	GetChReturnOfError() chan *ReturnOfError
	PutChReturnOfError(chan *ReturnOfError)
}

type PoolOfRuneThenErrorImpl struct {
	RuneArg         sync.Pool
	ErrorRtn        sync.Pool
	RuneWork        sync.Pool
	ErrorReturn     sync.Pool
	ChReturnOfError sync.Pool
}

func (__ *PoolOfRuneThenErrorImpl) GetRuneArg() *rune {
	return __.RuneArg.Get().(*rune)
}
func (__ *PoolOfRuneThenErrorImpl) PutRuneArg(p *rune) {
	__.RuneArg.Put(p)
}
func (__ *PoolOfRuneThenErrorImpl) GetErrorReturn() *error {
	return __.ErrorRtn.Get().(*error)
}
func (__ *PoolOfRuneThenErrorImpl) PutErrorReturn(p *error) {
	__.ErrorRtn.Put(p)
}

func (__ *PoolOfRuneThenErrorImpl) GetWorkOfRuneThenError() *WorkOfRuneThenError {
	return __.RuneWork.Get().(*WorkOfRuneThenError)
}
func (__ *PoolOfRuneThenErrorImpl) PutWorkOfRuneThenError(p *WorkOfRuneThenError) {
	__.RuneWork.Put(p)
}
func (__ *PoolOfRuneThenErrorImpl) GetReturnOfError() *ReturnOfError {
	return __.ErrorReturn.Get().(*ReturnOfError)
}
func (__ *PoolOfRuneThenErrorImpl) PutReturnOfError(p *ReturnOfError) {
	__.ErrorReturn.Put(p)
}

func (__ *PoolOfRuneThenErrorImpl) GetChReturnOfError() chan *ReturnOfError {
	return __.ChReturnOfError.Get().(chan *ReturnOfError)
}
func (__ *PoolOfRuneThenErrorImpl) PutChReturnOfError(p chan *ReturnOfError) {
	__.ChReturnOfError.Put(p)
}

func NewPoolOfRuneThenErrorImpl() *PoolOfRuneThenErrorImpl {
	return &PoolOfRuneThenErrorImpl{
		RuneArg: sync.Pool{
			New: func() interface{} {
				return new(rune)
			},
		},
		RuneWork: sync.Pool{
			New: func() interface{} {
				return new(WorkOfRuneThenError)
			},
		},
		ErrorRtn: sync.Pool{
			New: func() interface{} {
				return new(error)
			},
		},
		ErrorReturn: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfError)
			},
		},
		ChReturnOfError: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfError, 1)
			},
		},
	}
}

type ApiDecouplerOfRuneThenError struct {
	pool PoolOfRuneThenError
}

func NewApiDecouplerOfRuneThenError() *ApiDecouplerOfRuneThenError {
	return &ApiDecouplerOfRuneThenError{
		pool: NewPoolOfRuneThenErrorImpl(),
	}
}

func (__ *ApiDecouplerOfRuneThenError) ReturnError(rtn_ch chan<- *ReturnOfError, err error) {
	rtn := __.pool.GetReturnOfError()
	var other error
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfRuneThenError) HandleOfRuneThenError(ctx context.Context, req *WorkOfRuneThenError, h func(ctx context.Context, arg rune) (error, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfError()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfRuneThenError) DoOfRuneThenError(ctx context.Context, worker WorkerOfPushRuneThenError, arg rune) (error, error) {
	// ch := make(chan *ReturnOfError, 1)
	ch := __.pool.GetChReturnOfError()
	defer __.pool.PutChReturnOfError(ch)

	req := __.pool.GetWorkOfRuneThenError()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfRuneThenError(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfError(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfRuneThenError = func(ctx context.Context, arg rune) (error, error)

type WorkerOfRuneThenError struct {
	api_syncer *ApiDecouplerOfRuneThenError
	handler    WorkHandlerOfRuneThenError

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfRuneThenError
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfRuneThenError(ctx context.Context, h WorkHandlerOfRuneThenError, n int) *WorkerOfRuneThenError {
	__ := &WorkerOfRuneThenError{
		api_syncer: NewApiDecouplerOfRuneThenError(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfRuneThenError, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfRuneThenError{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfRuneThenError(req.Context, req.WorkOfRuneThenError, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfRuneThenError) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfRuneThenError) Push(ctx context.Context, req *WorkOfRuneThenError) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfRuneThenError)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfRuneThenError = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfRuneThenError) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfRuneThenError) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfRuneThenError) Call(ctx context.Context, arg rune) (error, error) {
	return __.api_syncer.DoOfRuneThenError(ctx, __, arg)
}

type PoolOfRuneThenFloat32 interface {
	GetRuneArg() *rune
	PutRuneArg(*rune)
	GetFloat32Return() *float32
	PutFloat32Return(*float32)

	GetWorkOfRuneThenFloat32() *WorkOfRuneThenFloat32
	GetReturnOfFloat32() *ReturnOfFloat32
	PutWorkOfRuneThenFloat32(*WorkOfRuneThenFloat32)
	PutReturnOfFloat32(*ReturnOfFloat32)

	GetChReturnOfFloat32() chan *ReturnOfFloat32
	PutChReturnOfFloat32(chan *ReturnOfFloat32)
}

type PoolOfRuneThenFloat32Impl struct {
	RuneArg           sync.Pool
	Float32Rtn        sync.Pool
	RuneWork          sync.Pool
	Float32Return     sync.Pool
	ChReturnOfFloat32 sync.Pool
}

func (__ *PoolOfRuneThenFloat32Impl) GetRuneArg() *rune {
	return __.RuneArg.Get().(*rune)
}
func (__ *PoolOfRuneThenFloat32Impl) PutRuneArg(p *rune) {
	__.RuneArg.Put(p)
}
func (__ *PoolOfRuneThenFloat32Impl) GetFloat32Return() *float32 {
	return __.Float32Rtn.Get().(*float32)
}
func (__ *PoolOfRuneThenFloat32Impl) PutFloat32Return(p *float32) {
	__.Float32Rtn.Put(p)
}

func (__ *PoolOfRuneThenFloat32Impl) GetWorkOfRuneThenFloat32() *WorkOfRuneThenFloat32 {
	return __.RuneWork.Get().(*WorkOfRuneThenFloat32)
}
func (__ *PoolOfRuneThenFloat32Impl) PutWorkOfRuneThenFloat32(p *WorkOfRuneThenFloat32) {
	__.RuneWork.Put(p)
}
func (__ *PoolOfRuneThenFloat32Impl) GetReturnOfFloat32() *ReturnOfFloat32 {
	return __.Float32Return.Get().(*ReturnOfFloat32)
}
func (__ *PoolOfRuneThenFloat32Impl) PutReturnOfFloat32(p *ReturnOfFloat32) {
	__.Float32Return.Put(p)
}

func (__ *PoolOfRuneThenFloat32Impl) GetChReturnOfFloat32() chan *ReturnOfFloat32 {
	return __.ChReturnOfFloat32.Get().(chan *ReturnOfFloat32)
}
func (__ *PoolOfRuneThenFloat32Impl) PutChReturnOfFloat32(p chan *ReturnOfFloat32) {
	__.ChReturnOfFloat32.Put(p)
}

func NewPoolOfRuneThenFloat32Impl() *PoolOfRuneThenFloat32Impl {
	return &PoolOfRuneThenFloat32Impl{
		RuneArg: sync.Pool{
			New: func() interface{} {
				return new(rune)
			},
		},
		RuneWork: sync.Pool{
			New: func() interface{} {
				return new(WorkOfRuneThenFloat32)
			},
		},
		Float32Rtn: sync.Pool{
			New: func() interface{} {
				return new(float32)
			},
		},
		Float32Return: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfFloat32)
			},
		},
		ChReturnOfFloat32: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfFloat32, 1)
			},
		},
	}
}

type ApiDecouplerOfRuneThenFloat32 struct {
	pool PoolOfRuneThenFloat32
}

func NewApiDecouplerOfRuneThenFloat32() *ApiDecouplerOfRuneThenFloat32 {
	return &ApiDecouplerOfRuneThenFloat32{
		pool: NewPoolOfRuneThenFloat32Impl(),
	}
}

func (__ *ApiDecouplerOfRuneThenFloat32) ReturnError(rtn_ch chan<- *ReturnOfFloat32, err error) {
	rtn := __.pool.GetReturnOfFloat32()
	var other float32
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfRuneThenFloat32) HandleOfRuneThenFloat32(ctx context.Context, req *WorkOfRuneThenFloat32, h func(ctx context.Context, arg rune) (float32, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfFloat32()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfRuneThenFloat32) DoOfRuneThenFloat32(ctx context.Context, worker WorkerOfPushRuneThenFloat32, arg rune) (float32, error) {
	// ch := make(chan *ReturnOfFloat32, 1)
	ch := __.pool.GetChReturnOfFloat32()
	defer __.pool.PutChReturnOfFloat32(ch)

	req := __.pool.GetWorkOfRuneThenFloat32()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfRuneThenFloat32(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfFloat32(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfRuneThenFloat32 = func(ctx context.Context, arg rune) (float32, error)

type WorkerOfRuneThenFloat32 struct {
	api_syncer *ApiDecouplerOfRuneThenFloat32
	handler    WorkHandlerOfRuneThenFloat32

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfRuneThenFloat32
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfRuneThenFloat32(ctx context.Context, h WorkHandlerOfRuneThenFloat32, n int) *WorkerOfRuneThenFloat32 {
	__ := &WorkerOfRuneThenFloat32{
		api_syncer: NewApiDecouplerOfRuneThenFloat32(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfRuneThenFloat32, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfRuneThenFloat32{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfRuneThenFloat32(req.Context, req.WorkOfRuneThenFloat32, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfRuneThenFloat32) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfRuneThenFloat32) Push(ctx context.Context, req *WorkOfRuneThenFloat32) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfRuneThenFloat32)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfRuneThenFloat32 = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfRuneThenFloat32) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfRuneThenFloat32) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfRuneThenFloat32) Call(ctx context.Context, arg rune) (float32, error) {
	return __.api_syncer.DoOfRuneThenFloat32(ctx, __, arg)
}

type PoolOfRuneThenFloat64 interface {
	GetRuneArg() *rune
	PutRuneArg(*rune)
	GetFloat64Return() *float64
	PutFloat64Return(*float64)

	GetWorkOfRuneThenFloat64() *WorkOfRuneThenFloat64
	GetReturnOfFloat64() *ReturnOfFloat64
	PutWorkOfRuneThenFloat64(*WorkOfRuneThenFloat64)
	PutReturnOfFloat64(*ReturnOfFloat64)

	GetChReturnOfFloat64() chan *ReturnOfFloat64
	PutChReturnOfFloat64(chan *ReturnOfFloat64)
}

type PoolOfRuneThenFloat64Impl struct {
	RuneArg           sync.Pool
	Float64Rtn        sync.Pool
	RuneWork          sync.Pool
	Float64Return     sync.Pool
	ChReturnOfFloat64 sync.Pool
}

func (__ *PoolOfRuneThenFloat64Impl) GetRuneArg() *rune {
	return __.RuneArg.Get().(*rune)
}
func (__ *PoolOfRuneThenFloat64Impl) PutRuneArg(p *rune) {
	__.RuneArg.Put(p)
}
func (__ *PoolOfRuneThenFloat64Impl) GetFloat64Return() *float64 {
	return __.Float64Rtn.Get().(*float64)
}
func (__ *PoolOfRuneThenFloat64Impl) PutFloat64Return(p *float64) {
	__.Float64Rtn.Put(p)
}

func (__ *PoolOfRuneThenFloat64Impl) GetWorkOfRuneThenFloat64() *WorkOfRuneThenFloat64 {
	return __.RuneWork.Get().(*WorkOfRuneThenFloat64)
}
func (__ *PoolOfRuneThenFloat64Impl) PutWorkOfRuneThenFloat64(p *WorkOfRuneThenFloat64) {
	__.RuneWork.Put(p)
}
func (__ *PoolOfRuneThenFloat64Impl) GetReturnOfFloat64() *ReturnOfFloat64 {
	return __.Float64Return.Get().(*ReturnOfFloat64)
}
func (__ *PoolOfRuneThenFloat64Impl) PutReturnOfFloat64(p *ReturnOfFloat64) {
	__.Float64Return.Put(p)
}

func (__ *PoolOfRuneThenFloat64Impl) GetChReturnOfFloat64() chan *ReturnOfFloat64 {
	return __.ChReturnOfFloat64.Get().(chan *ReturnOfFloat64)
}
func (__ *PoolOfRuneThenFloat64Impl) PutChReturnOfFloat64(p chan *ReturnOfFloat64) {
	__.ChReturnOfFloat64.Put(p)
}

func NewPoolOfRuneThenFloat64Impl() *PoolOfRuneThenFloat64Impl {
	return &PoolOfRuneThenFloat64Impl{
		RuneArg: sync.Pool{
			New: func() interface{} {
				return new(rune)
			},
		},
		RuneWork: sync.Pool{
			New: func() interface{} {
				return new(WorkOfRuneThenFloat64)
			},
		},
		Float64Rtn: sync.Pool{
			New: func() interface{} {
				return new(float64)
			},
		},
		Float64Return: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfFloat64)
			},
		},
		ChReturnOfFloat64: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfFloat64, 1)
			},
		},
	}
}

type ApiDecouplerOfRuneThenFloat64 struct {
	pool PoolOfRuneThenFloat64
}

func NewApiDecouplerOfRuneThenFloat64() *ApiDecouplerOfRuneThenFloat64 {
	return &ApiDecouplerOfRuneThenFloat64{
		pool: NewPoolOfRuneThenFloat64Impl(),
	}
}

func (__ *ApiDecouplerOfRuneThenFloat64) ReturnError(rtn_ch chan<- *ReturnOfFloat64, err error) {
	rtn := __.pool.GetReturnOfFloat64()
	var other float64
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfRuneThenFloat64) HandleOfRuneThenFloat64(ctx context.Context, req *WorkOfRuneThenFloat64, h func(ctx context.Context, arg rune) (float64, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfFloat64()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfRuneThenFloat64) DoOfRuneThenFloat64(ctx context.Context, worker WorkerOfPushRuneThenFloat64, arg rune) (float64, error) {
	// ch := make(chan *ReturnOfFloat64, 1)
	ch := __.pool.GetChReturnOfFloat64()
	defer __.pool.PutChReturnOfFloat64(ch)

	req := __.pool.GetWorkOfRuneThenFloat64()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfRuneThenFloat64(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfFloat64(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfRuneThenFloat64 = func(ctx context.Context, arg rune) (float64, error)

type WorkerOfRuneThenFloat64 struct {
	api_syncer *ApiDecouplerOfRuneThenFloat64
	handler    WorkHandlerOfRuneThenFloat64

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfRuneThenFloat64
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfRuneThenFloat64(ctx context.Context, h WorkHandlerOfRuneThenFloat64, n int) *WorkerOfRuneThenFloat64 {
	__ := &WorkerOfRuneThenFloat64{
		api_syncer: NewApiDecouplerOfRuneThenFloat64(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfRuneThenFloat64, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfRuneThenFloat64{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfRuneThenFloat64(req.Context, req.WorkOfRuneThenFloat64, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfRuneThenFloat64) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfRuneThenFloat64) Push(ctx context.Context, req *WorkOfRuneThenFloat64) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfRuneThenFloat64)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfRuneThenFloat64 = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfRuneThenFloat64) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfRuneThenFloat64) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfRuneThenFloat64) Call(ctx context.Context, arg rune) (float64, error) {
	return __.api_syncer.DoOfRuneThenFloat64(ctx, __, arg)
}

type PoolOfRuneThenInt interface {
	GetRuneArg() *rune
	PutRuneArg(*rune)
	GetIntReturn() *int
	PutIntReturn(*int)

	GetWorkOfRuneThenInt() *WorkOfRuneThenInt
	GetReturnOfInt() *ReturnOfInt
	PutWorkOfRuneThenInt(*WorkOfRuneThenInt)
	PutReturnOfInt(*ReturnOfInt)

	GetChReturnOfInt() chan *ReturnOfInt
	PutChReturnOfInt(chan *ReturnOfInt)
}

type PoolOfRuneThenIntImpl struct {
	RuneArg       sync.Pool
	IntRtn        sync.Pool
	RuneWork      sync.Pool
	IntReturn     sync.Pool
	ChReturnOfInt sync.Pool
}

func (__ *PoolOfRuneThenIntImpl) GetRuneArg() *rune {
	return __.RuneArg.Get().(*rune)
}
func (__ *PoolOfRuneThenIntImpl) PutRuneArg(p *rune) {
	__.RuneArg.Put(p)
}
func (__ *PoolOfRuneThenIntImpl) GetIntReturn() *int {
	return __.IntRtn.Get().(*int)
}
func (__ *PoolOfRuneThenIntImpl) PutIntReturn(p *int) {
	__.IntRtn.Put(p)
}

func (__ *PoolOfRuneThenIntImpl) GetWorkOfRuneThenInt() *WorkOfRuneThenInt {
	return __.RuneWork.Get().(*WorkOfRuneThenInt)
}
func (__ *PoolOfRuneThenIntImpl) PutWorkOfRuneThenInt(p *WorkOfRuneThenInt) {
	__.RuneWork.Put(p)
}
func (__ *PoolOfRuneThenIntImpl) GetReturnOfInt() *ReturnOfInt {
	return __.IntReturn.Get().(*ReturnOfInt)
}
func (__ *PoolOfRuneThenIntImpl) PutReturnOfInt(p *ReturnOfInt) {
	__.IntReturn.Put(p)
}

func (__ *PoolOfRuneThenIntImpl) GetChReturnOfInt() chan *ReturnOfInt {
	return __.ChReturnOfInt.Get().(chan *ReturnOfInt)
}
func (__ *PoolOfRuneThenIntImpl) PutChReturnOfInt(p chan *ReturnOfInt) {
	__.ChReturnOfInt.Put(p)
}

func NewPoolOfRuneThenIntImpl() *PoolOfRuneThenIntImpl {
	return &PoolOfRuneThenIntImpl{
		RuneArg: sync.Pool{
			New: func() interface{} {
				return new(rune)
			},
		},
		RuneWork: sync.Pool{
			New: func() interface{} {
				return new(WorkOfRuneThenInt)
			},
		},
		IntRtn: sync.Pool{
			New: func() interface{} {
				return new(int)
			},
		},
		IntReturn: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfInt)
			},
		},
		ChReturnOfInt: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfInt, 1)
			},
		},
	}
}

type ApiDecouplerOfRuneThenInt struct {
	pool PoolOfRuneThenInt
}

func NewApiDecouplerOfRuneThenInt() *ApiDecouplerOfRuneThenInt {
	return &ApiDecouplerOfRuneThenInt{
		pool: NewPoolOfRuneThenIntImpl(),
	}
}

func (__ *ApiDecouplerOfRuneThenInt) ReturnError(rtn_ch chan<- *ReturnOfInt, err error) {
	rtn := __.pool.GetReturnOfInt()
	var other int
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfRuneThenInt) HandleOfRuneThenInt(ctx context.Context, req *WorkOfRuneThenInt, h func(ctx context.Context, arg rune) (int, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfInt()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfRuneThenInt) DoOfRuneThenInt(ctx context.Context, worker WorkerOfPushRuneThenInt, arg rune) (int, error) {
	// ch := make(chan *ReturnOfInt, 1)
	ch := __.pool.GetChReturnOfInt()
	defer __.pool.PutChReturnOfInt(ch)

	req := __.pool.GetWorkOfRuneThenInt()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfRuneThenInt(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfInt(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfRuneThenInt = func(ctx context.Context, arg rune) (int, error)

type WorkerOfRuneThenInt struct {
	api_syncer *ApiDecouplerOfRuneThenInt
	handler    WorkHandlerOfRuneThenInt

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfRuneThenInt
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfRuneThenInt(ctx context.Context, h WorkHandlerOfRuneThenInt, n int) *WorkerOfRuneThenInt {
	__ := &WorkerOfRuneThenInt{
		api_syncer: NewApiDecouplerOfRuneThenInt(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfRuneThenInt, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfRuneThenInt{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfRuneThenInt(req.Context, req.WorkOfRuneThenInt, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfRuneThenInt) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfRuneThenInt) Push(ctx context.Context, req *WorkOfRuneThenInt) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfRuneThenInt)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfRuneThenInt = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfRuneThenInt) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfRuneThenInt) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfRuneThenInt) Call(ctx context.Context, arg rune) (int, error) {
	return __.api_syncer.DoOfRuneThenInt(ctx, __, arg)
}

type PoolOfRuneThenInt16 interface {
	GetRuneArg() *rune
	PutRuneArg(*rune)
	GetInt16Return() *int16
	PutInt16Return(*int16)

	GetWorkOfRuneThenInt16() *WorkOfRuneThenInt16
	GetReturnOfInt16() *ReturnOfInt16
	PutWorkOfRuneThenInt16(*WorkOfRuneThenInt16)
	PutReturnOfInt16(*ReturnOfInt16)

	GetChReturnOfInt16() chan *ReturnOfInt16
	PutChReturnOfInt16(chan *ReturnOfInt16)
}

type PoolOfRuneThenInt16Impl struct {
	RuneArg         sync.Pool
	Int16Rtn        sync.Pool
	RuneWork        sync.Pool
	Int16Return     sync.Pool
	ChReturnOfInt16 sync.Pool
}

func (__ *PoolOfRuneThenInt16Impl) GetRuneArg() *rune {
	return __.RuneArg.Get().(*rune)
}
func (__ *PoolOfRuneThenInt16Impl) PutRuneArg(p *rune) {
	__.RuneArg.Put(p)
}
func (__ *PoolOfRuneThenInt16Impl) GetInt16Return() *int16 {
	return __.Int16Rtn.Get().(*int16)
}
func (__ *PoolOfRuneThenInt16Impl) PutInt16Return(p *int16) {
	__.Int16Rtn.Put(p)
}

func (__ *PoolOfRuneThenInt16Impl) GetWorkOfRuneThenInt16() *WorkOfRuneThenInt16 {
	return __.RuneWork.Get().(*WorkOfRuneThenInt16)
}
func (__ *PoolOfRuneThenInt16Impl) PutWorkOfRuneThenInt16(p *WorkOfRuneThenInt16) {
	__.RuneWork.Put(p)
}
func (__ *PoolOfRuneThenInt16Impl) GetReturnOfInt16() *ReturnOfInt16 {
	return __.Int16Return.Get().(*ReturnOfInt16)
}
func (__ *PoolOfRuneThenInt16Impl) PutReturnOfInt16(p *ReturnOfInt16) {
	__.Int16Return.Put(p)
}

func (__ *PoolOfRuneThenInt16Impl) GetChReturnOfInt16() chan *ReturnOfInt16 {
	return __.ChReturnOfInt16.Get().(chan *ReturnOfInt16)
}
func (__ *PoolOfRuneThenInt16Impl) PutChReturnOfInt16(p chan *ReturnOfInt16) {
	__.ChReturnOfInt16.Put(p)
}

func NewPoolOfRuneThenInt16Impl() *PoolOfRuneThenInt16Impl {
	return &PoolOfRuneThenInt16Impl{
		RuneArg: sync.Pool{
			New: func() interface{} {
				return new(rune)
			},
		},
		RuneWork: sync.Pool{
			New: func() interface{} {
				return new(WorkOfRuneThenInt16)
			},
		},
		Int16Rtn: sync.Pool{
			New: func() interface{} {
				return new(int16)
			},
		},
		Int16Return: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfInt16)
			},
		},
		ChReturnOfInt16: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfInt16, 1)
			},
		},
	}
}

type ApiDecouplerOfRuneThenInt16 struct {
	pool PoolOfRuneThenInt16
}

func NewApiDecouplerOfRuneThenInt16() *ApiDecouplerOfRuneThenInt16 {
	return &ApiDecouplerOfRuneThenInt16{
		pool: NewPoolOfRuneThenInt16Impl(),
	}
}

func (__ *ApiDecouplerOfRuneThenInt16) ReturnError(rtn_ch chan<- *ReturnOfInt16, err error) {
	rtn := __.pool.GetReturnOfInt16()
	var other int16
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfRuneThenInt16) HandleOfRuneThenInt16(ctx context.Context, req *WorkOfRuneThenInt16, h func(ctx context.Context, arg rune) (int16, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfInt16()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfRuneThenInt16) DoOfRuneThenInt16(ctx context.Context, worker WorkerOfPushRuneThenInt16, arg rune) (int16, error) {
	// ch := make(chan *ReturnOfInt16, 1)
	ch := __.pool.GetChReturnOfInt16()
	defer __.pool.PutChReturnOfInt16(ch)

	req := __.pool.GetWorkOfRuneThenInt16()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfRuneThenInt16(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfInt16(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfRuneThenInt16 = func(ctx context.Context, arg rune) (int16, error)

type WorkerOfRuneThenInt16 struct {
	api_syncer *ApiDecouplerOfRuneThenInt16
	handler    WorkHandlerOfRuneThenInt16

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfRuneThenInt16
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfRuneThenInt16(ctx context.Context, h WorkHandlerOfRuneThenInt16, n int) *WorkerOfRuneThenInt16 {
	__ := &WorkerOfRuneThenInt16{
		api_syncer: NewApiDecouplerOfRuneThenInt16(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfRuneThenInt16, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfRuneThenInt16{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfRuneThenInt16(req.Context, req.WorkOfRuneThenInt16, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfRuneThenInt16) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfRuneThenInt16) Push(ctx context.Context, req *WorkOfRuneThenInt16) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfRuneThenInt16)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfRuneThenInt16 = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfRuneThenInt16) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfRuneThenInt16) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfRuneThenInt16) Call(ctx context.Context, arg rune) (int16, error) {
	return __.api_syncer.DoOfRuneThenInt16(ctx, __, arg)
}

type PoolOfRuneThenInt32 interface {
	GetRuneArg() *rune
	PutRuneArg(*rune)
	GetInt32Return() *int32
	PutInt32Return(*int32)

	GetWorkOfRuneThenInt32() *WorkOfRuneThenInt32
	GetReturnOfInt32() *ReturnOfInt32
	PutWorkOfRuneThenInt32(*WorkOfRuneThenInt32)
	PutReturnOfInt32(*ReturnOfInt32)

	GetChReturnOfInt32() chan *ReturnOfInt32
	PutChReturnOfInt32(chan *ReturnOfInt32)
}

type PoolOfRuneThenInt32Impl struct {
	RuneArg         sync.Pool
	Int32Rtn        sync.Pool
	RuneWork        sync.Pool
	Int32Return     sync.Pool
	ChReturnOfInt32 sync.Pool
}

func (__ *PoolOfRuneThenInt32Impl) GetRuneArg() *rune {
	return __.RuneArg.Get().(*rune)
}
func (__ *PoolOfRuneThenInt32Impl) PutRuneArg(p *rune) {
	__.RuneArg.Put(p)
}
func (__ *PoolOfRuneThenInt32Impl) GetInt32Return() *int32 {
	return __.Int32Rtn.Get().(*int32)
}
func (__ *PoolOfRuneThenInt32Impl) PutInt32Return(p *int32) {
	__.Int32Rtn.Put(p)
}

func (__ *PoolOfRuneThenInt32Impl) GetWorkOfRuneThenInt32() *WorkOfRuneThenInt32 {
	return __.RuneWork.Get().(*WorkOfRuneThenInt32)
}
func (__ *PoolOfRuneThenInt32Impl) PutWorkOfRuneThenInt32(p *WorkOfRuneThenInt32) {
	__.RuneWork.Put(p)
}
func (__ *PoolOfRuneThenInt32Impl) GetReturnOfInt32() *ReturnOfInt32 {
	return __.Int32Return.Get().(*ReturnOfInt32)
}
func (__ *PoolOfRuneThenInt32Impl) PutReturnOfInt32(p *ReturnOfInt32) {
	__.Int32Return.Put(p)
}

func (__ *PoolOfRuneThenInt32Impl) GetChReturnOfInt32() chan *ReturnOfInt32 {
	return __.ChReturnOfInt32.Get().(chan *ReturnOfInt32)
}
func (__ *PoolOfRuneThenInt32Impl) PutChReturnOfInt32(p chan *ReturnOfInt32) {
	__.ChReturnOfInt32.Put(p)
}

func NewPoolOfRuneThenInt32Impl() *PoolOfRuneThenInt32Impl {
	return &PoolOfRuneThenInt32Impl{
		RuneArg: sync.Pool{
			New: func() interface{} {
				return new(rune)
			},
		},
		RuneWork: sync.Pool{
			New: func() interface{} {
				return new(WorkOfRuneThenInt32)
			},
		},
		Int32Rtn: sync.Pool{
			New: func() interface{} {
				return new(int32)
			},
		},
		Int32Return: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfInt32)
			},
		},
		ChReturnOfInt32: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfInt32, 1)
			},
		},
	}
}

type ApiDecouplerOfRuneThenInt32 struct {
	pool PoolOfRuneThenInt32
}

func NewApiDecouplerOfRuneThenInt32() *ApiDecouplerOfRuneThenInt32 {
	return &ApiDecouplerOfRuneThenInt32{
		pool: NewPoolOfRuneThenInt32Impl(),
	}
}

func (__ *ApiDecouplerOfRuneThenInt32) ReturnError(rtn_ch chan<- *ReturnOfInt32, err error) {
	rtn := __.pool.GetReturnOfInt32()
	var other int32
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfRuneThenInt32) HandleOfRuneThenInt32(ctx context.Context, req *WorkOfRuneThenInt32, h func(ctx context.Context, arg rune) (int32, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfInt32()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfRuneThenInt32) DoOfRuneThenInt32(ctx context.Context, worker WorkerOfPushRuneThenInt32, arg rune) (int32, error) {
	// ch := make(chan *ReturnOfInt32, 1)
	ch := __.pool.GetChReturnOfInt32()
	defer __.pool.PutChReturnOfInt32(ch)

	req := __.pool.GetWorkOfRuneThenInt32()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfRuneThenInt32(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfInt32(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfRuneThenInt32 = func(ctx context.Context, arg rune) (int32, error)

type WorkerOfRuneThenInt32 struct {
	api_syncer *ApiDecouplerOfRuneThenInt32
	handler    WorkHandlerOfRuneThenInt32

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfRuneThenInt32
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfRuneThenInt32(ctx context.Context, h WorkHandlerOfRuneThenInt32, n int) *WorkerOfRuneThenInt32 {
	__ := &WorkerOfRuneThenInt32{
		api_syncer: NewApiDecouplerOfRuneThenInt32(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfRuneThenInt32, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfRuneThenInt32{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfRuneThenInt32(req.Context, req.WorkOfRuneThenInt32, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfRuneThenInt32) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfRuneThenInt32) Push(ctx context.Context, req *WorkOfRuneThenInt32) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfRuneThenInt32)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfRuneThenInt32 = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfRuneThenInt32) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfRuneThenInt32) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfRuneThenInt32) Call(ctx context.Context, arg rune) (int32, error) {
	return __.api_syncer.DoOfRuneThenInt32(ctx, __, arg)
}

type PoolOfRuneThenInt64 interface {
	GetRuneArg() *rune
	PutRuneArg(*rune)
	GetInt64Return() *int64
	PutInt64Return(*int64)

	GetWorkOfRuneThenInt64() *WorkOfRuneThenInt64
	GetReturnOfInt64() *ReturnOfInt64
	PutWorkOfRuneThenInt64(*WorkOfRuneThenInt64)
	PutReturnOfInt64(*ReturnOfInt64)

	GetChReturnOfInt64() chan *ReturnOfInt64
	PutChReturnOfInt64(chan *ReturnOfInt64)
}

type PoolOfRuneThenInt64Impl struct {
	RuneArg         sync.Pool
	Int64Rtn        sync.Pool
	RuneWork        sync.Pool
	Int64Return     sync.Pool
	ChReturnOfInt64 sync.Pool
}

func (__ *PoolOfRuneThenInt64Impl) GetRuneArg() *rune {
	return __.RuneArg.Get().(*rune)
}
func (__ *PoolOfRuneThenInt64Impl) PutRuneArg(p *rune) {
	__.RuneArg.Put(p)
}
func (__ *PoolOfRuneThenInt64Impl) GetInt64Return() *int64 {
	return __.Int64Rtn.Get().(*int64)
}
func (__ *PoolOfRuneThenInt64Impl) PutInt64Return(p *int64) {
	__.Int64Rtn.Put(p)
}

func (__ *PoolOfRuneThenInt64Impl) GetWorkOfRuneThenInt64() *WorkOfRuneThenInt64 {
	return __.RuneWork.Get().(*WorkOfRuneThenInt64)
}
func (__ *PoolOfRuneThenInt64Impl) PutWorkOfRuneThenInt64(p *WorkOfRuneThenInt64) {
	__.RuneWork.Put(p)
}
func (__ *PoolOfRuneThenInt64Impl) GetReturnOfInt64() *ReturnOfInt64 {
	return __.Int64Return.Get().(*ReturnOfInt64)
}
func (__ *PoolOfRuneThenInt64Impl) PutReturnOfInt64(p *ReturnOfInt64) {
	__.Int64Return.Put(p)
}

func (__ *PoolOfRuneThenInt64Impl) GetChReturnOfInt64() chan *ReturnOfInt64 {
	return __.ChReturnOfInt64.Get().(chan *ReturnOfInt64)
}
func (__ *PoolOfRuneThenInt64Impl) PutChReturnOfInt64(p chan *ReturnOfInt64) {
	__.ChReturnOfInt64.Put(p)
}

func NewPoolOfRuneThenInt64Impl() *PoolOfRuneThenInt64Impl {
	return &PoolOfRuneThenInt64Impl{
		RuneArg: sync.Pool{
			New: func() interface{} {
				return new(rune)
			},
		},
		RuneWork: sync.Pool{
			New: func() interface{} {
				return new(WorkOfRuneThenInt64)
			},
		},
		Int64Rtn: sync.Pool{
			New: func() interface{} {
				return new(int64)
			},
		},
		Int64Return: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfInt64)
			},
		},
		ChReturnOfInt64: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfInt64, 1)
			},
		},
	}
}

type ApiDecouplerOfRuneThenInt64 struct {
	pool PoolOfRuneThenInt64
}

func NewApiDecouplerOfRuneThenInt64() *ApiDecouplerOfRuneThenInt64 {
	return &ApiDecouplerOfRuneThenInt64{
		pool: NewPoolOfRuneThenInt64Impl(),
	}
}

func (__ *ApiDecouplerOfRuneThenInt64) ReturnError(rtn_ch chan<- *ReturnOfInt64, err error) {
	rtn := __.pool.GetReturnOfInt64()
	var other int64
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfRuneThenInt64) HandleOfRuneThenInt64(ctx context.Context, req *WorkOfRuneThenInt64, h func(ctx context.Context, arg rune) (int64, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfInt64()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfRuneThenInt64) DoOfRuneThenInt64(ctx context.Context, worker WorkerOfPushRuneThenInt64, arg rune) (int64, error) {
	// ch := make(chan *ReturnOfInt64, 1)
	ch := __.pool.GetChReturnOfInt64()
	defer __.pool.PutChReturnOfInt64(ch)

	req := __.pool.GetWorkOfRuneThenInt64()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfRuneThenInt64(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfInt64(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfRuneThenInt64 = func(ctx context.Context, arg rune) (int64, error)

type WorkerOfRuneThenInt64 struct {
	api_syncer *ApiDecouplerOfRuneThenInt64
	handler    WorkHandlerOfRuneThenInt64

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfRuneThenInt64
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfRuneThenInt64(ctx context.Context, h WorkHandlerOfRuneThenInt64, n int) *WorkerOfRuneThenInt64 {
	__ := &WorkerOfRuneThenInt64{
		api_syncer: NewApiDecouplerOfRuneThenInt64(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfRuneThenInt64, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfRuneThenInt64{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfRuneThenInt64(req.Context, req.WorkOfRuneThenInt64, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfRuneThenInt64) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfRuneThenInt64) Push(ctx context.Context, req *WorkOfRuneThenInt64) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfRuneThenInt64)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfRuneThenInt64 = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfRuneThenInt64) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfRuneThenInt64) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfRuneThenInt64) Call(ctx context.Context, arg rune) (int64, error) {
	return __.api_syncer.DoOfRuneThenInt64(ctx, __, arg)
}

type PoolOfRuneThenInt8 interface {
	GetRuneArg() *rune
	PutRuneArg(*rune)
	GetInt8Return() *int8
	PutInt8Return(*int8)

	GetWorkOfRuneThenInt8() *WorkOfRuneThenInt8
	GetReturnOfInt8() *ReturnOfInt8
	PutWorkOfRuneThenInt8(*WorkOfRuneThenInt8)
	PutReturnOfInt8(*ReturnOfInt8)

	GetChReturnOfInt8() chan *ReturnOfInt8
	PutChReturnOfInt8(chan *ReturnOfInt8)
}

type PoolOfRuneThenInt8Impl struct {
	RuneArg        sync.Pool
	Int8Rtn        sync.Pool
	RuneWork       sync.Pool
	Int8Return     sync.Pool
	ChReturnOfInt8 sync.Pool
}

func (__ *PoolOfRuneThenInt8Impl) GetRuneArg() *rune {
	return __.RuneArg.Get().(*rune)
}
func (__ *PoolOfRuneThenInt8Impl) PutRuneArg(p *rune) {
	__.RuneArg.Put(p)
}
func (__ *PoolOfRuneThenInt8Impl) GetInt8Return() *int8 {
	return __.Int8Rtn.Get().(*int8)
}
func (__ *PoolOfRuneThenInt8Impl) PutInt8Return(p *int8) {
	__.Int8Rtn.Put(p)
}

func (__ *PoolOfRuneThenInt8Impl) GetWorkOfRuneThenInt8() *WorkOfRuneThenInt8 {
	return __.RuneWork.Get().(*WorkOfRuneThenInt8)
}
func (__ *PoolOfRuneThenInt8Impl) PutWorkOfRuneThenInt8(p *WorkOfRuneThenInt8) {
	__.RuneWork.Put(p)
}
func (__ *PoolOfRuneThenInt8Impl) GetReturnOfInt8() *ReturnOfInt8 {
	return __.Int8Return.Get().(*ReturnOfInt8)
}
func (__ *PoolOfRuneThenInt8Impl) PutReturnOfInt8(p *ReturnOfInt8) {
	__.Int8Return.Put(p)
}

func (__ *PoolOfRuneThenInt8Impl) GetChReturnOfInt8() chan *ReturnOfInt8 {
	return __.ChReturnOfInt8.Get().(chan *ReturnOfInt8)
}
func (__ *PoolOfRuneThenInt8Impl) PutChReturnOfInt8(p chan *ReturnOfInt8) {
	__.ChReturnOfInt8.Put(p)
}

func NewPoolOfRuneThenInt8Impl() *PoolOfRuneThenInt8Impl {
	return &PoolOfRuneThenInt8Impl{
		RuneArg: sync.Pool{
			New: func() interface{} {
				return new(rune)
			},
		},
		RuneWork: sync.Pool{
			New: func() interface{} {
				return new(WorkOfRuneThenInt8)
			},
		},
		Int8Rtn: sync.Pool{
			New: func() interface{} {
				return new(int8)
			},
		},
		Int8Return: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfInt8)
			},
		},
		ChReturnOfInt8: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfInt8, 1)
			},
		},
	}
}

type ApiDecouplerOfRuneThenInt8 struct {
	pool PoolOfRuneThenInt8
}

func NewApiDecouplerOfRuneThenInt8() *ApiDecouplerOfRuneThenInt8 {
	return &ApiDecouplerOfRuneThenInt8{
		pool: NewPoolOfRuneThenInt8Impl(),
	}
}

func (__ *ApiDecouplerOfRuneThenInt8) ReturnError(rtn_ch chan<- *ReturnOfInt8, err error) {
	rtn := __.pool.GetReturnOfInt8()
	var other int8
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfRuneThenInt8) HandleOfRuneThenInt8(ctx context.Context, req *WorkOfRuneThenInt8, h func(ctx context.Context, arg rune) (int8, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfInt8()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfRuneThenInt8) DoOfRuneThenInt8(ctx context.Context, worker WorkerOfPushRuneThenInt8, arg rune) (int8, error) {
	// ch := make(chan *ReturnOfInt8, 1)
	ch := __.pool.GetChReturnOfInt8()
	defer __.pool.PutChReturnOfInt8(ch)

	req := __.pool.GetWorkOfRuneThenInt8()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfRuneThenInt8(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfInt8(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfRuneThenInt8 = func(ctx context.Context, arg rune) (int8, error)

type WorkerOfRuneThenInt8 struct {
	api_syncer *ApiDecouplerOfRuneThenInt8
	handler    WorkHandlerOfRuneThenInt8

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfRuneThenInt8
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfRuneThenInt8(ctx context.Context, h WorkHandlerOfRuneThenInt8, n int) *WorkerOfRuneThenInt8 {
	__ := &WorkerOfRuneThenInt8{
		api_syncer: NewApiDecouplerOfRuneThenInt8(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfRuneThenInt8, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfRuneThenInt8{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfRuneThenInt8(req.Context, req.WorkOfRuneThenInt8, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfRuneThenInt8) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfRuneThenInt8) Push(ctx context.Context, req *WorkOfRuneThenInt8) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfRuneThenInt8)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfRuneThenInt8 = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfRuneThenInt8) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfRuneThenInt8) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfRuneThenInt8) Call(ctx context.Context, arg rune) (int8, error) {
	return __.api_syncer.DoOfRuneThenInt8(ctx, __, arg)
}

type PoolOfRuneThenRune interface {
	GetRuneArg() *rune
	PutRuneArg(*rune)
	GetRuneReturn() *rune
	PutRuneReturn(*rune)

	GetWorkOfRuneThenRune() *WorkOfRuneThenRune
	GetReturnOfRune() *ReturnOfRune
	PutWorkOfRuneThenRune(*WorkOfRuneThenRune)
	PutReturnOfRune(*ReturnOfRune)

	GetChReturnOfRune() chan *ReturnOfRune
	PutChReturnOfRune(chan *ReturnOfRune)
}

type PoolOfRuneThenRuneImpl struct {
	RuneArg        sync.Pool
	RuneRtn        sync.Pool
	RuneWork       sync.Pool
	RuneReturn     sync.Pool
	ChReturnOfRune sync.Pool
}

func (__ *PoolOfRuneThenRuneImpl) GetRuneArg() *rune {
	return __.RuneArg.Get().(*rune)
}
func (__ *PoolOfRuneThenRuneImpl) PutRuneArg(p *rune) {
	__.RuneArg.Put(p)
}
func (__ *PoolOfRuneThenRuneImpl) GetRuneReturn() *rune {
	return __.RuneRtn.Get().(*rune)
}
func (__ *PoolOfRuneThenRuneImpl) PutRuneReturn(p *rune) {
	__.RuneRtn.Put(p)
}

func (__ *PoolOfRuneThenRuneImpl) GetWorkOfRuneThenRune() *WorkOfRuneThenRune {
	return __.RuneWork.Get().(*WorkOfRuneThenRune)
}
func (__ *PoolOfRuneThenRuneImpl) PutWorkOfRuneThenRune(p *WorkOfRuneThenRune) {
	__.RuneWork.Put(p)
}
func (__ *PoolOfRuneThenRuneImpl) GetReturnOfRune() *ReturnOfRune {
	return __.RuneReturn.Get().(*ReturnOfRune)
}
func (__ *PoolOfRuneThenRuneImpl) PutReturnOfRune(p *ReturnOfRune) {
	__.RuneReturn.Put(p)
}

func (__ *PoolOfRuneThenRuneImpl) GetChReturnOfRune() chan *ReturnOfRune {
	return __.ChReturnOfRune.Get().(chan *ReturnOfRune)
}
func (__ *PoolOfRuneThenRuneImpl) PutChReturnOfRune(p chan *ReturnOfRune) {
	__.ChReturnOfRune.Put(p)
}

func NewPoolOfRuneThenRuneImpl() *PoolOfRuneThenRuneImpl {
	return &PoolOfRuneThenRuneImpl{
		RuneArg: sync.Pool{
			New: func() interface{} {
				return new(rune)
			},
		},
		RuneWork: sync.Pool{
			New: func() interface{} {
				return new(WorkOfRuneThenRune)
			},
		},
		RuneRtn: sync.Pool{
			New: func() interface{} {
				return new(rune)
			},
		},
		RuneReturn: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfRune)
			},
		},
		ChReturnOfRune: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfRune, 1)
			},
		},
	}
}

type ApiDecouplerOfRuneThenRune struct {
	pool PoolOfRuneThenRune
}

func NewApiDecouplerOfRuneThenRune() *ApiDecouplerOfRuneThenRune {
	return &ApiDecouplerOfRuneThenRune{
		pool: NewPoolOfRuneThenRuneImpl(),
	}
}

func (__ *ApiDecouplerOfRuneThenRune) ReturnError(rtn_ch chan<- *ReturnOfRune, err error) {
	rtn := __.pool.GetReturnOfRune()
	var other rune
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfRuneThenRune) HandleOfRuneThenRune(ctx context.Context, req *WorkOfRuneThenRune, h func(ctx context.Context, arg rune) (rune, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfRune()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfRuneThenRune) DoOfRuneThenRune(ctx context.Context, worker WorkerOfPushRuneThenRune, arg rune) (rune, error) {
	// ch := make(chan *ReturnOfRune, 1)
	ch := __.pool.GetChReturnOfRune()
	defer __.pool.PutChReturnOfRune(ch)

	req := __.pool.GetWorkOfRuneThenRune()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfRuneThenRune(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfRune(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfRuneThenRune = func(ctx context.Context, arg rune) (rune, error)

type WorkerOfRuneThenRune struct {
	api_syncer *ApiDecouplerOfRuneThenRune
	handler    WorkHandlerOfRuneThenRune

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfRuneThenRune
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfRuneThenRune(ctx context.Context, h WorkHandlerOfRuneThenRune, n int) *WorkerOfRuneThenRune {
	__ := &WorkerOfRuneThenRune{
		api_syncer: NewApiDecouplerOfRuneThenRune(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfRuneThenRune, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfRuneThenRune{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfRuneThenRune(req.Context, req.WorkOfRuneThenRune, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfRuneThenRune) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfRuneThenRune) Push(ctx context.Context, req *WorkOfRuneThenRune) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfRuneThenRune)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfRuneThenRune = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfRuneThenRune) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfRuneThenRune) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfRuneThenRune) Call(ctx context.Context, arg rune) (rune, error) {
	return __.api_syncer.DoOfRuneThenRune(ctx, __, arg)
}

type PoolOfRuneThenString interface {
	GetRuneArg() *rune
	PutRuneArg(*rune)
	GetStringReturn() *string
	PutStringReturn(*string)

	GetWorkOfRuneThenString() *WorkOfRuneThenString
	GetReturnOfString() *ReturnOfString
	PutWorkOfRuneThenString(*WorkOfRuneThenString)
	PutReturnOfString(*ReturnOfString)

	GetChReturnOfString() chan *ReturnOfString
	PutChReturnOfString(chan *ReturnOfString)
}

type PoolOfRuneThenStringImpl struct {
	RuneArg          sync.Pool
	StringRtn        sync.Pool
	RuneWork         sync.Pool
	StringReturn     sync.Pool
	ChReturnOfString sync.Pool
}

func (__ *PoolOfRuneThenStringImpl) GetRuneArg() *rune {
	return __.RuneArg.Get().(*rune)
}
func (__ *PoolOfRuneThenStringImpl) PutRuneArg(p *rune) {
	__.RuneArg.Put(p)
}
func (__ *PoolOfRuneThenStringImpl) GetStringReturn() *string {
	return __.StringRtn.Get().(*string)
}
func (__ *PoolOfRuneThenStringImpl) PutStringReturn(p *string) {
	__.StringRtn.Put(p)
}

func (__ *PoolOfRuneThenStringImpl) GetWorkOfRuneThenString() *WorkOfRuneThenString {
	return __.RuneWork.Get().(*WorkOfRuneThenString)
}
func (__ *PoolOfRuneThenStringImpl) PutWorkOfRuneThenString(p *WorkOfRuneThenString) {
	__.RuneWork.Put(p)
}
func (__ *PoolOfRuneThenStringImpl) GetReturnOfString() *ReturnOfString {
	return __.StringReturn.Get().(*ReturnOfString)
}
func (__ *PoolOfRuneThenStringImpl) PutReturnOfString(p *ReturnOfString) {
	__.StringReturn.Put(p)
}

func (__ *PoolOfRuneThenStringImpl) GetChReturnOfString() chan *ReturnOfString {
	return __.ChReturnOfString.Get().(chan *ReturnOfString)
}
func (__ *PoolOfRuneThenStringImpl) PutChReturnOfString(p chan *ReturnOfString) {
	__.ChReturnOfString.Put(p)
}

func NewPoolOfRuneThenStringImpl() *PoolOfRuneThenStringImpl {
	return &PoolOfRuneThenStringImpl{
		RuneArg: sync.Pool{
			New: func() interface{} {
				return new(rune)
			},
		},
		RuneWork: sync.Pool{
			New: func() interface{} {
				return new(WorkOfRuneThenString)
			},
		},
		StringRtn: sync.Pool{
			New: func() interface{} {
				return new(string)
			},
		},
		StringReturn: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfString)
			},
		},
		ChReturnOfString: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfString, 1)
			},
		},
	}
}

type ApiDecouplerOfRuneThenString struct {
	pool PoolOfRuneThenString
}

func NewApiDecouplerOfRuneThenString() *ApiDecouplerOfRuneThenString {
	return &ApiDecouplerOfRuneThenString{
		pool: NewPoolOfRuneThenStringImpl(),
	}
}

func (__ *ApiDecouplerOfRuneThenString) ReturnError(rtn_ch chan<- *ReturnOfString, err error) {
	rtn := __.pool.GetReturnOfString()
	var other string
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfRuneThenString) HandleOfRuneThenString(ctx context.Context, req *WorkOfRuneThenString, h func(ctx context.Context, arg rune) (string, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfString()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfRuneThenString) DoOfRuneThenString(ctx context.Context, worker WorkerOfPushRuneThenString, arg rune) (string, error) {
	// ch := make(chan *ReturnOfString, 1)
	ch := __.pool.GetChReturnOfString()
	defer __.pool.PutChReturnOfString(ch)

	req := __.pool.GetWorkOfRuneThenString()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfRuneThenString(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfString(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfRuneThenString = func(ctx context.Context, arg rune) (string, error)

type WorkerOfRuneThenString struct {
	api_syncer *ApiDecouplerOfRuneThenString
	handler    WorkHandlerOfRuneThenString

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfRuneThenString
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfRuneThenString(ctx context.Context, h WorkHandlerOfRuneThenString, n int) *WorkerOfRuneThenString {
	__ := &WorkerOfRuneThenString{
		api_syncer: NewApiDecouplerOfRuneThenString(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfRuneThenString, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfRuneThenString{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfRuneThenString(req.Context, req.WorkOfRuneThenString, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfRuneThenString) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfRuneThenString) Push(ctx context.Context, req *WorkOfRuneThenString) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfRuneThenString)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfRuneThenString = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfRuneThenString) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfRuneThenString) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfRuneThenString) Call(ctx context.Context, arg rune) (string, error) {
	return __.api_syncer.DoOfRuneThenString(ctx, __, arg)
}

type PoolOfRuneThenUint interface {
	GetRuneArg() *rune
	PutRuneArg(*rune)
	GetUintReturn() *uint
	PutUintReturn(*uint)

	GetWorkOfRuneThenUint() *WorkOfRuneThenUint
	GetReturnOfUint() *ReturnOfUint
	PutWorkOfRuneThenUint(*WorkOfRuneThenUint)
	PutReturnOfUint(*ReturnOfUint)

	GetChReturnOfUint() chan *ReturnOfUint
	PutChReturnOfUint(chan *ReturnOfUint)
}

type PoolOfRuneThenUintImpl struct {
	RuneArg        sync.Pool
	UintRtn        sync.Pool
	RuneWork       sync.Pool
	UintReturn     sync.Pool
	ChReturnOfUint sync.Pool
}

func (__ *PoolOfRuneThenUintImpl) GetRuneArg() *rune {
	return __.RuneArg.Get().(*rune)
}
func (__ *PoolOfRuneThenUintImpl) PutRuneArg(p *rune) {
	__.RuneArg.Put(p)
}
func (__ *PoolOfRuneThenUintImpl) GetUintReturn() *uint {
	return __.UintRtn.Get().(*uint)
}
func (__ *PoolOfRuneThenUintImpl) PutUintReturn(p *uint) {
	__.UintRtn.Put(p)
}

func (__ *PoolOfRuneThenUintImpl) GetWorkOfRuneThenUint() *WorkOfRuneThenUint {
	return __.RuneWork.Get().(*WorkOfRuneThenUint)
}
func (__ *PoolOfRuneThenUintImpl) PutWorkOfRuneThenUint(p *WorkOfRuneThenUint) {
	__.RuneWork.Put(p)
}
func (__ *PoolOfRuneThenUintImpl) GetReturnOfUint() *ReturnOfUint {
	return __.UintReturn.Get().(*ReturnOfUint)
}
func (__ *PoolOfRuneThenUintImpl) PutReturnOfUint(p *ReturnOfUint) {
	__.UintReturn.Put(p)
}

func (__ *PoolOfRuneThenUintImpl) GetChReturnOfUint() chan *ReturnOfUint {
	return __.ChReturnOfUint.Get().(chan *ReturnOfUint)
}
func (__ *PoolOfRuneThenUintImpl) PutChReturnOfUint(p chan *ReturnOfUint) {
	__.ChReturnOfUint.Put(p)
}

func NewPoolOfRuneThenUintImpl() *PoolOfRuneThenUintImpl {
	return &PoolOfRuneThenUintImpl{
		RuneArg: sync.Pool{
			New: func() interface{} {
				return new(rune)
			},
		},
		RuneWork: sync.Pool{
			New: func() interface{} {
				return new(WorkOfRuneThenUint)
			},
		},
		UintRtn: sync.Pool{
			New: func() interface{} {
				return new(uint)
			},
		},
		UintReturn: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfUint)
			},
		},
		ChReturnOfUint: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfUint, 1)
			},
		},
	}
}

type ApiDecouplerOfRuneThenUint struct {
	pool PoolOfRuneThenUint
}

func NewApiDecouplerOfRuneThenUint() *ApiDecouplerOfRuneThenUint {
	return &ApiDecouplerOfRuneThenUint{
		pool: NewPoolOfRuneThenUintImpl(),
	}
}

func (__ *ApiDecouplerOfRuneThenUint) ReturnError(rtn_ch chan<- *ReturnOfUint, err error) {
	rtn := __.pool.GetReturnOfUint()
	var other uint
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfRuneThenUint) HandleOfRuneThenUint(ctx context.Context, req *WorkOfRuneThenUint, h func(ctx context.Context, arg rune) (uint, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfUint()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfRuneThenUint) DoOfRuneThenUint(ctx context.Context, worker WorkerOfPushRuneThenUint, arg rune) (uint, error) {
	// ch := make(chan *ReturnOfUint, 1)
	ch := __.pool.GetChReturnOfUint()
	defer __.pool.PutChReturnOfUint(ch)

	req := __.pool.GetWorkOfRuneThenUint()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfRuneThenUint(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfUint(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfRuneThenUint = func(ctx context.Context, arg rune) (uint, error)

type WorkerOfRuneThenUint struct {
	api_syncer *ApiDecouplerOfRuneThenUint
	handler    WorkHandlerOfRuneThenUint

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfRuneThenUint
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfRuneThenUint(ctx context.Context, h WorkHandlerOfRuneThenUint, n int) *WorkerOfRuneThenUint {
	__ := &WorkerOfRuneThenUint{
		api_syncer: NewApiDecouplerOfRuneThenUint(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfRuneThenUint, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfRuneThenUint{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfRuneThenUint(req.Context, req.WorkOfRuneThenUint, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfRuneThenUint) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfRuneThenUint) Push(ctx context.Context, req *WorkOfRuneThenUint) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfRuneThenUint)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfRuneThenUint = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfRuneThenUint) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfRuneThenUint) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfRuneThenUint) Call(ctx context.Context, arg rune) (uint, error) {
	return __.api_syncer.DoOfRuneThenUint(ctx, __, arg)
}

type PoolOfRuneThenUint16 interface {
	GetRuneArg() *rune
	PutRuneArg(*rune)
	GetUint16Return() *uint16
	PutUint16Return(*uint16)

	GetWorkOfRuneThenUint16() *WorkOfRuneThenUint16
	GetReturnOfUint16() *ReturnOfUint16
	PutWorkOfRuneThenUint16(*WorkOfRuneThenUint16)
	PutReturnOfUint16(*ReturnOfUint16)

	GetChReturnOfUint16() chan *ReturnOfUint16
	PutChReturnOfUint16(chan *ReturnOfUint16)
}

type PoolOfRuneThenUint16Impl struct {
	RuneArg          sync.Pool
	Uint16Rtn        sync.Pool
	RuneWork         sync.Pool
	Uint16Return     sync.Pool
	ChReturnOfUint16 sync.Pool
}

func (__ *PoolOfRuneThenUint16Impl) GetRuneArg() *rune {
	return __.RuneArg.Get().(*rune)
}
func (__ *PoolOfRuneThenUint16Impl) PutRuneArg(p *rune) {
	__.RuneArg.Put(p)
}
func (__ *PoolOfRuneThenUint16Impl) GetUint16Return() *uint16 {
	return __.Uint16Rtn.Get().(*uint16)
}
func (__ *PoolOfRuneThenUint16Impl) PutUint16Return(p *uint16) {
	__.Uint16Rtn.Put(p)
}

func (__ *PoolOfRuneThenUint16Impl) GetWorkOfRuneThenUint16() *WorkOfRuneThenUint16 {
	return __.RuneWork.Get().(*WorkOfRuneThenUint16)
}
func (__ *PoolOfRuneThenUint16Impl) PutWorkOfRuneThenUint16(p *WorkOfRuneThenUint16) {
	__.RuneWork.Put(p)
}
func (__ *PoolOfRuneThenUint16Impl) GetReturnOfUint16() *ReturnOfUint16 {
	return __.Uint16Return.Get().(*ReturnOfUint16)
}
func (__ *PoolOfRuneThenUint16Impl) PutReturnOfUint16(p *ReturnOfUint16) {
	__.Uint16Return.Put(p)
}

func (__ *PoolOfRuneThenUint16Impl) GetChReturnOfUint16() chan *ReturnOfUint16 {
	return __.ChReturnOfUint16.Get().(chan *ReturnOfUint16)
}
func (__ *PoolOfRuneThenUint16Impl) PutChReturnOfUint16(p chan *ReturnOfUint16) {
	__.ChReturnOfUint16.Put(p)
}

func NewPoolOfRuneThenUint16Impl() *PoolOfRuneThenUint16Impl {
	return &PoolOfRuneThenUint16Impl{
		RuneArg: sync.Pool{
			New: func() interface{} {
				return new(rune)
			},
		},
		RuneWork: sync.Pool{
			New: func() interface{} {
				return new(WorkOfRuneThenUint16)
			},
		},
		Uint16Rtn: sync.Pool{
			New: func() interface{} {
				return new(uint16)
			},
		},
		Uint16Return: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfUint16)
			},
		},
		ChReturnOfUint16: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfUint16, 1)
			},
		},
	}
}

type ApiDecouplerOfRuneThenUint16 struct {
	pool PoolOfRuneThenUint16
}

func NewApiDecouplerOfRuneThenUint16() *ApiDecouplerOfRuneThenUint16 {
	return &ApiDecouplerOfRuneThenUint16{
		pool: NewPoolOfRuneThenUint16Impl(),
	}
}

func (__ *ApiDecouplerOfRuneThenUint16) ReturnError(rtn_ch chan<- *ReturnOfUint16, err error) {
	rtn := __.pool.GetReturnOfUint16()
	var other uint16
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfRuneThenUint16) HandleOfRuneThenUint16(ctx context.Context, req *WorkOfRuneThenUint16, h func(ctx context.Context, arg rune) (uint16, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfUint16()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfRuneThenUint16) DoOfRuneThenUint16(ctx context.Context, worker WorkerOfPushRuneThenUint16, arg rune) (uint16, error) {
	// ch := make(chan *ReturnOfUint16, 1)
	ch := __.pool.GetChReturnOfUint16()
	defer __.pool.PutChReturnOfUint16(ch)

	req := __.pool.GetWorkOfRuneThenUint16()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfRuneThenUint16(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfUint16(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfRuneThenUint16 = func(ctx context.Context, arg rune) (uint16, error)

type WorkerOfRuneThenUint16 struct {
	api_syncer *ApiDecouplerOfRuneThenUint16
	handler    WorkHandlerOfRuneThenUint16

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfRuneThenUint16
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfRuneThenUint16(ctx context.Context, h WorkHandlerOfRuneThenUint16, n int) *WorkerOfRuneThenUint16 {
	__ := &WorkerOfRuneThenUint16{
		api_syncer: NewApiDecouplerOfRuneThenUint16(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfRuneThenUint16, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfRuneThenUint16{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfRuneThenUint16(req.Context, req.WorkOfRuneThenUint16, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfRuneThenUint16) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfRuneThenUint16) Push(ctx context.Context, req *WorkOfRuneThenUint16) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfRuneThenUint16)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfRuneThenUint16 = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfRuneThenUint16) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfRuneThenUint16) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfRuneThenUint16) Call(ctx context.Context, arg rune) (uint16, error) {
	return __.api_syncer.DoOfRuneThenUint16(ctx, __, arg)
}

type PoolOfRuneThenUint32 interface {
	GetRuneArg() *rune
	PutRuneArg(*rune)
	GetUint32Return() *uint32
	PutUint32Return(*uint32)

	GetWorkOfRuneThenUint32() *WorkOfRuneThenUint32
	GetReturnOfUint32() *ReturnOfUint32
	PutWorkOfRuneThenUint32(*WorkOfRuneThenUint32)
	PutReturnOfUint32(*ReturnOfUint32)

	GetChReturnOfUint32() chan *ReturnOfUint32
	PutChReturnOfUint32(chan *ReturnOfUint32)
}

type PoolOfRuneThenUint32Impl struct {
	RuneArg          sync.Pool
	Uint32Rtn        sync.Pool
	RuneWork         sync.Pool
	Uint32Return     sync.Pool
	ChReturnOfUint32 sync.Pool
}

func (__ *PoolOfRuneThenUint32Impl) GetRuneArg() *rune {
	return __.RuneArg.Get().(*rune)
}
func (__ *PoolOfRuneThenUint32Impl) PutRuneArg(p *rune) {
	__.RuneArg.Put(p)
}
func (__ *PoolOfRuneThenUint32Impl) GetUint32Return() *uint32 {
	return __.Uint32Rtn.Get().(*uint32)
}
func (__ *PoolOfRuneThenUint32Impl) PutUint32Return(p *uint32) {
	__.Uint32Rtn.Put(p)
}

func (__ *PoolOfRuneThenUint32Impl) GetWorkOfRuneThenUint32() *WorkOfRuneThenUint32 {
	return __.RuneWork.Get().(*WorkOfRuneThenUint32)
}
func (__ *PoolOfRuneThenUint32Impl) PutWorkOfRuneThenUint32(p *WorkOfRuneThenUint32) {
	__.RuneWork.Put(p)
}
func (__ *PoolOfRuneThenUint32Impl) GetReturnOfUint32() *ReturnOfUint32 {
	return __.Uint32Return.Get().(*ReturnOfUint32)
}
func (__ *PoolOfRuneThenUint32Impl) PutReturnOfUint32(p *ReturnOfUint32) {
	__.Uint32Return.Put(p)
}

func (__ *PoolOfRuneThenUint32Impl) GetChReturnOfUint32() chan *ReturnOfUint32 {
	return __.ChReturnOfUint32.Get().(chan *ReturnOfUint32)
}
func (__ *PoolOfRuneThenUint32Impl) PutChReturnOfUint32(p chan *ReturnOfUint32) {
	__.ChReturnOfUint32.Put(p)
}

func NewPoolOfRuneThenUint32Impl() *PoolOfRuneThenUint32Impl {
	return &PoolOfRuneThenUint32Impl{
		RuneArg: sync.Pool{
			New: func() interface{} {
				return new(rune)
			},
		},
		RuneWork: sync.Pool{
			New: func() interface{} {
				return new(WorkOfRuneThenUint32)
			},
		},
		Uint32Rtn: sync.Pool{
			New: func() interface{} {
				return new(uint32)
			},
		},
		Uint32Return: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfUint32)
			},
		},
		ChReturnOfUint32: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfUint32, 1)
			},
		},
	}
}

type ApiDecouplerOfRuneThenUint32 struct {
	pool PoolOfRuneThenUint32
}

func NewApiDecouplerOfRuneThenUint32() *ApiDecouplerOfRuneThenUint32 {
	return &ApiDecouplerOfRuneThenUint32{
		pool: NewPoolOfRuneThenUint32Impl(),
	}
}

func (__ *ApiDecouplerOfRuneThenUint32) ReturnError(rtn_ch chan<- *ReturnOfUint32, err error) {
	rtn := __.pool.GetReturnOfUint32()
	var other uint32
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfRuneThenUint32) HandleOfRuneThenUint32(ctx context.Context, req *WorkOfRuneThenUint32, h func(ctx context.Context, arg rune) (uint32, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfUint32()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfRuneThenUint32) DoOfRuneThenUint32(ctx context.Context, worker WorkerOfPushRuneThenUint32, arg rune) (uint32, error) {
	// ch := make(chan *ReturnOfUint32, 1)
	ch := __.pool.GetChReturnOfUint32()
	defer __.pool.PutChReturnOfUint32(ch)

	req := __.pool.GetWorkOfRuneThenUint32()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfRuneThenUint32(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfUint32(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfRuneThenUint32 = func(ctx context.Context, arg rune) (uint32, error)

type WorkerOfRuneThenUint32 struct {
	api_syncer *ApiDecouplerOfRuneThenUint32
	handler    WorkHandlerOfRuneThenUint32

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfRuneThenUint32
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfRuneThenUint32(ctx context.Context, h WorkHandlerOfRuneThenUint32, n int) *WorkerOfRuneThenUint32 {
	__ := &WorkerOfRuneThenUint32{
		api_syncer: NewApiDecouplerOfRuneThenUint32(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfRuneThenUint32, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfRuneThenUint32{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfRuneThenUint32(req.Context, req.WorkOfRuneThenUint32, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfRuneThenUint32) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfRuneThenUint32) Push(ctx context.Context, req *WorkOfRuneThenUint32) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfRuneThenUint32)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfRuneThenUint32 = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfRuneThenUint32) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfRuneThenUint32) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfRuneThenUint32) Call(ctx context.Context, arg rune) (uint32, error) {
	return __.api_syncer.DoOfRuneThenUint32(ctx, __, arg)
}

type PoolOfRuneThenUint64 interface {
	GetRuneArg() *rune
	PutRuneArg(*rune)
	GetUint64Return() *uint64
	PutUint64Return(*uint64)

	GetWorkOfRuneThenUint64() *WorkOfRuneThenUint64
	GetReturnOfUint64() *ReturnOfUint64
	PutWorkOfRuneThenUint64(*WorkOfRuneThenUint64)
	PutReturnOfUint64(*ReturnOfUint64)

	GetChReturnOfUint64() chan *ReturnOfUint64
	PutChReturnOfUint64(chan *ReturnOfUint64)
}

type PoolOfRuneThenUint64Impl struct {
	RuneArg          sync.Pool
	Uint64Rtn        sync.Pool
	RuneWork         sync.Pool
	Uint64Return     sync.Pool
	ChReturnOfUint64 sync.Pool
}

func (__ *PoolOfRuneThenUint64Impl) GetRuneArg() *rune {
	return __.RuneArg.Get().(*rune)
}
func (__ *PoolOfRuneThenUint64Impl) PutRuneArg(p *rune) {
	__.RuneArg.Put(p)
}
func (__ *PoolOfRuneThenUint64Impl) GetUint64Return() *uint64 {
	return __.Uint64Rtn.Get().(*uint64)
}
func (__ *PoolOfRuneThenUint64Impl) PutUint64Return(p *uint64) {
	__.Uint64Rtn.Put(p)
}

func (__ *PoolOfRuneThenUint64Impl) GetWorkOfRuneThenUint64() *WorkOfRuneThenUint64 {
	return __.RuneWork.Get().(*WorkOfRuneThenUint64)
}
func (__ *PoolOfRuneThenUint64Impl) PutWorkOfRuneThenUint64(p *WorkOfRuneThenUint64) {
	__.RuneWork.Put(p)
}
func (__ *PoolOfRuneThenUint64Impl) GetReturnOfUint64() *ReturnOfUint64 {
	return __.Uint64Return.Get().(*ReturnOfUint64)
}
func (__ *PoolOfRuneThenUint64Impl) PutReturnOfUint64(p *ReturnOfUint64) {
	__.Uint64Return.Put(p)
}

func (__ *PoolOfRuneThenUint64Impl) GetChReturnOfUint64() chan *ReturnOfUint64 {
	return __.ChReturnOfUint64.Get().(chan *ReturnOfUint64)
}
func (__ *PoolOfRuneThenUint64Impl) PutChReturnOfUint64(p chan *ReturnOfUint64) {
	__.ChReturnOfUint64.Put(p)
}

func NewPoolOfRuneThenUint64Impl() *PoolOfRuneThenUint64Impl {
	return &PoolOfRuneThenUint64Impl{
		RuneArg: sync.Pool{
			New: func() interface{} {
				return new(rune)
			},
		},
		RuneWork: sync.Pool{
			New: func() interface{} {
				return new(WorkOfRuneThenUint64)
			},
		},
		Uint64Rtn: sync.Pool{
			New: func() interface{} {
				return new(uint64)
			},
		},
		Uint64Return: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfUint64)
			},
		},
		ChReturnOfUint64: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfUint64, 1)
			},
		},
	}
}

type ApiDecouplerOfRuneThenUint64 struct {
	pool PoolOfRuneThenUint64
}

func NewApiDecouplerOfRuneThenUint64() *ApiDecouplerOfRuneThenUint64 {
	return &ApiDecouplerOfRuneThenUint64{
		pool: NewPoolOfRuneThenUint64Impl(),
	}
}

func (__ *ApiDecouplerOfRuneThenUint64) ReturnError(rtn_ch chan<- *ReturnOfUint64, err error) {
	rtn := __.pool.GetReturnOfUint64()
	var other uint64
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfRuneThenUint64) HandleOfRuneThenUint64(ctx context.Context, req *WorkOfRuneThenUint64, h func(ctx context.Context, arg rune) (uint64, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfUint64()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfRuneThenUint64) DoOfRuneThenUint64(ctx context.Context, worker WorkerOfPushRuneThenUint64, arg rune) (uint64, error) {
	// ch := make(chan *ReturnOfUint64, 1)
	ch := __.pool.GetChReturnOfUint64()
	defer __.pool.PutChReturnOfUint64(ch)

	req := __.pool.GetWorkOfRuneThenUint64()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfRuneThenUint64(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfUint64(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfRuneThenUint64 = func(ctx context.Context, arg rune) (uint64, error)

type WorkerOfRuneThenUint64 struct {
	api_syncer *ApiDecouplerOfRuneThenUint64
	handler    WorkHandlerOfRuneThenUint64

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfRuneThenUint64
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfRuneThenUint64(ctx context.Context, h WorkHandlerOfRuneThenUint64, n int) *WorkerOfRuneThenUint64 {
	__ := &WorkerOfRuneThenUint64{
		api_syncer: NewApiDecouplerOfRuneThenUint64(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfRuneThenUint64, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfRuneThenUint64{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfRuneThenUint64(req.Context, req.WorkOfRuneThenUint64, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfRuneThenUint64) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfRuneThenUint64) Push(ctx context.Context, req *WorkOfRuneThenUint64) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfRuneThenUint64)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfRuneThenUint64 = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfRuneThenUint64) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfRuneThenUint64) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfRuneThenUint64) Call(ctx context.Context, arg rune) (uint64, error) {
	return __.api_syncer.DoOfRuneThenUint64(ctx, __, arg)
}

type PoolOfRuneThenUint8 interface {
	GetRuneArg() *rune
	PutRuneArg(*rune)
	GetUint8Return() *uint8
	PutUint8Return(*uint8)

	GetWorkOfRuneThenUint8() *WorkOfRuneThenUint8
	GetReturnOfUint8() *ReturnOfUint8
	PutWorkOfRuneThenUint8(*WorkOfRuneThenUint8)
	PutReturnOfUint8(*ReturnOfUint8)

	GetChReturnOfUint8() chan *ReturnOfUint8
	PutChReturnOfUint8(chan *ReturnOfUint8)
}

type PoolOfRuneThenUint8Impl struct {
	RuneArg         sync.Pool
	Uint8Rtn        sync.Pool
	RuneWork        sync.Pool
	Uint8Return     sync.Pool
	ChReturnOfUint8 sync.Pool
}

func (__ *PoolOfRuneThenUint8Impl) GetRuneArg() *rune {
	return __.RuneArg.Get().(*rune)
}
func (__ *PoolOfRuneThenUint8Impl) PutRuneArg(p *rune) {
	__.RuneArg.Put(p)
}
func (__ *PoolOfRuneThenUint8Impl) GetUint8Return() *uint8 {
	return __.Uint8Rtn.Get().(*uint8)
}
func (__ *PoolOfRuneThenUint8Impl) PutUint8Return(p *uint8) {
	__.Uint8Rtn.Put(p)
}

func (__ *PoolOfRuneThenUint8Impl) GetWorkOfRuneThenUint8() *WorkOfRuneThenUint8 {
	return __.RuneWork.Get().(*WorkOfRuneThenUint8)
}
func (__ *PoolOfRuneThenUint8Impl) PutWorkOfRuneThenUint8(p *WorkOfRuneThenUint8) {
	__.RuneWork.Put(p)
}
func (__ *PoolOfRuneThenUint8Impl) GetReturnOfUint8() *ReturnOfUint8 {
	return __.Uint8Return.Get().(*ReturnOfUint8)
}
func (__ *PoolOfRuneThenUint8Impl) PutReturnOfUint8(p *ReturnOfUint8) {
	__.Uint8Return.Put(p)
}

func (__ *PoolOfRuneThenUint8Impl) GetChReturnOfUint8() chan *ReturnOfUint8 {
	return __.ChReturnOfUint8.Get().(chan *ReturnOfUint8)
}
func (__ *PoolOfRuneThenUint8Impl) PutChReturnOfUint8(p chan *ReturnOfUint8) {
	__.ChReturnOfUint8.Put(p)
}

func NewPoolOfRuneThenUint8Impl() *PoolOfRuneThenUint8Impl {
	return &PoolOfRuneThenUint8Impl{
		RuneArg: sync.Pool{
			New: func() interface{} {
				return new(rune)
			},
		},
		RuneWork: sync.Pool{
			New: func() interface{} {
				return new(WorkOfRuneThenUint8)
			},
		},
		Uint8Rtn: sync.Pool{
			New: func() interface{} {
				return new(uint8)
			},
		},
		Uint8Return: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfUint8)
			},
		},
		ChReturnOfUint8: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfUint8, 1)
			},
		},
	}
}

type ApiDecouplerOfRuneThenUint8 struct {
	pool PoolOfRuneThenUint8
}

func NewApiDecouplerOfRuneThenUint8() *ApiDecouplerOfRuneThenUint8 {
	return &ApiDecouplerOfRuneThenUint8{
		pool: NewPoolOfRuneThenUint8Impl(),
	}
}

func (__ *ApiDecouplerOfRuneThenUint8) ReturnError(rtn_ch chan<- *ReturnOfUint8, err error) {
	rtn := __.pool.GetReturnOfUint8()
	var other uint8
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfRuneThenUint8) HandleOfRuneThenUint8(ctx context.Context, req *WorkOfRuneThenUint8, h func(ctx context.Context, arg rune) (uint8, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfUint8()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfRuneThenUint8) DoOfRuneThenUint8(ctx context.Context, worker WorkerOfPushRuneThenUint8, arg rune) (uint8, error) {
	// ch := make(chan *ReturnOfUint8, 1)
	ch := __.pool.GetChReturnOfUint8()
	defer __.pool.PutChReturnOfUint8(ch)

	req := __.pool.GetWorkOfRuneThenUint8()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfRuneThenUint8(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfUint8(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfRuneThenUint8 = func(ctx context.Context, arg rune) (uint8, error)

type WorkerOfRuneThenUint8 struct {
	api_syncer *ApiDecouplerOfRuneThenUint8
	handler    WorkHandlerOfRuneThenUint8

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfRuneThenUint8
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfRuneThenUint8(ctx context.Context, h WorkHandlerOfRuneThenUint8, n int) *WorkerOfRuneThenUint8 {
	__ := &WorkerOfRuneThenUint8{
		api_syncer: NewApiDecouplerOfRuneThenUint8(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfRuneThenUint8, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfRuneThenUint8{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfRuneThenUint8(req.Context, req.WorkOfRuneThenUint8, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfRuneThenUint8) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfRuneThenUint8) Push(ctx context.Context, req *WorkOfRuneThenUint8) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfRuneThenUint8)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfRuneThenUint8 = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfRuneThenUint8) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfRuneThenUint8) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfRuneThenUint8) Call(ctx context.Context, arg rune) (uint8, error) {
	return __.api_syncer.DoOfRuneThenUint8(ctx, __, arg)
}

type PoolOfRuneThenUintptr interface {
	GetRuneArg() *rune
	PutRuneArg(*rune)
	GetUintptrReturn() *uintptr
	PutUintptrReturn(*uintptr)

	GetWorkOfRuneThenUintptr() *WorkOfRuneThenUintptr
	GetReturnOfUintptr() *ReturnOfUintptr
	PutWorkOfRuneThenUintptr(*WorkOfRuneThenUintptr)
	PutReturnOfUintptr(*ReturnOfUintptr)

	GetChReturnOfUintptr() chan *ReturnOfUintptr
	PutChReturnOfUintptr(chan *ReturnOfUintptr)
}

type PoolOfRuneThenUintptrImpl struct {
	RuneArg           sync.Pool
	UintptrRtn        sync.Pool
	RuneWork          sync.Pool
	UintptrReturn     sync.Pool
	ChReturnOfUintptr sync.Pool
}

func (__ *PoolOfRuneThenUintptrImpl) GetRuneArg() *rune {
	return __.RuneArg.Get().(*rune)
}
func (__ *PoolOfRuneThenUintptrImpl) PutRuneArg(p *rune) {
	__.RuneArg.Put(p)
}
func (__ *PoolOfRuneThenUintptrImpl) GetUintptrReturn() *uintptr {
	return __.UintptrRtn.Get().(*uintptr)
}
func (__ *PoolOfRuneThenUintptrImpl) PutUintptrReturn(p *uintptr) {
	__.UintptrRtn.Put(p)
}

func (__ *PoolOfRuneThenUintptrImpl) GetWorkOfRuneThenUintptr() *WorkOfRuneThenUintptr {
	return __.RuneWork.Get().(*WorkOfRuneThenUintptr)
}
func (__ *PoolOfRuneThenUintptrImpl) PutWorkOfRuneThenUintptr(p *WorkOfRuneThenUintptr) {
	__.RuneWork.Put(p)
}
func (__ *PoolOfRuneThenUintptrImpl) GetReturnOfUintptr() *ReturnOfUintptr {
	return __.UintptrReturn.Get().(*ReturnOfUintptr)
}
func (__ *PoolOfRuneThenUintptrImpl) PutReturnOfUintptr(p *ReturnOfUintptr) {
	__.UintptrReturn.Put(p)
}

func (__ *PoolOfRuneThenUintptrImpl) GetChReturnOfUintptr() chan *ReturnOfUintptr {
	return __.ChReturnOfUintptr.Get().(chan *ReturnOfUintptr)
}
func (__ *PoolOfRuneThenUintptrImpl) PutChReturnOfUintptr(p chan *ReturnOfUintptr) {
	__.ChReturnOfUintptr.Put(p)
}

func NewPoolOfRuneThenUintptrImpl() *PoolOfRuneThenUintptrImpl {
	return &PoolOfRuneThenUintptrImpl{
		RuneArg: sync.Pool{
			New: func() interface{} {
				return new(rune)
			},
		},
		RuneWork: sync.Pool{
			New: func() interface{} {
				return new(WorkOfRuneThenUintptr)
			},
		},
		UintptrRtn: sync.Pool{
			New: func() interface{} {
				return new(uintptr)
			},
		},
		UintptrReturn: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfUintptr)
			},
		},
		ChReturnOfUintptr: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfUintptr, 1)
			},
		},
	}
}

type ApiDecouplerOfRuneThenUintptr struct {
	pool PoolOfRuneThenUintptr
}

func NewApiDecouplerOfRuneThenUintptr() *ApiDecouplerOfRuneThenUintptr {
	return &ApiDecouplerOfRuneThenUintptr{
		pool: NewPoolOfRuneThenUintptrImpl(),
	}
}

func (__ *ApiDecouplerOfRuneThenUintptr) ReturnError(rtn_ch chan<- *ReturnOfUintptr, err error) {
	rtn := __.pool.GetReturnOfUintptr()
	var other uintptr
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfRuneThenUintptr) HandleOfRuneThenUintptr(ctx context.Context, req *WorkOfRuneThenUintptr, h func(ctx context.Context, arg rune) (uintptr, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfUintptr()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfRuneThenUintptr) DoOfRuneThenUintptr(ctx context.Context, worker WorkerOfPushRuneThenUintptr, arg rune) (uintptr, error) {
	// ch := make(chan *ReturnOfUintptr, 1)
	ch := __.pool.GetChReturnOfUintptr()
	defer __.pool.PutChReturnOfUintptr(ch)

	req := __.pool.GetWorkOfRuneThenUintptr()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfRuneThenUintptr(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfUintptr(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfRuneThenUintptr = func(ctx context.Context, arg rune) (uintptr, error)

type WorkerOfRuneThenUintptr struct {
	api_syncer *ApiDecouplerOfRuneThenUintptr
	handler    WorkHandlerOfRuneThenUintptr

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfRuneThenUintptr
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfRuneThenUintptr(ctx context.Context, h WorkHandlerOfRuneThenUintptr, n int) *WorkerOfRuneThenUintptr {
	__ := &WorkerOfRuneThenUintptr{
		api_syncer: NewApiDecouplerOfRuneThenUintptr(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfRuneThenUintptr, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfRuneThenUintptr{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfRuneThenUintptr(req.Context, req.WorkOfRuneThenUintptr, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfRuneThenUintptr) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfRuneThenUintptr) Push(ctx context.Context, req *WorkOfRuneThenUintptr) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfRuneThenUintptr)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfRuneThenUintptr = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfRuneThenUintptr) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfRuneThenUintptr) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfRuneThenUintptr) Call(ctx context.Context, arg rune) (uintptr, error) {
	return __.api_syncer.DoOfRuneThenUintptr(ctx, __, arg)
}

type PoolOfRuneThenInterface interface {
	GetRuneArg() *rune
	PutRuneArg(*rune)
	GetInterfaceReturn() *interface{}
	PutInterfaceReturn(*interface{})

	GetWorkOfRuneThenInterface() *WorkOfRuneThenInterface
	GetReturnOfInterface() *ReturnOfInterface
	PutWorkOfRuneThenInterface(*WorkOfRuneThenInterface)
	PutReturnOfInterface(*ReturnOfInterface)

	GetChReturnOfInterface() chan *ReturnOfInterface
	PutChReturnOfInterface(chan *ReturnOfInterface)
}

type PoolOfRuneThenInterfaceImpl struct {
	RuneArg             sync.Pool
	InterfaceRtn        sync.Pool
	RuneWork            sync.Pool
	InterfaceReturn     sync.Pool
	ChReturnOfInterface sync.Pool
}

func (__ *PoolOfRuneThenInterfaceImpl) GetRuneArg() *rune {
	return __.RuneArg.Get().(*rune)
}
func (__ *PoolOfRuneThenInterfaceImpl) PutRuneArg(p *rune) {
	__.RuneArg.Put(p)
}
func (__ *PoolOfRuneThenInterfaceImpl) GetInterfaceReturn() *interface{} {
	return __.InterfaceRtn.Get().(*interface{})
}
func (__ *PoolOfRuneThenInterfaceImpl) PutInterfaceReturn(p *interface{}) {
	__.InterfaceRtn.Put(p)
}

func (__ *PoolOfRuneThenInterfaceImpl) GetWorkOfRuneThenInterface() *WorkOfRuneThenInterface {
	return __.RuneWork.Get().(*WorkOfRuneThenInterface)
}
func (__ *PoolOfRuneThenInterfaceImpl) PutWorkOfRuneThenInterface(p *WorkOfRuneThenInterface) {
	__.RuneWork.Put(p)
}
func (__ *PoolOfRuneThenInterfaceImpl) GetReturnOfInterface() *ReturnOfInterface {
	return __.InterfaceReturn.Get().(*ReturnOfInterface)
}
func (__ *PoolOfRuneThenInterfaceImpl) PutReturnOfInterface(p *ReturnOfInterface) {
	__.InterfaceReturn.Put(p)
}

func (__ *PoolOfRuneThenInterfaceImpl) GetChReturnOfInterface() chan *ReturnOfInterface {
	return __.ChReturnOfInterface.Get().(chan *ReturnOfInterface)
}
func (__ *PoolOfRuneThenInterfaceImpl) PutChReturnOfInterface(p chan *ReturnOfInterface) {
	__.ChReturnOfInterface.Put(p)
}

func NewPoolOfRuneThenInterfaceImpl() *PoolOfRuneThenInterfaceImpl {
	return &PoolOfRuneThenInterfaceImpl{
		RuneArg: sync.Pool{
			New: func() interface{} {
				return new(rune)
			},
		},
		RuneWork: sync.Pool{
			New: func() interface{} {
				return new(WorkOfRuneThenInterface)
			},
		},
		InterfaceRtn: sync.Pool{
			New: func() interface{} {
				return new(interface{})
			},
		},
		InterfaceReturn: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfInterface)
			},
		},
		ChReturnOfInterface: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfInterface, 1)
			},
		},
	}
}

type ApiDecouplerOfRuneThenInterface struct {
	pool PoolOfRuneThenInterface
}

func NewApiDecouplerOfRuneThenInterface() *ApiDecouplerOfRuneThenInterface {
	return &ApiDecouplerOfRuneThenInterface{
		pool: NewPoolOfRuneThenInterfaceImpl(),
	}
}

func (__ *ApiDecouplerOfRuneThenInterface) ReturnError(rtn_ch chan<- *ReturnOfInterface, err error) {
	rtn := __.pool.GetReturnOfInterface()
	var other interface{}
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfRuneThenInterface) HandleOfRuneThenInterface(ctx context.Context, req *WorkOfRuneThenInterface, h func(ctx context.Context, arg rune) (interface{}, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfInterface()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfRuneThenInterface) DoOfRuneThenInterface(ctx context.Context, worker WorkerOfPushRuneThenInterface, arg rune) (interface{}, error) {
	// ch := make(chan *ReturnOfInterface, 1)
	ch := __.pool.GetChReturnOfInterface()
	defer __.pool.PutChReturnOfInterface(ch)

	req := __.pool.GetWorkOfRuneThenInterface()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfRuneThenInterface(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfInterface(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfRuneThenInterface = func(ctx context.Context, arg rune) (interface{}, error)

type WorkerOfRuneThenInterface struct {
	api_syncer *ApiDecouplerOfRuneThenInterface
	handler    WorkHandlerOfRuneThenInterface

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfRuneThenInterface
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfRuneThenInterface(ctx context.Context, h WorkHandlerOfRuneThenInterface, n int) *WorkerOfRuneThenInterface {
	__ := &WorkerOfRuneThenInterface{
		api_syncer: NewApiDecouplerOfRuneThenInterface(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfRuneThenInterface, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfRuneThenInterface{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfRuneThenInterface(req.Context, req.WorkOfRuneThenInterface, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfRuneThenInterface) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfRuneThenInterface) Push(ctx context.Context, req *WorkOfRuneThenInterface) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfRuneThenInterface)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfRuneThenInterface = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfRuneThenInterface) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfRuneThenInterface) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfRuneThenInterface) Call(ctx context.Context, arg rune) (interface{}, error) {
	return __.api_syncer.DoOfRuneThenInterface(ctx, __, arg)
}

type PoolOfRuneThenStruct interface {
	GetRuneArg() *rune
	PutRuneArg(*rune)
	GetStructReturn() *struct{}
	PutStructReturn(*struct{})

	GetWorkOfRuneThenStruct() *WorkOfRuneThenStruct
	GetReturnOfStruct() *ReturnOfStruct
	PutWorkOfRuneThenStruct(*WorkOfRuneThenStruct)
	PutReturnOfStruct(*ReturnOfStruct)

	GetChReturnOfStruct() chan *ReturnOfStruct
	PutChReturnOfStruct(chan *ReturnOfStruct)
}

type PoolOfRuneThenStructImpl struct {
	RuneArg          sync.Pool
	StructRtn        sync.Pool
	RuneWork         sync.Pool
	StructReturn     sync.Pool
	ChReturnOfStruct sync.Pool
}

func (__ *PoolOfRuneThenStructImpl) GetRuneArg() *rune {
	return __.RuneArg.Get().(*rune)
}
func (__ *PoolOfRuneThenStructImpl) PutRuneArg(p *rune) {
	__.RuneArg.Put(p)
}
func (__ *PoolOfRuneThenStructImpl) GetStructReturn() *struct{} {
	return __.StructRtn.Get().(*struct{})
}
func (__ *PoolOfRuneThenStructImpl) PutStructReturn(p *struct{}) {
	__.StructRtn.Put(p)
}

func (__ *PoolOfRuneThenStructImpl) GetWorkOfRuneThenStruct() *WorkOfRuneThenStruct {
	return __.RuneWork.Get().(*WorkOfRuneThenStruct)
}
func (__ *PoolOfRuneThenStructImpl) PutWorkOfRuneThenStruct(p *WorkOfRuneThenStruct) {
	__.RuneWork.Put(p)
}
func (__ *PoolOfRuneThenStructImpl) GetReturnOfStruct() *ReturnOfStruct {
	return __.StructReturn.Get().(*ReturnOfStruct)
}
func (__ *PoolOfRuneThenStructImpl) PutReturnOfStruct(p *ReturnOfStruct) {
	__.StructReturn.Put(p)
}

func (__ *PoolOfRuneThenStructImpl) GetChReturnOfStruct() chan *ReturnOfStruct {
	return __.ChReturnOfStruct.Get().(chan *ReturnOfStruct)
}
func (__ *PoolOfRuneThenStructImpl) PutChReturnOfStruct(p chan *ReturnOfStruct) {
	__.ChReturnOfStruct.Put(p)
}

func NewPoolOfRuneThenStructImpl() *PoolOfRuneThenStructImpl {
	return &PoolOfRuneThenStructImpl{
		RuneArg: sync.Pool{
			New: func() interface{} {
				return new(rune)
			},
		},
		RuneWork: sync.Pool{
			New: func() interface{} {
				return new(WorkOfRuneThenStruct)
			},
		},
		StructRtn: sync.Pool{
			New: func() interface{} {
				return new(struct{})
			},
		},
		StructReturn: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfStruct)
			},
		},
		ChReturnOfStruct: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfStruct, 1)
			},
		},
	}
}

type ApiDecouplerOfRuneThenStruct struct {
	pool PoolOfRuneThenStruct
}

func NewApiDecouplerOfRuneThenStruct() *ApiDecouplerOfRuneThenStruct {
	return &ApiDecouplerOfRuneThenStruct{
		pool: NewPoolOfRuneThenStructImpl(),
	}
}

func (__ *ApiDecouplerOfRuneThenStruct) ReturnError(rtn_ch chan<- *ReturnOfStruct, err error) {
	rtn := __.pool.GetReturnOfStruct()
	var other struct{}
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfRuneThenStruct) HandleOfRuneThenStruct(ctx context.Context, req *WorkOfRuneThenStruct, h func(ctx context.Context, arg rune) (struct{}, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfStruct()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfRuneThenStruct) DoOfRuneThenStruct(ctx context.Context, worker WorkerOfPushRuneThenStruct, arg rune) (struct{}, error) {
	// ch := make(chan *ReturnOfStruct, 1)
	ch := __.pool.GetChReturnOfStruct()
	defer __.pool.PutChReturnOfStruct(ch)

	req := __.pool.GetWorkOfRuneThenStruct()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfRuneThenStruct(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfStruct(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfRuneThenStruct = func(ctx context.Context, arg rune) (struct{}, error)

type WorkerOfRuneThenStruct struct {
	api_syncer *ApiDecouplerOfRuneThenStruct
	handler    WorkHandlerOfRuneThenStruct

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfRuneThenStruct
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfRuneThenStruct(ctx context.Context, h WorkHandlerOfRuneThenStruct, n int) *WorkerOfRuneThenStruct {
	__ := &WorkerOfRuneThenStruct{
		api_syncer: NewApiDecouplerOfRuneThenStruct(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfRuneThenStruct, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfRuneThenStruct{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfRuneThenStruct(req.Context, req.WorkOfRuneThenStruct, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfRuneThenStruct) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfRuneThenStruct) Push(ctx context.Context, req *WorkOfRuneThenStruct) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfRuneThenStruct)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfRuneThenStruct = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfRuneThenStruct) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfRuneThenStruct) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfRuneThenStruct) Call(ctx context.Context, arg rune) (struct{}, error) {
	return __.api_syncer.DoOfRuneThenStruct(ctx, __, arg)
}

type PoolOfStringThenBool interface {
	GetStringArg() *string
	PutStringArg(*string)
	GetBoolReturn() *bool
	PutBoolReturn(*bool)

	GetWorkOfStringThenBool() *WorkOfStringThenBool
	GetReturnOfBool() *ReturnOfBool
	PutWorkOfStringThenBool(*WorkOfStringThenBool)
	PutReturnOfBool(*ReturnOfBool)

	GetChReturnOfBool() chan *ReturnOfBool
	PutChReturnOfBool(chan *ReturnOfBool)
}

type PoolOfStringThenBoolImpl struct {
	StringArg      sync.Pool
	BoolRtn        sync.Pool
	StringWork     sync.Pool
	BoolReturn     sync.Pool
	ChReturnOfBool sync.Pool
}

func (__ *PoolOfStringThenBoolImpl) GetStringArg() *string {
	return __.StringArg.Get().(*string)
}
func (__ *PoolOfStringThenBoolImpl) PutStringArg(p *string) {
	__.StringArg.Put(p)
}
func (__ *PoolOfStringThenBoolImpl) GetBoolReturn() *bool {
	return __.BoolRtn.Get().(*bool)
}
func (__ *PoolOfStringThenBoolImpl) PutBoolReturn(p *bool) {
	__.BoolRtn.Put(p)
}

func (__ *PoolOfStringThenBoolImpl) GetWorkOfStringThenBool() *WorkOfStringThenBool {
	return __.StringWork.Get().(*WorkOfStringThenBool)
}
func (__ *PoolOfStringThenBoolImpl) PutWorkOfStringThenBool(p *WorkOfStringThenBool) {
	__.StringWork.Put(p)
}
func (__ *PoolOfStringThenBoolImpl) GetReturnOfBool() *ReturnOfBool {
	return __.BoolReturn.Get().(*ReturnOfBool)
}
func (__ *PoolOfStringThenBoolImpl) PutReturnOfBool(p *ReturnOfBool) {
	__.BoolReturn.Put(p)
}

func (__ *PoolOfStringThenBoolImpl) GetChReturnOfBool() chan *ReturnOfBool {
	return __.ChReturnOfBool.Get().(chan *ReturnOfBool)
}
func (__ *PoolOfStringThenBoolImpl) PutChReturnOfBool(p chan *ReturnOfBool) {
	__.ChReturnOfBool.Put(p)
}

func NewPoolOfStringThenBoolImpl() *PoolOfStringThenBoolImpl {
	return &PoolOfStringThenBoolImpl{
		StringArg: sync.Pool{
			New: func() interface{} {
				return new(string)
			},
		},
		StringWork: sync.Pool{
			New: func() interface{} {
				return new(WorkOfStringThenBool)
			},
		},
		BoolRtn: sync.Pool{
			New: func() interface{} {
				return new(bool)
			},
		},
		BoolReturn: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfBool)
			},
		},
		ChReturnOfBool: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfBool, 1)
			},
		},
	}
}

type ApiDecouplerOfStringThenBool struct {
	pool PoolOfStringThenBool
}

func NewApiDecouplerOfStringThenBool() *ApiDecouplerOfStringThenBool {
	return &ApiDecouplerOfStringThenBool{
		pool: NewPoolOfStringThenBoolImpl(),
	}
}

func (__ *ApiDecouplerOfStringThenBool) ReturnError(rtn_ch chan<- *ReturnOfBool, err error) {
	rtn := __.pool.GetReturnOfBool()
	var other bool
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfStringThenBool) HandleOfStringThenBool(ctx context.Context, req *WorkOfStringThenBool, h func(ctx context.Context, arg string) (bool, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfBool()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfStringThenBool) DoOfStringThenBool(ctx context.Context, worker WorkerOfPushStringThenBool, arg string) (bool, error) {
	// ch := make(chan *ReturnOfBool, 1)
	ch := __.pool.GetChReturnOfBool()
	defer __.pool.PutChReturnOfBool(ch)

	req := __.pool.GetWorkOfStringThenBool()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfStringThenBool(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfBool(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfStringThenBool = func(ctx context.Context, arg string) (bool, error)

type WorkerOfStringThenBool struct {
	api_syncer *ApiDecouplerOfStringThenBool
	handler    WorkHandlerOfStringThenBool

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfStringThenBool
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfStringThenBool(ctx context.Context, h WorkHandlerOfStringThenBool, n int) *WorkerOfStringThenBool {
	__ := &WorkerOfStringThenBool{
		api_syncer: NewApiDecouplerOfStringThenBool(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfStringThenBool, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfStringThenBool{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfStringThenBool(req.Context, req.WorkOfStringThenBool, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfStringThenBool) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfStringThenBool) Push(ctx context.Context, req *WorkOfStringThenBool) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfStringThenBool)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfStringThenBool = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfStringThenBool) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfStringThenBool) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfStringThenBool) Call(ctx context.Context, arg string) (bool, error) {
	return __.api_syncer.DoOfStringThenBool(ctx, __, arg)
}

type PoolOfStringThenByte interface {
	GetStringArg() *string
	PutStringArg(*string)
	GetByteReturn() *byte
	PutByteReturn(*byte)

	GetWorkOfStringThenByte() *WorkOfStringThenByte
	GetReturnOfByte() *ReturnOfByte
	PutWorkOfStringThenByte(*WorkOfStringThenByte)
	PutReturnOfByte(*ReturnOfByte)

	GetChReturnOfByte() chan *ReturnOfByte
	PutChReturnOfByte(chan *ReturnOfByte)
}

type PoolOfStringThenByteImpl struct {
	StringArg      sync.Pool
	ByteRtn        sync.Pool
	StringWork     sync.Pool
	ByteReturn     sync.Pool
	ChReturnOfByte sync.Pool
}

func (__ *PoolOfStringThenByteImpl) GetStringArg() *string {
	return __.StringArg.Get().(*string)
}
func (__ *PoolOfStringThenByteImpl) PutStringArg(p *string) {
	__.StringArg.Put(p)
}
func (__ *PoolOfStringThenByteImpl) GetByteReturn() *byte {
	return __.ByteRtn.Get().(*byte)
}
func (__ *PoolOfStringThenByteImpl) PutByteReturn(p *byte) {
	__.ByteRtn.Put(p)
}

func (__ *PoolOfStringThenByteImpl) GetWorkOfStringThenByte() *WorkOfStringThenByte {
	return __.StringWork.Get().(*WorkOfStringThenByte)
}
func (__ *PoolOfStringThenByteImpl) PutWorkOfStringThenByte(p *WorkOfStringThenByte) {
	__.StringWork.Put(p)
}
func (__ *PoolOfStringThenByteImpl) GetReturnOfByte() *ReturnOfByte {
	return __.ByteReturn.Get().(*ReturnOfByte)
}
func (__ *PoolOfStringThenByteImpl) PutReturnOfByte(p *ReturnOfByte) {
	__.ByteReturn.Put(p)
}

func (__ *PoolOfStringThenByteImpl) GetChReturnOfByte() chan *ReturnOfByte {
	return __.ChReturnOfByte.Get().(chan *ReturnOfByte)
}
func (__ *PoolOfStringThenByteImpl) PutChReturnOfByte(p chan *ReturnOfByte) {
	__.ChReturnOfByte.Put(p)
}

func NewPoolOfStringThenByteImpl() *PoolOfStringThenByteImpl {
	return &PoolOfStringThenByteImpl{
		StringArg: sync.Pool{
			New: func() interface{} {
				return new(string)
			},
		},
		StringWork: sync.Pool{
			New: func() interface{} {
				return new(WorkOfStringThenByte)
			},
		},
		ByteRtn: sync.Pool{
			New: func() interface{} {
				return new(byte)
			},
		},
		ByteReturn: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfByte)
			},
		},
		ChReturnOfByte: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfByte, 1)
			},
		},
	}
}

type ApiDecouplerOfStringThenByte struct {
	pool PoolOfStringThenByte
}

func NewApiDecouplerOfStringThenByte() *ApiDecouplerOfStringThenByte {
	return &ApiDecouplerOfStringThenByte{
		pool: NewPoolOfStringThenByteImpl(),
	}
}

func (__ *ApiDecouplerOfStringThenByte) ReturnError(rtn_ch chan<- *ReturnOfByte, err error) {
	rtn := __.pool.GetReturnOfByte()
	var other byte
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfStringThenByte) HandleOfStringThenByte(ctx context.Context, req *WorkOfStringThenByte, h func(ctx context.Context, arg string) (byte, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfByte()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfStringThenByte) DoOfStringThenByte(ctx context.Context, worker WorkerOfPushStringThenByte, arg string) (byte, error) {
	// ch := make(chan *ReturnOfByte, 1)
	ch := __.pool.GetChReturnOfByte()
	defer __.pool.PutChReturnOfByte(ch)

	req := __.pool.GetWorkOfStringThenByte()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfStringThenByte(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfByte(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfStringThenByte = func(ctx context.Context, arg string) (byte, error)

type WorkerOfStringThenByte struct {
	api_syncer *ApiDecouplerOfStringThenByte
	handler    WorkHandlerOfStringThenByte

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfStringThenByte
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfStringThenByte(ctx context.Context, h WorkHandlerOfStringThenByte, n int) *WorkerOfStringThenByte {
	__ := &WorkerOfStringThenByte{
		api_syncer: NewApiDecouplerOfStringThenByte(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfStringThenByte, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfStringThenByte{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfStringThenByte(req.Context, req.WorkOfStringThenByte, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfStringThenByte) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfStringThenByte) Push(ctx context.Context, req *WorkOfStringThenByte) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfStringThenByte)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfStringThenByte = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfStringThenByte) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfStringThenByte) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfStringThenByte) Call(ctx context.Context, arg string) (byte, error) {
	return __.api_syncer.DoOfStringThenByte(ctx, __, arg)
}

type PoolOfStringThenComplex128 interface {
	GetStringArg() *string
	PutStringArg(*string)
	GetComplex128Return() *complex128
	PutComplex128Return(*complex128)

	GetWorkOfStringThenComplex128() *WorkOfStringThenComplex128
	GetReturnOfComplex128() *ReturnOfComplex128
	PutWorkOfStringThenComplex128(*WorkOfStringThenComplex128)
	PutReturnOfComplex128(*ReturnOfComplex128)

	GetChReturnOfComplex128() chan *ReturnOfComplex128
	PutChReturnOfComplex128(chan *ReturnOfComplex128)
}

type PoolOfStringThenComplex128Impl struct {
	StringArg            sync.Pool
	Complex128Rtn        sync.Pool
	StringWork           sync.Pool
	Complex128Return     sync.Pool
	ChReturnOfComplex128 sync.Pool
}

func (__ *PoolOfStringThenComplex128Impl) GetStringArg() *string {
	return __.StringArg.Get().(*string)
}
func (__ *PoolOfStringThenComplex128Impl) PutStringArg(p *string) {
	__.StringArg.Put(p)
}
func (__ *PoolOfStringThenComplex128Impl) GetComplex128Return() *complex128 {
	return __.Complex128Rtn.Get().(*complex128)
}
func (__ *PoolOfStringThenComplex128Impl) PutComplex128Return(p *complex128) {
	__.Complex128Rtn.Put(p)
}

func (__ *PoolOfStringThenComplex128Impl) GetWorkOfStringThenComplex128() *WorkOfStringThenComplex128 {
	return __.StringWork.Get().(*WorkOfStringThenComplex128)
}
func (__ *PoolOfStringThenComplex128Impl) PutWorkOfStringThenComplex128(p *WorkOfStringThenComplex128) {
	__.StringWork.Put(p)
}
func (__ *PoolOfStringThenComplex128Impl) GetReturnOfComplex128() *ReturnOfComplex128 {
	return __.Complex128Return.Get().(*ReturnOfComplex128)
}
func (__ *PoolOfStringThenComplex128Impl) PutReturnOfComplex128(p *ReturnOfComplex128) {
	__.Complex128Return.Put(p)
}

func (__ *PoolOfStringThenComplex128Impl) GetChReturnOfComplex128() chan *ReturnOfComplex128 {
	return __.ChReturnOfComplex128.Get().(chan *ReturnOfComplex128)
}
func (__ *PoolOfStringThenComplex128Impl) PutChReturnOfComplex128(p chan *ReturnOfComplex128) {
	__.ChReturnOfComplex128.Put(p)
}

func NewPoolOfStringThenComplex128Impl() *PoolOfStringThenComplex128Impl {
	return &PoolOfStringThenComplex128Impl{
		StringArg: sync.Pool{
			New: func() interface{} {
				return new(string)
			},
		},
		StringWork: sync.Pool{
			New: func() interface{} {
				return new(WorkOfStringThenComplex128)
			},
		},
		Complex128Rtn: sync.Pool{
			New: func() interface{} {
				return new(complex128)
			},
		},
		Complex128Return: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfComplex128)
			},
		},
		ChReturnOfComplex128: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfComplex128, 1)
			},
		},
	}
}

type ApiDecouplerOfStringThenComplex128 struct {
	pool PoolOfStringThenComplex128
}

func NewApiDecouplerOfStringThenComplex128() *ApiDecouplerOfStringThenComplex128 {
	return &ApiDecouplerOfStringThenComplex128{
		pool: NewPoolOfStringThenComplex128Impl(),
	}
}

func (__ *ApiDecouplerOfStringThenComplex128) ReturnError(rtn_ch chan<- *ReturnOfComplex128, err error) {
	rtn := __.pool.GetReturnOfComplex128()
	var other complex128
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfStringThenComplex128) HandleOfStringThenComplex128(ctx context.Context, req *WorkOfStringThenComplex128, h func(ctx context.Context, arg string) (complex128, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfComplex128()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfStringThenComplex128) DoOfStringThenComplex128(ctx context.Context, worker WorkerOfPushStringThenComplex128, arg string) (complex128, error) {
	// ch := make(chan *ReturnOfComplex128, 1)
	ch := __.pool.GetChReturnOfComplex128()
	defer __.pool.PutChReturnOfComplex128(ch)

	req := __.pool.GetWorkOfStringThenComplex128()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfStringThenComplex128(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfComplex128(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfStringThenComplex128 = func(ctx context.Context, arg string) (complex128, error)

type WorkerOfStringThenComplex128 struct {
	api_syncer *ApiDecouplerOfStringThenComplex128
	handler    WorkHandlerOfStringThenComplex128

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfStringThenComplex128
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfStringThenComplex128(ctx context.Context, h WorkHandlerOfStringThenComplex128, n int) *WorkerOfStringThenComplex128 {
	__ := &WorkerOfStringThenComplex128{
		api_syncer: NewApiDecouplerOfStringThenComplex128(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfStringThenComplex128, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfStringThenComplex128{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfStringThenComplex128(req.Context, req.WorkOfStringThenComplex128, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfStringThenComplex128) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfStringThenComplex128) Push(ctx context.Context, req *WorkOfStringThenComplex128) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfStringThenComplex128)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfStringThenComplex128 = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfStringThenComplex128) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfStringThenComplex128) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfStringThenComplex128) Call(ctx context.Context, arg string) (complex128, error) {
	return __.api_syncer.DoOfStringThenComplex128(ctx, __, arg)
}

type PoolOfStringThenComplex64 interface {
	GetStringArg() *string
	PutStringArg(*string)
	GetComplex64Return() *complex64
	PutComplex64Return(*complex64)

	GetWorkOfStringThenComplex64() *WorkOfStringThenComplex64
	GetReturnOfComplex64() *ReturnOfComplex64
	PutWorkOfStringThenComplex64(*WorkOfStringThenComplex64)
	PutReturnOfComplex64(*ReturnOfComplex64)

	GetChReturnOfComplex64() chan *ReturnOfComplex64
	PutChReturnOfComplex64(chan *ReturnOfComplex64)
}

type PoolOfStringThenComplex64Impl struct {
	StringArg           sync.Pool
	Complex64Rtn        sync.Pool
	StringWork          sync.Pool
	Complex64Return     sync.Pool
	ChReturnOfComplex64 sync.Pool
}

func (__ *PoolOfStringThenComplex64Impl) GetStringArg() *string {
	return __.StringArg.Get().(*string)
}
func (__ *PoolOfStringThenComplex64Impl) PutStringArg(p *string) {
	__.StringArg.Put(p)
}
func (__ *PoolOfStringThenComplex64Impl) GetComplex64Return() *complex64 {
	return __.Complex64Rtn.Get().(*complex64)
}
func (__ *PoolOfStringThenComplex64Impl) PutComplex64Return(p *complex64) {
	__.Complex64Rtn.Put(p)
}

func (__ *PoolOfStringThenComplex64Impl) GetWorkOfStringThenComplex64() *WorkOfStringThenComplex64 {
	return __.StringWork.Get().(*WorkOfStringThenComplex64)
}
func (__ *PoolOfStringThenComplex64Impl) PutWorkOfStringThenComplex64(p *WorkOfStringThenComplex64) {
	__.StringWork.Put(p)
}
func (__ *PoolOfStringThenComplex64Impl) GetReturnOfComplex64() *ReturnOfComplex64 {
	return __.Complex64Return.Get().(*ReturnOfComplex64)
}
func (__ *PoolOfStringThenComplex64Impl) PutReturnOfComplex64(p *ReturnOfComplex64) {
	__.Complex64Return.Put(p)
}

func (__ *PoolOfStringThenComplex64Impl) GetChReturnOfComplex64() chan *ReturnOfComplex64 {
	return __.ChReturnOfComplex64.Get().(chan *ReturnOfComplex64)
}
func (__ *PoolOfStringThenComplex64Impl) PutChReturnOfComplex64(p chan *ReturnOfComplex64) {
	__.ChReturnOfComplex64.Put(p)
}

func NewPoolOfStringThenComplex64Impl() *PoolOfStringThenComplex64Impl {
	return &PoolOfStringThenComplex64Impl{
		StringArg: sync.Pool{
			New: func() interface{} {
				return new(string)
			},
		},
		StringWork: sync.Pool{
			New: func() interface{} {
				return new(WorkOfStringThenComplex64)
			},
		},
		Complex64Rtn: sync.Pool{
			New: func() interface{} {
				return new(complex64)
			},
		},
		Complex64Return: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfComplex64)
			},
		},
		ChReturnOfComplex64: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfComplex64, 1)
			},
		},
	}
}

type ApiDecouplerOfStringThenComplex64 struct {
	pool PoolOfStringThenComplex64
}

func NewApiDecouplerOfStringThenComplex64() *ApiDecouplerOfStringThenComplex64 {
	return &ApiDecouplerOfStringThenComplex64{
		pool: NewPoolOfStringThenComplex64Impl(),
	}
}

func (__ *ApiDecouplerOfStringThenComplex64) ReturnError(rtn_ch chan<- *ReturnOfComplex64, err error) {
	rtn := __.pool.GetReturnOfComplex64()
	var other complex64
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfStringThenComplex64) HandleOfStringThenComplex64(ctx context.Context, req *WorkOfStringThenComplex64, h func(ctx context.Context, arg string) (complex64, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfComplex64()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfStringThenComplex64) DoOfStringThenComplex64(ctx context.Context, worker WorkerOfPushStringThenComplex64, arg string) (complex64, error) {
	// ch := make(chan *ReturnOfComplex64, 1)
	ch := __.pool.GetChReturnOfComplex64()
	defer __.pool.PutChReturnOfComplex64(ch)

	req := __.pool.GetWorkOfStringThenComplex64()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfStringThenComplex64(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfComplex64(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfStringThenComplex64 = func(ctx context.Context, arg string) (complex64, error)

type WorkerOfStringThenComplex64 struct {
	api_syncer *ApiDecouplerOfStringThenComplex64
	handler    WorkHandlerOfStringThenComplex64

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfStringThenComplex64
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfStringThenComplex64(ctx context.Context, h WorkHandlerOfStringThenComplex64, n int) *WorkerOfStringThenComplex64 {
	__ := &WorkerOfStringThenComplex64{
		api_syncer: NewApiDecouplerOfStringThenComplex64(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfStringThenComplex64, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfStringThenComplex64{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfStringThenComplex64(req.Context, req.WorkOfStringThenComplex64, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfStringThenComplex64) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfStringThenComplex64) Push(ctx context.Context, req *WorkOfStringThenComplex64) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfStringThenComplex64)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfStringThenComplex64 = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfStringThenComplex64) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfStringThenComplex64) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfStringThenComplex64) Call(ctx context.Context, arg string) (complex64, error) {
	return __.api_syncer.DoOfStringThenComplex64(ctx, __, arg)
}

type PoolOfStringThenError interface {
	GetStringArg() *string
	PutStringArg(*string)
	GetErrorReturn() *error
	PutErrorReturn(*error)

	GetWorkOfStringThenError() *WorkOfStringThenError
	GetReturnOfError() *ReturnOfError
	PutWorkOfStringThenError(*WorkOfStringThenError)
	PutReturnOfError(*ReturnOfError)

	GetChReturnOfError() chan *ReturnOfError
	PutChReturnOfError(chan *ReturnOfError)
}

type PoolOfStringThenErrorImpl struct {
	StringArg       sync.Pool
	ErrorRtn        sync.Pool
	StringWork      sync.Pool
	ErrorReturn     sync.Pool
	ChReturnOfError sync.Pool
}

func (__ *PoolOfStringThenErrorImpl) GetStringArg() *string {
	return __.StringArg.Get().(*string)
}
func (__ *PoolOfStringThenErrorImpl) PutStringArg(p *string) {
	__.StringArg.Put(p)
}
func (__ *PoolOfStringThenErrorImpl) GetErrorReturn() *error {
	return __.ErrorRtn.Get().(*error)
}
func (__ *PoolOfStringThenErrorImpl) PutErrorReturn(p *error) {
	__.ErrorRtn.Put(p)
}

func (__ *PoolOfStringThenErrorImpl) GetWorkOfStringThenError() *WorkOfStringThenError {
	return __.StringWork.Get().(*WorkOfStringThenError)
}
func (__ *PoolOfStringThenErrorImpl) PutWorkOfStringThenError(p *WorkOfStringThenError) {
	__.StringWork.Put(p)
}
func (__ *PoolOfStringThenErrorImpl) GetReturnOfError() *ReturnOfError {
	return __.ErrorReturn.Get().(*ReturnOfError)
}
func (__ *PoolOfStringThenErrorImpl) PutReturnOfError(p *ReturnOfError) {
	__.ErrorReturn.Put(p)
}

func (__ *PoolOfStringThenErrorImpl) GetChReturnOfError() chan *ReturnOfError {
	return __.ChReturnOfError.Get().(chan *ReturnOfError)
}
func (__ *PoolOfStringThenErrorImpl) PutChReturnOfError(p chan *ReturnOfError) {
	__.ChReturnOfError.Put(p)
}

func NewPoolOfStringThenErrorImpl() *PoolOfStringThenErrorImpl {
	return &PoolOfStringThenErrorImpl{
		StringArg: sync.Pool{
			New: func() interface{} {
				return new(string)
			},
		},
		StringWork: sync.Pool{
			New: func() interface{} {
				return new(WorkOfStringThenError)
			},
		},
		ErrorRtn: sync.Pool{
			New: func() interface{} {
				return new(error)
			},
		},
		ErrorReturn: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfError)
			},
		},
		ChReturnOfError: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfError, 1)
			},
		},
	}
}

type ApiDecouplerOfStringThenError struct {
	pool PoolOfStringThenError
}

func NewApiDecouplerOfStringThenError() *ApiDecouplerOfStringThenError {
	return &ApiDecouplerOfStringThenError{
		pool: NewPoolOfStringThenErrorImpl(),
	}
}

func (__ *ApiDecouplerOfStringThenError) ReturnError(rtn_ch chan<- *ReturnOfError, err error) {
	rtn := __.pool.GetReturnOfError()
	var other error
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfStringThenError) HandleOfStringThenError(ctx context.Context, req *WorkOfStringThenError, h func(ctx context.Context, arg string) (error, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfError()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfStringThenError) DoOfStringThenError(ctx context.Context, worker WorkerOfPushStringThenError, arg string) (error, error) {
	// ch := make(chan *ReturnOfError, 1)
	ch := __.pool.GetChReturnOfError()
	defer __.pool.PutChReturnOfError(ch)

	req := __.pool.GetWorkOfStringThenError()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfStringThenError(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfError(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfStringThenError = func(ctx context.Context, arg string) (error, error)

type WorkerOfStringThenError struct {
	api_syncer *ApiDecouplerOfStringThenError
	handler    WorkHandlerOfStringThenError

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfStringThenError
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfStringThenError(ctx context.Context, h WorkHandlerOfStringThenError, n int) *WorkerOfStringThenError {
	__ := &WorkerOfStringThenError{
		api_syncer: NewApiDecouplerOfStringThenError(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfStringThenError, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfStringThenError{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfStringThenError(req.Context, req.WorkOfStringThenError, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfStringThenError) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfStringThenError) Push(ctx context.Context, req *WorkOfStringThenError) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfStringThenError)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfStringThenError = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfStringThenError) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfStringThenError) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfStringThenError) Call(ctx context.Context, arg string) (error, error) {
	return __.api_syncer.DoOfStringThenError(ctx, __, arg)
}

type PoolOfStringThenFloat32 interface {
	GetStringArg() *string
	PutStringArg(*string)
	GetFloat32Return() *float32
	PutFloat32Return(*float32)

	GetWorkOfStringThenFloat32() *WorkOfStringThenFloat32
	GetReturnOfFloat32() *ReturnOfFloat32
	PutWorkOfStringThenFloat32(*WorkOfStringThenFloat32)
	PutReturnOfFloat32(*ReturnOfFloat32)

	GetChReturnOfFloat32() chan *ReturnOfFloat32
	PutChReturnOfFloat32(chan *ReturnOfFloat32)
}

type PoolOfStringThenFloat32Impl struct {
	StringArg         sync.Pool
	Float32Rtn        sync.Pool
	StringWork        sync.Pool
	Float32Return     sync.Pool
	ChReturnOfFloat32 sync.Pool
}

func (__ *PoolOfStringThenFloat32Impl) GetStringArg() *string {
	return __.StringArg.Get().(*string)
}
func (__ *PoolOfStringThenFloat32Impl) PutStringArg(p *string) {
	__.StringArg.Put(p)
}
func (__ *PoolOfStringThenFloat32Impl) GetFloat32Return() *float32 {
	return __.Float32Rtn.Get().(*float32)
}
func (__ *PoolOfStringThenFloat32Impl) PutFloat32Return(p *float32) {
	__.Float32Rtn.Put(p)
}

func (__ *PoolOfStringThenFloat32Impl) GetWorkOfStringThenFloat32() *WorkOfStringThenFloat32 {
	return __.StringWork.Get().(*WorkOfStringThenFloat32)
}
func (__ *PoolOfStringThenFloat32Impl) PutWorkOfStringThenFloat32(p *WorkOfStringThenFloat32) {
	__.StringWork.Put(p)
}
func (__ *PoolOfStringThenFloat32Impl) GetReturnOfFloat32() *ReturnOfFloat32 {
	return __.Float32Return.Get().(*ReturnOfFloat32)
}
func (__ *PoolOfStringThenFloat32Impl) PutReturnOfFloat32(p *ReturnOfFloat32) {
	__.Float32Return.Put(p)
}

func (__ *PoolOfStringThenFloat32Impl) GetChReturnOfFloat32() chan *ReturnOfFloat32 {
	return __.ChReturnOfFloat32.Get().(chan *ReturnOfFloat32)
}
func (__ *PoolOfStringThenFloat32Impl) PutChReturnOfFloat32(p chan *ReturnOfFloat32) {
	__.ChReturnOfFloat32.Put(p)
}

func NewPoolOfStringThenFloat32Impl() *PoolOfStringThenFloat32Impl {
	return &PoolOfStringThenFloat32Impl{
		StringArg: sync.Pool{
			New: func() interface{} {
				return new(string)
			},
		},
		StringWork: sync.Pool{
			New: func() interface{} {
				return new(WorkOfStringThenFloat32)
			},
		},
		Float32Rtn: sync.Pool{
			New: func() interface{} {
				return new(float32)
			},
		},
		Float32Return: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfFloat32)
			},
		},
		ChReturnOfFloat32: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfFloat32, 1)
			},
		},
	}
}

type ApiDecouplerOfStringThenFloat32 struct {
	pool PoolOfStringThenFloat32
}

func NewApiDecouplerOfStringThenFloat32() *ApiDecouplerOfStringThenFloat32 {
	return &ApiDecouplerOfStringThenFloat32{
		pool: NewPoolOfStringThenFloat32Impl(),
	}
}

func (__ *ApiDecouplerOfStringThenFloat32) ReturnError(rtn_ch chan<- *ReturnOfFloat32, err error) {
	rtn := __.pool.GetReturnOfFloat32()
	var other float32
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfStringThenFloat32) HandleOfStringThenFloat32(ctx context.Context, req *WorkOfStringThenFloat32, h func(ctx context.Context, arg string) (float32, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfFloat32()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfStringThenFloat32) DoOfStringThenFloat32(ctx context.Context, worker WorkerOfPushStringThenFloat32, arg string) (float32, error) {
	// ch := make(chan *ReturnOfFloat32, 1)
	ch := __.pool.GetChReturnOfFloat32()
	defer __.pool.PutChReturnOfFloat32(ch)

	req := __.pool.GetWorkOfStringThenFloat32()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfStringThenFloat32(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfFloat32(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfStringThenFloat32 = func(ctx context.Context, arg string) (float32, error)

type WorkerOfStringThenFloat32 struct {
	api_syncer *ApiDecouplerOfStringThenFloat32
	handler    WorkHandlerOfStringThenFloat32

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfStringThenFloat32
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfStringThenFloat32(ctx context.Context, h WorkHandlerOfStringThenFloat32, n int) *WorkerOfStringThenFloat32 {
	__ := &WorkerOfStringThenFloat32{
		api_syncer: NewApiDecouplerOfStringThenFloat32(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfStringThenFloat32, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfStringThenFloat32{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfStringThenFloat32(req.Context, req.WorkOfStringThenFloat32, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfStringThenFloat32) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfStringThenFloat32) Push(ctx context.Context, req *WorkOfStringThenFloat32) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfStringThenFloat32)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfStringThenFloat32 = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfStringThenFloat32) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfStringThenFloat32) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfStringThenFloat32) Call(ctx context.Context, arg string) (float32, error) {
	return __.api_syncer.DoOfStringThenFloat32(ctx, __, arg)
}

type PoolOfStringThenFloat64 interface {
	GetStringArg() *string
	PutStringArg(*string)
	GetFloat64Return() *float64
	PutFloat64Return(*float64)

	GetWorkOfStringThenFloat64() *WorkOfStringThenFloat64
	GetReturnOfFloat64() *ReturnOfFloat64
	PutWorkOfStringThenFloat64(*WorkOfStringThenFloat64)
	PutReturnOfFloat64(*ReturnOfFloat64)

	GetChReturnOfFloat64() chan *ReturnOfFloat64
	PutChReturnOfFloat64(chan *ReturnOfFloat64)
}

type PoolOfStringThenFloat64Impl struct {
	StringArg         sync.Pool
	Float64Rtn        sync.Pool
	StringWork        sync.Pool
	Float64Return     sync.Pool
	ChReturnOfFloat64 sync.Pool
}

func (__ *PoolOfStringThenFloat64Impl) GetStringArg() *string {
	return __.StringArg.Get().(*string)
}
func (__ *PoolOfStringThenFloat64Impl) PutStringArg(p *string) {
	__.StringArg.Put(p)
}
func (__ *PoolOfStringThenFloat64Impl) GetFloat64Return() *float64 {
	return __.Float64Rtn.Get().(*float64)
}
func (__ *PoolOfStringThenFloat64Impl) PutFloat64Return(p *float64) {
	__.Float64Rtn.Put(p)
}

func (__ *PoolOfStringThenFloat64Impl) GetWorkOfStringThenFloat64() *WorkOfStringThenFloat64 {
	return __.StringWork.Get().(*WorkOfStringThenFloat64)
}
func (__ *PoolOfStringThenFloat64Impl) PutWorkOfStringThenFloat64(p *WorkOfStringThenFloat64) {
	__.StringWork.Put(p)
}
func (__ *PoolOfStringThenFloat64Impl) GetReturnOfFloat64() *ReturnOfFloat64 {
	return __.Float64Return.Get().(*ReturnOfFloat64)
}
func (__ *PoolOfStringThenFloat64Impl) PutReturnOfFloat64(p *ReturnOfFloat64) {
	__.Float64Return.Put(p)
}

func (__ *PoolOfStringThenFloat64Impl) GetChReturnOfFloat64() chan *ReturnOfFloat64 {
	return __.ChReturnOfFloat64.Get().(chan *ReturnOfFloat64)
}
func (__ *PoolOfStringThenFloat64Impl) PutChReturnOfFloat64(p chan *ReturnOfFloat64) {
	__.ChReturnOfFloat64.Put(p)
}

func NewPoolOfStringThenFloat64Impl() *PoolOfStringThenFloat64Impl {
	return &PoolOfStringThenFloat64Impl{
		StringArg: sync.Pool{
			New: func() interface{} {
				return new(string)
			},
		},
		StringWork: sync.Pool{
			New: func() interface{} {
				return new(WorkOfStringThenFloat64)
			},
		},
		Float64Rtn: sync.Pool{
			New: func() interface{} {
				return new(float64)
			},
		},
		Float64Return: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfFloat64)
			},
		},
		ChReturnOfFloat64: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfFloat64, 1)
			},
		},
	}
}

type ApiDecouplerOfStringThenFloat64 struct {
	pool PoolOfStringThenFloat64
}

func NewApiDecouplerOfStringThenFloat64() *ApiDecouplerOfStringThenFloat64 {
	return &ApiDecouplerOfStringThenFloat64{
		pool: NewPoolOfStringThenFloat64Impl(),
	}
}

func (__ *ApiDecouplerOfStringThenFloat64) ReturnError(rtn_ch chan<- *ReturnOfFloat64, err error) {
	rtn := __.pool.GetReturnOfFloat64()
	var other float64
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfStringThenFloat64) HandleOfStringThenFloat64(ctx context.Context, req *WorkOfStringThenFloat64, h func(ctx context.Context, arg string) (float64, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfFloat64()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfStringThenFloat64) DoOfStringThenFloat64(ctx context.Context, worker WorkerOfPushStringThenFloat64, arg string) (float64, error) {
	// ch := make(chan *ReturnOfFloat64, 1)
	ch := __.pool.GetChReturnOfFloat64()
	defer __.pool.PutChReturnOfFloat64(ch)

	req := __.pool.GetWorkOfStringThenFloat64()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfStringThenFloat64(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfFloat64(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfStringThenFloat64 = func(ctx context.Context, arg string) (float64, error)

type WorkerOfStringThenFloat64 struct {
	api_syncer *ApiDecouplerOfStringThenFloat64
	handler    WorkHandlerOfStringThenFloat64

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfStringThenFloat64
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfStringThenFloat64(ctx context.Context, h WorkHandlerOfStringThenFloat64, n int) *WorkerOfStringThenFloat64 {
	__ := &WorkerOfStringThenFloat64{
		api_syncer: NewApiDecouplerOfStringThenFloat64(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfStringThenFloat64, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfStringThenFloat64{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfStringThenFloat64(req.Context, req.WorkOfStringThenFloat64, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfStringThenFloat64) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfStringThenFloat64) Push(ctx context.Context, req *WorkOfStringThenFloat64) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfStringThenFloat64)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfStringThenFloat64 = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfStringThenFloat64) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfStringThenFloat64) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfStringThenFloat64) Call(ctx context.Context, arg string) (float64, error) {
	return __.api_syncer.DoOfStringThenFloat64(ctx, __, arg)
}

type PoolOfStringThenInt interface {
	GetStringArg() *string
	PutStringArg(*string)
	GetIntReturn() *int
	PutIntReturn(*int)

	GetWorkOfStringThenInt() *WorkOfStringThenInt
	GetReturnOfInt() *ReturnOfInt
	PutWorkOfStringThenInt(*WorkOfStringThenInt)
	PutReturnOfInt(*ReturnOfInt)

	GetChReturnOfInt() chan *ReturnOfInt
	PutChReturnOfInt(chan *ReturnOfInt)
}

type PoolOfStringThenIntImpl struct {
	StringArg     sync.Pool
	IntRtn        sync.Pool
	StringWork    sync.Pool
	IntReturn     sync.Pool
	ChReturnOfInt sync.Pool
}

func (__ *PoolOfStringThenIntImpl) GetStringArg() *string {
	return __.StringArg.Get().(*string)
}
func (__ *PoolOfStringThenIntImpl) PutStringArg(p *string) {
	__.StringArg.Put(p)
}
func (__ *PoolOfStringThenIntImpl) GetIntReturn() *int {
	return __.IntRtn.Get().(*int)
}
func (__ *PoolOfStringThenIntImpl) PutIntReturn(p *int) {
	__.IntRtn.Put(p)
}

func (__ *PoolOfStringThenIntImpl) GetWorkOfStringThenInt() *WorkOfStringThenInt {
	return __.StringWork.Get().(*WorkOfStringThenInt)
}
func (__ *PoolOfStringThenIntImpl) PutWorkOfStringThenInt(p *WorkOfStringThenInt) {
	__.StringWork.Put(p)
}
func (__ *PoolOfStringThenIntImpl) GetReturnOfInt() *ReturnOfInt {
	return __.IntReturn.Get().(*ReturnOfInt)
}
func (__ *PoolOfStringThenIntImpl) PutReturnOfInt(p *ReturnOfInt) {
	__.IntReturn.Put(p)
}

func (__ *PoolOfStringThenIntImpl) GetChReturnOfInt() chan *ReturnOfInt {
	return __.ChReturnOfInt.Get().(chan *ReturnOfInt)
}
func (__ *PoolOfStringThenIntImpl) PutChReturnOfInt(p chan *ReturnOfInt) {
	__.ChReturnOfInt.Put(p)
}

func NewPoolOfStringThenIntImpl() *PoolOfStringThenIntImpl {
	return &PoolOfStringThenIntImpl{
		StringArg: sync.Pool{
			New: func() interface{} {
				return new(string)
			},
		},
		StringWork: sync.Pool{
			New: func() interface{} {
				return new(WorkOfStringThenInt)
			},
		},
		IntRtn: sync.Pool{
			New: func() interface{} {
				return new(int)
			},
		},
		IntReturn: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfInt)
			},
		},
		ChReturnOfInt: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfInt, 1)
			},
		},
	}
}

type ApiDecouplerOfStringThenInt struct {
	pool PoolOfStringThenInt
}

func NewApiDecouplerOfStringThenInt() *ApiDecouplerOfStringThenInt {
	return &ApiDecouplerOfStringThenInt{
		pool: NewPoolOfStringThenIntImpl(),
	}
}

func (__ *ApiDecouplerOfStringThenInt) ReturnError(rtn_ch chan<- *ReturnOfInt, err error) {
	rtn := __.pool.GetReturnOfInt()
	var other int
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfStringThenInt) HandleOfStringThenInt(ctx context.Context, req *WorkOfStringThenInt, h func(ctx context.Context, arg string) (int, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfInt()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfStringThenInt) DoOfStringThenInt(ctx context.Context, worker WorkerOfPushStringThenInt, arg string) (int, error) {
	// ch := make(chan *ReturnOfInt, 1)
	ch := __.pool.GetChReturnOfInt()
	defer __.pool.PutChReturnOfInt(ch)

	req := __.pool.GetWorkOfStringThenInt()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfStringThenInt(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfInt(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfStringThenInt = func(ctx context.Context, arg string) (int, error)

type WorkerOfStringThenInt struct {
	api_syncer *ApiDecouplerOfStringThenInt
	handler    WorkHandlerOfStringThenInt

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfStringThenInt
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfStringThenInt(ctx context.Context, h WorkHandlerOfStringThenInt, n int) *WorkerOfStringThenInt {
	__ := &WorkerOfStringThenInt{
		api_syncer: NewApiDecouplerOfStringThenInt(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfStringThenInt, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfStringThenInt{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfStringThenInt(req.Context, req.WorkOfStringThenInt, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfStringThenInt) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfStringThenInt) Push(ctx context.Context, req *WorkOfStringThenInt) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfStringThenInt)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfStringThenInt = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfStringThenInt) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfStringThenInt) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfStringThenInt) Call(ctx context.Context, arg string) (int, error) {
	return __.api_syncer.DoOfStringThenInt(ctx, __, arg)
}

type PoolOfStringThenInt16 interface {
	GetStringArg() *string
	PutStringArg(*string)
	GetInt16Return() *int16
	PutInt16Return(*int16)

	GetWorkOfStringThenInt16() *WorkOfStringThenInt16
	GetReturnOfInt16() *ReturnOfInt16
	PutWorkOfStringThenInt16(*WorkOfStringThenInt16)
	PutReturnOfInt16(*ReturnOfInt16)

	GetChReturnOfInt16() chan *ReturnOfInt16
	PutChReturnOfInt16(chan *ReturnOfInt16)
}

type PoolOfStringThenInt16Impl struct {
	StringArg       sync.Pool
	Int16Rtn        sync.Pool
	StringWork      sync.Pool
	Int16Return     sync.Pool
	ChReturnOfInt16 sync.Pool
}

func (__ *PoolOfStringThenInt16Impl) GetStringArg() *string {
	return __.StringArg.Get().(*string)
}
func (__ *PoolOfStringThenInt16Impl) PutStringArg(p *string) {
	__.StringArg.Put(p)
}
func (__ *PoolOfStringThenInt16Impl) GetInt16Return() *int16 {
	return __.Int16Rtn.Get().(*int16)
}
func (__ *PoolOfStringThenInt16Impl) PutInt16Return(p *int16) {
	__.Int16Rtn.Put(p)
}

func (__ *PoolOfStringThenInt16Impl) GetWorkOfStringThenInt16() *WorkOfStringThenInt16 {
	return __.StringWork.Get().(*WorkOfStringThenInt16)
}
func (__ *PoolOfStringThenInt16Impl) PutWorkOfStringThenInt16(p *WorkOfStringThenInt16) {
	__.StringWork.Put(p)
}
func (__ *PoolOfStringThenInt16Impl) GetReturnOfInt16() *ReturnOfInt16 {
	return __.Int16Return.Get().(*ReturnOfInt16)
}
func (__ *PoolOfStringThenInt16Impl) PutReturnOfInt16(p *ReturnOfInt16) {
	__.Int16Return.Put(p)
}

func (__ *PoolOfStringThenInt16Impl) GetChReturnOfInt16() chan *ReturnOfInt16 {
	return __.ChReturnOfInt16.Get().(chan *ReturnOfInt16)
}
func (__ *PoolOfStringThenInt16Impl) PutChReturnOfInt16(p chan *ReturnOfInt16) {
	__.ChReturnOfInt16.Put(p)
}

func NewPoolOfStringThenInt16Impl() *PoolOfStringThenInt16Impl {
	return &PoolOfStringThenInt16Impl{
		StringArg: sync.Pool{
			New: func() interface{} {
				return new(string)
			},
		},
		StringWork: sync.Pool{
			New: func() interface{} {
				return new(WorkOfStringThenInt16)
			},
		},
		Int16Rtn: sync.Pool{
			New: func() interface{} {
				return new(int16)
			},
		},
		Int16Return: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfInt16)
			},
		},
		ChReturnOfInt16: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfInt16, 1)
			},
		},
	}
}

type ApiDecouplerOfStringThenInt16 struct {
	pool PoolOfStringThenInt16
}

func NewApiDecouplerOfStringThenInt16() *ApiDecouplerOfStringThenInt16 {
	return &ApiDecouplerOfStringThenInt16{
		pool: NewPoolOfStringThenInt16Impl(),
	}
}

func (__ *ApiDecouplerOfStringThenInt16) ReturnError(rtn_ch chan<- *ReturnOfInt16, err error) {
	rtn := __.pool.GetReturnOfInt16()
	var other int16
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfStringThenInt16) HandleOfStringThenInt16(ctx context.Context, req *WorkOfStringThenInt16, h func(ctx context.Context, arg string) (int16, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfInt16()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfStringThenInt16) DoOfStringThenInt16(ctx context.Context, worker WorkerOfPushStringThenInt16, arg string) (int16, error) {
	// ch := make(chan *ReturnOfInt16, 1)
	ch := __.pool.GetChReturnOfInt16()
	defer __.pool.PutChReturnOfInt16(ch)

	req := __.pool.GetWorkOfStringThenInt16()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfStringThenInt16(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfInt16(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfStringThenInt16 = func(ctx context.Context, arg string) (int16, error)

type WorkerOfStringThenInt16 struct {
	api_syncer *ApiDecouplerOfStringThenInt16
	handler    WorkHandlerOfStringThenInt16

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfStringThenInt16
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfStringThenInt16(ctx context.Context, h WorkHandlerOfStringThenInt16, n int) *WorkerOfStringThenInt16 {
	__ := &WorkerOfStringThenInt16{
		api_syncer: NewApiDecouplerOfStringThenInt16(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfStringThenInt16, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfStringThenInt16{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfStringThenInt16(req.Context, req.WorkOfStringThenInt16, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfStringThenInt16) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfStringThenInt16) Push(ctx context.Context, req *WorkOfStringThenInt16) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfStringThenInt16)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfStringThenInt16 = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfStringThenInt16) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfStringThenInt16) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfStringThenInt16) Call(ctx context.Context, arg string) (int16, error) {
	return __.api_syncer.DoOfStringThenInt16(ctx, __, arg)
}

type PoolOfStringThenInt32 interface {
	GetStringArg() *string
	PutStringArg(*string)
	GetInt32Return() *int32
	PutInt32Return(*int32)

	GetWorkOfStringThenInt32() *WorkOfStringThenInt32
	GetReturnOfInt32() *ReturnOfInt32
	PutWorkOfStringThenInt32(*WorkOfStringThenInt32)
	PutReturnOfInt32(*ReturnOfInt32)

	GetChReturnOfInt32() chan *ReturnOfInt32
	PutChReturnOfInt32(chan *ReturnOfInt32)
}

type PoolOfStringThenInt32Impl struct {
	StringArg       sync.Pool
	Int32Rtn        sync.Pool
	StringWork      sync.Pool
	Int32Return     sync.Pool
	ChReturnOfInt32 sync.Pool
}

func (__ *PoolOfStringThenInt32Impl) GetStringArg() *string {
	return __.StringArg.Get().(*string)
}
func (__ *PoolOfStringThenInt32Impl) PutStringArg(p *string) {
	__.StringArg.Put(p)
}
func (__ *PoolOfStringThenInt32Impl) GetInt32Return() *int32 {
	return __.Int32Rtn.Get().(*int32)
}
func (__ *PoolOfStringThenInt32Impl) PutInt32Return(p *int32) {
	__.Int32Rtn.Put(p)
}

func (__ *PoolOfStringThenInt32Impl) GetWorkOfStringThenInt32() *WorkOfStringThenInt32 {
	return __.StringWork.Get().(*WorkOfStringThenInt32)
}
func (__ *PoolOfStringThenInt32Impl) PutWorkOfStringThenInt32(p *WorkOfStringThenInt32) {
	__.StringWork.Put(p)
}
func (__ *PoolOfStringThenInt32Impl) GetReturnOfInt32() *ReturnOfInt32 {
	return __.Int32Return.Get().(*ReturnOfInt32)
}
func (__ *PoolOfStringThenInt32Impl) PutReturnOfInt32(p *ReturnOfInt32) {
	__.Int32Return.Put(p)
}

func (__ *PoolOfStringThenInt32Impl) GetChReturnOfInt32() chan *ReturnOfInt32 {
	return __.ChReturnOfInt32.Get().(chan *ReturnOfInt32)
}
func (__ *PoolOfStringThenInt32Impl) PutChReturnOfInt32(p chan *ReturnOfInt32) {
	__.ChReturnOfInt32.Put(p)
}

func NewPoolOfStringThenInt32Impl() *PoolOfStringThenInt32Impl {
	return &PoolOfStringThenInt32Impl{
		StringArg: sync.Pool{
			New: func() interface{} {
				return new(string)
			},
		},
		StringWork: sync.Pool{
			New: func() interface{} {
				return new(WorkOfStringThenInt32)
			},
		},
		Int32Rtn: sync.Pool{
			New: func() interface{} {
				return new(int32)
			},
		},
		Int32Return: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfInt32)
			},
		},
		ChReturnOfInt32: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfInt32, 1)
			},
		},
	}
}

type ApiDecouplerOfStringThenInt32 struct {
	pool PoolOfStringThenInt32
}

func NewApiDecouplerOfStringThenInt32() *ApiDecouplerOfStringThenInt32 {
	return &ApiDecouplerOfStringThenInt32{
		pool: NewPoolOfStringThenInt32Impl(),
	}
}

func (__ *ApiDecouplerOfStringThenInt32) ReturnError(rtn_ch chan<- *ReturnOfInt32, err error) {
	rtn := __.pool.GetReturnOfInt32()
	var other int32
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfStringThenInt32) HandleOfStringThenInt32(ctx context.Context, req *WorkOfStringThenInt32, h func(ctx context.Context, arg string) (int32, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfInt32()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfStringThenInt32) DoOfStringThenInt32(ctx context.Context, worker WorkerOfPushStringThenInt32, arg string) (int32, error) {
	// ch := make(chan *ReturnOfInt32, 1)
	ch := __.pool.GetChReturnOfInt32()
	defer __.pool.PutChReturnOfInt32(ch)

	req := __.pool.GetWorkOfStringThenInt32()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfStringThenInt32(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfInt32(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfStringThenInt32 = func(ctx context.Context, arg string) (int32, error)

type WorkerOfStringThenInt32 struct {
	api_syncer *ApiDecouplerOfStringThenInt32
	handler    WorkHandlerOfStringThenInt32

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfStringThenInt32
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfStringThenInt32(ctx context.Context, h WorkHandlerOfStringThenInt32, n int) *WorkerOfStringThenInt32 {
	__ := &WorkerOfStringThenInt32{
		api_syncer: NewApiDecouplerOfStringThenInt32(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfStringThenInt32, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfStringThenInt32{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfStringThenInt32(req.Context, req.WorkOfStringThenInt32, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfStringThenInt32) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfStringThenInt32) Push(ctx context.Context, req *WorkOfStringThenInt32) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfStringThenInt32)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfStringThenInt32 = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfStringThenInt32) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfStringThenInt32) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfStringThenInt32) Call(ctx context.Context, arg string) (int32, error) {
	return __.api_syncer.DoOfStringThenInt32(ctx, __, arg)
}

type PoolOfStringThenInt64 interface {
	GetStringArg() *string
	PutStringArg(*string)
	GetInt64Return() *int64
	PutInt64Return(*int64)

	GetWorkOfStringThenInt64() *WorkOfStringThenInt64
	GetReturnOfInt64() *ReturnOfInt64
	PutWorkOfStringThenInt64(*WorkOfStringThenInt64)
	PutReturnOfInt64(*ReturnOfInt64)

	GetChReturnOfInt64() chan *ReturnOfInt64
	PutChReturnOfInt64(chan *ReturnOfInt64)
}

type PoolOfStringThenInt64Impl struct {
	StringArg       sync.Pool
	Int64Rtn        sync.Pool
	StringWork      sync.Pool
	Int64Return     sync.Pool
	ChReturnOfInt64 sync.Pool
}

func (__ *PoolOfStringThenInt64Impl) GetStringArg() *string {
	return __.StringArg.Get().(*string)
}
func (__ *PoolOfStringThenInt64Impl) PutStringArg(p *string) {
	__.StringArg.Put(p)
}
func (__ *PoolOfStringThenInt64Impl) GetInt64Return() *int64 {
	return __.Int64Rtn.Get().(*int64)
}
func (__ *PoolOfStringThenInt64Impl) PutInt64Return(p *int64) {
	__.Int64Rtn.Put(p)
}

func (__ *PoolOfStringThenInt64Impl) GetWorkOfStringThenInt64() *WorkOfStringThenInt64 {
	return __.StringWork.Get().(*WorkOfStringThenInt64)
}
func (__ *PoolOfStringThenInt64Impl) PutWorkOfStringThenInt64(p *WorkOfStringThenInt64) {
	__.StringWork.Put(p)
}
func (__ *PoolOfStringThenInt64Impl) GetReturnOfInt64() *ReturnOfInt64 {
	return __.Int64Return.Get().(*ReturnOfInt64)
}
func (__ *PoolOfStringThenInt64Impl) PutReturnOfInt64(p *ReturnOfInt64) {
	__.Int64Return.Put(p)
}

func (__ *PoolOfStringThenInt64Impl) GetChReturnOfInt64() chan *ReturnOfInt64 {
	return __.ChReturnOfInt64.Get().(chan *ReturnOfInt64)
}
func (__ *PoolOfStringThenInt64Impl) PutChReturnOfInt64(p chan *ReturnOfInt64) {
	__.ChReturnOfInt64.Put(p)
}

func NewPoolOfStringThenInt64Impl() *PoolOfStringThenInt64Impl {
	return &PoolOfStringThenInt64Impl{
		StringArg: sync.Pool{
			New: func() interface{} {
				return new(string)
			},
		},
		StringWork: sync.Pool{
			New: func() interface{} {
				return new(WorkOfStringThenInt64)
			},
		},
		Int64Rtn: sync.Pool{
			New: func() interface{} {
				return new(int64)
			},
		},
		Int64Return: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfInt64)
			},
		},
		ChReturnOfInt64: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfInt64, 1)
			},
		},
	}
}

type ApiDecouplerOfStringThenInt64 struct {
	pool PoolOfStringThenInt64
}

func NewApiDecouplerOfStringThenInt64() *ApiDecouplerOfStringThenInt64 {
	return &ApiDecouplerOfStringThenInt64{
		pool: NewPoolOfStringThenInt64Impl(),
	}
}

func (__ *ApiDecouplerOfStringThenInt64) ReturnError(rtn_ch chan<- *ReturnOfInt64, err error) {
	rtn := __.pool.GetReturnOfInt64()
	var other int64
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfStringThenInt64) HandleOfStringThenInt64(ctx context.Context, req *WorkOfStringThenInt64, h func(ctx context.Context, arg string) (int64, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfInt64()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfStringThenInt64) DoOfStringThenInt64(ctx context.Context, worker WorkerOfPushStringThenInt64, arg string) (int64, error) {
	// ch := make(chan *ReturnOfInt64, 1)
	ch := __.pool.GetChReturnOfInt64()
	defer __.pool.PutChReturnOfInt64(ch)

	req := __.pool.GetWorkOfStringThenInt64()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfStringThenInt64(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfInt64(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfStringThenInt64 = func(ctx context.Context, arg string) (int64, error)

type WorkerOfStringThenInt64 struct {
	api_syncer *ApiDecouplerOfStringThenInt64
	handler    WorkHandlerOfStringThenInt64

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfStringThenInt64
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfStringThenInt64(ctx context.Context, h WorkHandlerOfStringThenInt64, n int) *WorkerOfStringThenInt64 {
	__ := &WorkerOfStringThenInt64{
		api_syncer: NewApiDecouplerOfStringThenInt64(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfStringThenInt64, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfStringThenInt64{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfStringThenInt64(req.Context, req.WorkOfStringThenInt64, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfStringThenInt64) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfStringThenInt64) Push(ctx context.Context, req *WorkOfStringThenInt64) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfStringThenInt64)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfStringThenInt64 = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfStringThenInt64) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfStringThenInt64) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfStringThenInt64) Call(ctx context.Context, arg string) (int64, error) {
	return __.api_syncer.DoOfStringThenInt64(ctx, __, arg)
}

type PoolOfStringThenInt8 interface {
	GetStringArg() *string
	PutStringArg(*string)
	GetInt8Return() *int8
	PutInt8Return(*int8)

	GetWorkOfStringThenInt8() *WorkOfStringThenInt8
	GetReturnOfInt8() *ReturnOfInt8
	PutWorkOfStringThenInt8(*WorkOfStringThenInt8)
	PutReturnOfInt8(*ReturnOfInt8)

	GetChReturnOfInt8() chan *ReturnOfInt8
	PutChReturnOfInt8(chan *ReturnOfInt8)
}

type PoolOfStringThenInt8Impl struct {
	StringArg      sync.Pool
	Int8Rtn        sync.Pool
	StringWork     sync.Pool
	Int8Return     sync.Pool
	ChReturnOfInt8 sync.Pool
}

func (__ *PoolOfStringThenInt8Impl) GetStringArg() *string {
	return __.StringArg.Get().(*string)
}
func (__ *PoolOfStringThenInt8Impl) PutStringArg(p *string) {
	__.StringArg.Put(p)
}
func (__ *PoolOfStringThenInt8Impl) GetInt8Return() *int8 {
	return __.Int8Rtn.Get().(*int8)
}
func (__ *PoolOfStringThenInt8Impl) PutInt8Return(p *int8) {
	__.Int8Rtn.Put(p)
}

func (__ *PoolOfStringThenInt8Impl) GetWorkOfStringThenInt8() *WorkOfStringThenInt8 {
	return __.StringWork.Get().(*WorkOfStringThenInt8)
}
func (__ *PoolOfStringThenInt8Impl) PutWorkOfStringThenInt8(p *WorkOfStringThenInt8) {
	__.StringWork.Put(p)
}
func (__ *PoolOfStringThenInt8Impl) GetReturnOfInt8() *ReturnOfInt8 {
	return __.Int8Return.Get().(*ReturnOfInt8)
}
func (__ *PoolOfStringThenInt8Impl) PutReturnOfInt8(p *ReturnOfInt8) {
	__.Int8Return.Put(p)
}

func (__ *PoolOfStringThenInt8Impl) GetChReturnOfInt8() chan *ReturnOfInt8 {
	return __.ChReturnOfInt8.Get().(chan *ReturnOfInt8)
}
func (__ *PoolOfStringThenInt8Impl) PutChReturnOfInt8(p chan *ReturnOfInt8) {
	__.ChReturnOfInt8.Put(p)
}

func NewPoolOfStringThenInt8Impl() *PoolOfStringThenInt8Impl {
	return &PoolOfStringThenInt8Impl{
		StringArg: sync.Pool{
			New: func() interface{} {
				return new(string)
			},
		},
		StringWork: sync.Pool{
			New: func() interface{} {
				return new(WorkOfStringThenInt8)
			},
		},
		Int8Rtn: sync.Pool{
			New: func() interface{} {
				return new(int8)
			},
		},
		Int8Return: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfInt8)
			},
		},
		ChReturnOfInt8: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfInt8, 1)
			},
		},
	}
}

type ApiDecouplerOfStringThenInt8 struct {
	pool PoolOfStringThenInt8
}

func NewApiDecouplerOfStringThenInt8() *ApiDecouplerOfStringThenInt8 {
	return &ApiDecouplerOfStringThenInt8{
		pool: NewPoolOfStringThenInt8Impl(),
	}
}

func (__ *ApiDecouplerOfStringThenInt8) ReturnError(rtn_ch chan<- *ReturnOfInt8, err error) {
	rtn := __.pool.GetReturnOfInt8()
	var other int8
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfStringThenInt8) HandleOfStringThenInt8(ctx context.Context, req *WorkOfStringThenInt8, h func(ctx context.Context, arg string) (int8, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfInt8()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfStringThenInt8) DoOfStringThenInt8(ctx context.Context, worker WorkerOfPushStringThenInt8, arg string) (int8, error) {
	// ch := make(chan *ReturnOfInt8, 1)
	ch := __.pool.GetChReturnOfInt8()
	defer __.pool.PutChReturnOfInt8(ch)

	req := __.pool.GetWorkOfStringThenInt8()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfStringThenInt8(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfInt8(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfStringThenInt8 = func(ctx context.Context, arg string) (int8, error)

type WorkerOfStringThenInt8 struct {
	api_syncer *ApiDecouplerOfStringThenInt8
	handler    WorkHandlerOfStringThenInt8

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfStringThenInt8
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfStringThenInt8(ctx context.Context, h WorkHandlerOfStringThenInt8, n int) *WorkerOfStringThenInt8 {
	__ := &WorkerOfStringThenInt8{
		api_syncer: NewApiDecouplerOfStringThenInt8(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfStringThenInt8, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfStringThenInt8{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfStringThenInt8(req.Context, req.WorkOfStringThenInt8, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfStringThenInt8) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfStringThenInt8) Push(ctx context.Context, req *WorkOfStringThenInt8) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfStringThenInt8)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfStringThenInt8 = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfStringThenInt8) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfStringThenInt8) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfStringThenInt8) Call(ctx context.Context, arg string) (int8, error) {
	return __.api_syncer.DoOfStringThenInt8(ctx, __, arg)
}

type PoolOfStringThenRune interface {
	GetStringArg() *string
	PutStringArg(*string)
	GetRuneReturn() *rune
	PutRuneReturn(*rune)

	GetWorkOfStringThenRune() *WorkOfStringThenRune
	GetReturnOfRune() *ReturnOfRune
	PutWorkOfStringThenRune(*WorkOfStringThenRune)
	PutReturnOfRune(*ReturnOfRune)

	GetChReturnOfRune() chan *ReturnOfRune
	PutChReturnOfRune(chan *ReturnOfRune)
}

type PoolOfStringThenRuneImpl struct {
	StringArg      sync.Pool
	RuneRtn        sync.Pool
	StringWork     sync.Pool
	RuneReturn     sync.Pool
	ChReturnOfRune sync.Pool
}

func (__ *PoolOfStringThenRuneImpl) GetStringArg() *string {
	return __.StringArg.Get().(*string)
}
func (__ *PoolOfStringThenRuneImpl) PutStringArg(p *string) {
	__.StringArg.Put(p)
}
func (__ *PoolOfStringThenRuneImpl) GetRuneReturn() *rune {
	return __.RuneRtn.Get().(*rune)
}
func (__ *PoolOfStringThenRuneImpl) PutRuneReturn(p *rune) {
	__.RuneRtn.Put(p)
}

func (__ *PoolOfStringThenRuneImpl) GetWorkOfStringThenRune() *WorkOfStringThenRune {
	return __.StringWork.Get().(*WorkOfStringThenRune)
}
func (__ *PoolOfStringThenRuneImpl) PutWorkOfStringThenRune(p *WorkOfStringThenRune) {
	__.StringWork.Put(p)
}
func (__ *PoolOfStringThenRuneImpl) GetReturnOfRune() *ReturnOfRune {
	return __.RuneReturn.Get().(*ReturnOfRune)
}
func (__ *PoolOfStringThenRuneImpl) PutReturnOfRune(p *ReturnOfRune) {
	__.RuneReturn.Put(p)
}

func (__ *PoolOfStringThenRuneImpl) GetChReturnOfRune() chan *ReturnOfRune {
	return __.ChReturnOfRune.Get().(chan *ReturnOfRune)
}
func (__ *PoolOfStringThenRuneImpl) PutChReturnOfRune(p chan *ReturnOfRune) {
	__.ChReturnOfRune.Put(p)
}

func NewPoolOfStringThenRuneImpl() *PoolOfStringThenRuneImpl {
	return &PoolOfStringThenRuneImpl{
		StringArg: sync.Pool{
			New: func() interface{} {
				return new(string)
			},
		},
		StringWork: sync.Pool{
			New: func() interface{} {
				return new(WorkOfStringThenRune)
			},
		},
		RuneRtn: sync.Pool{
			New: func() interface{} {
				return new(rune)
			},
		},
		RuneReturn: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfRune)
			},
		},
		ChReturnOfRune: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfRune, 1)
			},
		},
	}
}

type ApiDecouplerOfStringThenRune struct {
	pool PoolOfStringThenRune
}

func NewApiDecouplerOfStringThenRune() *ApiDecouplerOfStringThenRune {
	return &ApiDecouplerOfStringThenRune{
		pool: NewPoolOfStringThenRuneImpl(),
	}
}

func (__ *ApiDecouplerOfStringThenRune) ReturnError(rtn_ch chan<- *ReturnOfRune, err error) {
	rtn := __.pool.GetReturnOfRune()
	var other rune
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfStringThenRune) HandleOfStringThenRune(ctx context.Context, req *WorkOfStringThenRune, h func(ctx context.Context, arg string) (rune, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfRune()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfStringThenRune) DoOfStringThenRune(ctx context.Context, worker WorkerOfPushStringThenRune, arg string) (rune, error) {
	// ch := make(chan *ReturnOfRune, 1)
	ch := __.pool.GetChReturnOfRune()
	defer __.pool.PutChReturnOfRune(ch)

	req := __.pool.GetWorkOfStringThenRune()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfStringThenRune(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfRune(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfStringThenRune = func(ctx context.Context, arg string) (rune, error)

type WorkerOfStringThenRune struct {
	api_syncer *ApiDecouplerOfStringThenRune
	handler    WorkHandlerOfStringThenRune

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfStringThenRune
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfStringThenRune(ctx context.Context, h WorkHandlerOfStringThenRune, n int) *WorkerOfStringThenRune {
	__ := &WorkerOfStringThenRune{
		api_syncer: NewApiDecouplerOfStringThenRune(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfStringThenRune, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfStringThenRune{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfStringThenRune(req.Context, req.WorkOfStringThenRune, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfStringThenRune) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfStringThenRune) Push(ctx context.Context, req *WorkOfStringThenRune) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfStringThenRune)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfStringThenRune = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfStringThenRune) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfStringThenRune) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfStringThenRune) Call(ctx context.Context, arg string) (rune, error) {
	return __.api_syncer.DoOfStringThenRune(ctx, __, arg)
}

type PoolOfStringThenString interface {
	GetStringArg() *string
	PutStringArg(*string)
	GetStringReturn() *string
	PutStringReturn(*string)

	GetWorkOfStringThenString() *WorkOfStringThenString
	GetReturnOfString() *ReturnOfString
	PutWorkOfStringThenString(*WorkOfStringThenString)
	PutReturnOfString(*ReturnOfString)

	GetChReturnOfString() chan *ReturnOfString
	PutChReturnOfString(chan *ReturnOfString)
}

type PoolOfStringThenStringImpl struct {
	StringArg        sync.Pool
	StringRtn        sync.Pool
	StringWork       sync.Pool
	StringReturn     sync.Pool
	ChReturnOfString sync.Pool
}

func (__ *PoolOfStringThenStringImpl) GetStringArg() *string {
	return __.StringArg.Get().(*string)
}
func (__ *PoolOfStringThenStringImpl) PutStringArg(p *string) {
	__.StringArg.Put(p)
}
func (__ *PoolOfStringThenStringImpl) GetStringReturn() *string {
	return __.StringRtn.Get().(*string)
}
func (__ *PoolOfStringThenStringImpl) PutStringReturn(p *string) {
	__.StringRtn.Put(p)
}

func (__ *PoolOfStringThenStringImpl) GetWorkOfStringThenString() *WorkOfStringThenString {
	return __.StringWork.Get().(*WorkOfStringThenString)
}
func (__ *PoolOfStringThenStringImpl) PutWorkOfStringThenString(p *WorkOfStringThenString) {
	__.StringWork.Put(p)
}
func (__ *PoolOfStringThenStringImpl) GetReturnOfString() *ReturnOfString {
	return __.StringReturn.Get().(*ReturnOfString)
}
func (__ *PoolOfStringThenStringImpl) PutReturnOfString(p *ReturnOfString) {
	__.StringReturn.Put(p)
}

func (__ *PoolOfStringThenStringImpl) GetChReturnOfString() chan *ReturnOfString {
	return __.ChReturnOfString.Get().(chan *ReturnOfString)
}
func (__ *PoolOfStringThenStringImpl) PutChReturnOfString(p chan *ReturnOfString) {
	__.ChReturnOfString.Put(p)
}

func NewPoolOfStringThenStringImpl() *PoolOfStringThenStringImpl {
	return &PoolOfStringThenStringImpl{
		StringArg: sync.Pool{
			New: func() interface{} {
				return new(string)
			},
		},
		StringWork: sync.Pool{
			New: func() interface{} {
				return new(WorkOfStringThenString)
			},
		},
		StringRtn: sync.Pool{
			New: func() interface{} {
				return new(string)
			},
		},
		StringReturn: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfString)
			},
		},
		ChReturnOfString: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfString, 1)
			},
		},
	}
}

type ApiDecouplerOfStringThenString struct {
	pool PoolOfStringThenString
}

func NewApiDecouplerOfStringThenString() *ApiDecouplerOfStringThenString {
	return &ApiDecouplerOfStringThenString{
		pool: NewPoolOfStringThenStringImpl(),
	}
}

func (__ *ApiDecouplerOfStringThenString) ReturnError(rtn_ch chan<- *ReturnOfString, err error) {
	rtn := __.pool.GetReturnOfString()
	var other string
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfStringThenString) HandleOfStringThenString(ctx context.Context, req *WorkOfStringThenString, h func(ctx context.Context, arg string) (string, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfString()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfStringThenString) DoOfStringThenString(ctx context.Context, worker WorkerOfPushStringThenString, arg string) (string, error) {
	// ch := make(chan *ReturnOfString, 1)
	ch := __.pool.GetChReturnOfString()
	defer __.pool.PutChReturnOfString(ch)

	req := __.pool.GetWorkOfStringThenString()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfStringThenString(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfString(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfStringThenString = func(ctx context.Context, arg string) (string, error)

type WorkerOfStringThenString struct {
	api_syncer *ApiDecouplerOfStringThenString
	handler    WorkHandlerOfStringThenString

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfStringThenString
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfStringThenString(ctx context.Context, h WorkHandlerOfStringThenString, n int) *WorkerOfStringThenString {
	__ := &WorkerOfStringThenString{
		api_syncer: NewApiDecouplerOfStringThenString(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfStringThenString, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfStringThenString{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfStringThenString(req.Context, req.WorkOfStringThenString, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfStringThenString) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfStringThenString) Push(ctx context.Context, req *WorkOfStringThenString) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfStringThenString)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfStringThenString = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfStringThenString) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfStringThenString) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfStringThenString) Call(ctx context.Context, arg string) (string, error) {
	return __.api_syncer.DoOfStringThenString(ctx, __, arg)
}

type PoolOfStringThenUint interface {
	GetStringArg() *string
	PutStringArg(*string)
	GetUintReturn() *uint
	PutUintReturn(*uint)

	GetWorkOfStringThenUint() *WorkOfStringThenUint
	GetReturnOfUint() *ReturnOfUint
	PutWorkOfStringThenUint(*WorkOfStringThenUint)
	PutReturnOfUint(*ReturnOfUint)

	GetChReturnOfUint() chan *ReturnOfUint
	PutChReturnOfUint(chan *ReturnOfUint)
}

type PoolOfStringThenUintImpl struct {
	StringArg      sync.Pool
	UintRtn        sync.Pool
	StringWork     sync.Pool
	UintReturn     sync.Pool
	ChReturnOfUint sync.Pool
}

func (__ *PoolOfStringThenUintImpl) GetStringArg() *string {
	return __.StringArg.Get().(*string)
}
func (__ *PoolOfStringThenUintImpl) PutStringArg(p *string) {
	__.StringArg.Put(p)
}
func (__ *PoolOfStringThenUintImpl) GetUintReturn() *uint {
	return __.UintRtn.Get().(*uint)
}
func (__ *PoolOfStringThenUintImpl) PutUintReturn(p *uint) {
	__.UintRtn.Put(p)
}

func (__ *PoolOfStringThenUintImpl) GetWorkOfStringThenUint() *WorkOfStringThenUint {
	return __.StringWork.Get().(*WorkOfStringThenUint)
}
func (__ *PoolOfStringThenUintImpl) PutWorkOfStringThenUint(p *WorkOfStringThenUint) {
	__.StringWork.Put(p)
}
func (__ *PoolOfStringThenUintImpl) GetReturnOfUint() *ReturnOfUint {
	return __.UintReturn.Get().(*ReturnOfUint)
}
func (__ *PoolOfStringThenUintImpl) PutReturnOfUint(p *ReturnOfUint) {
	__.UintReturn.Put(p)
}

func (__ *PoolOfStringThenUintImpl) GetChReturnOfUint() chan *ReturnOfUint {
	return __.ChReturnOfUint.Get().(chan *ReturnOfUint)
}
func (__ *PoolOfStringThenUintImpl) PutChReturnOfUint(p chan *ReturnOfUint) {
	__.ChReturnOfUint.Put(p)
}

func NewPoolOfStringThenUintImpl() *PoolOfStringThenUintImpl {
	return &PoolOfStringThenUintImpl{
		StringArg: sync.Pool{
			New: func() interface{} {
				return new(string)
			},
		},
		StringWork: sync.Pool{
			New: func() interface{} {
				return new(WorkOfStringThenUint)
			},
		},
		UintRtn: sync.Pool{
			New: func() interface{} {
				return new(uint)
			},
		},
		UintReturn: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfUint)
			},
		},
		ChReturnOfUint: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfUint, 1)
			},
		},
	}
}

type ApiDecouplerOfStringThenUint struct {
	pool PoolOfStringThenUint
}

func NewApiDecouplerOfStringThenUint() *ApiDecouplerOfStringThenUint {
	return &ApiDecouplerOfStringThenUint{
		pool: NewPoolOfStringThenUintImpl(),
	}
}

func (__ *ApiDecouplerOfStringThenUint) ReturnError(rtn_ch chan<- *ReturnOfUint, err error) {
	rtn := __.pool.GetReturnOfUint()
	var other uint
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfStringThenUint) HandleOfStringThenUint(ctx context.Context, req *WorkOfStringThenUint, h func(ctx context.Context, arg string) (uint, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfUint()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfStringThenUint) DoOfStringThenUint(ctx context.Context, worker WorkerOfPushStringThenUint, arg string) (uint, error) {
	// ch := make(chan *ReturnOfUint, 1)
	ch := __.pool.GetChReturnOfUint()
	defer __.pool.PutChReturnOfUint(ch)

	req := __.pool.GetWorkOfStringThenUint()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfStringThenUint(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfUint(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfStringThenUint = func(ctx context.Context, arg string) (uint, error)

type WorkerOfStringThenUint struct {
	api_syncer *ApiDecouplerOfStringThenUint
	handler    WorkHandlerOfStringThenUint

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfStringThenUint
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfStringThenUint(ctx context.Context, h WorkHandlerOfStringThenUint, n int) *WorkerOfStringThenUint {
	__ := &WorkerOfStringThenUint{
		api_syncer: NewApiDecouplerOfStringThenUint(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfStringThenUint, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfStringThenUint{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfStringThenUint(req.Context, req.WorkOfStringThenUint, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfStringThenUint) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfStringThenUint) Push(ctx context.Context, req *WorkOfStringThenUint) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfStringThenUint)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfStringThenUint = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfStringThenUint) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfStringThenUint) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfStringThenUint) Call(ctx context.Context, arg string) (uint, error) {
	return __.api_syncer.DoOfStringThenUint(ctx, __, arg)
}

type PoolOfStringThenUint16 interface {
	GetStringArg() *string
	PutStringArg(*string)
	GetUint16Return() *uint16
	PutUint16Return(*uint16)

	GetWorkOfStringThenUint16() *WorkOfStringThenUint16
	GetReturnOfUint16() *ReturnOfUint16
	PutWorkOfStringThenUint16(*WorkOfStringThenUint16)
	PutReturnOfUint16(*ReturnOfUint16)

	GetChReturnOfUint16() chan *ReturnOfUint16
	PutChReturnOfUint16(chan *ReturnOfUint16)
}

type PoolOfStringThenUint16Impl struct {
	StringArg        sync.Pool
	Uint16Rtn        sync.Pool
	StringWork       sync.Pool
	Uint16Return     sync.Pool
	ChReturnOfUint16 sync.Pool
}

func (__ *PoolOfStringThenUint16Impl) GetStringArg() *string {
	return __.StringArg.Get().(*string)
}
func (__ *PoolOfStringThenUint16Impl) PutStringArg(p *string) {
	__.StringArg.Put(p)
}
func (__ *PoolOfStringThenUint16Impl) GetUint16Return() *uint16 {
	return __.Uint16Rtn.Get().(*uint16)
}
func (__ *PoolOfStringThenUint16Impl) PutUint16Return(p *uint16) {
	__.Uint16Rtn.Put(p)
}

func (__ *PoolOfStringThenUint16Impl) GetWorkOfStringThenUint16() *WorkOfStringThenUint16 {
	return __.StringWork.Get().(*WorkOfStringThenUint16)
}
func (__ *PoolOfStringThenUint16Impl) PutWorkOfStringThenUint16(p *WorkOfStringThenUint16) {
	__.StringWork.Put(p)
}
func (__ *PoolOfStringThenUint16Impl) GetReturnOfUint16() *ReturnOfUint16 {
	return __.Uint16Return.Get().(*ReturnOfUint16)
}
func (__ *PoolOfStringThenUint16Impl) PutReturnOfUint16(p *ReturnOfUint16) {
	__.Uint16Return.Put(p)
}

func (__ *PoolOfStringThenUint16Impl) GetChReturnOfUint16() chan *ReturnOfUint16 {
	return __.ChReturnOfUint16.Get().(chan *ReturnOfUint16)
}
func (__ *PoolOfStringThenUint16Impl) PutChReturnOfUint16(p chan *ReturnOfUint16) {
	__.ChReturnOfUint16.Put(p)
}

func NewPoolOfStringThenUint16Impl() *PoolOfStringThenUint16Impl {
	return &PoolOfStringThenUint16Impl{
		StringArg: sync.Pool{
			New: func() interface{} {
				return new(string)
			},
		},
		StringWork: sync.Pool{
			New: func() interface{} {
				return new(WorkOfStringThenUint16)
			},
		},
		Uint16Rtn: sync.Pool{
			New: func() interface{} {
				return new(uint16)
			},
		},
		Uint16Return: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfUint16)
			},
		},
		ChReturnOfUint16: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfUint16, 1)
			},
		},
	}
}

type ApiDecouplerOfStringThenUint16 struct {
	pool PoolOfStringThenUint16
}

func NewApiDecouplerOfStringThenUint16() *ApiDecouplerOfStringThenUint16 {
	return &ApiDecouplerOfStringThenUint16{
		pool: NewPoolOfStringThenUint16Impl(),
	}
}

func (__ *ApiDecouplerOfStringThenUint16) ReturnError(rtn_ch chan<- *ReturnOfUint16, err error) {
	rtn := __.pool.GetReturnOfUint16()
	var other uint16
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfStringThenUint16) HandleOfStringThenUint16(ctx context.Context, req *WorkOfStringThenUint16, h func(ctx context.Context, arg string) (uint16, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfUint16()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfStringThenUint16) DoOfStringThenUint16(ctx context.Context, worker WorkerOfPushStringThenUint16, arg string) (uint16, error) {
	// ch := make(chan *ReturnOfUint16, 1)
	ch := __.pool.GetChReturnOfUint16()
	defer __.pool.PutChReturnOfUint16(ch)

	req := __.pool.GetWorkOfStringThenUint16()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfStringThenUint16(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfUint16(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfStringThenUint16 = func(ctx context.Context, arg string) (uint16, error)

type WorkerOfStringThenUint16 struct {
	api_syncer *ApiDecouplerOfStringThenUint16
	handler    WorkHandlerOfStringThenUint16

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfStringThenUint16
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfStringThenUint16(ctx context.Context, h WorkHandlerOfStringThenUint16, n int) *WorkerOfStringThenUint16 {
	__ := &WorkerOfStringThenUint16{
		api_syncer: NewApiDecouplerOfStringThenUint16(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfStringThenUint16, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfStringThenUint16{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfStringThenUint16(req.Context, req.WorkOfStringThenUint16, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfStringThenUint16) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfStringThenUint16) Push(ctx context.Context, req *WorkOfStringThenUint16) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfStringThenUint16)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfStringThenUint16 = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfStringThenUint16) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfStringThenUint16) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfStringThenUint16) Call(ctx context.Context, arg string) (uint16, error) {
	return __.api_syncer.DoOfStringThenUint16(ctx, __, arg)
}

type PoolOfStringThenUint32 interface {
	GetStringArg() *string
	PutStringArg(*string)
	GetUint32Return() *uint32
	PutUint32Return(*uint32)

	GetWorkOfStringThenUint32() *WorkOfStringThenUint32
	GetReturnOfUint32() *ReturnOfUint32
	PutWorkOfStringThenUint32(*WorkOfStringThenUint32)
	PutReturnOfUint32(*ReturnOfUint32)

	GetChReturnOfUint32() chan *ReturnOfUint32
	PutChReturnOfUint32(chan *ReturnOfUint32)
}

type PoolOfStringThenUint32Impl struct {
	StringArg        sync.Pool
	Uint32Rtn        sync.Pool
	StringWork       sync.Pool
	Uint32Return     sync.Pool
	ChReturnOfUint32 sync.Pool
}

func (__ *PoolOfStringThenUint32Impl) GetStringArg() *string {
	return __.StringArg.Get().(*string)
}
func (__ *PoolOfStringThenUint32Impl) PutStringArg(p *string) {
	__.StringArg.Put(p)
}
func (__ *PoolOfStringThenUint32Impl) GetUint32Return() *uint32 {
	return __.Uint32Rtn.Get().(*uint32)
}
func (__ *PoolOfStringThenUint32Impl) PutUint32Return(p *uint32) {
	__.Uint32Rtn.Put(p)
}

func (__ *PoolOfStringThenUint32Impl) GetWorkOfStringThenUint32() *WorkOfStringThenUint32 {
	return __.StringWork.Get().(*WorkOfStringThenUint32)
}
func (__ *PoolOfStringThenUint32Impl) PutWorkOfStringThenUint32(p *WorkOfStringThenUint32) {
	__.StringWork.Put(p)
}
func (__ *PoolOfStringThenUint32Impl) GetReturnOfUint32() *ReturnOfUint32 {
	return __.Uint32Return.Get().(*ReturnOfUint32)
}
func (__ *PoolOfStringThenUint32Impl) PutReturnOfUint32(p *ReturnOfUint32) {
	__.Uint32Return.Put(p)
}

func (__ *PoolOfStringThenUint32Impl) GetChReturnOfUint32() chan *ReturnOfUint32 {
	return __.ChReturnOfUint32.Get().(chan *ReturnOfUint32)
}
func (__ *PoolOfStringThenUint32Impl) PutChReturnOfUint32(p chan *ReturnOfUint32) {
	__.ChReturnOfUint32.Put(p)
}

func NewPoolOfStringThenUint32Impl() *PoolOfStringThenUint32Impl {
	return &PoolOfStringThenUint32Impl{
		StringArg: sync.Pool{
			New: func() interface{} {
				return new(string)
			},
		},
		StringWork: sync.Pool{
			New: func() interface{} {
				return new(WorkOfStringThenUint32)
			},
		},
		Uint32Rtn: sync.Pool{
			New: func() interface{} {
				return new(uint32)
			},
		},
		Uint32Return: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfUint32)
			},
		},
		ChReturnOfUint32: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfUint32, 1)
			},
		},
	}
}

type ApiDecouplerOfStringThenUint32 struct {
	pool PoolOfStringThenUint32
}

func NewApiDecouplerOfStringThenUint32() *ApiDecouplerOfStringThenUint32 {
	return &ApiDecouplerOfStringThenUint32{
		pool: NewPoolOfStringThenUint32Impl(),
	}
}

func (__ *ApiDecouplerOfStringThenUint32) ReturnError(rtn_ch chan<- *ReturnOfUint32, err error) {
	rtn := __.pool.GetReturnOfUint32()
	var other uint32
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfStringThenUint32) HandleOfStringThenUint32(ctx context.Context, req *WorkOfStringThenUint32, h func(ctx context.Context, arg string) (uint32, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfUint32()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfStringThenUint32) DoOfStringThenUint32(ctx context.Context, worker WorkerOfPushStringThenUint32, arg string) (uint32, error) {
	// ch := make(chan *ReturnOfUint32, 1)
	ch := __.pool.GetChReturnOfUint32()
	defer __.pool.PutChReturnOfUint32(ch)

	req := __.pool.GetWorkOfStringThenUint32()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfStringThenUint32(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfUint32(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfStringThenUint32 = func(ctx context.Context, arg string) (uint32, error)

type WorkerOfStringThenUint32 struct {
	api_syncer *ApiDecouplerOfStringThenUint32
	handler    WorkHandlerOfStringThenUint32

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfStringThenUint32
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfStringThenUint32(ctx context.Context, h WorkHandlerOfStringThenUint32, n int) *WorkerOfStringThenUint32 {
	__ := &WorkerOfStringThenUint32{
		api_syncer: NewApiDecouplerOfStringThenUint32(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfStringThenUint32, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfStringThenUint32{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfStringThenUint32(req.Context, req.WorkOfStringThenUint32, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfStringThenUint32) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfStringThenUint32) Push(ctx context.Context, req *WorkOfStringThenUint32) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfStringThenUint32)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfStringThenUint32 = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfStringThenUint32) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfStringThenUint32) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfStringThenUint32) Call(ctx context.Context, arg string) (uint32, error) {
	return __.api_syncer.DoOfStringThenUint32(ctx, __, arg)
}

type PoolOfStringThenUint64 interface {
	GetStringArg() *string
	PutStringArg(*string)
	GetUint64Return() *uint64
	PutUint64Return(*uint64)

	GetWorkOfStringThenUint64() *WorkOfStringThenUint64
	GetReturnOfUint64() *ReturnOfUint64
	PutWorkOfStringThenUint64(*WorkOfStringThenUint64)
	PutReturnOfUint64(*ReturnOfUint64)

	GetChReturnOfUint64() chan *ReturnOfUint64
	PutChReturnOfUint64(chan *ReturnOfUint64)
}

type PoolOfStringThenUint64Impl struct {
	StringArg        sync.Pool
	Uint64Rtn        sync.Pool
	StringWork       sync.Pool
	Uint64Return     sync.Pool
	ChReturnOfUint64 sync.Pool
}

func (__ *PoolOfStringThenUint64Impl) GetStringArg() *string {
	return __.StringArg.Get().(*string)
}
func (__ *PoolOfStringThenUint64Impl) PutStringArg(p *string) {
	__.StringArg.Put(p)
}
func (__ *PoolOfStringThenUint64Impl) GetUint64Return() *uint64 {
	return __.Uint64Rtn.Get().(*uint64)
}
func (__ *PoolOfStringThenUint64Impl) PutUint64Return(p *uint64) {
	__.Uint64Rtn.Put(p)
}

func (__ *PoolOfStringThenUint64Impl) GetWorkOfStringThenUint64() *WorkOfStringThenUint64 {
	return __.StringWork.Get().(*WorkOfStringThenUint64)
}
func (__ *PoolOfStringThenUint64Impl) PutWorkOfStringThenUint64(p *WorkOfStringThenUint64) {
	__.StringWork.Put(p)
}
func (__ *PoolOfStringThenUint64Impl) GetReturnOfUint64() *ReturnOfUint64 {
	return __.Uint64Return.Get().(*ReturnOfUint64)
}
func (__ *PoolOfStringThenUint64Impl) PutReturnOfUint64(p *ReturnOfUint64) {
	__.Uint64Return.Put(p)
}

func (__ *PoolOfStringThenUint64Impl) GetChReturnOfUint64() chan *ReturnOfUint64 {
	return __.ChReturnOfUint64.Get().(chan *ReturnOfUint64)
}
func (__ *PoolOfStringThenUint64Impl) PutChReturnOfUint64(p chan *ReturnOfUint64) {
	__.ChReturnOfUint64.Put(p)
}

func NewPoolOfStringThenUint64Impl() *PoolOfStringThenUint64Impl {
	return &PoolOfStringThenUint64Impl{
		StringArg: sync.Pool{
			New: func() interface{} {
				return new(string)
			},
		},
		StringWork: sync.Pool{
			New: func() interface{} {
				return new(WorkOfStringThenUint64)
			},
		},
		Uint64Rtn: sync.Pool{
			New: func() interface{} {
				return new(uint64)
			},
		},
		Uint64Return: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfUint64)
			},
		},
		ChReturnOfUint64: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfUint64, 1)
			},
		},
	}
}

type ApiDecouplerOfStringThenUint64 struct {
	pool PoolOfStringThenUint64
}

func NewApiDecouplerOfStringThenUint64() *ApiDecouplerOfStringThenUint64 {
	return &ApiDecouplerOfStringThenUint64{
		pool: NewPoolOfStringThenUint64Impl(),
	}
}

func (__ *ApiDecouplerOfStringThenUint64) ReturnError(rtn_ch chan<- *ReturnOfUint64, err error) {
	rtn := __.pool.GetReturnOfUint64()
	var other uint64
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfStringThenUint64) HandleOfStringThenUint64(ctx context.Context, req *WorkOfStringThenUint64, h func(ctx context.Context, arg string) (uint64, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfUint64()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfStringThenUint64) DoOfStringThenUint64(ctx context.Context, worker WorkerOfPushStringThenUint64, arg string) (uint64, error) {
	// ch := make(chan *ReturnOfUint64, 1)
	ch := __.pool.GetChReturnOfUint64()
	defer __.pool.PutChReturnOfUint64(ch)

	req := __.pool.GetWorkOfStringThenUint64()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfStringThenUint64(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfUint64(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfStringThenUint64 = func(ctx context.Context, arg string) (uint64, error)

type WorkerOfStringThenUint64 struct {
	api_syncer *ApiDecouplerOfStringThenUint64
	handler    WorkHandlerOfStringThenUint64

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfStringThenUint64
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfStringThenUint64(ctx context.Context, h WorkHandlerOfStringThenUint64, n int) *WorkerOfStringThenUint64 {
	__ := &WorkerOfStringThenUint64{
		api_syncer: NewApiDecouplerOfStringThenUint64(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfStringThenUint64, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfStringThenUint64{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfStringThenUint64(req.Context, req.WorkOfStringThenUint64, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfStringThenUint64) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfStringThenUint64) Push(ctx context.Context, req *WorkOfStringThenUint64) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfStringThenUint64)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfStringThenUint64 = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfStringThenUint64) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfStringThenUint64) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfStringThenUint64) Call(ctx context.Context, arg string) (uint64, error) {
	return __.api_syncer.DoOfStringThenUint64(ctx, __, arg)
}

type PoolOfStringThenUint8 interface {
	GetStringArg() *string
	PutStringArg(*string)
	GetUint8Return() *uint8
	PutUint8Return(*uint8)

	GetWorkOfStringThenUint8() *WorkOfStringThenUint8
	GetReturnOfUint8() *ReturnOfUint8
	PutWorkOfStringThenUint8(*WorkOfStringThenUint8)
	PutReturnOfUint8(*ReturnOfUint8)

	GetChReturnOfUint8() chan *ReturnOfUint8
	PutChReturnOfUint8(chan *ReturnOfUint8)
}

type PoolOfStringThenUint8Impl struct {
	StringArg       sync.Pool
	Uint8Rtn        sync.Pool
	StringWork      sync.Pool
	Uint8Return     sync.Pool
	ChReturnOfUint8 sync.Pool
}

func (__ *PoolOfStringThenUint8Impl) GetStringArg() *string {
	return __.StringArg.Get().(*string)
}
func (__ *PoolOfStringThenUint8Impl) PutStringArg(p *string) {
	__.StringArg.Put(p)
}
func (__ *PoolOfStringThenUint8Impl) GetUint8Return() *uint8 {
	return __.Uint8Rtn.Get().(*uint8)
}
func (__ *PoolOfStringThenUint8Impl) PutUint8Return(p *uint8) {
	__.Uint8Rtn.Put(p)
}

func (__ *PoolOfStringThenUint8Impl) GetWorkOfStringThenUint8() *WorkOfStringThenUint8 {
	return __.StringWork.Get().(*WorkOfStringThenUint8)
}
func (__ *PoolOfStringThenUint8Impl) PutWorkOfStringThenUint8(p *WorkOfStringThenUint8) {
	__.StringWork.Put(p)
}
func (__ *PoolOfStringThenUint8Impl) GetReturnOfUint8() *ReturnOfUint8 {
	return __.Uint8Return.Get().(*ReturnOfUint8)
}
func (__ *PoolOfStringThenUint8Impl) PutReturnOfUint8(p *ReturnOfUint8) {
	__.Uint8Return.Put(p)
}

func (__ *PoolOfStringThenUint8Impl) GetChReturnOfUint8() chan *ReturnOfUint8 {
	return __.ChReturnOfUint8.Get().(chan *ReturnOfUint8)
}
func (__ *PoolOfStringThenUint8Impl) PutChReturnOfUint8(p chan *ReturnOfUint8) {
	__.ChReturnOfUint8.Put(p)
}

func NewPoolOfStringThenUint8Impl() *PoolOfStringThenUint8Impl {
	return &PoolOfStringThenUint8Impl{
		StringArg: sync.Pool{
			New: func() interface{} {
				return new(string)
			},
		},
		StringWork: sync.Pool{
			New: func() interface{} {
				return new(WorkOfStringThenUint8)
			},
		},
		Uint8Rtn: sync.Pool{
			New: func() interface{} {
				return new(uint8)
			},
		},
		Uint8Return: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfUint8)
			},
		},
		ChReturnOfUint8: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfUint8, 1)
			},
		},
	}
}

type ApiDecouplerOfStringThenUint8 struct {
	pool PoolOfStringThenUint8
}

func NewApiDecouplerOfStringThenUint8() *ApiDecouplerOfStringThenUint8 {
	return &ApiDecouplerOfStringThenUint8{
		pool: NewPoolOfStringThenUint8Impl(),
	}
}

func (__ *ApiDecouplerOfStringThenUint8) ReturnError(rtn_ch chan<- *ReturnOfUint8, err error) {
	rtn := __.pool.GetReturnOfUint8()
	var other uint8
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfStringThenUint8) HandleOfStringThenUint8(ctx context.Context, req *WorkOfStringThenUint8, h func(ctx context.Context, arg string) (uint8, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfUint8()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfStringThenUint8) DoOfStringThenUint8(ctx context.Context, worker WorkerOfPushStringThenUint8, arg string) (uint8, error) {
	// ch := make(chan *ReturnOfUint8, 1)
	ch := __.pool.GetChReturnOfUint8()
	defer __.pool.PutChReturnOfUint8(ch)

	req := __.pool.GetWorkOfStringThenUint8()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfStringThenUint8(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfUint8(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfStringThenUint8 = func(ctx context.Context, arg string) (uint8, error)

type WorkerOfStringThenUint8 struct {
	api_syncer *ApiDecouplerOfStringThenUint8
	handler    WorkHandlerOfStringThenUint8

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfStringThenUint8
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfStringThenUint8(ctx context.Context, h WorkHandlerOfStringThenUint8, n int) *WorkerOfStringThenUint8 {
	__ := &WorkerOfStringThenUint8{
		api_syncer: NewApiDecouplerOfStringThenUint8(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfStringThenUint8, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfStringThenUint8{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfStringThenUint8(req.Context, req.WorkOfStringThenUint8, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfStringThenUint8) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfStringThenUint8) Push(ctx context.Context, req *WorkOfStringThenUint8) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfStringThenUint8)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfStringThenUint8 = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfStringThenUint8) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfStringThenUint8) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfStringThenUint8) Call(ctx context.Context, arg string) (uint8, error) {
	return __.api_syncer.DoOfStringThenUint8(ctx, __, arg)
}

type PoolOfStringThenUintptr interface {
	GetStringArg() *string
	PutStringArg(*string)
	GetUintptrReturn() *uintptr
	PutUintptrReturn(*uintptr)

	GetWorkOfStringThenUintptr() *WorkOfStringThenUintptr
	GetReturnOfUintptr() *ReturnOfUintptr
	PutWorkOfStringThenUintptr(*WorkOfStringThenUintptr)
	PutReturnOfUintptr(*ReturnOfUintptr)

	GetChReturnOfUintptr() chan *ReturnOfUintptr
	PutChReturnOfUintptr(chan *ReturnOfUintptr)
}

type PoolOfStringThenUintptrImpl struct {
	StringArg         sync.Pool
	UintptrRtn        sync.Pool
	StringWork        sync.Pool
	UintptrReturn     sync.Pool
	ChReturnOfUintptr sync.Pool
}

func (__ *PoolOfStringThenUintptrImpl) GetStringArg() *string {
	return __.StringArg.Get().(*string)
}
func (__ *PoolOfStringThenUintptrImpl) PutStringArg(p *string) {
	__.StringArg.Put(p)
}
func (__ *PoolOfStringThenUintptrImpl) GetUintptrReturn() *uintptr {
	return __.UintptrRtn.Get().(*uintptr)
}
func (__ *PoolOfStringThenUintptrImpl) PutUintptrReturn(p *uintptr) {
	__.UintptrRtn.Put(p)
}

func (__ *PoolOfStringThenUintptrImpl) GetWorkOfStringThenUintptr() *WorkOfStringThenUintptr {
	return __.StringWork.Get().(*WorkOfStringThenUintptr)
}
func (__ *PoolOfStringThenUintptrImpl) PutWorkOfStringThenUintptr(p *WorkOfStringThenUintptr) {
	__.StringWork.Put(p)
}
func (__ *PoolOfStringThenUintptrImpl) GetReturnOfUintptr() *ReturnOfUintptr {
	return __.UintptrReturn.Get().(*ReturnOfUintptr)
}
func (__ *PoolOfStringThenUintptrImpl) PutReturnOfUintptr(p *ReturnOfUintptr) {
	__.UintptrReturn.Put(p)
}

func (__ *PoolOfStringThenUintptrImpl) GetChReturnOfUintptr() chan *ReturnOfUintptr {
	return __.ChReturnOfUintptr.Get().(chan *ReturnOfUintptr)
}
func (__ *PoolOfStringThenUintptrImpl) PutChReturnOfUintptr(p chan *ReturnOfUintptr) {
	__.ChReturnOfUintptr.Put(p)
}

func NewPoolOfStringThenUintptrImpl() *PoolOfStringThenUintptrImpl {
	return &PoolOfStringThenUintptrImpl{
		StringArg: sync.Pool{
			New: func() interface{} {
				return new(string)
			},
		},
		StringWork: sync.Pool{
			New: func() interface{} {
				return new(WorkOfStringThenUintptr)
			},
		},
		UintptrRtn: sync.Pool{
			New: func() interface{} {
				return new(uintptr)
			},
		},
		UintptrReturn: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfUintptr)
			},
		},
		ChReturnOfUintptr: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfUintptr, 1)
			},
		},
	}
}

type ApiDecouplerOfStringThenUintptr struct {
	pool PoolOfStringThenUintptr
}

func NewApiDecouplerOfStringThenUintptr() *ApiDecouplerOfStringThenUintptr {
	return &ApiDecouplerOfStringThenUintptr{
		pool: NewPoolOfStringThenUintptrImpl(),
	}
}

func (__ *ApiDecouplerOfStringThenUintptr) ReturnError(rtn_ch chan<- *ReturnOfUintptr, err error) {
	rtn := __.pool.GetReturnOfUintptr()
	var other uintptr
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfStringThenUintptr) HandleOfStringThenUintptr(ctx context.Context, req *WorkOfStringThenUintptr, h func(ctx context.Context, arg string) (uintptr, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfUintptr()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfStringThenUintptr) DoOfStringThenUintptr(ctx context.Context, worker WorkerOfPushStringThenUintptr, arg string) (uintptr, error) {
	// ch := make(chan *ReturnOfUintptr, 1)
	ch := __.pool.GetChReturnOfUintptr()
	defer __.pool.PutChReturnOfUintptr(ch)

	req := __.pool.GetWorkOfStringThenUintptr()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfStringThenUintptr(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfUintptr(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfStringThenUintptr = func(ctx context.Context, arg string) (uintptr, error)

type WorkerOfStringThenUintptr struct {
	api_syncer *ApiDecouplerOfStringThenUintptr
	handler    WorkHandlerOfStringThenUintptr

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfStringThenUintptr
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfStringThenUintptr(ctx context.Context, h WorkHandlerOfStringThenUintptr, n int) *WorkerOfStringThenUintptr {
	__ := &WorkerOfStringThenUintptr{
		api_syncer: NewApiDecouplerOfStringThenUintptr(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfStringThenUintptr, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfStringThenUintptr{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfStringThenUintptr(req.Context, req.WorkOfStringThenUintptr, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfStringThenUintptr) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfStringThenUintptr) Push(ctx context.Context, req *WorkOfStringThenUintptr) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfStringThenUintptr)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfStringThenUintptr = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfStringThenUintptr) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfStringThenUintptr) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfStringThenUintptr) Call(ctx context.Context, arg string) (uintptr, error) {
	return __.api_syncer.DoOfStringThenUintptr(ctx, __, arg)
}

type PoolOfStringThenInterface interface {
	GetStringArg() *string
	PutStringArg(*string)
	GetInterfaceReturn() *interface{}
	PutInterfaceReturn(*interface{})

	GetWorkOfStringThenInterface() *WorkOfStringThenInterface
	GetReturnOfInterface() *ReturnOfInterface
	PutWorkOfStringThenInterface(*WorkOfStringThenInterface)
	PutReturnOfInterface(*ReturnOfInterface)

	GetChReturnOfInterface() chan *ReturnOfInterface
	PutChReturnOfInterface(chan *ReturnOfInterface)
}

type PoolOfStringThenInterfaceImpl struct {
	StringArg           sync.Pool
	InterfaceRtn        sync.Pool
	StringWork          sync.Pool
	InterfaceReturn     sync.Pool
	ChReturnOfInterface sync.Pool
}

func (__ *PoolOfStringThenInterfaceImpl) GetStringArg() *string {
	return __.StringArg.Get().(*string)
}
func (__ *PoolOfStringThenInterfaceImpl) PutStringArg(p *string) {
	__.StringArg.Put(p)
}
func (__ *PoolOfStringThenInterfaceImpl) GetInterfaceReturn() *interface{} {
	return __.InterfaceRtn.Get().(*interface{})
}
func (__ *PoolOfStringThenInterfaceImpl) PutInterfaceReturn(p *interface{}) {
	__.InterfaceRtn.Put(p)
}

func (__ *PoolOfStringThenInterfaceImpl) GetWorkOfStringThenInterface() *WorkOfStringThenInterface {
	return __.StringWork.Get().(*WorkOfStringThenInterface)
}
func (__ *PoolOfStringThenInterfaceImpl) PutWorkOfStringThenInterface(p *WorkOfStringThenInterface) {
	__.StringWork.Put(p)
}
func (__ *PoolOfStringThenInterfaceImpl) GetReturnOfInterface() *ReturnOfInterface {
	return __.InterfaceReturn.Get().(*ReturnOfInterface)
}
func (__ *PoolOfStringThenInterfaceImpl) PutReturnOfInterface(p *ReturnOfInterface) {
	__.InterfaceReturn.Put(p)
}

func (__ *PoolOfStringThenInterfaceImpl) GetChReturnOfInterface() chan *ReturnOfInterface {
	return __.ChReturnOfInterface.Get().(chan *ReturnOfInterface)
}
func (__ *PoolOfStringThenInterfaceImpl) PutChReturnOfInterface(p chan *ReturnOfInterface) {
	__.ChReturnOfInterface.Put(p)
}

func NewPoolOfStringThenInterfaceImpl() *PoolOfStringThenInterfaceImpl {
	return &PoolOfStringThenInterfaceImpl{
		StringArg: sync.Pool{
			New: func() interface{} {
				return new(string)
			},
		},
		StringWork: sync.Pool{
			New: func() interface{} {
				return new(WorkOfStringThenInterface)
			},
		},
		InterfaceRtn: sync.Pool{
			New: func() interface{} {
				return new(interface{})
			},
		},
		InterfaceReturn: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfInterface)
			},
		},
		ChReturnOfInterface: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfInterface, 1)
			},
		},
	}
}

type ApiDecouplerOfStringThenInterface struct {
	pool PoolOfStringThenInterface
}

func NewApiDecouplerOfStringThenInterface() *ApiDecouplerOfStringThenInterface {
	return &ApiDecouplerOfStringThenInterface{
		pool: NewPoolOfStringThenInterfaceImpl(),
	}
}

func (__ *ApiDecouplerOfStringThenInterface) ReturnError(rtn_ch chan<- *ReturnOfInterface, err error) {
	rtn := __.pool.GetReturnOfInterface()
	var other interface{}
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfStringThenInterface) HandleOfStringThenInterface(ctx context.Context, req *WorkOfStringThenInterface, h func(ctx context.Context, arg string) (interface{}, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfInterface()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfStringThenInterface) DoOfStringThenInterface(ctx context.Context, worker WorkerOfPushStringThenInterface, arg string) (interface{}, error) {
	// ch := make(chan *ReturnOfInterface, 1)
	ch := __.pool.GetChReturnOfInterface()
	defer __.pool.PutChReturnOfInterface(ch)

	req := __.pool.GetWorkOfStringThenInterface()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfStringThenInterface(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfInterface(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfStringThenInterface = func(ctx context.Context, arg string) (interface{}, error)

type WorkerOfStringThenInterface struct {
	api_syncer *ApiDecouplerOfStringThenInterface
	handler    WorkHandlerOfStringThenInterface

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfStringThenInterface
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfStringThenInterface(ctx context.Context, h WorkHandlerOfStringThenInterface, n int) *WorkerOfStringThenInterface {
	__ := &WorkerOfStringThenInterface{
		api_syncer: NewApiDecouplerOfStringThenInterface(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfStringThenInterface, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfStringThenInterface{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfStringThenInterface(req.Context, req.WorkOfStringThenInterface, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfStringThenInterface) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfStringThenInterface) Push(ctx context.Context, req *WorkOfStringThenInterface) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfStringThenInterface)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfStringThenInterface = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfStringThenInterface) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfStringThenInterface) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfStringThenInterface) Call(ctx context.Context, arg string) (interface{}, error) {
	return __.api_syncer.DoOfStringThenInterface(ctx, __, arg)
}

type PoolOfStringThenStruct interface {
	GetStringArg() *string
	PutStringArg(*string)
	GetStructReturn() *struct{}
	PutStructReturn(*struct{})

	GetWorkOfStringThenStruct() *WorkOfStringThenStruct
	GetReturnOfStruct() *ReturnOfStruct
	PutWorkOfStringThenStruct(*WorkOfStringThenStruct)
	PutReturnOfStruct(*ReturnOfStruct)

	GetChReturnOfStruct() chan *ReturnOfStruct
	PutChReturnOfStruct(chan *ReturnOfStruct)
}

type PoolOfStringThenStructImpl struct {
	StringArg        sync.Pool
	StructRtn        sync.Pool
	StringWork       sync.Pool
	StructReturn     sync.Pool
	ChReturnOfStruct sync.Pool
}

func (__ *PoolOfStringThenStructImpl) GetStringArg() *string {
	return __.StringArg.Get().(*string)
}
func (__ *PoolOfStringThenStructImpl) PutStringArg(p *string) {
	__.StringArg.Put(p)
}
func (__ *PoolOfStringThenStructImpl) GetStructReturn() *struct{} {
	return __.StructRtn.Get().(*struct{})
}
func (__ *PoolOfStringThenStructImpl) PutStructReturn(p *struct{}) {
	__.StructRtn.Put(p)
}

func (__ *PoolOfStringThenStructImpl) GetWorkOfStringThenStruct() *WorkOfStringThenStruct {
	return __.StringWork.Get().(*WorkOfStringThenStruct)
}
func (__ *PoolOfStringThenStructImpl) PutWorkOfStringThenStruct(p *WorkOfStringThenStruct) {
	__.StringWork.Put(p)
}
func (__ *PoolOfStringThenStructImpl) GetReturnOfStruct() *ReturnOfStruct {
	return __.StructReturn.Get().(*ReturnOfStruct)
}
func (__ *PoolOfStringThenStructImpl) PutReturnOfStruct(p *ReturnOfStruct) {
	__.StructReturn.Put(p)
}

func (__ *PoolOfStringThenStructImpl) GetChReturnOfStruct() chan *ReturnOfStruct {
	return __.ChReturnOfStruct.Get().(chan *ReturnOfStruct)
}
func (__ *PoolOfStringThenStructImpl) PutChReturnOfStruct(p chan *ReturnOfStruct) {
	__.ChReturnOfStruct.Put(p)
}

func NewPoolOfStringThenStructImpl() *PoolOfStringThenStructImpl {
	return &PoolOfStringThenStructImpl{
		StringArg: sync.Pool{
			New: func() interface{} {
				return new(string)
			},
		},
		StringWork: sync.Pool{
			New: func() interface{} {
				return new(WorkOfStringThenStruct)
			},
		},
		StructRtn: sync.Pool{
			New: func() interface{} {
				return new(struct{})
			},
		},
		StructReturn: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfStruct)
			},
		},
		ChReturnOfStruct: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfStruct, 1)
			},
		},
	}
}

type ApiDecouplerOfStringThenStruct struct {
	pool PoolOfStringThenStruct
}

func NewApiDecouplerOfStringThenStruct() *ApiDecouplerOfStringThenStruct {
	return &ApiDecouplerOfStringThenStruct{
		pool: NewPoolOfStringThenStructImpl(),
	}
}

func (__ *ApiDecouplerOfStringThenStruct) ReturnError(rtn_ch chan<- *ReturnOfStruct, err error) {
	rtn := __.pool.GetReturnOfStruct()
	var other struct{}
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfStringThenStruct) HandleOfStringThenStruct(ctx context.Context, req *WorkOfStringThenStruct, h func(ctx context.Context, arg string) (struct{}, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfStruct()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfStringThenStruct) DoOfStringThenStruct(ctx context.Context, worker WorkerOfPushStringThenStruct, arg string) (struct{}, error) {
	// ch := make(chan *ReturnOfStruct, 1)
	ch := __.pool.GetChReturnOfStruct()
	defer __.pool.PutChReturnOfStruct(ch)

	req := __.pool.GetWorkOfStringThenStruct()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfStringThenStruct(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfStruct(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfStringThenStruct = func(ctx context.Context, arg string) (struct{}, error)

type WorkerOfStringThenStruct struct {
	api_syncer *ApiDecouplerOfStringThenStruct
	handler    WorkHandlerOfStringThenStruct

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfStringThenStruct
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfStringThenStruct(ctx context.Context, h WorkHandlerOfStringThenStruct, n int) *WorkerOfStringThenStruct {
	__ := &WorkerOfStringThenStruct{
		api_syncer: NewApiDecouplerOfStringThenStruct(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfStringThenStruct, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfStringThenStruct{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfStringThenStruct(req.Context, req.WorkOfStringThenStruct, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfStringThenStruct) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfStringThenStruct) Push(ctx context.Context, req *WorkOfStringThenStruct) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfStringThenStruct)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfStringThenStruct = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfStringThenStruct) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfStringThenStruct) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfStringThenStruct) Call(ctx context.Context, arg string) (struct{}, error) {
	return __.api_syncer.DoOfStringThenStruct(ctx, __, arg)
}

type PoolOfUintThenBool interface {
	GetUintArg() *uint
	PutUintArg(*uint)
	GetBoolReturn() *bool
	PutBoolReturn(*bool)

	GetWorkOfUintThenBool() *WorkOfUintThenBool
	GetReturnOfBool() *ReturnOfBool
	PutWorkOfUintThenBool(*WorkOfUintThenBool)
	PutReturnOfBool(*ReturnOfBool)

	GetChReturnOfBool() chan *ReturnOfBool
	PutChReturnOfBool(chan *ReturnOfBool)
}

type PoolOfUintThenBoolImpl struct {
	UintArg        sync.Pool
	BoolRtn        sync.Pool
	UintWork       sync.Pool
	BoolReturn     sync.Pool
	ChReturnOfBool sync.Pool
}

func (__ *PoolOfUintThenBoolImpl) GetUintArg() *uint {
	return __.UintArg.Get().(*uint)
}
func (__ *PoolOfUintThenBoolImpl) PutUintArg(p *uint) {
	__.UintArg.Put(p)
}
func (__ *PoolOfUintThenBoolImpl) GetBoolReturn() *bool {
	return __.BoolRtn.Get().(*bool)
}
func (__ *PoolOfUintThenBoolImpl) PutBoolReturn(p *bool) {
	__.BoolRtn.Put(p)
}

func (__ *PoolOfUintThenBoolImpl) GetWorkOfUintThenBool() *WorkOfUintThenBool {
	return __.UintWork.Get().(*WorkOfUintThenBool)
}
func (__ *PoolOfUintThenBoolImpl) PutWorkOfUintThenBool(p *WorkOfUintThenBool) {
	__.UintWork.Put(p)
}
func (__ *PoolOfUintThenBoolImpl) GetReturnOfBool() *ReturnOfBool {
	return __.BoolReturn.Get().(*ReturnOfBool)
}
func (__ *PoolOfUintThenBoolImpl) PutReturnOfBool(p *ReturnOfBool) {
	__.BoolReturn.Put(p)
}

func (__ *PoolOfUintThenBoolImpl) GetChReturnOfBool() chan *ReturnOfBool {
	return __.ChReturnOfBool.Get().(chan *ReturnOfBool)
}
func (__ *PoolOfUintThenBoolImpl) PutChReturnOfBool(p chan *ReturnOfBool) {
	__.ChReturnOfBool.Put(p)
}

func NewPoolOfUintThenBoolImpl() *PoolOfUintThenBoolImpl {
	return &PoolOfUintThenBoolImpl{
		UintArg: sync.Pool{
			New: func() interface{} {
				return new(uint)
			},
		},
		UintWork: sync.Pool{
			New: func() interface{} {
				return new(WorkOfUintThenBool)
			},
		},
		BoolRtn: sync.Pool{
			New: func() interface{} {
				return new(bool)
			},
		},
		BoolReturn: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfBool)
			},
		},
		ChReturnOfBool: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfBool, 1)
			},
		},
	}
}

type ApiDecouplerOfUintThenBool struct {
	pool PoolOfUintThenBool
}

func NewApiDecouplerOfUintThenBool() *ApiDecouplerOfUintThenBool {
	return &ApiDecouplerOfUintThenBool{
		pool: NewPoolOfUintThenBoolImpl(),
	}
}

func (__ *ApiDecouplerOfUintThenBool) ReturnError(rtn_ch chan<- *ReturnOfBool, err error) {
	rtn := __.pool.GetReturnOfBool()
	var other bool
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfUintThenBool) HandleOfUintThenBool(ctx context.Context, req *WorkOfUintThenBool, h func(ctx context.Context, arg uint) (bool, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfBool()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfUintThenBool) DoOfUintThenBool(ctx context.Context, worker WorkerOfPushUintThenBool, arg uint) (bool, error) {
	// ch := make(chan *ReturnOfBool, 1)
	ch := __.pool.GetChReturnOfBool()
	defer __.pool.PutChReturnOfBool(ch)

	req := __.pool.GetWorkOfUintThenBool()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfUintThenBool(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfBool(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfUintThenBool = func(ctx context.Context, arg uint) (bool, error)

type WorkerOfUintThenBool struct {
	api_syncer *ApiDecouplerOfUintThenBool
	handler    WorkHandlerOfUintThenBool

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfUintThenBool
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfUintThenBool(ctx context.Context, h WorkHandlerOfUintThenBool, n int) *WorkerOfUintThenBool {
	__ := &WorkerOfUintThenBool{
		api_syncer: NewApiDecouplerOfUintThenBool(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfUintThenBool, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfUintThenBool{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfUintThenBool(req.Context, req.WorkOfUintThenBool, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfUintThenBool) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfUintThenBool) Push(ctx context.Context, req *WorkOfUintThenBool) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfUintThenBool)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfUintThenBool = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfUintThenBool) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfUintThenBool) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfUintThenBool) Call(ctx context.Context, arg uint) (bool, error) {
	return __.api_syncer.DoOfUintThenBool(ctx, __, arg)
}

type PoolOfUintThenByte interface {
	GetUintArg() *uint
	PutUintArg(*uint)
	GetByteReturn() *byte
	PutByteReturn(*byte)

	GetWorkOfUintThenByte() *WorkOfUintThenByte
	GetReturnOfByte() *ReturnOfByte
	PutWorkOfUintThenByte(*WorkOfUintThenByte)
	PutReturnOfByte(*ReturnOfByte)

	GetChReturnOfByte() chan *ReturnOfByte
	PutChReturnOfByte(chan *ReturnOfByte)
}

type PoolOfUintThenByteImpl struct {
	UintArg        sync.Pool
	ByteRtn        sync.Pool
	UintWork       sync.Pool
	ByteReturn     sync.Pool
	ChReturnOfByte sync.Pool
}

func (__ *PoolOfUintThenByteImpl) GetUintArg() *uint {
	return __.UintArg.Get().(*uint)
}
func (__ *PoolOfUintThenByteImpl) PutUintArg(p *uint) {
	__.UintArg.Put(p)
}
func (__ *PoolOfUintThenByteImpl) GetByteReturn() *byte {
	return __.ByteRtn.Get().(*byte)
}
func (__ *PoolOfUintThenByteImpl) PutByteReturn(p *byte) {
	__.ByteRtn.Put(p)
}

func (__ *PoolOfUintThenByteImpl) GetWorkOfUintThenByte() *WorkOfUintThenByte {
	return __.UintWork.Get().(*WorkOfUintThenByte)
}
func (__ *PoolOfUintThenByteImpl) PutWorkOfUintThenByte(p *WorkOfUintThenByte) {
	__.UintWork.Put(p)
}
func (__ *PoolOfUintThenByteImpl) GetReturnOfByte() *ReturnOfByte {
	return __.ByteReturn.Get().(*ReturnOfByte)
}
func (__ *PoolOfUintThenByteImpl) PutReturnOfByte(p *ReturnOfByte) {
	__.ByteReturn.Put(p)
}

func (__ *PoolOfUintThenByteImpl) GetChReturnOfByte() chan *ReturnOfByte {
	return __.ChReturnOfByte.Get().(chan *ReturnOfByte)
}
func (__ *PoolOfUintThenByteImpl) PutChReturnOfByte(p chan *ReturnOfByte) {
	__.ChReturnOfByte.Put(p)
}

func NewPoolOfUintThenByteImpl() *PoolOfUintThenByteImpl {
	return &PoolOfUintThenByteImpl{
		UintArg: sync.Pool{
			New: func() interface{} {
				return new(uint)
			},
		},
		UintWork: sync.Pool{
			New: func() interface{} {
				return new(WorkOfUintThenByte)
			},
		},
		ByteRtn: sync.Pool{
			New: func() interface{} {
				return new(byte)
			},
		},
		ByteReturn: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfByte)
			},
		},
		ChReturnOfByte: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfByte, 1)
			},
		},
	}
}

type ApiDecouplerOfUintThenByte struct {
	pool PoolOfUintThenByte
}

func NewApiDecouplerOfUintThenByte() *ApiDecouplerOfUintThenByte {
	return &ApiDecouplerOfUintThenByte{
		pool: NewPoolOfUintThenByteImpl(),
	}
}

func (__ *ApiDecouplerOfUintThenByte) ReturnError(rtn_ch chan<- *ReturnOfByte, err error) {
	rtn := __.pool.GetReturnOfByte()
	var other byte
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfUintThenByte) HandleOfUintThenByte(ctx context.Context, req *WorkOfUintThenByte, h func(ctx context.Context, arg uint) (byte, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfByte()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfUintThenByte) DoOfUintThenByte(ctx context.Context, worker WorkerOfPushUintThenByte, arg uint) (byte, error) {
	// ch := make(chan *ReturnOfByte, 1)
	ch := __.pool.GetChReturnOfByte()
	defer __.pool.PutChReturnOfByte(ch)

	req := __.pool.GetWorkOfUintThenByte()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfUintThenByte(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfByte(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfUintThenByte = func(ctx context.Context, arg uint) (byte, error)

type WorkerOfUintThenByte struct {
	api_syncer *ApiDecouplerOfUintThenByte
	handler    WorkHandlerOfUintThenByte

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfUintThenByte
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfUintThenByte(ctx context.Context, h WorkHandlerOfUintThenByte, n int) *WorkerOfUintThenByte {
	__ := &WorkerOfUintThenByte{
		api_syncer: NewApiDecouplerOfUintThenByte(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfUintThenByte, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfUintThenByte{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfUintThenByte(req.Context, req.WorkOfUintThenByte, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfUintThenByte) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfUintThenByte) Push(ctx context.Context, req *WorkOfUintThenByte) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfUintThenByte)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfUintThenByte = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfUintThenByte) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfUintThenByte) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfUintThenByte) Call(ctx context.Context, arg uint) (byte, error) {
	return __.api_syncer.DoOfUintThenByte(ctx, __, arg)
}

type PoolOfUintThenComplex128 interface {
	GetUintArg() *uint
	PutUintArg(*uint)
	GetComplex128Return() *complex128
	PutComplex128Return(*complex128)

	GetWorkOfUintThenComplex128() *WorkOfUintThenComplex128
	GetReturnOfComplex128() *ReturnOfComplex128
	PutWorkOfUintThenComplex128(*WorkOfUintThenComplex128)
	PutReturnOfComplex128(*ReturnOfComplex128)

	GetChReturnOfComplex128() chan *ReturnOfComplex128
	PutChReturnOfComplex128(chan *ReturnOfComplex128)
}

type PoolOfUintThenComplex128Impl struct {
	UintArg              sync.Pool
	Complex128Rtn        sync.Pool
	UintWork             sync.Pool
	Complex128Return     sync.Pool
	ChReturnOfComplex128 sync.Pool
}

func (__ *PoolOfUintThenComplex128Impl) GetUintArg() *uint {
	return __.UintArg.Get().(*uint)
}
func (__ *PoolOfUintThenComplex128Impl) PutUintArg(p *uint) {
	__.UintArg.Put(p)
}
func (__ *PoolOfUintThenComplex128Impl) GetComplex128Return() *complex128 {
	return __.Complex128Rtn.Get().(*complex128)
}
func (__ *PoolOfUintThenComplex128Impl) PutComplex128Return(p *complex128) {
	__.Complex128Rtn.Put(p)
}

func (__ *PoolOfUintThenComplex128Impl) GetWorkOfUintThenComplex128() *WorkOfUintThenComplex128 {
	return __.UintWork.Get().(*WorkOfUintThenComplex128)
}
func (__ *PoolOfUintThenComplex128Impl) PutWorkOfUintThenComplex128(p *WorkOfUintThenComplex128) {
	__.UintWork.Put(p)
}
func (__ *PoolOfUintThenComplex128Impl) GetReturnOfComplex128() *ReturnOfComplex128 {
	return __.Complex128Return.Get().(*ReturnOfComplex128)
}
func (__ *PoolOfUintThenComplex128Impl) PutReturnOfComplex128(p *ReturnOfComplex128) {
	__.Complex128Return.Put(p)
}

func (__ *PoolOfUintThenComplex128Impl) GetChReturnOfComplex128() chan *ReturnOfComplex128 {
	return __.ChReturnOfComplex128.Get().(chan *ReturnOfComplex128)
}
func (__ *PoolOfUintThenComplex128Impl) PutChReturnOfComplex128(p chan *ReturnOfComplex128) {
	__.ChReturnOfComplex128.Put(p)
}

func NewPoolOfUintThenComplex128Impl() *PoolOfUintThenComplex128Impl {
	return &PoolOfUintThenComplex128Impl{
		UintArg: sync.Pool{
			New: func() interface{} {
				return new(uint)
			},
		},
		UintWork: sync.Pool{
			New: func() interface{} {
				return new(WorkOfUintThenComplex128)
			},
		},
		Complex128Rtn: sync.Pool{
			New: func() interface{} {
				return new(complex128)
			},
		},
		Complex128Return: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfComplex128)
			},
		},
		ChReturnOfComplex128: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfComplex128, 1)
			},
		},
	}
}

type ApiDecouplerOfUintThenComplex128 struct {
	pool PoolOfUintThenComplex128
}

func NewApiDecouplerOfUintThenComplex128() *ApiDecouplerOfUintThenComplex128 {
	return &ApiDecouplerOfUintThenComplex128{
		pool: NewPoolOfUintThenComplex128Impl(),
	}
}

func (__ *ApiDecouplerOfUintThenComplex128) ReturnError(rtn_ch chan<- *ReturnOfComplex128, err error) {
	rtn := __.pool.GetReturnOfComplex128()
	var other complex128
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfUintThenComplex128) HandleOfUintThenComplex128(ctx context.Context, req *WorkOfUintThenComplex128, h func(ctx context.Context, arg uint) (complex128, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfComplex128()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfUintThenComplex128) DoOfUintThenComplex128(ctx context.Context, worker WorkerOfPushUintThenComplex128, arg uint) (complex128, error) {
	// ch := make(chan *ReturnOfComplex128, 1)
	ch := __.pool.GetChReturnOfComplex128()
	defer __.pool.PutChReturnOfComplex128(ch)

	req := __.pool.GetWorkOfUintThenComplex128()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfUintThenComplex128(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfComplex128(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfUintThenComplex128 = func(ctx context.Context, arg uint) (complex128, error)

type WorkerOfUintThenComplex128 struct {
	api_syncer *ApiDecouplerOfUintThenComplex128
	handler    WorkHandlerOfUintThenComplex128

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfUintThenComplex128
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfUintThenComplex128(ctx context.Context, h WorkHandlerOfUintThenComplex128, n int) *WorkerOfUintThenComplex128 {
	__ := &WorkerOfUintThenComplex128{
		api_syncer: NewApiDecouplerOfUintThenComplex128(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfUintThenComplex128, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfUintThenComplex128{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfUintThenComplex128(req.Context, req.WorkOfUintThenComplex128, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfUintThenComplex128) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfUintThenComplex128) Push(ctx context.Context, req *WorkOfUintThenComplex128) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfUintThenComplex128)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfUintThenComplex128 = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfUintThenComplex128) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfUintThenComplex128) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfUintThenComplex128) Call(ctx context.Context, arg uint) (complex128, error) {
	return __.api_syncer.DoOfUintThenComplex128(ctx, __, arg)
}

type PoolOfUintThenComplex64 interface {
	GetUintArg() *uint
	PutUintArg(*uint)
	GetComplex64Return() *complex64
	PutComplex64Return(*complex64)

	GetWorkOfUintThenComplex64() *WorkOfUintThenComplex64
	GetReturnOfComplex64() *ReturnOfComplex64
	PutWorkOfUintThenComplex64(*WorkOfUintThenComplex64)
	PutReturnOfComplex64(*ReturnOfComplex64)

	GetChReturnOfComplex64() chan *ReturnOfComplex64
	PutChReturnOfComplex64(chan *ReturnOfComplex64)
}

type PoolOfUintThenComplex64Impl struct {
	UintArg             sync.Pool
	Complex64Rtn        sync.Pool
	UintWork            sync.Pool
	Complex64Return     sync.Pool
	ChReturnOfComplex64 sync.Pool
}

func (__ *PoolOfUintThenComplex64Impl) GetUintArg() *uint {
	return __.UintArg.Get().(*uint)
}
func (__ *PoolOfUintThenComplex64Impl) PutUintArg(p *uint) {
	__.UintArg.Put(p)
}
func (__ *PoolOfUintThenComplex64Impl) GetComplex64Return() *complex64 {
	return __.Complex64Rtn.Get().(*complex64)
}
func (__ *PoolOfUintThenComplex64Impl) PutComplex64Return(p *complex64) {
	__.Complex64Rtn.Put(p)
}

func (__ *PoolOfUintThenComplex64Impl) GetWorkOfUintThenComplex64() *WorkOfUintThenComplex64 {
	return __.UintWork.Get().(*WorkOfUintThenComplex64)
}
func (__ *PoolOfUintThenComplex64Impl) PutWorkOfUintThenComplex64(p *WorkOfUintThenComplex64) {
	__.UintWork.Put(p)
}
func (__ *PoolOfUintThenComplex64Impl) GetReturnOfComplex64() *ReturnOfComplex64 {
	return __.Complex64Return.Get().(*ReturnOfComplex64)
}
func (__ *PoolOfUintThenComplex64Impl) PutReturnOfComplex64(p *ReturnOfComplex64) {
	__.Complex64Return.Put(p)
}

func (__ *PoolOfUintThenComplex64Impl) GetChReturnOfComplex64() chan *ReturnOfComplex64 {
	return __.ChReturnOfComplex64.Get().(chan *ReturnOfComplex64)
}
func (__ *PoolOfUintThenComplex64Impl) PutChReturnOfComplex64(p chan *ReturnOfComplex64) {
	__.ChReturnOfComplex64.Put(p)
}

func NewPoolOfUintThenComplex64Impl() *PoolOfUintThenComplex64Impl {
	return &PoolOfUintThenComplex64Impl{
		UintArg: sync.Pool{
			New: func() interface{} {
				return new(uint)
			},
		},
		UintWork: sync.Pool{
			New: func() interface{} {
				return new(WorkOfUintThenComplex64)
			},
		},
		Complex64Rtn: sync.Pool{
			New: func() interface{} {
				return new(complex64)
			},
		},
		Complex64Return: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfComplex64)
			},
		},
		ChReturnOfComplex64: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfComplex64, 1)
			},
		},
	}
}

type ApiDecouplerOfUintThenComplex64 struct {
	pool PoolOfUintThenComplex64
}

func NewApiDecouplerOfUintThenComplex64() *ApiDecouplerOfUintThenComplex64 {
	return &ApiDecouplerOfUintThenComplex64{
		pool: NewPoolOfUintThenComplex64Impl(),
	}
}

func (__ *ApiDecouplerOfUintThenComplex64) ReturnError(rtn_ch chan<- *ReturnOfComplex64, err error) {
	rtn := __.pool.GetReturnOfComplex64()
	var other complex64
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfUintThenComplex64) HandleOfUintThenComplex64(ctx context.Context, req *WorkOfUintThenComplex64, h func(ctx context.Context, arg uint) (complex64, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfComplex64()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfUintThenComplex64) DoOfUintThenComplex64(ctx context.Context, worker WorkerOfPushUintThenComplex64, arg uint) (complex64, error) {
	// ch := make(chan *ReturnOfComplex64, 1)
	ch := __.pool.GetChReturnOfComplex64()
	defer __.pool.PutChReturnOfComplex64(ch)

	req := __.pool.GetWorkOfUintThenComplex64()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfUintThenComplex64(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfComplex64(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfUintThenComplex64 = func(ctx context.Context, arg uint) (complex64, error)

type WorkerOfUintThenComplex64 struct {
	api_syncer *ApiDecouplerOfUintThenComplex64
	handler    WorkHandlerOfUintThenComplex64

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfUintThenComplex64
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfUintThenComplex64(ctx context.Context, h WorkHandlerOfUintThenComplex64, n int) *WorkerOfUintThenComplex64 {
	__ := &WorkerOfUintThenComplex64{
		api_syncer: NewApiDecouplerOfUintThenComplex64(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfUintThenComplex64, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfUintThenComplex64{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfUintThenComplex64(req.Context, req.WorkOfUintThenComplex64, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfUintThenComplex64) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfUintThenComplex64) Push(ctx context.Context, req *WorkOfUintThenComplex64) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfUintThenComplex64)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfUintThenComplex64 = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfUintThenComplex64) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfUintThenComplex64) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfUintThenComplex64) Call(ctx context.Context, arg uint) (complex64, error) {
	return __.api_syncer.DoOfUintThenComplex64(ctx, __, arg)
}

type PoolOfUintThenError interface {
	GetUintArg() *uint
	PutUintArg(*uint)
	GetErrorReturn() *error
	PutErrorReturn(*error)

	GetWorkOfUintThenError() *WorkOfUintThenError
	GetReturnOfError() *ReturnOfError
	PutWorkOfUintThenError(*WorkOfUintThenError)
	PutReturnOfError(*ReturnOfError)

	GetChReturnOfError() chan *ReturnOfError
	PutChReturnOfError(chan *ReturnOfError)
}

type PoolOfUintThenErrorImpl struct {
	UintArg         sync.Pool
	ErrorRtn        sync.Pool
	UintWork        sync.Pool
	ErrorReturn     sync.Pool
	ChReturnOfError sync.Pool
}

func (__ *PoolOfUintThenErrorImpl) GetUintArg() *uint {
	return __.UintArg.Get().(*uint)
}
func (__ *PoolOfUintThenErrorImpl) PutUintArg(p *uint) {
	__.UintArg.Put(p)
}
func (__ *PoolOfUintThenErrorImpl) GetErrorReturn() *error {
	return __.ErrorRtn.Get().(*error)
}
func (__ *PoolOfUintThenErrorImpl) PutErrorReturn(p *error) {
	__.ErrorRtn.Put(p)
}

func (__ *PoolOfUintThenErrorImpl) GetWorkOfUintThenError() *WorkOfUintThenError {
	return __.UintWork.Get().(*WorkOfUintThenError)
}
func (__ *PoolOfUintThenErrorImpl) PutWorkOfUintThenError(p *WorkOfUintThenError) {
	__.UintWork.Put(p)
}
func (__ *PoolOfUintThenErrorImpl) GetReturnOfError() *ReturnOfError {
	return __.ErrorReturn.Get().(*ReturnOfError)
}
func (__ *PoolOfUintThenErrorImpl) PutReturnOfError(p *ReturnOfError) {
	__.ErrorReturn.Put(p)
}

func (__ *PoolOfUintThenErrorImpl) GetChReturnOfError() chan *ReturnOfError {
	return __.ChReturnOfError.Get().(chan *ReturnOfError)
}
func (__ *PoolOfUintThenErrorImpl) PutChReturnOfError(p chan *ReturnOfError) {
	__.ChReturnOfError.Put(p)
}

func NewPoolOfUintThenErrorImpl() *PoolOfUintThenErrorImpl {
	return &PoolOfUintThenErrorImpl{
		UintArg: sync.Pool{
			New: func() interface{} {
				return new(uint)
			},
		},
		UintWork: sync.Pool{
			New: func() interface{} {
				return new(WorkOfUintThenError)
			},
		},
		ErrorRtn: sync.Pool{
			New: func() interface{} {
				return new(error)
			},
		},
		ErrorReturn: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfError)
			},
		},
		ChReturnOfError: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfError, 1)
			},
		},
	}
}

type ApiDecouplerOfUintThenError struct {
	pool PoolOfUintThenError
}

func NewApiDecouplerOfUintThenError() *ApiDecouplerOfUintThenError {
	return &ApiDecouplerOfUintThenError{
		pool: NewPoolOfUintThenErrorImpl(),
	}
}

func (__ *ApiDecouplerOfUintThenError) ReturnError(rtn_ch chan<- *ReturnOfError, err error) {
	rtn := __.pool.GetReturnOfError()
	var other error
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfUintThenError) HandleOfUintThenError(ctx context.Context, req *WorkOfUintThenError, h func(ctx context.Context, arg uint) (error, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfError()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfUintThenError) DoOfUintThenError(ctx context.Context, worker WorkerOfPushUintThenError, arg uint) (error, error) {
	// ch := make(chan *ReturnOfError, 1)
	ch := __.pool.GetChReturnOfError()
	defer __.pool.PutChReturnOfError(ch)

	req := __.pool.GetWorkOfUintThenError()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfUintThenError(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfError(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfUintThenError = func(ctx context.Context, arg uint) (error, error)

type WorkerOfUintThenError struct {
	api_syncer *ApiDecouplerOfUintThenError
	handler    WorkHandlerOfUintThenError

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfUintThenError
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfUintThenError(ctx context.Context, h WorkHandlerOfUintThenError, n int) *WorkerOfUintThenError {
	__ := &WorkerOfUintThenError{
		api_syncer: NewApiDecouplerOfUintThenError(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfUintThenError, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfUintThenError{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfUintThenError(req.Context, req.WorkOfUintThenError, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfUintThenError) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfUintThenError) Push(ctx context.Context, req *WorkOfUintThenError) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfUintThenError)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfUintThenError = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfUintThenError) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfUintThenError) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfUintThenError) Call(ctx context.Context, arg uint) (error, error) {
	return __.api_syncer.DoOfUintThenError(ctx, __, arg)
}

type PoolOfUintThenFloat32 interface {
	GetUintArg() *uint
	PutUintArg(*uint)
	GetFloat32Return() *float32
	PutFloat32Return(*float32)

	GetWorkOfUintThenFloat32() *WorkOfUintThenFloat32
	GetReturnOfFloat32() *ReturnOfFloat32
	PutWorkOfUintThenFloat32(*WorkOfUintThenFloat32)
	PutReturnOfFloat32(*ReturnOfFloat32)

	GetChReturnOfFloat32() chan *ReturnOfFloat32
	PutChReturnOfFloat32(chan *ReturnOfFloat32)
}

type PoolOfUintThenFloat32Impl struct {
	UintArg           sync.Pool
	Float32Rtn        sync.Pool
	UintWork          sync.Pool
	Float32Return     sync.Pool
	ChReturnOfFloat32 sync.Pool
}

func (__ *PoolOfUintThenFloat32Impl) GetUintArg() *uint {
	return __.UintArg.Get().(*uint)
}
func (__ *PoolOfUintThenFloat32Impl) PutUintArg(p *uint) {
	__.UintArg.Put(p)
}
func (__ *PoolOfUintThenFloat32Impl) GetFloat32Return() *float32 {
	return __.Float32Rtn.Get().(*float32)
}
func (__ *PoolOfUintThenFloat32Impl) PutFloat32Return(p *float32) {
	__.Float32Rtn.Put(p)
}

func (__ *PoolOfUintThenFloat32Impl) GetWorkOfUintThenFloat32() *WorkOfUintThenFloat32 {
	return __.UintWork.Get().(*WorkOfUintThenFloat32)
}
func (__ *PoolOfUintThenFloat32Impl) PutWorkOfUintThenFloat32(p *WorkOfUintThenFloat32) {
	__.UintWork.Put(p)
}
func (__ *PoolOfUintThenFloat32Impl) GetReturnOfFloat32() *ReturnOfFloat32 {
	return __.Float32Return.Get().(*ReturnOfFloat32)
}
func (__ *PoolOfUintThenFloat32Impl) PutReturnOfFloat32(p *ReturnOfFloat32) {
	__.Float32Return.Put(p)
}

func (__ *PoolOfUintThenFloat32Impl) GetChReturnOfFloat32() chan *ReturnOfFloat32 {
	return __.ChReturnOfFloat32.Get().(chan *ReturnOfFloat32)
}
func (__ *PoolOfUintThenFloat32Impl) PutChReturnOfFloat32(p chan *ReturnOfFloat32) {
	__.ChReturnOfFloat32.Put(p)
}

func NewPoolOfUintThenFloat32Impl() *PoolOfUintThenFloat32Impl {
	return &PoolOfUintThenFloat32Impl{
		UintArg: sync.Pool{
			New: func() interface{} {
				return new(uint)
			},
		},
		UintWork: sync.Pool{
			New: func() interface{} {
				return new(WorkOfUintThenFloat32)
			},
		},
		Float32Rtn: sync.Pool{
			New: func() interface{} {
				return new(float32)
			},
		},
		Float32Return: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfFloat32)
			},
		},
		ChReturnOfFloat32: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfFloat32, 1)
			},
		},
	}
}

type ApiDecouplerOfUintThenFloat32 struct {
	pool PoolOfUintThenFloat32
}

func NewApiDecouplerOfUintThenFloat32() *ApiDecouplerOfUintThenFloat32 {
	return &ApiDecouplerOfUintThenFloat32{
		pool: NewPoolOfUintThenFloat32Impl(),
	}
}

func (__ *ApiDecouplerOfUintThenFloat32) ReturnError(rtn_ch chan<- *ReturnOfFloat32, err error) {
	rtn := __.pool.GetReturnOfFloat32()
	var other float32
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfUintThenFloat32) HandleOfUintThenFloat32(ctx context.Context, req *WorkOfUintThenFloat32, h func(ctx context.Context, arg uint) (float32, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfFloat32()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfUintThenFloat32) DoOfUintThenFloat32(ctx context.Context, worker WorkerOfPushUintThenFloat32, arg uint) (float32, error) {
	// ch := make(chan *ReturnOfFloat32, 1)
	ch := __.pool.GetChReturnOfFloat32()
	defer __.pool.PutChReturnOfFloat32(ch)

	req := __.pool.GetWorkOfUintThenFloat32()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfUintThenFloat32(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfFloat32(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfUintThenFloat32 = func(ctx context.Context, arg uint) (float32, error)

type WorkerOfUintThenFloat32 struct {
	api_syncer *ApiDecouplerOfUintThenFloat32
	handler    WorkHandlerOfUintThenFloat32

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfUintThenFloat32
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfUintThenFloat32(ctx context.Context, h WorkHandlerOfUintThenFloat32, n int) *WorkerOfUintThenFloat32 {
	__ := &WorkerOfUintThenFloat32{
		api_syncer: NewApiDecouplerOfUintThenFloat32(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfUintThenFloat32, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfUintThenFloat32{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfUintThenFloat32(req.Context, req.WorkOfUintThenFloat32, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfUintThenFloat32) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfUintThenFloat32) Push(ctx context.Context, req *WorkOfUintThenFloat32) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfUintThenFloat32)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfUintThenFloat32 = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfUintThenFloat32) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfUintThenFloat32) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfUintThenFloat32) Call(ctx context.Context, arg uint) (float32, error) {
	return __.api_syncer.DoOfUintThenFloat32(ctx, __, arg)
}

type PoolOfUintThenFloat64 interface {
	GetUintArg() *uint
	PutUintArg(*uint)
	GetFloat64Return() *float64
	PutFloat64Return(*float64)

	GetWorkOfUintThenFloat64() *WorkOfUintThenFloat64
	GetReturnOfFloat64() *ReturnOfFloat64
	PutWorkOfUintThenFloat64(*WorkOfUintThenFloat64)
	PutReturnOfFloat64(*ReturnOfFloat64)

	GetChReturnOfFloat64() chan *ReturnOfFloat64
	PutChReturnOfFloat64(chan *ReturnOfFloat64)
}

type PoolOfUintThenFloat64Impl struct {
	UintArg           sync.Pool
	Float64Rtn        sync.Pool
	UintWork          sync.Pool
	Float64Return     sync.Pool
	ChReturnOfFloat64 sync.Pool
}

func (__ *PoolOfUintThenFloat64Impl) GetUintArg() *uint {
	return __.UintArg.Get().(*uint)
}
func (__ *PoolOfUintThenFloat64Impl) PutUintArg(p *uint) {
	__.UintArg.Put(p)
}
func (__ *PoolOfUintThenFloat64Impl) GetFloat64Return() *float64 {
	return __.Float64Rtn.Get().(*float64)
}
func (__ *PoolOfUintThenFloat64Impl) PutFloat64Return(p *float64) {
	__.Float64Rtn.Put(p)
}

func (__ *PoolOfUintThenFloat64Impl) GetWorkOfUintThenFloat64() *WorkOfUintThenFloat64 {
	return __.UintWork.Get().(*WorkOfUintThenFloat64)
}
func (__ *PoolOfUintThenFloat64Impl) PutWorkOfUintThenFloat64(p *WorkOfUintThenFloat64) {
	__.UintWork.Put(p)
}
func (__ *PoolOfUintThenFloat64Impl) GetReturnOfFloat64() *ReturnOfFloat64 {
	return __.Float64Return.Get().(*ReturnOfFloat64)
}
func (__ *PoolOfUintThenFloat64Impl) PutReturnOfFloat64(p *ReturnOfFloat64) {
	__.Float64Return.Put(p)
}

func (__ *PoolOfUintThenFloat64Impl) GetChReturnOfFloat64() chan *ReturnOfFloat64 {
	return __.ChReturnOfFloat64.Get().(chan *ReturnOfFloat64)
}
func (__ *PoolOfUintThenFloat64Impl) PutChReturnOfFloat64(p chan *ReturnOfFloat64) {
	__.ChReturnOfFloat64.Put(p)
}

func NewPoolOfUintThenFloat64Impl() *PoolOfUintThenFloat64Impl {
	return &PoolOfUintThenFloat64Impl{
		UintArg: sync.Pool{
			New: func() interface{} {
				return new(uint)
			},
		},
		UintWork: sync.Pool{
			New: func() interface{} {
				return new(WorkOfUintThenFloat64)
			},
		},
		Float64Rtn: sync.Pool{
			New: func() interface{} {
				return new(float64)
			},
		},
		Float64Return: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfFloat64)
			},
		},
		ChReturnOfFloat64: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfFloat64, 1)
			},
		},
	}
}

type ApiDecouplerOfUintThenFloat64 struct {
	pool PoolOfUintThenFloat64
}

func NewApiDecouplerOfUintThenFloat64() *ApiDecouplerOfUintThenFloat64 {
	return &ApiDecouplerOfUintThenFloat64{
		pool: NewPoolOfUintThenFloat64Impl(),
	}
}

func (__ *ApiDecouplerOfUintThenFloat64) ReturnError(rtn_ch chan<- *ReturnOfFloat64, err error) {
	rtn := __.pool.GetReturnOfFloat64()
	var other float64
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfUintThenFloat64) HandleOfUintThenFloat64(ctx context.Context, req *WorkOfUintThenFloat64, h func(ctx context.Context, arg uint) (float64, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfFloat64()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfUintThenFloat64) DoOfUintThenFloat64(ctx context.Context, worker WorkerOfPushUintThenFloat64, arg uint) (float64, error) {
	// ch := make(chan *ReturnOfFloat64, 1)
	ch := __.pool.GetChReturnOfFloat64()
	defer __.pool.PutChReturnOfFloat64(ch)

	req := __.pool.GetWorkOfUintThenFloat64()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfUintThenFloat64(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfFloat64(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfUintThenFloat64 = func(ctx context.Context, arg uint) (float64, error)

type WorkerOfUintThenFloat64 struct {
	api_syncer *ApiDecouplerOfUintThenFloat64
	handler    WorkHandlerOfUintThenFloat64

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfUintThenFloat64
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfUintThenFloat64(ctx context.Context, h WorkHandlerOfUintThenFloat64, n int) *WorkerOfUintThenFloat64 {
	__ := &WorkerOfUintThenFloat64{
		api_syncer: NewApiDecouplerOfUintThenFloat64(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfUintThenFloat64, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfUintThenFloat64{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfUintThenFloat64(req.Context, req.WorkOfUintThenFloat64, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfUintThenFloat64) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfUintThenFloat64) Push(ctx context.Context, req *WorkOfUintThenFloat64) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfUintThenFloat64)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfUintThenFloat64 = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfUintThenFloat64) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfUintThenFloat64) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfUintThenFloat64) Call(ctx context.Context, arg uint) (float64, error) {
	return __.api_syncer.DoOfUintThenFloat64(ctx, __, arg)
}

type PoolOfUintThenInt interface {
	GetUintArg() *uint
	PutUintArg(*uint)
	GetIntReturn() *int
	PutIntReturn(*int)

	GetWorkOfUintThenInt() *WorkOfUintThenInt
	GetReturnOfInt() *ReturnOfInt
	PutWorkOfUintThenInt(*WorkOfUintThenInt)
	PutReturnOfInt(*ReturnOfInt)

	GetChReturnOfInt() chan *ReturnOfInt
	PutChReturnOfInt(chan *ReturnOfInt)
}

type PoolOfUintThenIntImpl struct {
	UintArg       sync.Pool
	IntRtn        sync.Pool
	UintWork      sync.Pool
	IntReturn     sync.Pool
	ChReturnOfInt sync.Pool
}

func (__ *PoolOfUintThenIntImpl) GetUintArg() *uint {
	return __.UintArg.Get().(*uint)
}
func (__ *PoolOfUintThenIntImpl) PutUintArg(p *uint) {
	__.UintArg.Put(p)
}
func (__ *PoolOfUintThenIntImpl) GetIntReturn() *int {
	return __.IntRtn.Get().(*int)
}
func (__ *PoolOfUintThenIntImpl) PutIntReturn(p *int) {
	__.IntRtn.Put(p)
}

func (__ *PoolOfUintThenIntImpl) GetWorkOfUintThenInt() *WorkOfUintThenInt {
	return __.UintWork.Get().(*WorkOfUintThenInt)
}
func (__ *PoolOfUintThenIntImpl) PutWorkOfUintThenInt(p *WorkOfUintThenInt) {
	__.UintWork.Put(p)
}
func (__ *PoolOfUintThenIntImpl) GetReturnOfInt() *ReturnOfInt {
	return __.IntReturn.Get().(*ReturnOfInt)
}
func (__ *PoolOfUintThenIntImpl) PutReturnOfInt(p *ReturnOfInt) {
	__.IntReturn.Put(p)
}

func (__ *PoolOfUintThenIntImpl) GetChReturnOfInt() chan *ReturnOfInt {
	return __.ChReturnOfInt.Get().(chan *ReturnOfInt)
}
func (__ *PoolOfUintThenIntImpl) PutChReturnOfInt(p chan *ReturnOfInt) {
	__.ChReturnOfInt.Put(p)
}

func NewPoolOfUintThenIntImpl() *PoolOfUintThenIntImpl {
	return &PoolOfUintThenIntImpl{
		UintArg: sync.Pool{
			New: func() interface{} {
				return new(uint)
			},
		},
		UintWork: sync.Pool{
			New: func() interface{} {
				return new(WorkOfUintThenInt)
			},
		},
		IntRtn: sync.Pool{
			New: func() interface{} {
				return new(int)
			},
		},
		IntReturn: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfInt)
			},
		},
		ChReturnOfInt: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfInt, 1)
			},
		},
	}
}

type ApiDecouplerOfUintThenInt struct {
	pool PoolOfUintThenInt
}

func NewApiDecouplerOfUintThenInt() *ApiDecouplerOfUintThenInt {
	return &ApiDecouplerOfUintThenInt{
		pool: NewPoolOfUintThenIntImpl(),
	}
}

func (__ *ApiDecouplerOfUintThenInt) ReturnError(rtn_ch chan<- *ReturnOfInt, err error) {
	rtn := __.pool.GetReturnOfInt()
	var other int
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfUintThenInt) HandleOfUintThenInt(ctx context.Context, req *WorkOfUintThenInt, h func(ctx context.Context, arg uint) (int, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfInt()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfUintThenInt) DoOfUintThenInt(ctx context.Context, worker WorkerOfPushUintThenInt, arg uint) (int, error) {
	// ch := make(chan *ReturnOfInt, 1)
	ch := __.pool.GetChReturnOfInt()
	defer __.pool.PutChReturnOfInt(ch)

	req := __.pool.GetWorkOfUintThenInt()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfUintThenInt(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfInt(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfUintThenInt = func(ctx context.Context, arg uint) (int, error)

type WorkerOfUintThenInt struct {
	api_syncer *ApiDecouplerOfUintThenInt
	handler    WorkHandlerOfUintThenInt

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfUintThenInt
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfUintThenInt(ctx context.Context, h WorkHandlerOfUintThenInt, n int) *WorkerOfUintThenInt {
	__ := &WorkerOfUintThenInt{
		api_syncer: NewApiDecouplerOfUintThenInt(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfUintThenInt, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfUintThenInt{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfUintThenInt(req.Context, req.WorkOfUintThenInt, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfUintThenInt) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfUintThenInt) Push(ctx context.Context, req *WorkOfUintThenInt) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfUintThenInt)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfUintThenInt = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfUintThenInt) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfUintThenInt) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfUintThenInt) Call(ctx context.Context, arg uint) (int, error) {
	return __.api_syncer.DoOfUintThenInt(ctx, __, arg)
}

type PoolOfUintThenInt16 interface {
	GetUintArg() *uint
	PutUintArg(*uint)
	GetInt16Return() *int16
	PutInt16Return(*int16)

	GetWorkOfUintThenInt16() *WorkOfUintThenInt16
	GetReturnOfInt16() *ReturnOfInt16
	PutWorkOfUintThenInt16(*WorkOfUintThenInt16)
	PutReturnOfInt16(*ReturnOfInt16)

	GetChReturnOfInt16() chan *ReturnOfInt16
	PutChReturnOfInt16(chan *ReturnOfInt16)
}

type PoolOfUintThenInt16Impl struct {
	UintArg         sync.Pool
	Int16Rtn        sync.Pool
	UintWork        sync.Pool
	Int16Return     sync.Pool
	ChReturnOfInt16 sync.Pool
}

func (__ *PoolOfUintThenInt16Impl) GetUintArg() *uint {
	return __.UintArg.Get().(*uint)
}
func (__ *PoolOfUintThenInt16Impl) PutUintArg(p *uint) {
	__.UintArg.Put(p)
}
func (__ *PoolOfUintThenInt16Impl) GetInt16Return() *int16 {
	return __.Int16Rtn.Get().(*int16)
}
func (__ *PoolOfUintThenInt16Impl) PutInt16Return(p *int16) {
	__.Int16Rtn.Put(p)
}

func (__ *PoolOfUintThenInt16Impl) GetWorkOfUintThenInt16() *WorkOfUintThenInt16 {
	return __.UintWork.Get().(*WorkOfUintThenInt16)
}
func (__ *PoolOfUintThenInt16Impl) PutWorkOfUintThenInt16(p *WorkOfUintThenInt16) {
	__.UintWork.Put(p)
}
func (__ *PoolOfUintThenInt16Impl) GetReturnOfInt16() *ReturnOfInt16 {
	return __.Int16Return.Get().(*ReturnOfInt16)
}
func (__ *PoolOfUintThenInt16Impl) PutReturnOfInt16(p *ReturnOfInt16) {
	__.Int16Return.Put(p)
}

func (__ *PoolOfUintThenInt16Impl) GetChReturnOfInt16() chan *ReturnOfInt16 {
	return __.ChReturnOfInt16.Get().(chan *ReturnOfInt16)
}
func (__ *PoolOfUintThenInt16Impl) PutChReturnOfInt16(p chan *ReturnOfInt16) {
	__.ChReturnOfInt16.Put(p)
}

func NewPoolOfUintThenInt16Impl() *PoolOfUintThenInt16Impl {
	return &PoolOfUintThenInt16Impl{
		UintArg: sync.Pool{
			New: func() interface{} {
				return new(uint)
			},
		},
		UintWork: sync.Pool{
			New: func() interface{} {
				return new(WorkOfUintThenInt16)
			},
		},
		Int16Rtn: sync.Pool{
			New: func() interface{} {
				return new(int16)
			},
		},
		Int16Return: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfInt16)
			},
		},
		ChReturnOfInt16: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfInt16, 1)
			},
		},
	}
}

type ApiDecouplerOfUintThenInt16 struct {
	pool PoolOfUintThenInt16
}

func NewApiDecouplerOfUintThenInt16() *ApiDecouplerOfUintThenInt16 {
	return &ApiDecouplerOfUintThenInt16{
		pool: NewPoolOfUintThenInt16Impl(),
	}
}

func (__ *ApiDecouplerOfUintThenInt16) ReturnError(rtn_ch chan<- *ReturnOfInt16, err error) {
	rtn := __.pool.GetReturnOfInt16()
	var other int16
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfUintThenInt16) HandleOfUintThenInt16(ctx context.Context, req *WorkOfUintThenInt16, h func(ctx context.Context, arg uint) (int16, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfInt16()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfUintThenInt16) DoOfUintThenInt16(ctx context.Context, worker WorkerOfPushUintThenInt16, arg uint) (int16, error) {
	// ch := make(chan *ReturnOfInt16, 1)
	ch := __.pool.GetChReturnOfInt16()
	defer __.pool.PutChReturnOfInt16(ch)

	req := __.pool.GetWorkOfUintThenInt16()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfUintThenInt16(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfInt16(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfUintThenInt16 = func(ctx context.Context, arg uint) (int16, error)

type WorkerOfUintThenInt16 struct {
	api_syncer *ApiDecouplerOfUintThenInt16
	handler    WorkHandlerOfUintThenInt16

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfUintThenInt16
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfUintThenInt16(ctx context.Context, h WorkHandlerOfUintThenInt16, n int) *WorkerOfUintThenInt16 {
	__ := &WorkerOfUintThenInt16{
		api_syncer: NewApiDecouplerOfUintThenInt16(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfUintThenInt16, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfUintThenInt16{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfUintThenInt16(req.Context, req.WorkOfUintThenInt16, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfUintThenInt16) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfUintThenInt16) Push(ctx context.Context, req *WorkOfUintThenInt16) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfUintThenInt16)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfUintThenInt16 = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfUintThenInt16) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfUintThenInt16) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfUintThenInt16) Call(ctx context.Context, arg uint) (int16, error) {
	return __.api_syncer.DoOfUintThenInt16(ctx, __, arg)
}

type PoolOfUintThenInt32 interface {
	GetUintArg() *uint
	PutUintArg(*uint)
	GetInt32Return() *int32
	PutInt32Return(*int32)

	GetWorkOfUintThenInt32() *WorkOfUintThenInt32
	GetReturnOfInt32() *ReturnOfInt32
	PutWorkOfUintThenInt32(*WorkOfUintThenInt32)
	PutReturnOfInt32(*ReturnOfInt32)

	GetChReturnOfInt32() chan *ReturnOfInt32
	PutChReturnOfInt32(chan *ReturnOfInt32)
}

type PoolOfUintThenInt32Impl struct {
	UintArg         sync.Pool
	Int32Rtn        sync.Pool
	UintWork        sync.Pool
	Int32Return     sync.Pool
	ChReturnOfInt32 sync.Pool
}

func (__ *PoolOfUintThenInt32Impl) GetUintArg() *uint {
	return __.UintArg.Get().(*uint)
}
func (__ *PoolOfUintThenInt32Impl) PutUintArg(p *uint) {
	__.UintArg.Put(p)
}
func (__ *PoolOfUintThenInt32Impl) GetInt32Return() *int32 {
	return __.Int32Rtn.Get().(*int32)
}
func (__ *PoolOfUintThenInt32Impl) PutInt32Return(p *int32) {
	__.Int32Rtn.Put(p)
}

func (__ *PoolOfUintThenInt32Impl) GetWorkOfUintThenInt32() *WorkOfUintThenInt32 {
	return __.UintWork.Get().(*WorkOfUintThenInt32)
}
func (__ *PoolOfUintThenInt32Impl) PutWorkOfUintThenInt32(p *WorkOfUintThenInt32) {
	__.UintWork.Put(p)
}
func (__ *PoolOfUintThenInt32Impl) GetReturnOfInt32() *ReturnOfInt32 {
	return __.Int32Return.Get().(*ReturnOfInt32)
}
func (__ *PoolOfUintThenInt32Impl) PutReturnOfInt32(p *ReturnOfInt32) {
	__.Int32Return.Put(p)
}

func (__ *PoolOfUintThenInt32Impl) GetChReturnOfInt32() chan *ReturnOfInt32 {
	return __.ChReturnOfInt32.Get().(chan *ReturnOfInt32)
}
func (__ *PoolOfUintThenInt32Impl) PutChReturnOfInt32(p chan *ReturnOfInt32) {
	__.ChReturnOfInt32.Put(p)
}

func NewPoolOfUintThenInt32Impl() *PoolOfUintThenInt32Impl {
	return &PoolOfUintThenInt32Impl{
		UintArg: sync.Pool{
			New: func() interface{} {
				return new(uint)
			},
		},
		UintWork: sync.Pool{
			New: func() interface{} {
				return new(WorkOfUintThenInt32)
			},
		},
		Int32Rtn: sync.Pool{
			New: func() interface{} {
				return new(int32)
			},
		},
		Int32Return: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfInt32)
			},
		},
		ChReturnOfInt32: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfInt32, 1)
			},
		},
	}
}

type ApiDecouplerOfUintThenInt32 struct {
	pool PoolOfUintThenInt32
}

func NewApiDecouplerOfUintThenInt32() *ApiDecouplerOfUintThenInt32 {
	return &ApiDecouplerOfUintThenInt32{
		pool: NewPoolOfUintThenInt32Impl(),
	}
}

func (__ *ApiDecouplerOfUintThenInt32) ReturnError(rtn_ch chan<- *ReturnOfInt32, err error) {
	rtn := __.pool.GetReturnOfInt32()
	var other int32
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfUintThenInt32) HandleOfUintThenInt32(ctx context.Context, req *WorkOfUintThenInt32, h func(ctx context.Context, arg uint) (int32, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfInt32()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfUintThenInt32) DoOfUintThenInt32(ctx context.Context, worker WorkerOfPushUintThenInt32, arg uint) (int32, error) {
	// ch := make(chan *ReturnOfInt32, 1)
	ch := __.pool.GetChReturnOfInt32()
	defer __.pool.PutChReturnOfInt32(ch)

	req := __.pool.GetWorkOfUintThenInt32()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfUintThenInt32(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfInt32(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfUintThenInt32 = func(ctx context.Context, arg uint) (int32, error)

type WorkerOfUintThenInt32 struct {
	api_syncer *ApiDecouplerOfUintThenInt32
	handler    WorkHandlerOfUintThenInt32

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfUintThenInt32
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfUintThenInt32(ctx context.Context, h WorkHandlerOfUintThenInt32, n int) *WorkerOfUintThenInt32 {
	__ := &WorkerOfUintThenInt32{
		api_syncer: NewApiDecouplerOfUintThenInt32(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfUintThenInt32, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfUintThenInt32{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfUintThenInt32(req.Context, req.WorkOfUintThenInt32, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfUintThenInt32) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfUintThenInt32) Push(ctx context.Context, req *WorkOfUintThenInt32) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfUintThenInt32)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfUintThenInt32 = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfUintThenInt32) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfUintThenInt32) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfUintThenInt32) Call(ctx context.Context, arg uint) (int32, error) {
	return __.api_syncer.DoOfUintThenInt32(ctx, __, arg)
}

type PoolOfUintThenInt64 interface {
	GetUintArg() *uint
	PutUintArg(*uint)
	GetInt64Return() *int64
	PutInt64Return(*int64)

	GetWorkOfUintThenInt64() *WorkOfUintThenInt64
	GetReturnOfInt64() *ReturnOfInt64
	PutWorkOfUintThenInt64(*WorkOfUintThenInt64)
	PutReturnOfInt64(*ReturnOfInt64)

	GetChReturnOfInt64() chan *ReturnOfInt64
	PutChReturnOfInt64(chan *ReturnOfInt64)
}

type PoolOfUintThenInt64Impl struct {
	UintArg         sync.Pool
	Int64Rtn        sync.Pool
	UintWork        sync.Pool
	Int64Return     sync.Pool
	ChReturnOfInt64 sync.Pool
}

func (__ *PoolOfUintThenInt64Impl) GetUintArg() *uint {
	return __.UintArg.Get().(*uint)
}
func (__ *PoolOfUintThenInt64Impl) PutUintArg(p *uint) {
	__.UintArg.Put(p)
}
func (__ *PoolOfUintThenInt64Impl) GetInt64Return() *int64 {
	return __.Int64Rtn.Get().(*int64)
}
func (__ *PoolOfUintThenInt64Impl) PutInt64Return(p *int64) {
	__.Int64Rtn.Put(p)
}

func (__ *PoolOfUintThenInt64Impl) GetWorkOfUintThenInt64() *WorkOfUintThenInt64 {
	return __.UintWork.Get().(*WorkOfUintThenInt64)
}
func (__ *PoolOfUintThenInt64Impl) PutWorkOfUintThenInt64(p *WorkOfUintThenInt64) {
	__.UintWork.Put(p)
}
func (__ *PoolOfUintThenInt64Impl) GetReturnOfInt64() *ReturnOfInt64 {
	return __.Int64Return.Get().(*ReturnOfInt64)
}
func (__ *PoolOfUintThenInt64Impl) PutReturnOfInt64(p *ReturnOfInt64) {
	__.Int64Return.Put(p)
}

func (__ *PoolOfUintThenInt64Impl) GetChReturnOfInt64() chan *ReturnOfInt64 {
	return __.ChReturnOfInt64.Get().(chan *ReturnOfInt64)
}
func (__ *PoolOfUintThenInt64Impl) PutChReturnOfInt64(p chan *ReturnOfInt64) {
	__.ChReturnOfInt64.Put(p)
}

func NewPoolOfUintThenInt64Impl() *PoolOfUintThenInt64Impl {
	return &PoolOfUintThenInt64Impl{
		UintArg: sync.Pool{
			New: func() interface{} {
				return new(uint)
			},
		},
		UintWork: sync.Pool{
			New: func() interface{} {
				return new(WorkOfUintThenInt64)
			},
		},
		Int64Rtn: sync.Pool{
			New: func() interface{} {
				return new(int64)
			},
		},
		Int64Return: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfInt64)
			},
		},
		ChReturnOfInt64: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfInt64, 1)
			},
		},
	}
}

type ApiDecouplerOfUintThenInt64 struct {
	pool PoolOfUintThenInt64
}

func NewApiDecouplerOfUintThenInt64() *ApiDecouplerOfUintThenInt64 {
	return &ApiDecouplerOfUintThenInt64{
		pool: NewPoolOfUintThenInt64Impl(),
	}
}

func (__ *ApiDecouplerOfUintThenInt64) ReturnError(rtn_ch chan<- *ReturnOfInt64, err error) {
	rtn := __.pool.GetReturnOfInt64()
	var other int64
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfUintThenInt64) HandleOfUintThenInt64(ctx context.Context, req *WorkOfUintThenInt64, h func(ctx context.Context, arg uint) (int64, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfInt64()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfUintThenInt64) DoOfUintThenInt64(ctx context.Context, worker WorkerOfPushUintThenInt64, arg uint) (int64, error) {
	// ch := make(chan *ReturnOfInt64, 1)
	ch := __.pool.GetChReturnOfInt64()
	defer __.pool.PutChReturnOfInt64(ch)

	req := __.pool.GetWorkOfUintThenInt64()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfUintThenInt64(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfInt64(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfUintThenInt64 = func(ctx context.Context, arg uint) (int64, error)

type WorkerOfUintThenInt64 struct {
	api_syncer *ApiDecouplerOfUintThenInt64
	handler    WorkHandlerOfUintThenInt64

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfUintThenInt64
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfUintThenInt64(ctx context.Context, h WorkHandlerOfUintThenInt64, n int) *WorkerOfUintThenInt64 {
	__ := &WorkerOfUintThenInt64{
		api_syncer: NewApiDecouplerOfUintThenInt64(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfUintThenInt64, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfUintThenInt64{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfUintThenInt64(req.Context, req.WorkOfUintThenInt64, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfUintThenInt64) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfUintThenInt64) Push(ctx context.Context, req *WorkOfUintThenInt64) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfUintThenInt64)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfUintThenInt64 = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfUintThenInt64) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfUintThenInt64) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfUintThenInt64) Call(ctx context.Context, arg uint) (int64, error) {
	return __.api_syncer.DoOfUintThenInt64(ctx, __, arg)
}

type PoolOfUintThenInt8 interface {
	GetUintArg() *uint
	PutUintArg(*uint)
	GetInt8Return() *int8
	PutInt8Return(*int8)

	GetWorkOfUintThenInt8() *WorkOfUintThenInt8
	GetReturnOfInt8() *ReturnOfInt8
	PutWorkOfUintThenInt8(*WorkOfUintThenInt8)
	PutReturnOfInt8(*ReturnOfInt8)

	GetChReturnOfInt8() chan *ReturnOfInt8
	PutChReturnOfInt8(chan *ReturnOfInt8)
}

type PoolOfUintThenInt8Impl struct {
	UintArg        sync.Pool
	Int8Rtn        sync.Pool
	UintWork       sync.Pool
	Int8Return     sync.Pool
	ChReturnOfInt8 sync.Pool
}

func (__ *PoolOfUintThenInt8Impl) GetUintArg() *uint {
	return __.UintArg.Get().(*uint)
}
func (__ *PoolOfUintThenInt8Impl) PutUintArg(p *uint) {
	__.UintArg.Put(p)
}
func (__ *PoolOfUintThenInt8Impl) GetInt8Return() *int8 {
	return __.Int8Rtn.Get().(*int8)
}
func (__ *PoolOfUintThenInt8Impl) PutInt8Return(p *int8) {
	__.Int8Rtn.Put(p)
}

func (__ *PoolOfUintThenInt8Impl) GetWorkOfUintThenInt8() *WorkOfUintThenInt8 {
	return __.UintWork.Get().(*WorkOfUintThenInt8)
}
func (__ *PoolOfUintThenInt8Impl) PutWorkOfUintThenInt8(p *WorkOfUintThenInt8) {
	__.UintWork.Put(p)
}
func (__ *PoolOfUintThenInt8Impl) GetReturnOfInt8() *ReturnOfInt8 {
	return __.Int8Return.Get().(*ReturnOfInt8)
}
func (__ *PoolOfUintThenInt8Impl) PutReturnOfInt8(p *ReturnOfInt8) {
	__.Int8Return.Put(p)
}

func (__ *PoolOfUintThenInt8Impl) GetChReturnOfInt8() chan *ReturnOfInt8 {
	return __.ChReturnOfInt8.Get().(chan *ReturnOfInt8)
}
func (__ *PoolOfUintThenInt8Impl) PutChReturnOfInt8(p chan *ReturnOfInt8) {
	__.ChReturnOfInt8.Put(p)
}

func NewPoolOfUintThenInt8Impl() *PoolOfUintThenInt8Impl {
	return &PoolOfUintThenInt8Impl{
		UintArg: sync.Pool{
			New: func() interface{} {
				return new(uint)
			},
		},
		UintWork: sync.Pool{
			New: func() interface{} {
				return new(WorkOfUintThenInt8)
			},
		},
		Int8Rtn: sync.Pool{
			New: func() interface{} {
				return new(int8)
			},
		},
		Int8Return: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfInt8)
			},
		},
		ChReturnOfInt8: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfInt8, 1)
			},
		},
	}
}

type ApiDecouplerOfUintThenInt8 struct {
	pool PoolOfUintThenInt8
}

func NewApiDecouplerOfUintThenInt8() *ApiDecouplerOfUintThenInt8 {
	return &ApiDecouplerOfUintThenInt8{
		pool: NewPoolOfUintThenInt8Impl(),
	}
}

func (__ *ApiDecouplerOfUintThenInt8) ReturnError(rtn_ch chan<- *ReturnOfInt8, err error) {
	rtn := __.pool.GetReturnOfInt8()
	var other int8
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfUintThenInt8) HandleOfUintThenInt8(ctx context.Context, req *WorkOfUintThenInt8, h func(ctx context.Context, arg uint) (int8, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfInt8()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfUintThenInt8) DoOfUintThenInt8(ctx context.Context, worker WorkerOfPushUintThenInt8, arg uint) (int8, error) {
	// ch := make(chan *ReturnOfInt8, 1)
	ch := __.pool.GetChReturnOfInt8()
	defer __.pool.PutChReturnOfInt8(ch)

	req := __.pool.GetWorkOfUintThenInt8()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfUintThenInt8(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfInt8(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfUintThenInt8 = func(ctx context.Context, arg uint) (int8, error)

type WorkerOfUintThenInt8 struct {
	api_syncer *ApiDecouplerOfUintThenInt8
	handler    WorkHandlerOfUintThenInt8

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfUintThenInt8
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfUintThenInt8(ctx context.Context, h WorkHandlerOfUintThenInt8, n int) *WorkerOfUintThenInt8 {
	__ := &WorkerOfUintThenInt8{
		api_syncer: NewApiDecouplerOfUintThenInt8(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfUintThenInt8, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfUintThenInt8{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfUintThenInt8(req.Context, req.WorkOfUintThenInt8, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfUintThenInt8) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfUintThenInt8) Push(ctx context.Context, req *WorkOfUintThenInt8) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfUintThenInt8)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfUintThenInt8 = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfUintThenInt8) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfUintThenInt8) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfUintThenInt8) Call(ctx context.Context, arg uint) (int8, error) {
	return __.api_syncer.DoOfUintThenInt8(ctx, __, arg)
}

type PoolOfUintThenRune interface {
	GetUintArg() *uint
	PutUintArg(*uint)
	GetRuneReturn() *rune
	PutRuneReturn(*rune)

	GetWorkOfUintThenRune() *WorkOfUintThenRune
	GetReturnOfRune() *ReturnOfRune
	PutWorkOfUintThenRune(*WorkOfUintThenRune)
	PutReturnOfRune(*ReturnOfRune)

	GetChReturnOfRune() chan *ReturnOfRune
	PutChReturnOfRune(chan *ReturnOfRune)
}

type PoolOfUintThenRuneImpl struct {
	UintArg        sync.Pool
	RuneRtn        sync.Pool
	UintWork       sync.Pool
	RuneReturn     sync.Pool
	ChReturnOfRune sync.Pool
}

func (__ *PoolOfUintThenRuneImpl) GetUintArg() *uint {
	return __.UintArg.Get().(*uint)
}
func (__ *PoolOfUintThenRuneImpl) PutUintArg(p *uint) {
	__.UintArg.Put(p)
}
func (__ *PoolOfUintThenRuneImpl) GetRuneReturn() *rune {
	return __.RuneRtn.Get().(*rune)
}
func (__ *PoolOfUintThenRuneImpl) PutRuneReturn(p *rune) {
	__.RuneRtn.Put(p)
}

func (__ *PoolOfUintThenRuneImpl) GetWorkOfUintThenRune() *WorkOfUintThenRune {
	return __.UintWork.Get().(*WorkOfUintThenRune)
}
func (__ *PoolOfUintThenRuneImpl) PutWorkOfUintThenRune(p *WorkOfUintThenRune) {
	__.UintWork.Put(p)
}
func (__ *PoolOfUintThenRuneImpl) GetReturnOfRune() *ReturnOfRune {
	return __.RuneReturn.Get().(*ReturnOfRune)
}
func (__ *PoolOfUintThenRuneImpl) PutReturnOfRune(p *ReturnOfRune) {
	__.RuneReturn.Put(p)
}

func (__ *PoolOfUintThenRuneImpl) GetChReturnOfRune() chan *ReturnOfRune {
	return __.ChReturnOfRune.Get().(chan *ReturnOfRune)
}
func (__ *PoolOfUintThenRuneImpl) PutChReturnOfRune(p chan *ReturnOfRune) {
	__.ChReturnOfRune.Put(p)
}

func NewPoolOfUintThenRuneImpl() *PoolOfUintThenRuneImpl {
	return &PoolOfUintThenRuneImpl{
		UintArg: sync.Pool{
			New: func() interface{} {
				return new(uint)
			},
		},
		UintWork: sync.Pool{
			New: func() interface{} {
				return new(WorkOfUintThenRune)
			},
		},
		RuneRtn: sync.Pool{
			New: func() interface{} {
				return new(rune)
			},
		},
		RuneReturn: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfRune)
			},
		},
		ChReturnOfRune: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfRune, 1)
			},
		},
	}
}

type ApiDecouplerOfUintThenRune struct {
	pool PoolOfUintThenRune
}

func NewApiDecouplerOfUintThenRune() *ApiDecouplerOfUintThenRune {
	return &ApiDecouplerOfUintThenRune{
		pool: NewPoolOfUintThenRuneImpl(),
	}
}

func (__ *ApiDecouplerOfUintThenRune) ReturnError(rtn_ch chan<- *ReturnOfRune, err error) {
	rtn := __.pool.GetReturnOfRune()
	var other rune
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfUintThenRune) HandleOfUintThenRune(ctx context.Context, req *WorkOfUintThenRune, h func(ctx context.Context, arg uint) (rune, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfRune()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfUintThenRune) DoOfUintThenRune(ctx context.Context, worker WorkerOfPushUintThenRune, arg uint) (rune, error) {
	// ch := make(chan *ReturnOfRune, 1)
	ch := __.pool.GetChReturnOfRune()
	defer __.pool.PutChReturnOfRune(ch)

	req := __.pool.GetWorkOfUintThenRune()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfUintThenRune(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfRune(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfUintThenRune = func(ctx context.Context, arg uint) (rune, error)

type WorkerOfUintThenRune struct {
	api_syncer *ApiDecouplerOfUintThenRune
	handler    WorkHandlerOfUintThenRune

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfUintThenRune
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfUintThenRune(ctx context.Context, h WorkHandlerOfUintThenRune, n int) *WorkerOfUintThenRune {
	__ := &WorkerOfUintThenRune{
		api_syncer: NewApiDecouplerOfUintThenRune(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfUintThenRune, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfUintThenRune{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfUintThenRune(req.Context, req.WorkOfUintThenRune, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfUintThenRune) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfUintThenRune) Push(ctx context.Context, req *WorkOfUintThenRune) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfUintThenRune)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfUintThenRune = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfUintThenRune) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfUintThenRune) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfUintThenRune) Call(ctx context.Context, arg uint) (rune, error) {
	return __.api_syncer.DoOfUintThenRune(ctx, __, arg)
}

type PoolOfUintThenString interface {
	GetUintArg() *uint
	PutUintArg(*uint)
	GetStringReturn() *string
	PutStringReturn(*string)

	GetWorkOfUintThenString() *WorkOfUintThenString
	GetReturnOfString() *ReturnOfString
	PutWorkOfUintThenString(*WorkOfUintThenString)
	PutReturnOfString(*ReturnOfString)

	GetChReturnOfString() chan *ReturnOfString
	PutChReturnOfString(chan *ReturnOfString)
}

type PoolOfUintThenStringImpl struct {
	UintArg          sync.Pool
	StringRtn        sync.Pool
	UintWork         sync.Pool
	StringReturn     sync.Pool
	ChReturnOfString sync.Pool
}

func (__ *PoolOfUintThenStringImpl) GetUintArg() *uint {
	return __.UintArg.Get().(*uint)
}
func (__ *PoolOfUintThenStringImpl) PutUintArg(p *uint) {
	__.UintArg.Put(p)
}
func (__ *PoolOfUintThenStringImpl) GetStringReturn() *string {
	return __.StringRtn.Get().(*string)
}
func (__ *PoolOfUintThenStringImpl) PutStringReturn(p *string) {
	__.StringRtn.Put(p)
}

func (__ *PoolOfUintThenStringImpl) GetWorkOfUintThenString() *WorkOfUintThenString {
	return __.UintWork.Get().(*WorkOfUintThenString)
}
func (__ *PoolOfUintThenStringImpl) PutWorkOfUintThenString(p *WorkOfUintThenString) {
	__.UintWork.Put(p)
}
func (__ *PoolOfUintThenStringImpl) GetReturnOfString() *ReturnOfString {
	return __.StringReturn.Get().(*ReturnOfString)
}
func (__ *PoolOfUintThenStringImpl) PutReturnOfString(p *ReturnOfString) {
	__.StringReturn.Put(p)
}

func (__ *PoolOfUintThenStringImpl) GetChReturnOfString() chan *ReturnOfString {
	return __.ChReturnOfString.Get().(chan *ReturnOfString)
}
func (__ *PoolOfUintThenStringImpl) PutChReturnOfString(p chan *ReturnOfString) {
	__.ChReturnOfString.Put(p)
}

func NewPoolOfUintThenStringImpl() *PoolOfUintThenStringImpl {
	return &PoolOfUintThenStringImpl{
		UintArg: sync.Pool{
			New: func() interface{} {
				return new(uint)
			},
		},
		UintWork: sync.Pool{
			New: func() interface{} {
				return new(WorkOfUintThenString)
			},
		},
		StringRtn: sync.Pool{
			New: func() interface{} {
				return new(string)
			},
		},
		StringReturn: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfString)
			},
		},
		ChReturnOfString: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfString, 1)
			},
		},
	}
}

type ApiDecouplerOfUintThenString struct {
	pool PoolOfUintThenString
}

func NewApiDecouplerOfUintThenString() *ApiDecouplerOfUintThenString {
	return &ApiDecouplerOfUintThenString{
		pool: NewPoolOfUintThenStringImpl(),
	}
}

func (__ *ApiDecouplerOfUintThenString) ReturnError(rtn_ch chan<- *ReturnOfString, err error) {
	rtn := __.pool.GetReturnOfString()
	var other string
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfUintThenString) HandleOfUintThenString(ctx context.Context, req *WorkOfUintThenString, h func(ctx context.Context, arg uint) (string, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfString()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfUintThenString) DoOfUintThenString(ctx context.Context, worker WorkerOfPushUintThenString, arg uint) (string, error) {
	// ch := make(chan *ReturnOfString, 1)
	ch := __.pool.GetChReturnOfString()
	defer __.pool.PutChReturnOfString(ch)

	req := __.pool.GetWorkOfUintThenString()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfUintThenString(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfString(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfUintThenString = func(ctx context.Context, arg uint) (string, error)

type WorkerOfUintThenString struct {
	api_syncer *ApiDecouplerOfUintThenString
	handler    WorkHandlerOfUintThenString

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfUintThenString
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfUintThenString(ctx context.Context, h WorkHandlerOfUintThenString, n int) *WorkerOfUintThenString {
	__ := &WorkerOfUintThenString{
		api_syncer: NewApiDecouplerOfUintThenString(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfUintThenString, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfUintThenString{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfUintThenString(req.Context, req.WorkOfUintThenString, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfUintThenString) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfUintThenString) Push(ctx context.Context, req *WorkOfUintThenString) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfUintThenString)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfUintThenString = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfUintThenString) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfUintThenString) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfUintThenString) Call(ctx context.Context, arg uint) (string, error) {
	return __.api_syncer.DoOfUintThenString(ctx, __, arg)
}

type PoolOfUintThenUint interface {
	GetUintArg() *uint
	PutUintArg(*uint)
	GetUintReturn() *uint
	PutUintReturn(*uint)

	GetWorkOfUintThenUint() *WorkOfUintThenUint
	GetReturnOfUint() *ReturnOfUint
	PutWorkOfUintThenUint(*WorkOfUintThenUint)
	PutReturnOfUint(*ReturnOfUint)

	GetChReturnOfUint() chan *ReturnOfUint
	PutChReturnOfUint(chan *ReturnOfUint)
}

type PoolOfUintThenUintImpl struct {
	UintArg        sync.Pool
	UintRtn        sync.Pool
	UintWork       sync.Pool
	UintReturn     sync.Pool
	ChReturnOfUint sync.Pool
}

func (__ *PoolOfUintThenUintImpl) GetUintArg() *uint {
	return __.UintArg.Get().(*uint)
}
func (__ *PoolOfUintThenUintImpl) PutUintArg(p *uint) {
	__.UintArg.Put(p)
}
func (__ *PoolOfUintThenUintImpl) GetUintReturn() *uint {
	return __.UintRtn.Get().(*uint)
}
func (__ *PoolOfUintThenUintImpl) PutUintReturn(p *uint) {
	__.UintRtn.Put(p)
}

func (__ *PoolOfUintThenUintImpl) GetWorkOfUintThenUint() *WorkOfUintThenUint {
	return __.UintWork.Get().(*WorkOfUintThenUint)
}
func (__ *PoolOfUintThenUintImpl) PutWorkOfUintThenUint(p *WorkOfUintThenUint) {
	__.UintWork.Put(p)
}
func (__ *PoolOfUintThenUintImpl) GetReturnOfUint() *ReturnOfUint {
	return __.UintReturn.Get().(*ReturnOfUint)
}
func (__ *PoolOfUintThenUintImpl) PutReturnOfUint(p *ReturnOfUint) {
	__.UintReturn.Put(p)
}

func (__ *PoolOfUintThenUintImpl) GetChReturnOfUint() chan *ReturnOfUint {
	return __.ChReturnOfUint.Get().(chan *ReturnOfUint)
}
func (__ *PoolOfUintThenUintImpl) PutChReturnOfUint(p chan *ReturnOfUint) {
	__.ChReturnOfUint.Put(p)
}

func NewPoolOfUintThenUintImpl() *PoolOfUintThenUintImpl {
	return &PoolOfUintThenUintImpl{
		UintArg: sync.Pool{
			New: func() interface{} {
				return new(uint)
			},
		},
		UintWork: sync.Pool{
			New: func() interface{} {
				return new(WorkOfUintThenUint)
			},
		},
		UintRtn: sync.Pool{
			New: func() interface{} {
				return new(uint)
			},
		},
		UintReturn: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfUint)
			},
		},
		ChReturnOfUint: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfUint, 1)
			},
		},
	}
}

type ApiDecouplerOfUintThenUint struct {
	pool PoolOfUintThenUint
}

func NewApiDecouplerOfUintThenUint() *ApiDecouplerOfUintThenUint {
	return &ApiDecouplerOfUintThenUint{
		pool: NewPoolOfUintThenUintImpl(),
	}
}

func (__ *ApiDecouplerOfUintThenUint) ReturnError(rtn_ch chan<- *ReturnOfUint, err error) {
	rtn := __.pool.GetReturnOfUint()
	var other uint
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfUintThenUint) HandleOfUintThenUint(ctx context.Context, req *WorkOfUintThenUint, h func(ctx context.Context, arg uint) (uint, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfUint()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfUintThenUint) DoOfUintThenUint(ctx context.Context, worker WorkerOfPushUintThenUint, arg uint) (uint, error) {
	// ch := make(chan *ReturnOfUint, 1)
	ch := __.pool.GetChReturnOfUint()
	defer __.pool.PutChReturnOfUint(ch)

	req := __.pool.GetWorkOfUintThenUint()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfUintThenUint(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfUint(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfUintThenUint = func(ctx context.Context, arg uint) (uint, error)

type WorkerOfUintThenUint struct {
	api_syncer *ApiDecouplerOfUintThenUint
	handler    WorkHandlerOfUintThenUint

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfUintThenUint
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfUintThenUint(ctx context.Context, h WorkHandlerOfUintThenUint, n int) *WorkerOfUintThenUint {
	__ := &WorkerOfUintThenUint{
		api_syncer: NewApiDecouplerOfUintThenUint(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfUintThenUint, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfUintThenUint{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfUintThenUint(req.Context, req.WorkOfUintThenUint, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfUintThenUint) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfUintThenUint) Push(ctx context.Context, req *WorkOfUintThenUint) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfUintThenUint)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfUintThenUint = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfUintThenUint) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfUintThenUint) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfUintThenUint) Call(ctx context.Context, arg uint) (uint, error) {
	return __.api_syncer.DoOfUintThenUint(ctx, __, arg)
}

type PoolOfUintThenUint16 interface {
	GetUintArg() *uint
	PutUintArg(*uint)
	GetUint16Return() *uint16
	PutUint16Return(*uint16)

	GetWorkOfUintThenUint16() *WorkOfUintThenUint16
	GetReturnOfUint16() *ReturnOfUint16
	PutWorkOfUintThenUint16(*WorkOfUintThenUint16)
	PutReturnOfUint16(*ReturnOfUint16)

	GetChReturnOfUint16() chan *ReturnOfUint16
	PutChReturnOfUint16(chan *ReturnOfUint16)
}

type PoolOfUintThenUint16Impl struct {
	UintArg          sync.Pool
	Uint16Rtn        sync.Pool
	UintWork         sync.Pool
	Uint16Return     sync.Pool
	ChReturnOfUint16 sync.Pool
}

func (__ *PoolOfUintThenUint16Impl) GetUintArg() *uint {
	return __.UintArg.Get().(*uint)
}
func (__ *PoolOfUintThenUint16Impl) PutUintArg(p *uint) {
	__.UintArg.Put(p)
}
func (__ *PoolOfUintThenUint16Impl) GetUint16Return() *uint16 {
	return __.Uint16Rtn.Get().(*uint16)
}
func (__ *PoolOfUintThenUint16Impl) PutUint16Return(p *uint16) {
	__.Uint16Rtn.Put(p)
}

func (__ *PoolOfUintThenUint16Impl) GetWorkOfUintThenUint16() *WorkOfUintThenUint16 {
	return __.UintWork.Get().(*WorkOfUintThenUint16)
}
func (__ *PoolOfUintThenUint16Impl) PutWorkOfUintThenUint16(p *WorkOfUintThenUint16) {
	__.UintWork.Put(p)
}
func (__ *PoolOfUintThenUint16Impl) GetReturnOfUint16() *ReturnOfUint16 {
	return __.Uint16Return.Get().(*ReturnOfUint16)
}
func (__ *PoolOfUintThenUint16Impl) PutReturnOfUint16(p *ReturnOfUint16) {
	__.Uint16Return.Put(p)
}

func (__ *PoolOfUintThenUint16Impl) GetChReturnOfUint16() chan *ReturnOfUint16 {
	return __.ChReturnOfUint16.Get().(chan *ReturnOfUint16)
}
func (__ *PoolOfUintThenUint16Impl) PutChReturnOfUint16(p chan *ReturnOfUint16) {
	__.ChReturnOfUint16.Put(p)
}

func NewPoolOfUintThenUint16Impl() *PoolOfUintThenUint16Impl {
	return &PoolOfUintThenUint16Impl{
		UintArg: sync.Pool{
			New: func() interface{} {
				return new(uint)
			},
		},
		UintWork: sync.Pool{
			New: func() interface{} {
				return new(WorkOfUintThenUint16)
			},
		},
		Uint16Rtn: sync.Pool{
			New: func() interface{} {
				return new(uint16)
			},
		},
		Uint16Return: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfUint16)
			},
		},
		ChReturnOfUint16: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfUint16, 1)
			},
		},
	}
}

type ApiDecouplerOfUintThenUint16 struct {
	pool PoolOfUintThenUint16
}

func NewApiDecouplerOfUintThenUint16() *ApiDecouplerOfUintThenUint16 {
	return &ApiDecouplerOfUintThenUint16{
		pool: NewPoolOfUintThenUint16Impl(),
	}
}

func (__ *ApiDecouplerOfUintThenUint16) ReturnError(rtn_ch chan<- *ReturnOfUint16, err error) {
	rtn := __.pool.GetReturnOfUint16()
	var other uint16
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfUintThenUint16) HandleOfUintThenUint16(ctx context.Context, req *WorkOfUintThenUint16, h func(ctx context.Context, arg uint) (uint16, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfUint16()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfUintThenUint16) DoOfUintThenUint16(ctx context.Context, worker WorkerOfPushUintThenUint16, arg uint) (uint16, error) {
	// ch := make(chan *ReturnOfUint16, 1)
	ch := __.pool.GetChReturnOfUint16()
	defer __.pool.PutChReturnOfUint16(ch)

	req := __.pool.GetWorkOfUintThenUint16()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfUintThenUint16(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfUint16(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfUintThenUint16 = func(ctx context.Context, arg uint) (uint16, error)

type WorkerOfUintThenUint16 struct {
	api_syncer *ApiDecouplerOfUintThenUint16
	handler    WorkHandlerOfUintThenUint16

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfUintThenUint16
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfUintThenUint16(ctx context.Context, h WorkHandlerOfUintThenUint16, n int) *WorkerOfUintThenUint16 {
	__ := &WorkerOfUintThenUint16{
		api_syncer: NewApiDecouplerOfUintThenUint16(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfUintThenUint16, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfUintThenUint16{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfUintThenUint16(req.Context, req.WorkOfUintThenUint16, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfUintThenUint16) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfUintThenUint16) Push(ctx context.Context, req *WorkOfUintThenUint16) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfUintThenUint16)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfUintThenUint16 = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfUintThenUint16) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfUintThenUint16) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfUintThenUint16) Call(ctx context.Context, arg uint) (uint16, error) {
	return __.api_syncer.DoOfUintThenUint16(ctx, __, arg)
}

type PoolOfUintThenUint32 interface {
	GetUintArg() *uint
	PutUintArg(*uint)
	GetUint32Return() *uint32
	PutUint32Return(*uint32)

	GetWorkOfUintThenUint32() *WorkOfUintThenUint32
	GetReturnOfUint32() *ReturnOfUint32
	PutWorkOfUintThenUint32(*WorkOfUintThenUint32)
	PutReturnOfUint32(*ReturnOfUint32)

	GetChReturnOfUint32() chan *ReturnOfUint32
	PutChReturnOfUint32(chan *ReturnOfUint32)
}

type PoolOfUintThenUint32Impl struct {
	UintArg          sync.Pool
	Uint32Rtn        sync.Pool
	UintWork         sync.Pool
	Uint32Return     sync.Pool
	ChReturnOfUint32 sync.Pool
}

func (__ *PoolOfUintThenUint32Impl) GetUintArg() *uint {
	return __.UintArg.Get().(*uint)
}
func (__ *PoolOfUintThenUint32Impl) PutUintArg(p *uint) {
	__.UintArg.Put(p)
}
func (__ *PoolOfUintThenUint32Impl) GetUint32Return() *uint32 {
	return __.Uint32Rtn.Get().(*uint32)
}
func (__ *PoolOfUintThenUint32Impl) PutUint32Return(p *uint32) {
	__.Uint32Rtn.Put(p)
}

func (__ *PoolOfUintThenUint32Impl) GetWorkOfUintThenUint32() *WorkOfUintThenUint32 {
	return __.UintWork.Get().(*WorkOfUintThenUint32)
}
func (__ *PoolOfUintThenUint32Impl) PutWorkOfUintThenUint32(p *WorkOfUintThenUint32) {
	__.UintWork.Put(p)
}
func (__ *PoolOfUintThenUint32Impl) GetReturnOfUint32() *ReturnOfUint32 {
	return __.Uint32Return.Get().(*ReturnOfUint32)
}
func (__ *PoolOfUintThenUint32Impl) PutReturnOfUint32(p *ReturnOfUint32) {
	__.Uint32Return.Put(p)
}

func (__ *PoolOfUintThenUint32Impl) GetChReturnOfUint32() chan *ReturnOfUint32 {
	return __.ChReturnOfUint32.Get().(chan *ReturnOfUint32)
}
func (__ *PoolOfUintThenUint32Impl) PutChReturnOfUint32(p chan *ReturnOfUint32) {
	__.ChReturnOfUint32.Put(p)
}

func NewPoolOfUintThenUint32Impl() *PoolOfUintThenUint32Impl {
	return &PoolOfUintThenUint32Impl{
		UintArg: sync.Pool{
			New: func() interface{} {
				return new(uint)
			},
		},
		UintWork: sync.Pool{
			New: func() interface{} {
				return new(WorkOfUintThenUint32)
			},
		},
		Uint32Rtn: sync.Pool{
			New: func() interface{} {
				return new(uint32)
			},
		},
		Uint32Return: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfUint32)
			},
		},
		ChReturnOfUint32: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfUint32, 1)
			},
		},
	}
}

type ApiDecouplerOfUintThenUint32 struct {
	pool PoolOfUintThenUint32
}

func NewApiDecouplerOfUintThenUint32() *ApiDecouplerOfUintThenUint32 {
	return &ApiDecouplerOfUintThenUint32{
		pool: NewPoolOfUintThenUint32Impl(),
	}
}

func (__ *ApiDecouplerOfUintThenUint32) ReturnError(rtn_ch chan<- *ReturnOfUint32, err error) {
	rtn := __.pool.GetReturnOfUint32()
	var other uint32
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfUintThenUint32) HandleOfUintThenUint32(ctx context.Context, req *WorkOfUintThenUint32, h func(ctx context.Context, arg uint) (uint32, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfUint32()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfUintThenUint32) DoOfUintThenUint32(ctx context.Context, worker WorkerOfPushUintThenUint32, arg uint) (uint32, error) {
	// ch := make(chan *ReturnOfUint32, 1)
	ch := __.pool.GetChReturnOfUint32()
	defer __.pool.PutChReturnOfUint32(ch)

	req := __.pool.GetWorkOfUintThenUint32()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfUintThenUint32(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfUint32(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfUintThenUint32 = func(ctx context.Context, arg uint) (uint32, error)

type WorkerOfUintThenUint32 struct {
	api_syncer *ApiDecouplerOfUintThenUint32
	handler    WorkHandlerOfUintThenUint32

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfUintThenUint32
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfUintThenUint32(ctx context.Context, h WorkHandlerOfUintThenUint32, n int) *WorkerOfUintThenUint32 {
	__ := &WorkerOfUintThenUint32{
		api_syncer: NewApiDecouplerOfUintThenUint32(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfUintThenUint32, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfUintThenUint32{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfUintThenUint32(req.Context, req.WorkOfUintThenUint32, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfUintThenUint32) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfUintThenUint32) Push(ctx context.Context, req *WorkOfUintThenUint32) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfUintThenUint32)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfUintThenUint32 = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfUintThenUint32) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfUintThenUint32) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfUintThenUint32) Call(ctx context.Context, arg uint) (uint32, error) {
	return __.api_syncer.DoOfUintThenUint32(ctx, __, arg)
}

type PoolOfUintThenUint64 interface {
	GetUintArg() *uint
	PutUintArg(*uint)
	GetUint64Return() *uint64
	PutUint64Return(*uint64)

	GetWorkOfUintThenUint64() *WorkOfUintThenUint64
	GetReturnOfUint64() *ReturnOfUint64
	PutWorkOfUintThenUint64(*WorkOfUintThenUint64)
	PutReturnOfUint64(*ReturnOfUint64)

	GetChReturnOfUint64() chan *ReturnOfUint64
	PutChReturnOfUint64(chan *ReturnOfUint64)
}

type PoolOfUintThenUint64Impl struct {
	UintArg          sync.Pool
	Uint64Rtn        sync.Pool
	UintWork         sync.Pool
	Uint64Return     sync.Pool
	ChReturnOfUint64 sync.Pool
}

func (__ *PoolOfUintThenUint64Impl) GetUintArg() *uint {
	return __.UintArg.Get().(*uint)
}
func (__ *PoolOfUintThenUint64Impl) PutUintArg(p *uint) {
	__.UintArg.Put(p)
}
func (__ *PoolOfUintThenUint64Impl) GetUint64Return() *uint64 {
	return __.Uint64Rtn.Get().(*uint64)
}
func (__ *PoolOfUintThenUint64Impl) PutUint64Return(p *uint64) {
	__.Uint64Rtn.Put(p)
}

func (__ *PoolOfUintThenUint64Impl) GetWorkOfUintThenUint64() *WorkOfUintThenUint64 {
	return __.UintWork.Get().(*WorkOfUintThenUint64)
}
func (__ *PoolOfUintThenUint64Impl) PutWorkOfUintThenUint64(p *WorkOfUintThenUint64) {
	__.UintWork.Put(p)
}
func (__ *PoolOfUintThenUint64Impl) GetReturnOfUint64() *ReturnOfUint64 {
	return __.Uint64Return.Get().(*ReturnOfUint64)
}
func (__ *PoolOfUintThenUint64Impl) PutReturnOfUint64(p *ReturnOfUint64) {
	__.Uint64Return.Put(p)
}

func (__ *PoolOfUintThenUint64Impl) GetChReturnOfUint64() chan *ReturnOfUint64 {
	return __.ChReturnOfUint64.Get().(chan *ReturnOfUint64)
}
func (__ *PoolOfUintThenUint64Impl) PutChReturnOfUint64(p chan *ReturnOfUint64) {
	__.ChReturnOfUint64.Put(p)
}

func NewPoolOfUintThenUint64Impl() *PoolOfUintThenUint64Impl {
	return &PoolOfUintThenUint64Impl{
		UintArg: sync.Pool{
			New: func() interface{} {
				return new(uint)
			},
		},
		UintWork: sync.Pool{
			New: func() interface{} {
				return new(WorkOfUintThenUint64)
			},
		},
		Uint64Rtn: sync.Pool{
			New: func() interface{} {
				return new(uint64)
			},
		},
		Uint64Return: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfUint64)
			},
		},
		ChReturnOfUint64: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfUint64, 1)
			},
		},
	}
}

type ApiDecouplerOfUintThenUint64 struct {
	pool PoolOfUintThenUint64
}

func NewApiDecouplerOfUintThenUint64() *ApiDecouplerOfUintThenUint64 {
	return &ApiDecouplerOfUintThenUint64{
		pool: NewPoolOfUintThenUint64Impl(),
	}
}

func (__ *ApiDecouplerOfUintThenUint64) ReturnError(rtn_ch chan<- *ReturnOfUint64, err error) {
	rtn := __.pool.GetReturnOfUint64()
	var other uint64
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfUintThenUint64) HandleOfUintThenUint64(ctx context.Context, req *WorkOfUintThenUint64, h func(ctx context.Context, arg uint) (uint64, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfUint64()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfUintThenUint64) DoOfUintThenUint64(ctx context.Context, worker WorkerOfPushUintThenUint64, arg uint) (uint64, error) {
	// ch := make(chan *ReturnOfUint64, 1)
	ch := __.pool.GetChReturnOfUint64()
	defer __.pool.PutChReturnOfUint64(ch)

	req := __.pool.GetWorkOfUintThenUint64()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfUintThenUint64(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfUint64(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfUintThenUint64 = func(ctx context.Context, arg uint) (uint64, error)

type WorkerOfUintThenUint64 struct {
	api_syncer *ApiDecouplerOfUintThenUint64
	handler    WorkHandlerOfUintThenUint64

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfUintThenUint64
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfUintThenUint64(ctx context.Context, h WorkHandlerOfUintThenUint64, n int) *WorkerOfUintThenUint64 {
	__ := &WorkerOfUintThenUint64{
		api_syncer: NewApiDecouplerOfUintThenUint64(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfUintThenUint64, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfUintThenUint64{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfUintThenUint64(req.Context, req.WorkOfUintThenUint64, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfUintThenUint64) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfUintThenUint64) Push(ctx context.Context, req *WorkOfUintThenUint64) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfUintThenUint64)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfUintThenUint64 = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfUintThenUint64) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfUintThenUint64) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfUintThenUint64) Call(ctx context.Context, arg uint) (uint64, error) {
	return __.api_syncer.DoOfUintThenUint64(ctx, __, arg)
}

type PoolOfUintThenUint8 interface {
	GetUintArg() *uint
	PutUintArg(*uint)
	GetUint8Return() *uint8
	PutUint8Return(*uint8)

	GetWorkOfUintThenUint8() *WorkOfUintThenUint8
	GetReturnOfUint8() *ReturnOfUint8
	PutWorkOfUintThenUint8(*WorkOfUintThenUint8)
	PutReturnOfUint8(*ReturnOfUint8)

	GetChReturnOfUint8() chan *ReturnOfUint8
	PutChReturnOfUint8(chan *ReturnOfUint8)
}

type PoolOfUintThenUint8Impl struct {
	UintArg         sync.Pool
	Uint8Rtn        sync.Pool
	UintWork        sync.Pool
	Uint8Return     sync.Pool
	ChReturnOfUint8 sync.Pool
}

func (__ *PoolOfUintThenUint8Impl) GetUintArg() *uint {
	return __.UintArg.Get().(*uint)
}
func (__ *PoolOfUintThenUint8Impl) PutUintArg(p *uint) {
	__.UintArg.Put(p)
}
func (__ *PoolOfUintThenUint8Impl) GetUint8Return() *uint8 {
	return __.Uint8Rtn.Get().(*uint8)
}
func (__ *PoolOfUintThenUint8Impl) PutUint8Return(p *uint8) {
	__.Uint8Rtn.Put(p)
}

func (__ *PoolOfUintThenUint8Impl) GetWorkOfUintThenUint8() *WorkOfUintThenUint8 {
	return __.UintWork.Get().(*WorkOfUintThenUint8)
}
func (__ *PoolOfUintThenUint8Impl) PutWorkOfUintThenUint8(p *WorkOfUintThenUint8) {
	__.UintWork.Put(p)
}
func (__ *PoolOfUintThenUint8Impl) GetReturnOfUint8() *ReturnOfUint8 {
	return __.Uint8Return.Get().(*ReturnOfUint8)
}
func (__ *PoolOfUintThenUint8Impl) PutReturnOfUint8(p *ReturnOfUint8) {
	__.Uint8Return.Put(p)
}

func (__ *PoolOfUintThenUint8Impl) GetChReturnOfUint8() chan *ReturnOfUint8 {
	return __.ChReturnOfUint8.Get().(chan *ReturnOfUint8)
}
func (__ *PoolOfUintThenUint8Impl) PutChReturnOfUint8(p chan *ReturnOfUint8) {
	__.ChReturnOfUint8.Put(p)
}

func NewPoolOfUintThenUint8Impl() *PoolOfUintThenUint8Impl {
	return &PoolOfUintThenUint8Impl{
		UintArg: sync.Pool{
			New: func() interface{} {
				return new(uint)
			},
		},
		UintWork: sync.Pool{
			New: func() interface{} {
				return new(WorkOfUintThenUint8)
			},
		},
		Uint8Rtn: sync.Pool{
			New: func() interface{} {
				return new(uint8)
			},
		},
		Uint8Return: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfUint8)
			},
		},
		ChReturnOfUint8: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfUint8, 1)
			},
		},
	}
}

type ApiDecouplerOfUintThenUint8 struct {
	pool PoolOfUintThenUint8
}

func NewApiDecouplerOfUintThenUint8() *ApiDecouplerOfUintThenUint8 {
	return &ApiDecouplerOfUintThenUint8{
		pool: NewPoolOfUintThenUint8Impl(),
	}
}

func (__ *ApiDecouplerOfUintThenUint8) ReturnError(rtn_ch chan<- *ReturnOfUint8, err error) {
	rtn := __.pool.GetReturnOfUint8()
	var other uint8
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfUintThenUint8) HandleOfUintThenUint8(ctx context.Context, req *WorkOfUintThenUint8, h func(ctx context.Context, arg uint) (uint8, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfUint8()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfUintThenUint8) DoOfUintThenUint8(ctx context.Context, worker WorkerOfPushUintThenUint8, arg uint) (uint8, error) {
	// ch := make(chan *ReturnOfUint8, 1)
	ch := __.pool.GetChReturnOfUint8()
	defer __.pool.PutChReturnOfUint8(ch)

	req := __.pool.GetWorkOfUintThenUint8()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfUintThenUint8(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfUint8(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfUintThenUint8 = func(ctx context.Context, arg uint) (uint8, error)

type WorkerOfUintThenUint8 struct {
	api_syncer *ApiDecouplerOfUintThenUint8
	handler    WorkHandlerOfUintThenUint8

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfUintThenUint8
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfUintThenUint8(ctx context.Context, h WorkHandlerOfUintThenUint8, n int) *WorkerOfUintThenUint8 {
	__ := &WorkerOfUintThenUint8{
		api_syncer: NewApiDecouplerOfUintThenUint8(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfUintThenUint8, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfUintThenUint8{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfUintThenUint8(req.Context, req.WorkOfUintThenUint8, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfUintThenUint8) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfUintThenUint8) Push(ctx context.Context, req *WorkOfUintThenUint8) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfUintThenUint8)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfUintThenUint8 = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfUintThenUint8) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfUintThenUint8) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfUintThenUint8) Call(ctx context.Context, arg uint) (uint8, error) {
	return __.api_syncer.DoOfUintThenUint8(ctx, __, arg)
}

type PoolOfUintThenUintptr interface {
	GetUintArg() *uint
	PutUintArg(*uint)
	GetUintptrReturn() *uintptr
	PutUintptrReturn(*uintptr)

	GetWorkOfUintThenUintptr() *WorkOfUintThenUintptr
	GetReturnOfUintptr() *ReturnOfUintptr
	PutWorkOfUintThenUintptr(*WorkOfUintThenUintptr)
	PutReturnOfUintptr(*ReturnOfUintptr)

	GetChReturnOfUintptr() chan *ReturnOfUintptr
	PutChReturnOfUintptr(chan *ReturnOfUintptr)
}

type PoolOfUintThenUintptrImpl struct {
	UintArg           sync.Pool
	UintptrRtn        sync.Pool
	UintWork          sync.Pool
	UintptrReturn     sync.Pool
	ChReturnOfUintptr sync.Pool
}

func (__ *PoolOfUintThenUintptrImpl) GetUintArg() *uint {
	return __.UintArg.Get().(*uint)
}
func (__ *PoolOfUintThenUintptrImpl) PutUintArg(p *uint) {
	__.UintArg.Put(p)
}
func (__ *PoolOfUintThenUintptrImpl) GetUintptrReturn() *uintptr {
	return __.UintptrRtn.Get().(*uintptr)
}
func (__ *PoolOfUintThenUintptrImpl) PutUintptrReturn(p *uintptr) {
	__.UintptrRtn.Put(p)
}

func (__ *PoolOfUintThenUintptrImpl) GetWorkOfUintThenUintptr() *WorkOfUintThenUintptr {
	return __.UintWork.Get().(*WorkOfUintThenUintptr)
}
func (__ *PoolOfUintThenUintptrImpl) PutWorkOfUintThenUintptr(p *WorkOfUintThenUintptr) {
	__.UintWork.Put(p)
}
func (__ *PoolOfUintThenUintptrImpl) GetReturnOfUintptr() *ReturnOfUintptr {
	return __.UintptrReturn.Get().(*ReturnOfUintptr)
}
func (__ *PoolOfUintThenUintptrImpl) PutReturnOfUintptr(p *ReturnOfUintptr) {
	__.UintptrReturn.Put(p)
}

func (__ *PoolOfUintThenUintptrImpl) GetChReturnOfUintptr() chan *ReturnOfUintptr {
	return __.ChReturnOfUintptr.Get().(chan *ReturnOfUintptr)
}
func (__ *PoolOfUintThenUintptrImpl) PutChReturnOfUintptr(p chan *ReturnOfUintptr) {
	__.ChReturnOfUintptr.Put(p)
}

func NewPoolOfUintThenUintptrImpl() *PoolOfUintThenUintptrImpl {
	return &PoolOfUintThenUintptrImpl{
		UintArg: sync.Pool{
			New: func() interface{} {
				return new(uint)
			},
		},
		UintWork: sync.Pool{
			New: func() interface{} {
				return new(WorkOfUintThenUintptr)
			},
		},
		UintptrRtn: sync.Pool{
			New: func() interface{} {
				return new(uintptr)
			},
		},
		UintptrReturn: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfUintptr)
			},
		},
		ChReturnOfUintptr: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfUintptr, 1)
			},
		},
	}
}

type ApiDecouplerOfUintThenUintptr struct {
	pool PoolOfUintThenUintptr
}

func NewApiDecouplerOfUintThenUintptr() *ApiDecouplerOfUintThenUintptr {
	return &ApiDecouplerOfUintThenUintptr{
		pool: NewPoolOfUintThenUintptrImpl(),
	}
}

func (__ *ApiDecouplerOfUintThenUintptr) ReturnError(rtn_ch chan<- *ReturnOfUintptr, err error) {
	rtn := __.pool.GetReturnOfUintptr()
	var other uintptr
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfUintThenUintptr) HandleOfUintThenUintptr(ctx context.Context, req *WorkOfUintThenUintptr, h func(ctx context.Context, arg uint) (uintptr, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfUintptr()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfUintThenUintptr) DoOfUintThenUintptr(ctx context.Context, worker WorkerOfPushUintThenUintptr, arg uint) (uintptr, error) {
	// ch := make(chan *ReturnOfUintptr, 1)
	ch := __.pool.GetChReturnOfUintptr()
	defer __.pool.PutChReturnOfUintptr(ch)

	req := __.pool.GetWorkOfUintThenUintptr()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfUintThenUintptr(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfUintptr(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfUintThenUintptr = func(ctx context.Context, arg uint) (uintptr, error)

type WorkerOfUintThenUintptr struct {
	api_syncer *ApiDecouplerOfUintThenUintptr
	handler    WorkHandlerOfUintThenUintptr

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfUintThenUintptr
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfUintThenUintptr(ctx context.Context, h WorkHandlerOfUintThenUintptr, n int) *WorkerOfUintThenUintptr {
	__ := &WorkerOfUintThenUintptr{
		api_syncer: NewApiDecouplerOfUintThenUintptr(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfUintThenUintptr, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfUintThenUintptr{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfUintThenUintptr(req.Context, req.WorkOfUintThenUintptr, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfUintThenUintptr) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfUintThenUintptr) Push(ctx context.Context, req *WorkOfUintThenUintptr) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfUintThenUintptr)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfUintThenUintptr = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfUintThenUintptr) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfUintThenUintptr) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfUintThenUintptr) Call(ctx context.Context, arg uint) (uintptr, error) {
	return __.api_syncer.DoOfUintThenUintptr(ctx, __, arg)
}

type PoolOfUintThenInterface interface {
	GetUintArg() *uint
	PutUintArg(*uint)
	GetInterfaceReturn() *interface{}
	PutInterfaceReturn(*interface{})

	GetWorkOfUintThenInterface() *WorkOfUintThenInterface
	GetReturnOfInterface() *ReturnOfInterface
	PutWorkOfUintThenInterface(*WorkOfUintThenInterface)
	PutReturnOfInterface(*ReturnOfInterface)

	GetChReturnOfInterface() chan *ReturnOfInterface
	PutChReturnOfInterface(chan *ReturnOfInterface)
}

type PoolOfUintThenInterfaceImpl struct {
	UintArg             sync.Pool
	InterfaceRtn        sync.Pool
	UintWork            sync.Pool
	InterfaceReturn     sync.Pool
	ChReturnOfInterface sync.Pool
}

func (__ *PoolOfUintThenInterfaceImpl) GetUintArg() *uint {
	return __.UintArg.Get().(*uint)
}
func (__ *PoolOfUintThenInterfaceImpl) PutUintArg(p *uint) {
	__.UintArg.Put(p)
}
func (__ *PoolOfUintThenInterfaceImpl) GetInterfaceReturn() *interface{} {
	return __.InterfaceRtn.Get().(*interface{})
}
func (__ *PoolOfUintThenInterfaceImpl) PutInterfaceReturn(p *interface{}) {
	__.InterfaceRtn.Put(p)
}

func (__ *PoolOfUintThenInterfaceImpl) GetWorkOfUintThenInterface() *WorkOfUintThenInterface {
	return __.UintWork.Get().(*WorkOfUintThenInterface)
}
func (__ *PoolOfUintThenInterfaceImpl) PutWorkOfUintThenInterface(p *WorkOfUintThenInterface) {
	__.UintWork.Put(p)
}
func (__ *PoolOfUintThenInterfaceImpl) GetReturnOfInterface() *ReturnOfInterface {
	return __.InterfaceReturn.Get().(*ReturnOfInterface)
}
func (__ *PoolOfUintThenInterfaceImpl) PutReturnOfInterface(p *ReturnOfInterface) {
	__.InterfaceReturn.Put(p)
}

func (__ *PoolOfUintThenInterfaceImpl) GetChReturnOfInterface() chan *ReturnOfInterface {
	return __.ChReturnOfInterface.Get().(chan *ReturnOfInterface)
}
func (__ *PoolOfUintThenInterfaceImpl) PutChReturnOfInterface(p chan *ReturnOfInterface) {
	__.ChReturnOfInterface.Put(p)
}

func NewPoolOfUintThenInterfaceImpl() *PoolOfUintThenInterfaceImpl {
	return &PoolOfUintThenInterfaceImpl{
		UintArg: sync.Pool{
			New: func() interface{} {
				return new(uint)
			},
		},
		UintWork: sync.Pool{
			New: func() interface{} {
				return new(WorkOfUintThenInterface)
			},
		},
		InterfaceRtn: sync.Pool{
			New: func() interface{} {
				return new(interface{})
			},
		},
		InterfaceReturn: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfInterface)
			},
		},
		ChReturnOfInterface: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfInterface, 1)
			},
		},
	}
}

type ApiDecouplerOfUintThenInterface struct {
	pool PoolOfUintThenInterface
}

func NewApiDecouplerOfUintThenInterface() *ApiDecouplerOfUintThenInterface {
	return &ApiDecouplerOfUintThenInterface{
		pool: NewPoolOfUintThenInterfaceImpl(),
	}
}

func (__ *ApiDecouplerOfUintThenInterface) ReturnError(rtn_ch chan<- *ReturnOfInterface, err error) {
	rtn := __.pool.GetReturnOfInterface()
	var other interface{}
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfUintThenInterface) HandleOfUintThenInterface(ctx context.Context, req *WorkOfUintThenInterface, h func(ctx context.Context, arg uint) (interface{}, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfInterface()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfUintThenInterface) DoOfUintThenInterface(ctx context.Context, worker WorkerOfPushUintThenInterface, arg uint) (interface{}, error) {
	// ch := make(chan *ReturnOfInterface, 1)
	ch := __.pool.GetChReturnOfInterface()
	defer __.pool.PutChReturnOfInterface(ch)

	req := __.pool.GetWorkOfUintThenInterface()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfUintThenInterface(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfInterface(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfUintThenInterface = func(ctx context.Context, arg uint) (interface{}, error)

type WorkerOfUintThenInterface struct {
	api_syncer *ApiDecouplerOfUintThenInterface
	handler    WorkHandlerOfUintThenInterface

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfUintThenInterface
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfUintThenInterface(ctx context.Context, h WorkHandlerOfUintThenInterface, n int) *WorkerOfUintThenInterface {
	__ := &WorkerOfUintThenInterface{
		api_syncer: NewApiDecouplerOfUintThenInterface(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfUintThenInterface, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfUintThenInterface{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfUintThenInterface(req.Context, req.WorkOfUintThenInterface, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfUintThenInterface) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfUintThenInterface) Push(ctx context.Context, req *WorkOfUintThenInterface) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfUintThenInterface)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfUintThenInterface = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfUintThenInterface) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfUintThenInterface) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfUintThenInterface) Call(ctx context.Context, arg uint) (interface{}, error) {
	return __.api_syncer.DoOfUintThenInterface(ctx, __, arg)
}

type PoolOfUintThenStruct interface {
	GetUintArg() *uint
	PutUintArg(*uint)
	GetStructReturn() *struct{}
	PutStructReturn(*struct{})

	GetWorkOfUintThenStruct() *WorkOfUintThenStruct
	GetReturnOfStruct() *ReturnOfStruct
	PutWorkOfUintThenStruct(*WorkOfUintThenStruct)
	PutReturnOfStruct(*ReturnOfStruct)

	GetChReturnOfStruct() chan *ReturnOfStruct
	PutChReturnOfStruct(chan *ReturnOfStruct)
}

type PoolOfUintThenStructImpl struct {
	UintArg          sync.Pool
	StructRtn        sync.Pool
	UintWork         sync.Pool
	StructReturn     sync.Pool
	ChReturnOfStruct sync.Pool
}

func (__ *PoolOfUintThenStructImpl) GetUintArg() *uint {
	return __.UintArg.Get().(*uint)
}
func (__ *PoolOfUintThenStructImpl) PutUintArg(p *uint) {
	__.UintArg.Put(p)
}
func (__ *PoolOfUintThenStructImpl) GetStructReturn() *struct{} {
	return __.StructRtn.Get().(*struct{})
}
func (__ *PoolOfUintThenStructImpl) PutStructReturn(p *struct{}) {
	__.StructRtn.Put(p)
}

func (__ *PoolOfUintThenStructImpl) GetWorkOfUintThenStruct() *WorkOfUintThenStruct {
	return __.UintWork.Get().(*WorkOfUintThenStruct)
}
func (__ *PoolOfUintThenStructImpl) PutWorkOfUintThenStruct(p *WorkOfUintThenStruct) {
	__.UintWork.Put(p)
}
func (__ *PoolOfUintThenStructImpl) GetReturnOfStruct() *ReturnOfStruct {
	return __.StructReturn.Get().(*ReturnOfStruct)
}
func (__ *PoolOfUintThenStructImpl) PutReturnOfStruct(p *ReturnOfStruct) {
	__.StructReturn.Put(p)
}

func (__ *PoolOfUintThenStructImpl) GetChReturnOfStruct() chan *ReturnOfStruct {
	return __.ChReturnOfStruct.Get().(chan *ReturnOfStruct)
}
func (__ *PoolOfUintThenStructImpl) PutChReturnOfStruct(p chan *ReturnOfStruct) {
	__.ChReturnOfStruct.Put(p)
}

func NewPoolOfUintThenStructImpl() *PoolOfUintThenStructImpl {
	return &PoolOfUintThenStructImpl{
		UintArg: sync.Pool{
			New: func() interface{} {
				return new(uint)
			},
		},
		UintWork: sync.Pool{
			New: func() interface{} {
				return new(WorkOfUintThenStruct)
			},
		},
		StructRtn: sync.Pool{
			New: func() interface{} {
				return new(struct{})
			},
		},
		StructReturn: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfStruct)
			},
		},
		ChReturnOfStruct: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfStruct, 1)
			},
		},
	}
}

type ApiDecouplerOfUintThenStruct struct {
	pool PoolOfUintThenStruct
}

func NewApiDecouplerOfUintThenStruct() *ApiDecouplerOfUintThenStruct {
	return &ApiDecouplerOfUintThenStruct{
		pool: NewPoolOfUintThenStructImpl(),
	}
}

func (__ *ApiDecouplerOfUintThenStruct) ReturnError(rtn_ch chan<- *ReturnOfStruct, err error) {
	rtn := __.pool.GetReturnOfStruct()
	var other struct{}
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfUintThenStruct) HandleOfUintThenStruct(ctx context.Context, req *WorkOfUintThenStruct, h func(ctx context.Context, arg uint) (struct{}, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfStruct()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfUintThenStruct) DoOfUintThenStruct(ctx context.Context, worker WorkerOfPushUintThenStruct, arg uint) (struct{}, error) {
	// ch := make(chan *ReturnOfStruct, 1)
	ch := __.pool.GetChReturnOfStruct()
	defer __.pool.PutChReturnOfStruct(ch)

	req := __.pool.GetWorkOfUintThenStruct()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfUintThenStruct(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfStruct(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfUintThenStruct = func(ctx context.Context, arg uint) (struct{}, error)

type WorkerOfUintThenStruct struct {
	api_syncer *ApiDecouplerOfUintThenStruct
	handler    WorkHandlerOfUintThenStruct

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfUintThenStruct
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfUintThenStruct(ctx context.Context, h WorkHandlerOfUintThenStruct, n int) *WorkerOfUintThenStruct {
	__ := &WorkerOfUintThenStruct{
		api_syncer: NewApiDecouplerOfUintThenStruct(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfUintThenStruct, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfUintThenStruct{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfUintThenStruct(req.Context, req.WorkOfUintThenStruct, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfUintThenStruct) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfUintThenStruct) Push(ctx context.Context, req *WorkOfUintThenStruct) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfUintThenStruct)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfUintThenStruct = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfUintThenStruct) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfUintThenStruct) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfUintThenStruct) Call(ctx context.Context, arg uint) (struct{}, error) {
	return __.api_syncer.DoOfUintThenStruct(ctx, __, arg)
}

type PoolOfUint16ThenBool interface {
	GetUint16Arg() *uint16
	PutUint16Arg(*uint16)
	GetBoolReturn() *bool
	PutBoolReturn(*bool)

	GetWorkOfUint16ThenBool() *WorkOfUint16ThenBool
	GetReturnOfBool() *ReturnOfBool
	PutWorkOfUint16ThenBool(*WorkOfUint16ThenBool)
	PutReturnOfBool(*ReturnOfBool)

	GetChReturnOfBool() chan *ReturnOfBool
	PutChReturnOfBool(chan *ReturnOfBool)
}

type PoolOfUint16ThenBoolImpl struct {
	Uint16Arg      sync.Pool
	BoolRtn        sync.Pool
	Uint16Work     sync.Pool
	BoolReturn     sync.Pool
	ChReturnOfBool sync.Pool
}

func (__ *PoolOfUint16ThenBoolImpl) GetUint16Arg() *uint16 {
	return __.Uint16Arg.Get().(*uint16)
}
func (__ *PoolOfUint16ThenBoolImpl) PutUint16Arg(p *uint16) {
	__.Uint16Arg.Put(p)
}
func (__ *PoolOfUint16ThenBoolImpl) GetBoolReturn() *bool {
	return __.BoolRtn.Get().(*bool)
}
func (__ *PoolOfUint16ThenBoolImpl) PutBoolReturn(p *bool) {
	__.BoolRtn.Put(p)
}

func (__ *PoolOfUint16ThenBoolImpl) GetWorkOfUint16ThenBool() *WorkOfUint16ThenBool {
	return __.Uint16Work.Get().(*WorkOfUint16ThenBool)
}
func (__ *PoolOfUint16ThenBoolImpl) PutWorkOfUint16ThenBool(p *WorkOfUint16ThenBool) {
	__.Uint16Work.Put(p)
}
func (__ *PoolOfUint16ThenBoolImpl) GetReturnOfBool() *ReturnOfBool {
	return __.BoolReturn.Get().(*ReturnOfBool)
}
func (__ *PoolOfUint16ThenBoolImpl) PutReturnOfBool(p *ReturnOfBool) {
	__.BoolReturn.Put(p)
}

func (__ *PoolOfUint16ThenBoolImpl) GetChReturnOfBool() chan *ReturnOfBool {
	return __.ChReturnOfBool.Get().(chan *ReturnOfBool)
}
func (__ *PoolOfUint16ThenBoolImpl) PutChReturnOfBool(p chan *ReturnOfBool) {
	__.ChReturnOfBool.Put(p)
}

func NewPoolOfUint16ThenBoolImpl() *PoolOfUint16ThenBoolImpl {
	return &PoolOfUint16ThenBoolImpl{
		Uint16Arg: sync.Pool{
			New: func() interface{} {
				return new(uint16)
			},
		},
		Uint16Work: sync.Pool{
			New: func() interface{} {
				return new(WorkOfUint16ThenBool)
			},
		},
		BoolRtn: sync.Pool{
			New: func() interface{} {
				return new(bool)
			},
		},
		BoolReturn: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfBool)
			},
		},
		ChReturnOfBool: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfBool, 1)
			},
		},
	}
}

type ApiDecouplerOfUint16ThenBool struct {
	pool PoolOfUint16ThenBool
}

func NewApiDecouplerOfUint16ThenBool() *ApiDecouplerOfUint16ThenBool {
	return &ApiDecouplerOfUint16ThenBool{
		pool: NewPoolOfUint16ThenBoolImpl(),
	}
}

func (__ *ApiDecouplerOfUint16ThenBool) ReturnError(rtn_ch chan<- *ReturnOfBool, err error) {
	rtn := __.pool.GetReturnOfBool()
	var other bool
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfUint16ThenBool) HandleOfUint16ThenBool(ctx context.Context, req *WorkOfUint16ThenBool, h func(ctx context.Context, arg uint16) (bool, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfBool()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfUint16ThenBool) DoOfUint16ThenBool(ctx context.Context, worker WorkerOfPushUint16ThenBool, arg uint16) (bool, error) {
	// ch := make(chan *ReturnOfBool, 1)
	ch := __.pool.GetChReturnOfBool()
	defer __.pool.PutChReturnOfBool(ch)

	req := __.pool.GetWorkOfUint16ThenBool()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfUint16ThenBool(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfBool(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfUint16ThenBool = func(ctx context.Context, arg uint16) (bool, error)

type WorkerOfUint16ThenBool struct {
	api_syncer *ApiDecouplerOfUint16ThenBool
	handler    WorkHandlerOfUint16ThenBool

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfUint16ThenBool
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfUint16ThenBool(ctx context.Context, h WorkHandlerOfUint16ThenBool, n int) *WorkerOfUint16ThenBool {
	__ := &WorkerOfUint16ThenBool{
		api_syncer: NewApiDecouplerOfUint16ThenBool(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfUint16ThenBool, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfUint16ThenBool{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfUint16ThenBool(req.Context, req.WorkOfUint16ThenBool, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfUint16ThenBool) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfUint16ThenBool) Push(ctx context.Context, req *WorkOfUint16ThenBool) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfUint16ThenBool)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfUint16ThenBool = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfUint16ThenBool) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfUint16ThenBool) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfUint16ThenBool) Call(ctx context.Context, arg uint16) (bool, error) {
	return __.api_syncer.DoOfUint16ThenBool(ctx, __, arg)
}

type PoolOfUint16ThenByte interface {
	GetUint16Arg() *uint16
	PutUint16Arg(*uint16)
	GetByteReturn() *byte
	PutByteReturn(*byte)

	GetWorkOfUint16ThenByte() *WorkOfUint16ThenByte
	GetReturnOfByte() *ReturnOfByte
	PutWorkOfUint16ThenByte(*WorkOfUint16ThenByte)
	PutReturnOfByte(*ReturnOfByte)

	GetChReturnOfByte() chan *ReturnOfByte
	PutChReturnOfByte(chan *ReturnOfByte)
}

type PoolOfUint16ThenByteImpl struct {
	Uint16Arg      sync.Pool
	ByteRtn        sync.Pool
	Uint16Work     sync.Pool
	ByteReturn     sync.Pool
	ChReturnOfByte sync.Pool
}

func (__ *PoolOfUint16ThenByteImpl) GetUint16Arg() *uint16 {
	return __.Uint16Arg.Get().(*uint16)
}
func (__ *PoolOfUint16ThenByteImpl) PutUint16Arg(p *uint16) {
	__.Uint16Arg.Put(p)
}
func (__ *PoolOfUint16ThenByteImpl) GetByteReturn() *byte {
	return __.ByteRtn.Get().(*byte)
}
func (__ *PoolOfUint16ThenByteImpl) PutByteReturn(p *byte) {
	__.ByteRtn.Put(p)
}

func (__ *PoolOfUint16ThenByteImpl) GetWorkOfUint16ThenByte() *WorkOfUint16ThenByte {
	return __.Uint16Work.Get().(*WorkOfUint16ThenByte)
}
func (__ *PoolOfUint16ThenByteImpl) PutWorkOfUint16ThenByte(p *WorkOfUint16ThenByte) {
	__.Uint16Work.Put(p)
}
func (__ *PoolOfUint16ThenByteImpl) GetReturnOfByte() *ReturnOfByte {
	return __.ByteReturn.Get().(*ReturnOfByte)
}
func (__ *PoolOfUint16ThenByteImpl) PutReturnOfByte(p *ReturnOfByte) {
	__.ByteReturn.Put(p)
}

func (__ *PoolOfUint16ThenByteImpl) GetChReturnOfByte() chan *ReturnOfByte {
	return __.ChReturnOfByte.Get().(chan *ReturnOfByte)
}
func (__ *PoolOfUint16ThenByteImpl) PutChReturnOfByte(p chan *ReturnOfByte) {
	__.ChReturnOfByte.Put(p)
}

func NewPoolOfUint16ThenByteImpl() *PoolOfUint16ThenByteImpl {
	return &PoolOfUint16ThenByteImpl{
		Uint16Arg: sync.Pool{
			New: func() interface{} {
				return new(uint16)
			},
		},
		Uint16Work: sync.Pool{
			New: func() interface{} {
				return new(WorkOfUint16ThenByte)
			},
		},
		ByteRtn: sync.Pool{
			New: func() interface{} {
				return new(byte)
			},
		},
		ByteReturn: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfByte)
			},
		},
		ChReturnOfByte: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfByte, 1)
			},
		},
	}
}

type ApiDecouplerOfUint16ThenByte struct {
	pool PoolOfUint16ThenByte
}

func NewApiDecouplerOfUint16ThenByte() *ApiDecouplerOfUint16ThenByte {
	return &ApiDecouplerOfUint16ThenByte{
		pool: NewPoolOfUint16ThenByteImpl(),
	}
}

func (__ *ApiDecouplerOfUint16ThenByte) ReturnError(rtn_ch chan<- *ReturnOfByte, err error) {
	rtn := __.pool.GetReturnOfByte()
	var other byte
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfUint16ThenByte) HandleOfUint16ThenByte(ctx context.Context, req *WorkOfUint16ThenByte, h func(ctx context.Context, arg uint16) (byte, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfByte()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfUint16ThenByte) DoOfUint16ThenByte(ctx context.Context, worker WorkerOfPushUint16ThenByte, arg uint16) (byte, error) {
	// ch := make(chan *ReturnOfByte, 1)
	ch := __.pool.GetChReturnOfByte()
	defer __.pool.PutChReturnOfByte(ch)

	req := __.pool.GetWorkOfUint16ThenByte()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfUint16ThenByte(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfByte(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfUint16ThenByte = func(ctx context.Context, arg uint16) (byte, error)

type WorkerOfUint16ThenByte struct {
	api_syncer *ApiDecouplerOfUint16ThenByte
	handler    WorkHandlerOfUint16ThenByte

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfUint16ThenByte
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfUint16ThenByte(ctx context.Context, h WorkHandlerOfUint16ThenByte, n int) *WorkerOfUint16ThenByte {
	__ := &WorkerOfUint16ThenByte{
		api_syncer: NewApiDecouplerOfUint16ThenByte(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfUint16ThenByte, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfUint16ThenByte{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfUint16ThenByte(req.Context, req.WorkOfUint16ThenByte, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfUint16ThenByte) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfUint16ThenByte) Push(ctx context.Context, req *WorkOfUint16ThenByte) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfUint16ThenByte)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfUint16ThenByte = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfUint16ThenByte) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfUint16ThenByte) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfUint16ThenByte) Call(ctx context.Context, arg uint16) (byte, error) {
	return __.api_syncer.DoOfUint16ThenByte(ctx, __, arg)
}

type PoolOfUint16ThenComplex128 interface {
	GetUint16Arg() *uint16
	PutUint16Arg(*uint16)
	GetComplex128Return() *complex128
	PutComplex128Return(*complex128)

	GetWorkOfUint16ThenComplex128() *WorkOfUint16ThenComplex128
	GetReturnOfComplex128() *ReturnOfComplex128
	PutWorkOfUint16ThenComplex128(*WorkOfUint16ThenComplex128)
	PutReturnOfComplex128(*ReturnOfComplex128)

	GetChReturnOfComplex128() chan *ReturnOfComplex128
	PutChReturnOfComplex128(chan *ReturnOfComplex128)
}

type PoolOfUint16ThenComplex128Impl struct {
	Uint16Arg            sync.Pool
	Complex128Rtn        sync.Pool
	Uint16Work           sync.Pool
	Complex128Return     sync.Pool
	ChReturnOfComplex128 sync.Pool
}

func (__ *PoolOfUint16ThenComplex128Impl) GetUint16Arg() *uint16 {
	return __.Uint16Arg.Get().(*uint16)
}
func (__ *PoolOfUint16ThenComplex128Impl) PutUint16Arg(p *uint16) {
	__.Uint16Arg.Put(p)
}
func (__ *PoolOfUint16ThenComplex128Impl) GetComplex128Return() *complex128 {
	return __.Complex128Rtn.Get().(*complex128)
}
func (__ *PoolOfUint16ThenComplex128Impl) PutComplex128Return(p *complex128) {
	__.Complex128Rtn.Put(p)
}

func (__ *PoolOfUint16ThenComplex128Impl) GetWorkOfUint16ThenComplex128() *WorkOfUint16ThenComplex128 {
	return __.Uint16Work.Get().(*WorkOfUint16ThenComplex128)
}
func (__ *PoolOfUint16ThenComplex128Impl) PutWorkOfUint16ThenComplex128(p *WorkOfUint16ThenComplex128) {
	__.Uint16Work.Put(p)
}
func (__ *PoolOfUint16ThenComplex128Impl) GetReturnOfComplex128() *ReturnOfComplex128 {
	return __.Complex128Return.Get().(*ReturnOfComplex128)
}
func (__ *PoolOfUint16ThenComplex128Impl) PutReturnOfComplex128(p *ReturnOfComplex128) {
	__.Complex128Return.Put(p)
}

func (__ *PoolOfUint16ThenComplex128Impl) GetChReturnOfComplex128() chan *ReturnOfComplex128 {
	return __.ChReturnOfComplex128.Get().(chan *ReturnOfComplex128)
}
func (__ *PoolOfUint16ThenComplex128Impl) PutChReturnOfComplex128(p chan *ReturnOfComplex128) {
	__.ChReturnOfComplex128.Put(p)
}

func NewPoolOfUint16ThenComplex128Impl() *PoolOfUint16ThenComplex128Impl {
	return &PoolOfUint16ThenComplex128Impl{
		Uint16Arg: sync.Pool{
			New: func() interface{} {
				return new(uint16)
			},
		},
		Uint16Work: sync.Pool{
			New: func() interface{} {
				return new(WorkOfUint16ThenComplex128)
			},
		},
		Complex128Rtn: sync.Pool{
			New: func() interface{} {
				return new(complex128)
			},
		},
		Complex128Return: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfComplex128)
			},
		},
		ChReturnOfComplex128: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfComplex128, 1)
			},
		},
	}
}

type ApiDecouplerOfUint16ThenComplex128 struct {
	pool PoolOfUint16ThenComplex128
}

func NewApiDecouplerOfUint16ThenComplex128() *ApiDecouplerOfUint16ThenComplex128 {
	return &ApiDecouplerOfUint16ThenComplex128{
		pool: NewPoolOfUint16ThenComplex128Impl(),
	}
}

func (__ *ApiDecouplerOfUint16ThenComplex128) ReturnError(rtn_ch chan<- *ReturnOfComplex128, err error) {
	rtn := __.pool.GetReturnOfComplex128()
	var other complex128
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfUint16ThenComplex128) HandleOfUint16ThenComplex128(ctx context.Context, req *WorkOfUint16ThenComplex128, h func(ctx context.Context, arg uint16) (complex128, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfComplex128()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfUint16ThenComplex128) DoOfUint16ThenComplex128(ctx context.Context, worker WorkerOfPushUint16ThenComplex128, arg uint16) (complex128, error) {
	// ch := make(chan *ReturnOfComplex128, 1)
	ch := __.pool.GetChReturnOfComplex128()
	defer __.pool.PutChReturnOfComplex128(ch)

	req := __.pool.GetWorkOfUint16ThenComplex128()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfUint16ThenComplex128(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfComplex128(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfUint16ThenComplex128 = func(ctx context.Context, arg uint16) (complex128, error)

type WorkerOfUint16ThenComplex128 struct {
	api_syncer *ApiDecouplerOfUint16ThenComplex128
	handler    WorkHandlerOfUint16ThenComplex128

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfUint16ThenComplex128
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfUint16ThenComplex128(ctx context.Context, h WorkHandlerOfUint16ThenComplex128, n int) *WorkerOfUint16ThenComplex128 {
	__ := &WorkerOfUint16ThenComplex128{
		api_syncer: NewApiDecouplerOfUint16ThenComplex128(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfUint16ThenComplex128, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfUint16ThenComplex128{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfUint16ThenComplex128(req.Context, req.WorkOfUint16ThenComplex128, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfUint16ThenComplex128) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfUint16ThenComplex128) Push(ctx context.Context, req *WorkOfUint16ThenComplex128) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfUint16ThenComplex128)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfUint16ThenComplex128 = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfUint16ThenComplex128) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfUint16ThenComplex128) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfUint16ThenComplex128) Call(ctx context.Context, arg uint16) (complex128, error) {
	return __.api_syncer.DoOfUint16ThenComplex128(ctx, __, arg)
}

type PoolOfUint16ThenComplex64 interface {
	GetUint16Arg() *uint16
	PutUint16Arg(*uint16)
	GetComplex64Return() *complex64
	PutComplex64Return(*complex64)

	GetWorkOfUint16ThenComplex64() *WorkOfUint16ThenComplex64
	GetReturnOfComplex64() *ReturnOfComplex64
	PutWorkOfUint16ThenComplex64(*WorkOfUint16ThenComplex64)
	PutReturnOfComplex64(*ReturnOfComplex64)

	GetChReturnOfComplex64() chan *ReturnOfComplex64
	PutChReturnOfComplex64(chan *ReturnOfComplex64)
}

type PoolOfUint16ThenComplex64Impl struct {
	Uint16Arg           sync.Pool
	Complex64Rtn        sync.Pool
	Uint16Work          sync.Pool
	Complex64Return     sync.Pool
	ChReturnOfComplex64 sync.Pool
}

func (__ *PoolOfUint16ThenComplex64Impl) GetUint16Arg() *uint16 {
	return __.Uint16Arg.Get().(*uint16)
}
func (__ *PoolOfUint16ThenComplex64Impl) PutUint16Arg(p *uint16) {
	__.Uint16Arg.Put(p)
}
func (__ *PoolOfUint16ThenComplex64Impl) GetComplex64Return() *complex64 {
	return __.Complex64Rtn.Get().(*complex64)
}
func (__ *PoolOfUint16ThenComplex64Impl) PutComplex64Return(p *complex64) {
	__.Complex64Rtn.Put(p)
}

func (__ *PoolOfUint16ThenComplex64Impl) GetWorkOfUint16ThenComplex64() *WorkOfUint16ThenComplex64 {
	return __.Uint16Work.Get().(*WorkOfUint16ThenComplex64)
}
func (__ *PoolOfUint16ThenComplex64Impl) PutWorkOfUint16ThenComplex64(p *WorkOfUint16ThenComplex64) {
	__.Uint16Work.Put(p)
}
func (__ *PoolOfUint16ThenComplex64Impl) GetReturnOfComplex64() *ReturnOfComplex64 {
	return __.Complex64Return.Get().(*ReturnOfComplex64)
}
func (__ *PoolOfUint16ThenComplex64Impl) PutReturnOfComplex64(p *ReturnOfComplex64) {
	__.Complex64Return.Put(p)
}

func (__ *PoolOfUint16ThenComplex64Impl) GetChReturnOfComplex64() chan *ReturnOfComplex64 {
	return __.ChReturnOfComplex64.Get().(chan *ReturnOfComplex64)
}
func (__ *PoolOfUint16ThenComplex64Impl) PutChReturnOfComplex64(p chan *ReturnOfComplex64) {
	__.ChReturnOfComplex64.Put(p)
}

func NewPoolOfUint16ThenComplex64Impl() *PoolOfUint16ThenComplex64Impl {
	return &PoolOfUint16ThenComplex64Impl{
		Uint16Arg: sync.Pool{
			New: func() interface{} {
				return new(uint16)
			},
		},
		Uint16Work: sync.Pool{
			New: func() interface{} {
				return new(WorkOfUint16ThenComplex64)
			},
		},
		Complex64Rtn: sync.Pool{
			New: func() interface{} {
				return new(complex64)
			},
		},
		Complex64Return: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfComplex64)
			},
		},
		ChReturnOfComplex64: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfComplex64, 1)
			},
		},
	}
}

type ApiDecouplerOfUint16ThenComplex64 struct {
	pool PoolOfUint16ThenComplex64
}

func NewApiDecouplerOfUint16ThenComplex64() *ApiDecouplerOfUint16ThenComplex64 {
	return &ApiDecouplerOfUint16ThenComplex64{
		pool: NewPoolOfUint16ThenComplex64Impl(),
	}
}

func (__ *ApiDecouplerOfUint16ThenComplex64) ReturnError(rtn_ch chan<- *ReturnOfComplex64, err error) {
	rtn := __.pool.GetReturnOfComplex64()
	var other complex64
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfUint16ThenComplex64) HandleOfUint16ThenComplex64(ctx context.Context, req *WorkOfUint16ThenComplex64, h func(ctx context.Context, arg uint16) (complex64, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfComplex64()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfUint16ThenComplex64) DoOfUint16ThenComplex64(ctx context.Context, worker WorkerOfPushUint16ThenComplex64, arg uint16) (complex64, error) {
	// ch := make(chan *ReturnOfComplex64, 1)
	ch := __.pool.GetChReturnOfComplex64()
	defer __.pool.PutChReturnOfComplex64(ch)

	req := __.pool.GetWorkOfUint16ThenComplex64()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfUint16ThenComplex64(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfComplex64(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfUint16ThenComplex64 = func(ctx context.Context, arg uint16) (complex64, error)

type WorkerOfUint16ThenComplex64 struct {
	api_syncer *ApiDecouplerOfUint16ThenComplex64
	handler    WorkHandlerOfUint16ThenComplex64

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfUint16ThenComplex64
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfUint16ThenComplex64(ctx context.Context, h WorkHandlerOfUint16ThenComplex64, n int) *WorkerOfUint16ThenComplex64 {
	__ := &WorkerOfUint16ThenComplex64{
		api_syncer: NewApiDecouplerOfUint16ThenComplex64(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfUint16ThenComplex64, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfUint16ThenComplex64{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfUint16ThenComplex64(req.Context, req.WorkOfUint16ThenComplex64, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfUint16ThenComplex64) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfUint16ThenComplex64) Push(ctx context.Context, req *WorkOfUint16ThenComplex64) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfUint16ThenComplex64)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfUint16ThenComplex64 = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfUint16ThenComplex64) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfUint16ThenComplex64) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfUint16ThenComplex64) Call(ctx context.Context, arg uint16) (complex64, error) {
	return __.api_syncer.DoOfUint16ThenComplex64(ctx, __, arg)
}

type PoolOfUint16ThenError interface {
	GetUint16Arg() *uint16
	PutUint16Arg(*uint16)
	GetErrorReturn() *error
	PutErrorReturn(*error)

	GetWorkOfUint16ThenError() *WorkOfUint16ThenError
	GetReturnOfError() *ReturnOfError
	PutWorkOfUint16ThenError(*WorkOfUint16ThenError)
	PutReturnOfError(*ReturnOfError)

	GetChReturnOfError() chan *ReturnOfError
	PutChReturnOfError(chan *ReturnOfError)
}

type PoolOfUint16ThenErrorImpl struct {
	Uint16Arg       sync.Pool
	ErrorRtn        sync.Pool
	Uint16Work      sync.Pool
	ErrorReturn     sync.Pool
	ChReturnOfError sync.Pool
}

func (__ *PoolOfUint16ThenErrorImpl) GetUint16Arg() *uint16 {
	return __.Uint16Arg.Get().(*uint16)
}
func (__ *PoolOfUint16ThenErrorImpl) PutUint16Arg(p *uint16) {
	__.Uint16Arg.Put(p)
}
func (__ *PoolOfUint16ThenErrorImpl) GetErrorReturn() *error {
	return __.ErrorRtn.Get().(*error)
}
func (__ *PoolOfUint16ThenErrorImpl) PutErrorReturn(p *error) {
	__.ErrorRtn.Put(p)
}

func (__ *PoolOfUint16ThenErrorImpl) GetWorkOfUint16ThenError() *WorkOfUint16ThenError {
	return __.Uint16Work.Get().(*WorkOfUint16ThenError)
}
func (__ *PoolOfUint16ThenErrorImpl) PutWorkOfUint16ThenError(p *WorkOfUint16ThenError) {
	__.Uint16Work.Put(p)
}
func (__ *PoolOfUint16ThenErrorImpl) GetReturnOfError() *ReturnOfError {
	return __.ErrorReturn.Get().(*ReturnOfError)
}
func (__ *PoolOfUint16ThenErrorImpl) PutReturnOfError(p *ReturnOfError) {
	__.ErrorReturn.Put(p)
}

func (__ *PoolOfUint16ThenErrorImpl) GetChReturnOfError() chan *ReturnOfError {
	return __.ChReturnOfError.Get().(chan *ReturnOfError)
}
func (__ *PoolOfUint16ThenErrorImpl) PutChReturnOfError(p chan *ReturnOfError) {
	__.ChReturnOfError.Put(p)
}

func NewPoolOfUint16ThenErrorImpl() *PoolOfUint16ThenErrorImpl {
	return &PoolOfUint16ThenErrorImpl{
		Uint16Arg: sync.Pool{
			New: func() interface{} {
				return new(uint16)
			},
		},
		Uint16Work: sync.Pool{
			New: func() interface{} {
				return new(WorkOfUint16ThenError)
			},
		},
		ErrorRtn: sync.Pool{
			New: func() interface{} {
				return new(error)
			},
		},
		ErrorReturn: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfError)
			},
		},
		ChReturnOfError: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfError, 1)
			},
		},
	}
}

type ApiDecouplerOfUint16ThenError struct {
	pool PoolOfUint16ThenError
}

func NewApiDecouplerOfUint16ThenError() *ApiDecouplerOfUint16ThenError {
	return &ApiDecouplerOfUint16ThenError{
		pool: NewPoolOfUint16ThenErrorImpl(),
	}
}

func (__ *ApiDecouplerOfUint16ThenError) ReturnError(rtn_ch chan<- *ReturnOfError, err error) {
	rtn := __.pool.GetReturnOfError()
	var other error
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfUint16ThenError) HandleOfUint16ThenError(ctx context.Context, req *WorkOfUint16ThenError, h func(ctx context.Context, arg uint16) (error, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfError()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfUint16ThenError) DoOfUint16ThenError(ctx context.Context, worker WorkerOfPushUint16ThenError, arg uint16) (error, error) {
	// ch := make(chan *ReturnOfError, 1)
	ch := __.pool.GetChReturnOfError()
	defer __.pool.PutChReturnOfError(ch)

	req := __.pool.GetWorkOfUint16ThenError()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfUint16ThenError(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfError(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfUint16ThenError = func(ctx context.Context, arg uint16) (error, error)

type WorkerOfUint16ThenError struct {
	api_syncer *ApiDecouplerOfUint16ThenError
	handler    WorkHandlerOfUint16ThenError

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfUint16ThenError
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfUint16ThenError(ctx context.Context, h WorkHandlerOfUint16ThenError, n int) *WorkerOfUint16ThenError {
	__ := &WorkerOfUint16ThenError{
		api_syncer: NewApiDecouplerOfUint16ThenError(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfUint16ThenError, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfUint16ThenError{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfUint16ThenError(req.Context, req.WorkOfUint16ThenError, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfUint16ThenError) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfUint16ThenError) Push(ctx context.Context, req *WorkOfUint16ThenError) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfUint16ThenError)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfUint16ThenError = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfUint16ThenError) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfUint16ThenError) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfUint16ThenError) Call(ctx context.Context, arg uint16) (error, error) {
	return __.api_syncer.DoOfUint16ThenError(ctx, __, arg)
}

type PoolOfUint16ThenFloat32 interface {
	GetUint16Arg() *uint16
	PutUint16Arg(*uint16)
	GetFloat32Return() *float32
	PutFloat32Return(*float32)

	GetWorkOfUint16ThenFloat32() *WorkOfUint16ThenFloat32
	GetReturnOfFloat32() *ReturnOfFloat32
	PutWorkOfUint16ThenFloat32(*WorkOfUint16ThenFloat32)
	PutReturnOfFloat32(*ReturnOfFloat32)

	GetChReturnOfFloat32() chan *ReturnOfFloat32
	PutChReturnOfFloat32(chan *ReturnOfFloat32)
}

type PoolOfUint16ThenFloat32Impl struct {
	Uint16Arg         sync.Pool
	Float32Rtn        sync.Pool
	Uint16Work        sync.Pool
	Float32Return     sync.Pool
	ChReturnOfFloat32 sync.Pool
}

func (__ *PoolOfUint16ThenFloat32Impl) GetUint16Arg() *uint16 {
	return __.Uint16Arg.Get().(*uint16)
}
func (__ *PoolOfUint16ThenFloat32Impl) PutUint16Arg(p *uint16) {
	__.Uint16Arg.Put(p)
}
func (__ *PoolOfUint16ThenFloat32Impl) GetFloat32Return() *float32 {
	return __.Float32Rtn.Get().(*float32)
}
func (__ *PoolOfUint16ThenFloat32Impl) PutFloat32Return(p *float32) {
	__.Float32Rtn.Put(p)
}

func (__ *PoolOfUint16ThenFloat32Impl) GetWorkOfUint16ThenFloat32() *WorkOfUint16ThenFloat32 {
	return __.Uint16Work.Get().(*WorkOfUint16ThenFloat32)
}
func (__ *PoolOfUint16ThenFloat32Impl) PutWorkOfUint16ThenFloat32(p *WorkOfUint16ThenFloat32) {
	__.Uint16Work.Put(p)
}
func (__ *PoolOfUint16ThenFloat32Impl) GetReturnOfFloat32() *ReturnOfFloat32 {
	return __.Float32Return.Get().(*ReturnOfFloat32)
}
func (__ *PoolOfUint16ThenFloat32Impl) PutReturnOfFloat32(p *ReturnOfFloat32) {
	__.Float32Return.Put(p)
}

func (__ *PoolOfUint16ThenFloat32Impl) GetChReturnOfFloat32() chan *ReturnOfFloat32 {
	return __.ChReturnOfFloat32.Get().(chan *ReturnOfFloat32)
}
func (__ *PoolOfUint16ThenFloat32Impl) PutChReturnOfFloat32(p chan *ReturnOfFloat32) {
	__.ChReturnOfFloat32.Put(p)
}

func NewPoolOfUint16ThenFloat32Impl() *PoolOfUint16ThenFloat32Impl {
	return &PoolOfUint16ThenFloat32Impl{
		Uint16Arg: sync.Pool{
			New: func() interface{} {
				return new(uint16)
			},
		},
		Uint16Work: sync.Pool{
			New: func() interface{} {
				return new(WorkOfUint16ThenFloat32)
			},
		},
		Float32Rtn: sync.Pool{
			New: func() interface{} {
				return new(float32)
			},
		},
		Float32Return: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfFloat32)
			},
		},
		ChReturnOfFloat32: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfFloat32, 1)
			},
		},
	}
}

type ApiDecouplerOfUint16ThenFloat32 struct {
	pool PoolOfUint16ThenFloat32
}

func NewApiDecouplerOfUint16ThenFloat32() *ApiDecouplerOfUint16ThenFloat32 {
	return &ApiDecouplerOfUint16ThenFloat32{
		pool: NewPoolOfUint16ThenFloat32Impl(),
	}
}

func (__ *ApiDecouplerOfUint16ThenFloat32) ReturnError(rtn_ch chan<- *ReturnOfFloat32, err error) {
	rtn := __.pool.GetReturnOfFloat32()
	var other float32
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfUint16ThenFloat32) HandleOfUint16ThenFloat32(ctx context.Context, req *WorkOfUint16ThenFloat32, h func(ctx context.Context, arg uint16) (float32, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfFloat32()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfUint16ThenFloat32) DoOfUint16ThenFloat32(ctx context.Context, worker WorkerOfPushUint16ThenFloat32, arg uint16) (float32, error) {
	// ch := make(chan *ReturnOfFloat32, 1)
	ch := __.pool.GetChReturnOfFloat32()
	defer __.pool.PutChReturnOfFloat32(ch)

	req := __.pool.GetWorkOfUint16ThenFloat32()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfUint16ThenFloat32(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfFloat32(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfUint16ThenFloat32 = func(ctx context.Context, arg uint16) (float32, error)

type WorkerOfUint16ThenFloat32 struct {
	api_syncer *ApiDecouplerOfUint16ThenFloat32
	handler    WorkHandlerOfUint16ThenFloat32

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfUint16ThenFloat32
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfUint16ThenFloat32(ctx context.Context, h WorkHandlerOfUint16ThenFloat32, n int) *WorkerOfUint16ThenFloat32 {
	__ := &WorkerOfUint16ThenFloat32{
		api_syncer: NewApiDecouplerOfUint16ThenFloat32(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfUint16ThenFloat32, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfUint16ThenFloat32{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfUint16ThenFloat32(req.Context, req.WorkOfUint16ThenFloat32, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfUint16ThenFloat32) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfUint16ThenFloat32) Push(ctx context.Context, req *WorkOfUint16ThenFloat32) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfUint16ThenFloat32)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfUint16ThenFloat32 = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfUint16ThenFloat32) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfUint16ThenFloat32) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfUint16ThenFloat32) Call(ctx context.Context, arg uint16) (float32, error) {
	return __.api_syncer.DoOfUint16ThenFloat32(ctx, __, arg)
}

type PoolOfUint16ThenFloat64 interface {
	GetUint16Arg() *uint16
	PutUint16Arg(*uint16)
	GetFloat64Return() *float64
	PutFloat64Return(*float64)

	GetWorkOfUint16ThenFloat64() *WorkOfUint16ThenFloat64
	GetReturnOfFloat64() *ReturnOfFloat64
	PutWorkOfUint16ThenFloat64(*WorkOfUint16ThenFloat64)
	PutReturnOfFloat64(*ReturnOfFloat64)

	GetChReturnOfFloat64() chan *ReturnOfFloat64
	PutChReturnOfFloat64(chan *ReturnOfFloat64)
}

type PoolOfUint16ThenFloat64Impl struct {
	Uint16Arg         sync.Pool
	Float64Rtn        sync.Pool
	Uint16Work        sync.Pool
	Float64Return     sync.Pool
	ChReturnOfFloat64 sync.Pool
}

func (__ *PoolOfUint16ThenFloat64Impl) GetUint16Arg() *uint16 {
	return __.Uint16Arg.Get().(*uint16)
}
func (__ *PoolOfUint16ThenFloat64Impl) PutUint16Arg(p *uint16) {
	__.Uint16Arg.Put(p)
}
func (__ *PoolOfUint16ThenFloat64Impl) GetFloat64Return() *float64 {
	return __.Float64Rtn.Get().(*float64)
}
func (__ *PoolOfUint16ThenFloat64Impl) PutFloat64Return(p *float64) {
	__.Float64Rtn.Put(p)
}

func (__ *PoolOfUint16ThenFloat64Impl) GetWorkOfUint16ThenFloat64() *WorkOfUint16ThenFloat64 {
	return __.Uint16Work.Get().(*WorkOfUint16ThenFloat64)
}
func (__ *PoolOfUint16ThenFloat64Impl) PutWorkOfUint16ThenFloat64(p *WorkOfUint16ThenFloat64) {
	__.Uint16Work.Put(p)
}
func (__ *PoolOfUint16ThenFloat64Impl) GetReturnOfFloat64() *ReturnOfFloat64 {
	return __.Float64Return.Get().(*ReturnOfFloat64)
}
func (__ *PoolOfUint16ThenFloat64Impl) PutReturnOfFloat64(p *ReturnOfFloat64) {
	__.Float64Return.Put(p)
}

func (__ *PoolOfUint16ThenFloat64Impl) GetChReturnOfFloat64() chan *ReturnOfFloat64 {
	return __.ChReturnOfFloat64.Get().(chan *ReturnOfFloat64)
}
func (__ *PoolOfUint16ThenFloat64Impl) PutChReturnOfFloat64(p chan *ReturnOfFloat64) {
	__.ChReturnOfFloat64.Put(p)
}

func NewPoolOfUint16ThenFloat64Impl() *PoolOfUint16ThenFloat64Impl {
	return &PoolOfUint16ThenFloat64Impl{
		Uint16Arg: sync.Pool{
			New: func() interface{} {
				return new(uint16)
			},
		},
		Uint16Work: sync.Pool{
			New: func() interface{} {
				return new(WorkOfUint16ThenFloat64)
			},
		},
		Float64Rtn: sync.Pool{
			New: func() interface{} {
				return new(float64)
			},
		},
		Float64Return: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfFloat64)
			},
		},
		ChReturnOfFloat64: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfFloat64, 1)
			},
		},
	}
}

type ApiDecouplerOfUint16ThenFloat64 struct {
	pool PoolOfUint16ThenFloat64
}

func NewApiDecouplerOfUint16ThenFloat64() *ApiDecouplerOfUint16ThenFloat64 {
	return &ApiDecouplerOfUint16ThenFloat64{
		pool: NewPoolOfUint16ThenFloat64Impl(),
	}
}

func (__ *ApiDecouplerOfUint16ThenFloat64) ReturnError(rtn_ch chan<- *ReturnOfFloat64, err error) {
	rtn := __.pool.GetReturnOfFloat64()
	var other float64
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfUint16ThenFloat64) HandleOfUint16ThenFloat64(ctx context.Context, req *WorkOfUint16ThenFloat64, h func(ctx context.Context, arg uint16) (float64, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfFloat64()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfUint16ThenFloat64) DoOfUint16ThenFloat64(ctx context.Context, worker WorkerOfPushUint16ThenFloat64, arg uint16) (float64, error) {
	// ch := make(chan *ReturnOfFloat64, 1)
	ch := __.pool.GetChReturnOfFloat64()
	defer __.pool.PutChReturnOfFloat64(ch)

	req := __.pool.GetWorkOfUint16ThenFloat64()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfUint16ThenFloat64(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfFloat64(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfUint16ThenFloat64 = func(ctx context.Context, arg uint16) (float64, error)

type WorkerOfUint16ThenFloat64 struct {
	api_syncer *ApiDecouplerOfUint16ThenFloat64
	handler    WorkHandlerOfUint16ThenFloat64

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfUint16ThenFloat64
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfUint16ThenFloat64(ctx context.Context, h WorkHandlerOfUint16ThenFloat64, n int) *WorkerOfUint16ThenFloat64 {
	__ := &WorkerOfUint16ThenFloat64{
		api_syncer: NewApiDecouplerOfUint16ThenFloat64(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfUint16ThenFloat64, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfUint16ThenFloat64{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfUint16ThenFloat64(req.Context, req.WorkOfUint16ThenFloat64, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfUint16ThenFloat64) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfUint16ThenFloat64) Push(ctx context.Context, req *WorkOfUint16ThenFloat64) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfUint16ThenFloat64)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfUint16ThenFloat64 = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfUint16ThenFloat64) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfUint16ThenFloat64) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfUint16ThenFloat64) Call(ctx context.Context, arg uint16) (float64, error) {
	return __.api_syncer.DoOfUint16ThenFloat64(ctx, __, arg)
}

type PoolOfUint16ThenInt interface {
	GetUint16Arg() *uint16
	PutUint16Arg(*uint16)
	GetIntReturn() *int
	PutIntReturn(*int)

	GetWorkOfUint16ThenInt() *WorkOfUint16ThenInt
	GetReturnOfInt() *ReturnOfInt
	PutWorkOfUint16ThenInt(*WorkOfUint16ThenInt)
	PutReturnOfInt(*ReturnOfInt)

	GetChReturnOfInt() chan *ReturnOfInt
	PutChReturnOfInt(chan *ReturnOfInt)
}

type PoolOfUint16ThenIntImpl struct {
	Uint16Arg     sync.Pool
	IntRtn        sync.Pool
	Uint16Work    sync.Pool
	IntReturn     sync.Pool
	ChReturnOfInt sync.Pool
}

func (__ *PoolOfUint16ThenIntImpl) GetUint16Arg() *uint16 {
	return __.Uint16Arg.Get().(*uint16)
}
func (__ *PoolOfUint16ThenIntImpl) PutUint16Arg(p *uint16) {
	__.Uint16Arg.Put(p)
}
func (__ *PoolOfUint16ThenIntImpl) GetIntReturn() *int {
	return __.IntRtn.Get().(*int)
}
func (__ *PoolOfUint16ThenIntImpl) PutIntReturn(p *int) {
	__.IntRtn.Put(p)
}

func (__ *PoolOfUint16ThenIntImpl) GetWorkOfUint16ThenInt() *WorkOfUint16ThenInt {
	return __.Uint16Work.Get().(*WorkOfUint16ThenInt)
}
func (__ *PoolOfUint16ThenIntImpl) PutWorkOfUint16ThenInt(p *WorkOfUint16ThenInt) {
	__.Uint16Work.Put(p)
}
func (__ *PoolOfUint16ThenIntImpl) GetReturnOfInt() *ReturnOfInt {
	return __.IntReturn.Get().(*ReturnOfInt)
}
func (__ *PoolOfUint16ThenIntImpl) PutReturnOfInt(p *ReturnOfInt) {
	__.IntReturn.Put(p)
}

func (__ *PoolOfUint16ThenIntImpl) GetChReturnOfInt() chan *ReturnOfInt {
	return __.ChReturnOfInt.Get().(chan *ReturnOfInt)
}
func (__ *PoolOfUint16ThenIntImpl) PutChReturnOfInt(p chan *ReturnOfInt) {
	__.ChReturnOfInt.Put(p)
}

func NewPoolOfUint16ThenIntImpl() *PoolOfUint16ThenIntImpl {
	return &PoolOfUint16ThenIntImpl{
		Uint16Arg: sync.Pool{
			New: func() interface{} {
				return new(uint16)
			},
		},
		Uint16Work: sync.Pool{
			New: func() interface{} {
				return new(WorkOfUint16ThenInt)
			},
		},
		IntRtn: sync.Pool{
			New: func() interface{} {
				return new(int)
			},
		},
		IntReturn: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfInt)
			},
		},
		ChReturnOfInt: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfInt, 1)
			},
		},
	}
}

type ApiDecouplerOfUint16ThenInt struct {
	pool PoolOfUint16ThenInt
}

func NewApiDecouplerOfUint16ThenInt() *ApiDecouplerOfUint16ThenInt {
	return &ApiDecouplerOfUint16ThenInt{
		pool: NewPoolOfUint16ThenIntImpl(),
	}
}

func (__ *ApiDecouplerOfUint16ThenInt) ReturnError(rtn_ch chan<- *ReturnOfInt, err error) {
	rtn := __.pool.GetReturnOfInt()
	var other int
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfUint16ThenInt) HandleOfUint16ThenInt(ctx context.Context, req *WorkOfUint16ThenInt, h func(ctx context.Context, arg uint16) (int, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfInt()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfUint16ThenInt) DoOfUint16ThenInt(ctx context.Context, worker WorkerOfPushUint16ThenInt, arg uint16) (int, error) {
	// ch := make(chan *ReturnOfInt, 1)
	ch := __.pool.GetChReturnOfInt()
	defer __.pool.PutChReturnOfInt(ch)

	req := __.pool.GetWorkOfUint16ThenInt()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfUint16ThenInt(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfInt(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfUint16ThenInt = func(ctx context.Context, arg uint16) (int, error)

type WorkerOfUint16ThenInt struct {
	api_syncer *ApiDecouplerOfUint16ThenInt
	handler    WorkHandlerOfUint16ThenInt

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfUint16ThenInt
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfUint16ThenInt(ctx context.Context, h WorkHandlerOfUint16ThenInt, n int) *WorkerOfUint16ThenInt {
	__ := &WorkerOfUint16ThenInt{
		api_syncer: NewApiDecouplerOfUint16ThenInt(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfUint16ThenInt, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfUint16ThenInt{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfUint16ThenInt(req.Context, req.WorkOfUint16ThenInt, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfUint16ThenInt) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfUint16ThenInt) Push(ctx context.Context, req *WorkOfUint16ThenInt) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfUint16ThenInt)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfUint16ThenInt = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfUint16ThenInt) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfUint16ThenInt) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfUint16ThenInt) Call(ctx context.Context, arg uint16) (int, error) {
	return __.api_syncer.DoOfUint16ThenInt(ctx, __, arg)
}

type PoolOfUint16ThenInt16 interface {
	GetUint16Arg() *uint16
	PutUint16Arg(*uint16)
	GetInt16Return() *int16
	PutInt16Return(*int16)

	GetWorkOfUint16ThenInt16() *WorkOfUint16ThenInt16
	GetReturnOfInt16() *ReturnOfInt16
	PutWorkOfUint16ThenInt16(*WorkOfUint16ThenInt16)
	PutReturnOfInt16(*ReturnOfInt16)

	GetChReturnOfInt16() chan *ReturnOfInt16
	PutChReturnOfInt16(chan *ReturnOfInt16)
}

type PoolOfUint16ThenInt16Impl struct {
	Uint16Arg       sync.Pool
	Int16Rtn        sync.Pool
	Uint16Work      sync.Pool
	Int16Return     sync.Pool
	ChReturnOfInt16 sync.Pool
}

func (__ *PoolOfUint16ThenInt16Impl) GetUint16Arg() *uint16 {
	return __.Uint16Arg.Get().(*uint16)
}
func (__ *PoolOfUint16ThenInt16Impl) PutUint16Arg(p *uint16) {
	__.Uint16Arg.Put(p)
}
func (__ *PoolOfUint16ThenInt16Impl) GetInt16Return() *int16 {
	return __.Int16Rtn.Get().(*int16)
}
func (__ *PoolOfUint16ThenInt16Impl) PutInt16Return(p *int16) {
	__.Int16Rtn.Put(p)
}

func (__ *PoolOfUint16ThenInt16Impl) GetWorkOfUint16ThenInt16() *WorkOfUint16ThenInt16 {
	return __.Uint16Work.Get().(*WorkOfUint16ThenInt16)
}
func (__ *PoolOfUint16ThenInt16Impl) PutWorkOfUint16ThenInt16(p *WorkOfUint16ThenInt16) {
	__.Uint16Work.Put(p)
}
func (__ *PoolOfUint16ThenInt16Impl) GetReturnOfInt16() *ReturnOfInt16 {
	return __.Int16Return.Get().(*ReturnOfInt16)
}
func (__ *PoolOfUint16ThenInt16Impl) PutReturnOfInt16(p *ReturnOfInt16) {
	__.Int16Return.Put(p)
}

func (__ *PoolOfUint16ThenInt16Impl) GetChReturnOfInt16() chan *ReturnOfInt16 {
	return __.ChReturnOfInt16.Get().(chan *ReturnOfInt16)
}
func (__ *PoolOfUint16ThenInt16Impl) PutChReturnOfInt16(p chan *ReturnOfInt16) {
	__.ChReturnOfInt16.Put(p)
}

func NewPoolOfUint16ThenInt16Impl() *PoolOfUint16ThenInt16Impl {
	return &PoolOfUint16ThenInt16Impl{
		Uint16Arg: sync.Pool{
			New: func() interface{} {
				return new(uint16)
			},
		},
		Uint16Work: sync.Pool{
			New: func() interface{} {
				return new(WorkOfUint16ThenInt16)
			},
		},
		Int16Rtn: sync.Pool{
			New: func() interface{} {
				return new(int16)
			},
		},
		Int16Return: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfInt16)
			},
		},
		ChReturnOfInt16: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfInt16, 1)
			},
		},
	}
}

type ApiDecouplerOfUint16ThenInt16 struct {
	pool PoolOfUint16ThenInt16
}

func NewApiDecouplerOfUint16ThenInt16() *ApiDecouplerOfUint16ThenInt16 {
	return &ApiDecouplerOfUint16ThenInt16{
		pool: NewPoolOfUint16ThenInt16Impl(),
	}
}

func (__ *ApiDecouplerOfUint16ThenInt16) ReturnError(rtn_ch chan<- *ReturnOfInt16, err error) {
	rtn := __.pool.GetReturnOfInt16()
	var other int16
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfUint16ThenInt16) HandleOfUint16ThenInt16(ctx context.Context, req *WorkOfUint16ThenInt16, h func(ctx context.Context, arg uint16) (int16, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfInt16()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfUint16ThenInt16) DoOfUint16ThenInt16(ctx context.Context, worker WorkerOfPushUint16ThenInt16, arg uint16) (int16, error) {
	// ch := make(chan *ReturnOfInt16, 1)
	ch := __.pool.GetChReturnOfInt16()
	defer __.pool.PutChReturnOfInt16(ch)

	req := __.pool.GetWorkOfUint16ThenInt16()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfUint16ThenInt16(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfInt16(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfUint16ThenInt16 = func(ctx context.Context, arg uint16) (int16, error)

type WorkerOfUint16ThenInt16 struct {
	api_syncer *ApiDecouplerOfUint16ThenInt16
	handler    WorkHandlerOfUint16ThenInt16

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfUint16ThenInt16
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfUint16ThenInt16(ctx context.Context, h WorkHandlerOfUint16ThenInt16, n int) *WorkerOfUint16ThenInt16 {
	__ := &WorkerOfUint16ThenInt16{
		api_syncer: NewApiDecouplerOfUint16ThenInt16(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfUint16ThenInt16, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfUint16ThenInt16{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfUint16ThenInt16(req.Context, req.WorkOfUint16ThenInt16, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfUint16ThenInt16) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfUint16ThenInt16) Push(ctx context.Context, req *WorkOfUint16ThenInt16) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfUint16ThenInt16)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfUint16ThenInt16 = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfUint16ThenInt16) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfUint16ThenInt16) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfUint16ThenInt16) Call(ctx context.Context, arg uint16) (int16, error) {
	return __.api_syncer.DoOfUint16ThenInt16(ctx, __, arg)
}

type PoolOfUint16ThenInt32 interface {
	GetUint16Arg() *uint16
	PutUint16Arg(*uint16)
	GetInt32Return() *int32
	PutInt32Return(*int32)

	GetWorkOfUint16ThenInt32() *WorkOfUint16ThenInt32
	GetReturnOfInt32() *ReturnOfInt32
	PutWorkOfUint16ThenInt32(*WorkOfUint16ThenInt32)
	PutReturnOfInt32(*ReturnOfInt32)

	GetChReturnOfInt32() chan *ReturnOfInt32
	PutChReturnOfInt32(chan *ReturnOfInt32)
}

type PoolOfUint16ThenInt32Impl struct {
	Uint16Arg       sync.Pool
	Int32Rtn        sync.Pool
	Uint16Work      sync.Pool
	Int32Return     sync.Pool
	ChReturnOfInt32 sync.Pool
}

func (__ *PoolOfUint16ThenInt32Impl) GetUint16Arg() *uint16 {
	return __.Uint16Arg.Get().(*uint16)
}
func (__ *PoolOfUint16ThenInt32Impl) PutUint16Arg(p *uint16) {
	__.Uint16Arg.Put(p)
}
func (__ *PoolOfUint16ThenInt32Impl) GetInt32Return() *int32 {
	return __.Int32Rtn.Get().(*int32)
}
func (__ *PoolOfUint16ThenInt32Impl) PutInt32Return(p *int32) {
	__.Int32Rtn.Put(p)
}

func (__ *PoolOfUint16ThenInt32Impl) GetWorkOfUint16ThenInt32() *WorkOfUint16ThenInt32 {
	return __.Uint16Work.Get().(*WorkOfUint16ThenInt32)
}
func (__ *PoolOfUint16ThenInt32Impl) PutWorkOfUint16ThenInt32(p *WorkOfUint16ThenInt32) {
	__.Uint16Work.Put(p)
}
func (__ *PoolOfUint16ThenInt32Impl) GetReturnOfInt32() *ReturnOfInt32 {
	return __.Int32Return.Get().(*ReturnOfInt32)
}
func (__ *PoolOfUint16ThenInt32Impl) PutReturnOfInt32(p *ReturnOfInt32) {
	__.Int32Return.Put(p)
}

func (__ *PoolOfUint16ThenInt32Impl) GetChReturnOfInt32() chan *ReturnOfInt32 {
	return __.ChReturnOfInt32.Get().(chan *ReturnOfInt32)
}
func (__ *PoolOfUint16ThenInt32Impl) PutChReturnOfInt32(p chan *ReturnOfInt32) {
	__.ChReturnOfInt32.Put(p)
}

func NewPoolOfUint16ThenInt32Impl() *PoolOfUint16ThenInt32Impl {
	return &PoolOfUint16ThenInt32Impl{
		Uint16Arg: sync.Pool{
			New: func() interface{} {
				return new(uint16)
			},
		},
		Uint16Work: sync.Pool{
			New: func() interface{} {
				return new(WorkOfUint16ThenInt32)
			},
		},
		Int32Rtn: sync.Pool{
			New: func() interface{} {
				return new(int32)
			},
		},
		Int32Return: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfInt32)
			},
		},
		ChReturnOfInt32: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfInt32, 1)
			},
		},
	}
}

type ApiDecouplerOfUint16ThenInt32 struct {
	pool PoolOfUint16ThenInt32
}

func NewApiDecouplerOfUint16ThenInt32() *ApiDecouplerOfUint16ThenInt32 {
	return &ApiDecouplerOfUint16ThenInt32{
		pool: NewPoolOfUint16ThenInt32Impl(),
	}
}

func (__ *ApiDecouplerOfUint16ThenInt32) ReturnError(rtn_ch chan<- *ReturnOfInt32, err error) {
	rtn := __.pool.GetReturnOfInt32()
	var other int32
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfUint16ThenInt32) HandleOfUint16ThenInt32(ctx context.Context, req *WorkOfUint16ThenInt32, h func(ctx context.Context, arg uint16) (int32, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfInt32()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfUint16ThenInt32) DoOfUint16ThenInt32(ctx context.Context, worker WorkerOfPushUint16ThenInt32, arg uint16) (int32, error) {
	// ch := make(chan *ReturnOfInt32, 1)
	ch := __.pool.GetChReturnOfInt32()
	defer __.pool.PutChReturnOfInt32(ch)

	req := __.pool.GetWorkOfUint16ThenInt32()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfUint16ThenInt32(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfInt32(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfUint16ThenInt32 = func(ctx context.Context, arg uint16) (int32, error)

type WorkerOfUint16ThenInt32 struct {
	api_syncer *ApiDecouplerOfUint16ThenInt32
	handler    WorkHandlerOfUint16ThenInt32

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfUint16ThenInt32
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfUint16ThenInt32(ctx context.Context, h WorkHandlerOfUint16ThenInt32, n int) *WorkerOfUint16ThenInt32 {
	__ := &WorkerOfUint16ThenInt32{
		api_syncer: NewApiDecouplerOfUint16ThenInt32(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfUint16ThenInt32, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfUint16ThenInt32{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfUint16ThenInt32(req.Context, req.WorkOfUint16ThenInt32, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfUint16ThenInt32) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfUint16ThenInt32) Push(ctx context.Context, req *WorkOfUint16ThenInt32) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfUint16ThenInt32)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfUint16ThenInt32 = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfUint16ThenInt32) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfUint16ThenInt32) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfUint16ThenInt32) Call(ctx context.Context, arg uint16) (int32, error) {
	return __.api_syncer.DoOfUint16ThenInt32(ctx, __, arg)
}

type PoolOfUint16ThenInt64 interface {
	GetUint16Arg() *uint16
	PutUint16Arg(*uint16)
	GetInt64Return() *int64
	PutInt64Return(*int64)

	GetWorkOfUint16ThenInt64() *WorkOfUint16ThenInt64
	GetReturnOfInt64() *ReturnOfInt64
	PutWorkOfUint16ThenInt64(*WorkOfUint16ThenInt64)
	PutReturnOfInt64(*ReturnOfInt64)

	GetChReturnOfInt64() chan *ReturnOfInt64
	PutChReturnOfInt64(chan *ReturnOfInt64)
}

type PoolOfUint16ThenInt64Impl struct {
	Uint16Arg       sync.Pool
	Int64Rtn        sync.Pool
	Uint16Work      sync.Pool
	Int64Return     sync.Pool
	ChReturnOfInt64 sync.Pool
}

func (__ *PoolOfUint16ThenInt64Impl) GetUint16Arg() *uint16 {
	return __.Uint16Arg.Get().(*uint16)
}
func (__ *PoolOfUint16ThenInt64Impl) PutUint16Arg(p *uint16) {
	__.Uint16Arg.Put(p)
}
func (__ *PoolOfUint16ThenInt64Impl) GetInt64Return() *int64 {
	return __.Int64Rtn.Get().(*int64)
}
func (__ *PoolOfUint16ThenInt64Impl) PutInt64Return(p *int64) {
	__.Int64Rtn.Put(p)
}

func (__ *PoolOfUint16ThenInt64Impl) GetWorkOfUint16ThenInt64() *WorkOfUint16ThenInt64 {
	return __.Uint16Work.Get().(*WorkOfUint16ThenInt64)
}
func (__ *PoolOfUint16ThenInt64Impl) PutWorkOfUint16ThenInt64(p *WorkOfUint16ThenInt64) {
	__.Uint16Work.Put(p)
}
func (__ *PoolOfUint16ThenInt64Impl) GetReturnOfInt64() *ReturnOfInt64 {
	return __.Int64Return.Get().(*ReturnOfInt64)
}
func (__ *PoolOfUint16ThenInt64Impl) PutReturnOfInt64(p *ReturnOfInt64) {
	__.Int64Return.Put(p)
}

func (__ *PoolOfUint16ThenInt64Impl) GetChReturnOfInt64() chan *ReturnOfInt64 {
	return __.ChReturnOfInt64.Get().(chan *ReturnOfInt64)
}
func (__ *PoolOfUint16ThenInt64Impl) PutChReturnOfInt64(p chan *ReturnOfInt64) {
	__.ChReturnOfInt64.Put(p)
}

func NewPoolOfUint16ThenInt64Impl() *PoolOfUint16ThenInt64Impl {
	return &PoolOfUint16ThenInt64Impl{
		Uint16Arg: sync.Pool{
			New: func() interface{} {
				return new(uint16)
			},
		},
		Uint16Work: sync.Pool{
			New: func() interface{} {
				return new(WorkOfUint16ThenInt64)
			},
		},
		Int64Rtn: sync.Pool{
			New: func() interface{} {
				return new(int64)
			},
		},
		Int64Return: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfInt64)
			},
		},
		ChReturnOfInt64: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfInt64, 1)
			},
		},
	}
}

type ApiDecouplerOfUint16ThenInt64 struct {
	pool PoolOfUint16ThenInt64
}

func NewApiDecouplerOfUint16ThenInt64() *ApiDecouplerOfUint16ThenInt64 {
	return &ApiDecouplerOfUint16ThenInt64{
		pool: NewPoolOfUint16ThenInt64Impl(),
	}
}

func (__ *ApiDecouplerOfUint16ThenInt64) ReturnError(rtn_ch chan<- *ReturnOfInt64, err error) {
	rtn := __.pool.GetReturnOfInt64()
	var other int64
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfUint16ThenInt64) HandleOfUint16ThenInt64(ctx context.Context, req *WorkOfUint16ThenInt64, h func(ctx context.Context, arg uint16) (int64, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfInt64()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfUint16ThenInt64) DoOfUint16ThenInt64(ctx context.Context, worker WorkerOfPushUint16ThenInt64, arg uint16) (int64, error) {
	// ch := make(chan *ReturnOfInt64, 1)
	ch := __.pool.GetChReturnOfInt64()
	defer __.pool.PutChReturnOfInt64(ch)

	req := __.pool.GetWorkOfUint16ThenInt64()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfUint16ThenInt64(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfInt64(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfUint16ThenInt64 = func(ctx context.Context, arg uint16) (int64, error)

type WorkerOfUint16ThenInt64 struct {
	api_syncer *ApiDecouplerOfUint16ThenInt64
	handler    WorkHandlerOfUint16ThenInt64

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfUint16ThenInt64
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfUint16ThenInt64(ctx context.Context, h WorkHandlerOfUint16ThenInt64, n int) *WorkerOfUint16ThenInt64 {
	__ := &WorkerOfUint16ThenInt64{
		api_syncer: NewApiDecouplerOfUint16ThenInt64(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfUint16ThenInt64, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfUint16ThenInt64{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfUint16ThenInt64(req.Context, req.WorkOfUint16ThenInt64, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfUint16ThenInt64) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfUint16ThenInt64) Push(ctx context.Context, req *WorkOfUint16ThenInt64) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfUint16ThenInt64)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfUint16ThenInt64 = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfUint16ThenInt64) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfUint16ThenInt64) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfUint16ThenInt64) Call(ctx context.Context, arg uint16) (int64, error) {
	return __.api_syncer.DoOfUint16ThenInt64(ctx, __, arg)
}

type PoolOfUint16ThenInt8 interface {
	GetUint16Arg() *uint16
	PutUint16Arg(*uint16)
	GetInt8Return() *int8
	PutInt8Return(*int8)

	GetWorkOfUint16ThenInt8() *WorkOfUint16ThenInt8
	GetReturnOfInt8() *ReturnOfInt8
	PutWorkOfUint16ThenInt8(*WorkOfUint16ThenInt8)
	PutReturnOfInt8(*ReturnOfInt8)

	GetChReturnOfInt8() chan *ReturnOfInt8
	PutChReturnOfInt8(chan *ReturnOfInt8)
}

type PoolOfUint16ThenInt8Impl struct {
	Uint16Arg      sync.Pool
	Int8Rtn        sync.Pool
	Uint16Work     sync.Pool
	Int8Return     sync.Pool
	ChReturnOfInt8 sync.Pool
}

func (__ *PoolOfUint16ThenInt8Impl) GetUint16Arg() *uint16 {
	return __.Uint16Arg.Get().(*uint16)
}
func (__ *PoolOfUint16ThenInt8Impl) PutUint16Arg(p *uint16) {
	__.Uint16Arg.Put(p)
}
func (__ *PoolOfUint16ThenInt8Impl) GetInt8Return() *int8 {
	return __.Int8Rtn.Get().(*int8)
}
func (__ *PoolOfUint16ThenInt8Impl) PutInt8Return(p *int8) {
	__.Int8Rtn.Put(p)
}

func (__ *PoolOfUint16ThenInt8Impl) GetWorkOfUint16ThenInt8() *WorkOfUint16ThenInt8 {
	return __.Uint16Work.Get().(*WorkOfUint16ThenInt8)
}
func (__ *PoolOfUint16ThenInt8Impl) PutWorkOfUint16ThenInt8(p *WorkOfUint16ThenInt8) {
	__.Uint16Work.Put(p)
}
func (__ *PoolOfUint16ThenInt8Impl) GetReturnOfInt8() *ReturnOfInt8 {
	return __.Int8Return.Get().(*ReturnOfInt8)
}
func (__ *PoolOfUint16ThenInt8Impl) PutReturnOfInt8(p *ReturnOfInt8) {
	__.Int8Return.Put(p)
}

func (__ *PoolOfUint16ThenInt8Impl) GetChReturnOfInt8() chan *ReturnOfInt8 {
	return __.ChReturnOfInt8.Get().(chan *ReturnOfInt8)
}
func (__ *PoolOfUint16ThenInt8Impl) PutChReturnOfInt8(p chan *ReturnOfInt8) {
	__.ChReturnOfInt8.Put(p)
}

func NewPoolOfUint16ThenInt8Impl() *PoolOfUint16ThenInt8Impl {
	return &PoolOfUint16ThenInt8Impl{
		Uint16Arg: sync.Pool{
			New: func() interface{} {
				return new(uint16)
			},
		},
		Uint16Work: sync.Pool{
			New: func() interface{} {
				return new(WorkOfUint16ThenInt8)
			},
		},
		Int8Rtn: sync.Pool{
			New: func() interface{} {
				return new(int8)
			},
		},
		Int8Return: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfInt8)
			},
		},
		ChReturnOfInt8: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfInt8, 1)
			},
		},
	}
}

type ApiDecouplerOfUint16ThenInt8 struct {
	pool PoolOfUint16ThenInt8
}

func NewApiDecouplerOfUint16ThenInt8() *ApiDecouplerOfUint16ThenInt8 {
	return &ApiDecouplerOfUint16ThenInt8{
		pool: NewPoolOfUint16ThenInt8Impl(),
	}
}

func (__ *ApiDecouplerOfUint16ThenInt8) ReturnError(rtn_ch chan<- *ReturnOfInt8, err error) {
	rtn := __.pool.GetReturnOfInt8()
	var other int8
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfUint16ThenInt8) HandleOfUint16ThenInt8(ctx context.Context, req *WorkOfUint16ThenInt8, h func(ctx context.Context, arg uint16) (int8, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfInt8()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfUint16ThenInt8) DoOfUint16ThenInt8(ctx context.Context, worker WorkerOfPushUint16ThenInt8, arg uint16) (int8, error) {
	// ch := make(chan *ReturnOfInt8, 1)
	ch := __.pool.GetChReturnOfInt8()
	defer __.pool.PutChReturnOfInt8(ch)

	req := __.pool.GetWorkOfUint16ThenInt8()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfUint16ThenInt8(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfInt8(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfUint16ThenInt8 = func(ctx context.Context, arg uint16) (int8, error)

type WorkerOfUint16ThenInt8 struct {
	api_syncer *ApiDecouplerOfUint16ThenInt8
	handler    WorkHandlerOfUint16ThenInt8

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfUint16ThenInt8
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfUint16ThenInt8(ctx context.Context, h WorkHandlerOfUint16ThenInt8, n int) *WorkerOfUint16ThenInt8 {
	__ := &WorkerOfUint16ThenInt8{
		api_syncer: NewApiDecouplerOfUint16ThenInt8(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfUint16ThenInt8, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfUint16ThenInt8{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfUint16ThenInt8(req.Context, req.WorkOfUint16ThenInt8, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfUint16ThenInt8) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfUint16ThenInt8) Push(ctx context.Context, req *WorkOfUint16ThenInt8) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfUint16ThenInt8)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfUint16ThenInt8 = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfUint16ThenInt8) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfUint16ThenInt8) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfUint16ThenInt8) Call(ctx context.Context, arg uint16) (int8, error) {
	return __.api_syncer.DoOfUint16ThenInt8(ctx, __, arg)
}

type PoolOfUint16ThenRune interface {
	GetUint16Arg() *uint16
	PutUint16Arg(*uint16)
	GetRuneReturn() *rune
	PutRuneReturn(*rune)

	GetWorkOfUint16ThenRune() *WorkOfUint16ThenRune
	GetReturnOfRune() *ReturnOfRune
	PutWorkOfUint16ThenRune(*WorkOfUint16ThenRune)
	PutReturnOfRune(*ReturnOfRune)

	GetChReturnOfRune() chan *ReturnOfRune
	PutChReturnOfRune(chan *ReturnOfRune)
}

type PoolOfUint16ThenRuneImpl struct {
	Uint16Arg      sync.Pool
	RuneRtn        sync.Pool
	Uint16Work     sync.Pool
	RuneReturn     sync.Pool
	ChReturnOfRune sync.Pool
}

func (__ *PoolOfUint16ThenRuneImpl) GetUint16Arg() *uint16 {
	return __.Uint16Arg.Get().(*uint16)
}
func (__ *PoolOfUint16ThenRuneImpl) PutUint16Arg(p *uint16) {
	__.Uint16Arg.Put(p)
}
func (__ *PoolOfUint16ThenRuneImpl) GetRuneReturn() *rune {
	return __.RuneRtn.Get().(*rune)
}
func (__ *PoolOfUint16ThenRuneImpl) PutRuneReturn(p *rune) {
	__.RuneRtn.Put(p)
}

func (__ *PoolOfUint16ThenRuneImpl) GetWorkOfUint16ThenRune() *WorkOfUint16ThenRune {
	return __.Uint16Work.Get().(*WorkOfUint16ThenRune)
}
func (__ *PoolOfUint16ThenRuneImpl) PutWorkOfUint16ThenRune(p *WorkOfUint16ThenRune) {
	__.Uint16Work.Put(p)
}
func (__ *PoolOfUint16ThenRuneImpl) GetReturnOfRune() *ReturnOfRune {
	return __.RuneReturn.Get().(*ReturnOfRune)
}
func (__ *PoolOfUint16ThenRuneImpl) PutReturnOfRune(p *ReturnOfRune) {
	__.RuneReturn.Put(p)
}

func (__ *PoolOfUint16ThenRuneImpl) GetChReturnOfRune() chan *ReturnOfRune {
	return __.ChReturnOfRune.Get().(chan *ReturnOfRune)
}
func (__ *PoolOfUint16ThenRuneImpl) PutChReturnOfRune(p chan *ReturnOfRune) {
	__.ChReturnOfRune.Put(p)
}

func NewPoolOfUint16ThenRuneImpl() *PoolOfUint16ThenRuneImpl {
	return &PoolOfUint16ThenRuneImpl{
		Uint16Arg: sync.Pool{
			New: func() interface{} {
				return new(uint16)
			},
		},
		Uint16Work: sync.Pool{
			New: func() interface{} {
				return new(WorkOfUint16ThenRune)
			},
		},
		RuneRtn: sync.Pool{
			New: func() interface{} {
				return new(rune)
			},
		},
		RuneReturn: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfRune)
			},
		},
		ChReturnOfRune: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfRune, 1)
			},
		},
	}
}

type ApiDecouplerOfUint16ThenRune struct {
	pool PoolOfUint16ThenRune
}

func NewApiDecouplerOfUint16ThenRune() *ApiDecouplerOfUint16ThenRune {
	return &ApiDecouplerOfUint16ThenRune{
		pool: NewPoolOfUint16ThenRuneImpl(),
	}
}

func (__ *ApiDecouplerOfUint16ThenRune) ReturnError(rtn_ch chan<- *ReturnOfRune, err error) {
	rtn := __.pool.GetReturnOfRune()
	var other rune
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfUint16ThenRune) HandleOfUint16ThenRune(ctx context.Context, req *WorkOfUint16ThenRune, h func(ctx context.Context, arg uint16) (rune, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfRune()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfUint16ThenRune) DoOfUint16ThenRune(ctx context.Context, worker WorkerOfPushUint16ThenRune, arg uint16) (rune, error) {
	// ch := make(chan *ReturnOfRune, 1)
	ch := __.pool.GetChReturnOfRune()
	defer __.pool.PutChReturnOfRune(ch)

	req := __.pool.GetWorkOfUint16ThenRune()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfUint16ThenRune(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfRune(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfUint16ThenRune = func(ctx context.Context, arg uint16) (rune, error)

type WorkerOfUint16ThenRune struct {
	api_syncer *ApiDecouplerOfUint16ThenRune
	handler    WorkHandlerOfUint16ThenRune

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfUint16ThenRune
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfUint16ThenRune(ctx context.Context, h WorkHandlerOfUint16ThenRune, n int) *WorkerOfUint16ThenRune {
	__ := &WorkerOfUint16ThenRune{
		api_syncer: NewApiDecouplerOfUint16ThenRune(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfUint16ThenRune, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfUint16ThenRune{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfUint16ThenRune(req.Context, req.WorkOfUint16ThenRune, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfUint16ThenRune) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfUint16ThenRune) Push(ctx context.Context, req *WorkOfUint16ThenRune) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfUint16ThenRune)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfUint16ThenRune = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfUint16ThenRune) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfUint16ThenRune) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfUint16ThenRune) Call(ctx context.Context, arg uint16) (rune, error) {
	return __.api_syncer.DoOfUint16ThenRune(ctx, __, arg)
}

type PoolOfUint16ThenString interface {
	GetUint16Arg() *uint16
	PutUint16Arg(*uint16)
	GetStringReturn() *string
	PutStringReturn(*string)

	GetWorkOfUint16ThenString() *WorkOfUint16ThenString
	GetReturnOfString() *ReturnOfString
	PutWorkOfUint16ThenString(*WorkOfUint16ThenString)
	PutReturnOfString(*ReturnOfString)

	GetChReturnOfString() chan *ReturnOfString
	PutChReturnOfString(chan *ReturnOfString)
}

type PoolOfUint16ThenStringImpl struct {
	Uint16Arg        sync.Pool
	StringRtn        sync.Pool
	Uint16Work       sync.Pool
	StringReturn     sync.Pool
	ChReturnOfString sync.Pool
}

func (__ *PoolOfUint16ThenStringImpl) GetUint16Arg() *uint16 {
	return __.Uint16Arg.Get().(*uint16)
}
func (__ *PoolOfUint16ThenStringImpl) PutUint16Arg(p *uint16) {
	__.Uint16Arg.Put(p)
}
func (__ *PoolOfUint16ThenStringImpl) GetStringReturn() *string {
	return __.StringRtn.Get().(*string)
}
func (__ *PoolOfUint16ThenStringImpl) PutStringReturn(p *string) {
	__.StringRtn.Put(p)
}

func (__ *PoolOfUint16ThenStringImpl) GetWorkOfUint16ThenString() *WorkOfUint16ThenString {
	return __.Uint16Work.Get().(*WorkOfUint16ThenString)
}
func (__ *PoolOfUint16ThenStringImpl) PutWorkOfUint16ThenString(p *WorkOfUint16ThenString) {
	__.Uint16Work.Put(p)
}
func (__ *PoolOfUint16ThenStringImpl) GetReturnOfString() *ReturnOfString {
	return __.StringReturn.Get().(*ReturnOfString)
}
func (__ *PoolOfUint16ThenStringImpl) PutReturnOfString(p *ReturnOfString) {
	__.StringReturn.Put(p)
}

func (__ *PoolOfUint16ThenStringImpl) GetChReturnOfString() chan *ReturnOfString {
	return __.ChReturnOfString.Get().(chan *ReturnOfString)
}
func (__ *PoolOfUint16ThenStringImpl) PutChReturnOfString(p chan *ReturnOfString) {
	__.ChReturnOfString.Put(p)
}

func NewPoolOfUint16ThenStringImpl() *PoolOfUint16ThenStringImpl {
	return &PoolOfUint16ThenStringImpl{
		Uint16Arg: sync.Pool{
			New: func() interface{} {
				return new(uint16)
			},
		},
		Uint16Work: sync.Pool{
			New: func() interface{} {
				return new(WorkOfUint16ThenString)
			},
		},
		StringRtn: sync.Pool{
			New: func() interface{} {
				return new(string)
			},
		},
		StringReturn: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfString)
			},
		},
		ChReturnOfString: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfString, 1)
			},
		},
	}
}

type ApiDecouplerOfUint16ThenString struct {
	pool PoolOfUint16ThenString
}

func NewApiDecouplerOfUint16ThenString() *ApiDecouplerOfUint16ThenString {
	return &ApiDecouplerOfUint16ThenString{
		pool: NewPoolOfUint16ThenStringImpl(),
	}
}

func (__ *ApiDecouplerOfUint16ThenString) ReturnError(rtn_ch chan<- *ReturnOfString, err error) {
	rtn := __.pool.GetReturnOfString()
	var other string
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfUint16ThenString) HandleOfUint16ThenString(ctx context.Context, req *WorkOfUint16ThenString, h func(ctx context.Context, arg uint16) (string, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfString()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfUint16ThenString) DoOfUint16ThenString(ctx context.Context, worker WorkerOfPushUint16ThenString, arg uint16) (string, error) {
	// ch := make(chan *ReturnOfString, 1)
	ch := __.pool.GetChReturnOfString()
	defer __.pool.PutChReturnOfString(ch)

	req := __.pool.GetWorkOfUint16ThenString()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfUint16ThenString(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfString(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfUint16ThenString = func(ctx context.Context, arg uint16) (string, error)

type WorkerOfUint16ThenString struct {
	api_syncer *ApiDecouplerOfUint16ThenString
	handler    WorkHandlerOfUint16ThenString

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfUint16ThenString
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfUint16ThenString(ctx context.Context, h WorkHandlerOfUint16ThenString, n int) *WorkerOfUint16ThenString {
	__ := &WorkerOfUint16ThenString{
		api_syncer: NewApiDecouplerOfUint16ThenString(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfUint16ThenString, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfUint16ThenString{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfUint16ThenString(req.Context, req.WorkOfUint16ThenString, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfUint16ThenString) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfUint16ThenString) Push(ctx context.Context, req *WorkOfUint16ThenString) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfUint16ThenString)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfUint16ThenString = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfUint16ThenString) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfUint16ThenString) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfUint16ThenString) Call(ctx context.Context, arg uint16) (string, error) {
	return __.api_syncer.DoOfUint16ThenString(ctx, __, arg)
}

type PoolOfUint16ThenUint interface {
	GetUint16Arg() *uint16
	PutUint16Arg(*uint16)
	GetUintReturn() *uint
	PutUintReturn(*uint)

	GetWorkOfUint16ThenUint() *WorkOfUint16ThenUint
	GetReturnOfUint() *ReturnOfUint
	PutWorkOfUint16ThenUint(*WorkOfUint16ThenUint)
	PutReturnOfUint(*ReturnOfUint)

	GetChReturnOfUint() chan *ReturnOfUint
	PutChReturnOfUint(chan *ReturnOfUint)
}

type PoolOfUint16ThenUintImpl struct {
	Uint16Arg      sync.Pool
	UintRtn        sync.Pool
	Uint16Work     sync.Pool
	UintReturn     sync.Pool
	ChReturnOfUint sync.Pool
}

func (__ *PoolOfUint16ThenUintImpl) GetUint16Arg() *uint16 {
	return __.Uint16Arg.Get().(*uint16)
}
func (__ *PoolOfUint16ThenUintImpl) PutUint16Arg(p *uint16) {
	__.Uint16Arg.Put(p)
}
func (__ *PoolOfUint16ThenUintImpl) GetUintReturn() *uint {
	return __.UintRtn.Get().(*uint)
}
func (__ *PoolOfUint16ThenUintImpl) PutUintReturn(p *uint) {
	__.UintRtn.Put(p)
}

func (__ *PoolOfUint16ThenUintImpl) GetWorkOfUint16ThenUint() *WorkOfUint16ThenUint {
	return __.Uint16Work.Get().(*WorkOfUint16ThenUint)
}
func (__ *PoolOfUint16ThenUintImpl) PutWorkOfUint16ThenUint(p *WorkOfUint16ThenUint) {
	__.Uint16Work.Put(p)
}
func (__ *PoolOfUint16ThenUintImpl) GetReturnOfUint() *ReturnOfUint {
	return __.UintReturn.Get().(*ReturnOfUint)
}
func (__ *PoolOfUint16ThenUintImpl) PutReturnOfUint(p *ReturnOfUint) {
	__.UintReturn.Put(p)
}

func (__ *PoolOfUint16ThenUintImpl) GetChReturnOfUint() chan *ReturnOfUint {
	return __.ChReturnOfUint.Get().(chan *ReturnOfUint)
}
func (__ *PoolOfUint16ThenUintImpl) PutChReturnOfUint(p chan *ReturnOfUint) {
	__.ChReturnOfUint.Put(p)
}

func NewPoolOfUint16ThenUintImpl() *PoolOfUint16ThenUintImpl {
	return &PoolOfUint16ThenUintImpl{
		Uint16Arg: sync.Pool{
			New: func() interface{} {
				return new(uint16)
			},
		},
		Uint16Work: sync.Pool{
			New: func() interface{} {
				return new(WorkOfUint16ThenUint)
			},
		},
		UintRtn: sync.Pool{
			New: func() interface{} {
				return new(uint)
			},
		},
		UintReturn: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfUint)
			},
		},
		ChReturnOfUint: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfUint, 1)
			},
		},
	}
}

type ApiDecouplerOfUint16ThenUint struct {
	pool PoolOfUint16ThenUint
}

func NewApiDecouplerOfUint16ThenUint() *ApiDecouplerOfUint16ThenUint {
	return &ApiDecouplerOfUint16ThenUint{
		pool: NewPoolOfUint16ThenUintImpl(),
	}
}

func (__ *ApiDecouplerOfUint16ThenUint) ReturnError(rtn_ch chan<- *ReturnOfUint, err error) {
	rtn := __.pool.GetReturnOfUint()
	var other uint
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfUint16ThenUint) HandleOfUint16ThenUint(ctx context.Context, req *WorkOfUint16ThenUint, h func(ctx context.Context, arg uint16) (uint, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfUint()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfUint16ThenUint) DoOfUint16ThenUint(ctx context.Context, worker WorkerOfPushUint16ThenUint, arg uint16) (uint, error) {
	// ch := make(chan *ReturnOfUint, 1)
	ch := __.pool.GetChReturnOfUint()
	defer __.pool.PutChReturnOfUint(ch)

	req := __.pool.GetWorkOfUint16ThenUint()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfUint16ThenUint(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfUint(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfUint16ThenUint = func(ctx context.Context, arg uint16) (uint, error)

type WorkerOfUint16ThenUint struct {
	api_syncer *ApiDecouplerOfUint16ThenUint
	handler    WorkHandlerOfUint16ThenUint

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfUint16ThenUint
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfUint16ThenUint(ctx context.Context, h WorkHandlerOfUint16ThenUint, n int) *WorkerOfUint16ThenUint {
	__ := &WorkerOfUint16ThenUint{
		api_syncer: NewApiDecouplerOfUint16ThenUint(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfUint16ThenUint, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfUint16ThenUint{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfUint16ThenUint(req.Context, req.WorkOfUint16ThenUint, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfUint16ThenUint) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfUint16ThenUint) Push(ctx context.Context, req *WorkOfUint16ThenUint) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfUint16ThenUint)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfUint16ThenUint = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfUint16ThenUint) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfUint16ThenUint) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfUint16ThenUint) Call(ctx context.Context, arg uint16) (uint, error) {
	return __.api_syncer.DoOfUint16ThenUint(ctx, __, arg)
}

type PoolOfUint16ThenUint16 interface {
	GetUint16Arg() *uint16
	PutUint16Arg(*uint16)
	GetUint16Return() *uint16
	PutUint16Return(*uint16)

	GetWorkOfUint16ThenUint16() *WorkOfUint16ThenUint16
	GetReturnOfUint16() *ReturnOfUint16
	PutWorkOfUint16ThenUint16(*WorkOfUint16ThenUint16)
	PutReturnOfUint16(*ReturnOfUint16)

	GetChReturnOfUint16() chan *ReturnOfUint16
	PutChReturnOfUint16(chan *ReturnOfUint16)
}

type PoolOfUint16ThenUint16Impl struct {
	Uint16Arg        sync.Pool
	Uint16Rtn        sync.Pool
	Uint16Work       sync.Pool
	Uint16Return     sync.Pool
	ChReturnOfUint16 sync.Pool
}

func (__ *PoolOfUint16ThenUint16Impl) GetUint16Arg() *uint16 {
	return __.Uint16Arg.Get().(*uint16)
}
func (__ *PoolOfUint16ThenUint16Impl) PutUint16Arg(p *uint16) {
	__.Uint16Arg.Put(p)
}
func (__ *PoolOfUint16ThenUint16Impl) GetUint16Return() *uint16 {
	return __.Uint16Rtn.Get().(*uint16)
}
func (__ *PoolOfUint16ThenUint16Impl) PutUint16Return(p *uint16) {
	__.Uint16Rtn.Put(p)
}

func (__ *PoolOfUint16ThenUint16Impl) GetWorkOfUint16ThenUint16() *WorkOfUint16ThenUint16 {
	return __.Uint16Work.Get().(*WorkOfUint16ThenUint16)
}
func (__ *PoolOfUint16ThenUint16Impl) PutWorkOfUint16ThenUint16(p *WorkOfUint16ThenUint16) {
	__.Uint16Work.Put(p)
}
func (__ *PoolOfUint16ThenUint16Impl) GetReturnOfUint16() *ReturnOfUint16 {
	return __.Uint16Return.Get().(*ReturnOfUint16)
}
func (__ *PoolOfUint16ThenUint16Impl) PutReturnOfUint16(p *ReturnOfUint16) {
	__.Uint16Return.Put(p)
}

func (__ *PoolOfUint16ThenUint16Impl) GetChReturnOfUint16() chan *ReturnOfUint16 {
	return __.ChReturnOfUint16.Get().(chan *ReturnOfUint16)
}
func (__ *PoolOfUint16ThenUint16Impl) PutChReturnOfUint16(p chan *ReturnOfUint16) {
	__.ChReturnOfUint16.Put(p)
}

func NewPoolOfUint16ThenUint16Impl() *PoolOfUint16ThenUint16Impl {
	return &PoolOfUint16ThenUint16Impl{
		Uint16Arg: sync.Pool{
			New: func() interface{} {
				return new(uint16)
			},
		},
		Uint16Work: sync.Pool{
			New: func() interface{} {
				return new(WorkOfUint16ThenUint16)
			},
		},
		Uint16Rtn: sync.Pool{
			New: func() interface{} {
				return new(uint16)
			},
		},
		Uint16Return: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfUint16)
			},
		},
		ChReturnOfUint16: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfUint16, 1)
			},
		},
	}
}

type ApiDecouplerOfUint16ThenUint16 struct {
	pool PoolOfUint16ThenUint16
}

func NewApiDecouplerOfUint16ThenUint16() *ApiDecouplerOfUint16ThenUint16 {
	return &ApiDecouplerOfUint16ThenUint16{
		pool: NewPoolOfUint16ThenUint16Impl(),
	}
}

func (__ *ApiDecouplerOfUint16ThenUint16) ReturnError(rtn_ch chan<- *ReturnOfUint16, err error) {
	rtn := __.pool.GetReturnOfUint16()
	var other uint16
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfUint16ThenUint16) HandleOfUint16ThenUint16(ctx context.Context, req *WorkOfUint16ThenUint16, h func(ctx context.Context, arg uint16) (uint16, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfUint16()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfUint16ThenUint16) DoOfUint16ThenUint16(ctx context.Context, worker WorkerOfPushUint16ThenUint16, arg uint16) (uint16, error) {
	// ch := make(chan *ReturnOfUint16, 1)
	ch := __.pool.GetChReturnOfUint16()
	defer __.pool.PutChReturnOfUint16(ch)

	req := __.pool.GetWorkOfUint16ThenUint16()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfUint16ThenUint16(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfUint16(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfUint16ThenUint16 = func(ctx context.Context, arg uint16) (uint16, error)

type WorkerOfUint16ThenUint16 struct {
	api_syncer *ApiDecouplerOfUint16ThenUint16
	handler    WorkHandlerOfUint16ThenUint16

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfUint16ThenUint16
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfUint16ThenUint16(ctx context.Context, h WorkHandlerOfUint16ThenUint16, n int) *WorkerOfUint16ThenUint16 {
	__ := &WorkerOfUint16ThenUint16{
		api_syncer: NewApiDecouplerOfUint16ThenUint16(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfUint16ThenUint16, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfUint16ThenUint16{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfUint16ThenUint16(req.Context, req.WorkOfUint16ThenUint16, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfUint16ThenUint16) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfUint16ThenUint16) Push(ctx context.Context, req *WorkOfUint16ThenUint16) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfUint16ThenUint16)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfUint16ThenUint16 = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfUint16ThenUint16) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfUint16ThenUint16) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfUint16ThenUint16) Call(ctx context.Context, arg uint16) (uint16, error) {
	return __.api_syncer.DoOfUint16ThenUint16(ctx, __, arg)
}

type PoolOfUint16ThenUint32 interface {
	GetUint16Arg() *uint16
	PutUint16Arg(*uint16)
	GetUint32Return() *uint32
	PutUint32Return(*uint32)

	GetWorkOfUint16ThenUint32() *WorkOfUint16ThenUint32
	GetReturnOfUint32() *ReturnOfUint32
	PutWorkOfUint16ThenUint32(*WorkOfUint16ThenUint32)
	PutReturnOfUint32(*ReturnOfUint32)

	GetChReturnOfUint32() chan *ReturnOfUint32
	PutChReturnOfUint32(chan *ReturnOfUint32)
}

type PoolOfUint16ThenUint32Impl struct {
	Uint16Arg        sync.Pool
	Uint32Rtn        sync.Pool
	Uint16Work       sync.Pool
	Uint32Return     sync.Pool
	ChReturnOfUint32 sync.Pool
}

func (__ *PoolOfUint16ThenUint32Impl) GetUint16Arg() *uint16 {
	return __.Uint16Arg.Get().(*uint16)
}
func (__ *PoolOfUint16ThenUint32Impl) PutUint16Arg(p *uint16) {
	__.Uint16Arg.Put(p)
}
func (__ *PoolOfUint16ThenUint32Impl) GetUint32Return() *uint32 {
	return __.Uint32Rtn.Get().(*uint32)
}
func (__ *PoolOfUint16ThenUint32Impl) PutUint32Return(p *uint32) {
	__.Uint32Rtn.Put(p)
}

func (__ *PoolOfUint16ThenUint32Impl) GetWorkOfUint16ThenUint32() *WorkOfUint16ThenUint32 {
	return __.Uint16Work.Get().(*WorkOfUint16ThenUint32)
}
func (__ *PoolOfUint16ThenUint32Impl) PutWorkOfUint16ThenUint32(p *WorkOfUint16ThenUint32) {
	__.Uint16Work.Put(p)
}
func (__ *PoolOfUint16ThenUint32Impl) GetReturnOfUint32() *ReturnOfUint32 {
	return __.Uint32Return.Get().(*ReturnOfUint32)
}
func (__ *PoolOfUint16ThenUint32Impl) PutReturnOfUint32(p *ReturnOfUint32) {
	__.Uint32Return.Put(p)
}

func (__ *PoolOfUint16ThenUint32Impl) GetChReturnOfUint32() chan *ReturnOfUint32 {
	return __.ChReturnOfUint32.Get().(chan *ReturnOfUint32)
}
func (__ *PoolOfUint16ThenUint32Impl) PutChReturnOfUint32(p chan *ReturnOfUint32) {
	__.ChReturnOfUint32.Put(p)
}

func NewPoolOfUint16ThenUint32Impl() *PoolOfUint16ThenUint32Impl {
	return &PoolOfUint16ThenUint32Impl{
		Uint16Arg: sync.Pool{
			New: func() interface{} {
				return new(uint16)
			},
		},
		Uint16Work: sync.Pool{
			New: func() interface{} {
				return new(WorkOfUint16ThenUint32)
			},
		},
		Uint32Rtn: sync.Pool{
			New: func() interface{} {
				return new(uint32)
			},
		},
		Uint32Return: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfUint32)
			},
		},
		ChReturnOfUint32: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfUint32, 1)
			},
		},
	}
}

type ApiDecouplerOfUint16ThenUint32 struct {
	pool PoolOfUint16ThenUint32
}

func NewApiDecouplerOfUint16ThenUint32() *ApiDecouplerOfUint16ThenUint32 {
	return &ApiDecouplerOfUint16ThenUint32{
		pool: NewPoolOfUint16ThenUint32Impl(),
	}
}

func (__ *ApiDecouplerOfUint16ThenUint32) ReturnError(rtn_ch chan<- *ReturnOfUint32, err error) {
	rtn := __.pool.GetReturnOfUint32()
	var other uint32
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfUint16ThenUint32) HandleOfUint16ThenUint32(ctx context.Context, req *WorkOfUint16ThenUint32, h func(ctx context.Context, arg uint16) (uint32, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfUint32()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfUint16ThenUint32) DoOfUint16ThenUint32(ctx context.Context, worker WorkerOfPushUint16ThenUint32, arg uint16) (uint32, error) {
	// ch := make(chan *ReturnOfUint32, 1)
	ch := __.pool.GetChReturnOfUint32()
	defer __.pool.PutChReturnOfUint32(ch)

	req := __.pool.GetWorkOfUint16ThenUint32()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfUint16ThenUint32(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfUint32(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfUint16ThenUint32 = func(ctx context.Context, arg uint16) (uint32, error)

type WorkerOfUint16ThenUint32 struct {
	api_syncer *ApiDecouplerOfUint16ThenUint32
	handler    WorkHandlerOfUint16ThenUint32

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfUint16ThenUint32
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfUint16ThenUint32(ctx context.Context, h WorkHandlerOfUint16ThenUint32, n int) *WorkerOfUint16ThenUint32 {
	__ := &WorkerOfUint16ThenUint32{
		api_syncer: NewApiDecouplerOfUint16ThenUint32(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfUint16ThenUint32, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfUint16ThenUint32{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfUint16ThenUint32(req.Context, req.WorkOfUint16ThenUint32, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfUint16ThenUint32) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfUint16ThenUint32) Push(ctx context.Context, req *WorkOfUint16ThenUint32) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfUint16ThenUint32)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfUint16ThenUint32 = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfUint16ThenUint32) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfUint16ThenUint32) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfUint16ThenUint32) Call(ctx context.Context, arg uint16) (uint32, error) {
	return __.api_syncer.DoOfUint16ThenUint32(ctx, __, arg)
}

type PoolOfUint16ThenUint64 interface {
	GetUint16Arg() *uint16
	PutUint16Arg(*uint16)
	GetUint64Return() *uint64
	PutUint64Return(*uint64)

	GetWorkOfUint16ThenUint64() *WorkOfUint16ThenUint64
	GetReturnOfUint64() *ReturnOfUint64
	PutWorkOfUint16ThenUint64(*WorkOfUint16ThenUint64)
	PutReturnOfUint64(*ReturnOfUint64)

	GetChReturnOfUint64() chan *ReturnOfUint64
	PutChReturnOfUint64(chan *ReturnOfUint64)
}

type PoolOfUint16ThenUint64Impl struct {
	Uint16Arg        sync.Pool
	Uint64Rtn        sync.Pool
	Uint16Work       sync.Pool
	Uint64Return     sync.Pool
	ChReturnOfUint64 sync.Pool
}

func (__ *PoolOfUint16ThenUint64Impl) GetUint16Arg() *uint16 {
	return __.Uint16Arg.Get().(*uint16)
}
func (__ *PoolOfUint16ThenUint64Impl) PutUint16Arg(p *uint16) {
	__.Uint16Arg.Put(p)
}
func (__ *PoolOfUint16ThenUint64Impl) GetUint64Return() *uint64 {
	return __.Uint64Rtn.Get().(*uint64)
}
func (__ *PoolOfUint16ThenUint64Impl) PutUint64Return(p *uint64) {
	__.Uint64Rtn.Put(p)
}

func (__ *PoolOfUint16ThenUint64Impl) GetWorkOfUint16ThenUint64() *WorkOfUint16ThenUint64 {
	return __.Uint16Work.Get().(*WorkOfUint16ThenUint64)
}
func (__ *PoolOfUint16ThenUint64Impl) PutWorkOfUint16ThenUint64(p *WorkOfUint16ThenUint64) {
	__.Uint16Work.Put(p)
}
func (__ *PoolOfUint16ThenUint64Impl) GetReturnOfUint64() *ReturnOfUint64 {
	return __.Uint64Return.Get().(*ReturnOfUint64)
}
func (__ *PoolOfUint16ThenUint64Impl) PutReturnOfUint64(p *ReturnOfUint64) {
	__.Uint64Return.Put(p)
}

func (__ *PoolOfUint16ThenUint64Impl) GetChReturnOfUint64() chan *ReturnOfUint64 {
	return __.ChReturnOfUint64.Get().(chan *ReturnOfUint64)
}
func (__ *PoolOfUint16ThenUint64Impl) PutChReturnOfUint64(p chan *ReturnOfUint64) {
	__.ChReturnOfUint64.Put(p)
}

func NewPoolOfUint16ThenUint64Impl() *PoolOfUint16ThenUint64Impl {
	return &PoolOfUint16ThenUint64Impl{
		Uint16Arg: sync.Pool{
			New: func() interface{} {
				return new(uint16)
			},
		},
		Uint16Work: sync.Pool{
			New: func() interface{} {
				return new(WorkOfUint16ThenUint64)
			},
		},
		Uint64Rtn: sync.Pool{
			New: func() interface{} {
				return new(uint64)
			},
		},
		Uint64Return: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfUint64)
			},
		},
		ChReturnOfUint64: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfUint64, 1)
			},
		},
	}
}

type ApiDecouplerOfUint16ThenUint64 struct {
	pool PoolOfUint16ThenUint64
}

func NewApiDecouplerOfUint16ThenUint64() *ApiDecouplerOfUint16ThenUint64 {
	return &ApiDecouplerOfUint16ThenUint64{
		pool: NewPoolOfUint16ThenUint64Impl(),
	}
}

func (__ *ApiDecouplerOfUint16ThenUint64) ReturnError(rtn_ch chan<- *ReturnOfUint64, err error) {
	rtn := __.pool.GetReturnOfUint64()
	var other uint64
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfUint16ThenUint64) HandleOfUint16ThenUint64(ctx context.Context, req *WorkOfUint16ThenUint64, h func(ctx context.Context, arg uint16) (uint64, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfUint64()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfUint16ThenUint64) DoOfUint16ThenUint64(ctx context.Context, worker WorkerOfPushUint16ThenUint64, arg uint16) (uint64, error) {
	// ch := make(chan *ReturnOfUint64, 1)
	ch := __.pool.GetChReturnOfUint64()
	defer __.pool.PutChReturnOfUint64(ch)

	req := __.pool.GetWorkOfUint16ThenUint64()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfUint16ThenUint64(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfUint64(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfUint16ThenUint64 = func(ctx context.Context, arg uint16) (uint64, error)

type WorkerOfUint16ThenUint64 struct {
	api_syncer *ApiDecouplerOfUint16ThenUint64
	handler    WorkHandlerOfUint16ThenUint64

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfUint16ThenUint64
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfUint16ThenUint64(ctx context.Context, h WorkHandlerOfUint16ThenUint64, n int) *WorkerOfUint16ThenUint64 {
	__ := &WorkerOfUint16ThenUint64{
		api_syncer: NewApiDecouplerOfUint16ThenUint64(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfUint16ThenUint64, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfUint16ThenUint64{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfUint16ThenUint64(req.Context, req.WorkOfUint16ThenUint64, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfUint16ThenUint64) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfUint16ThenUint64) Push(ctx context.Context, req *WorkOfUint16ThenUint64) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfUint16ThenUint64)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfUint16ThenUint64 = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfUint16ThenUint64) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfUint16ThenUint64) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfUint16ThenUint64) Call(ctx context.Context, arg uint16) (uint64, error) {
	return __.api_syncer.DoOfUint16ThenUint64(ctx, __, arg)
}

type PoolOfUint16ThenUint8 interface {
	GetUint16Arg() *uint16
	PutUint16Arg(*uint16)
	GetUint8Return() *uint8
	PutUint8Return(*uint8)

	GetWorkOfUint16ThenUint8() *WorkOfUint16ThenUint8
	GetReturnOfUint8() *ReturnOfUint8
	PutWorkOfUint16ThenUint8(*WorkOfUint16ThenUint8)
	PutReturnOfUint8(*ReturnOfUint8)

	GetChReturnOfUint8() chan *ReturnOfUint8
	PutChReturnOfUint8(chan *ReturnOfUint8)
}

type PoolOfUint16ThenUint8Impl struct {
	Uint16Arg       sync.Pool
	Uint8Rtn        sync.Pool
	Uint16Work      sync.Pool
	Uint8Return     sync.Pool
	ChReturnOfUint8 sync.Pool
}

func (__ *PoolOfUint16ThenUint8Impl) GetUint16Arg() *uint16 {
	return __.Uint16Arg.Get().(*uint16)
}
func (__ *PoolOfUint16ThenUint8Impl) PutUint16Arg(p *uint16) {
	__.Uint16Arg.Put(p)
}
func (__ *PoolOfUint16ThenUint8Impl) GetUint8Return() *uint8 {
	return __.Uint8Rtn.Get().(*uint8)
}
func (__ *PoolOfUint16ThenUint8Impl) PutUint8Return(p *uint8) {
	__.Uint8Rtn.Put(p)
}

func (__ *PoolOfUint16ThenUint8Impl) GetWorkOfUint16ThenUint8() *WorkOfUint16ThenUint8 {
	return __.Uint16Work.Get().(*WorkOfUint16ThenUint8)
}
func (__ *PoolOfUint16ThenUint8Impl) PutWorkOfUint16ThenUint8(p *WorkOfUint16ThenUint8) {
	__.Uint16Work.Put(p)
}
func (__ *PoolOfUint16ThenUint8Impl) GetReturnOfUint8() *ReturnOfUint8 {
	return __.Uint8Return.Get().(*ReturnOfUint8)
}
func (__ *PoolOfUint16ThenUint8Impl) PutReturnOfUint8(p *ReturnOfUint8) {
	__.Uint8Return.Put(p)
}

func (__ *PoolOfUint16ThenUint8Impl) GetChReturnOfUint8() chan *ReturnOfUint8 {
	return __.ChReturnOfUint8.Get().(chan *ReturnOfUint8)
}
func (__ *PoolOfUint16ThenUint8Impl) PutChReturnOfUint8(p chan *ReturnOfUint8) {
	__.ChReturnOfUint8.Put(p)
}

func NewPoolOfUint16ThenUint8Impl() *PoolOfUint16ThenUint8Impl {
	return &PoolOfUint16ThenUint8Impl{
		Uint16Arg: sync.Pool{
			New: func() interface{} {
				return new(uint16)
			},
		},
		Uint16Work: sync.Pool{
			New: func() interface{} {
				return new(WorkOfUint16ThenUint8)
			},
		},
		Uint8Rtn: sync.Pool{
			New: func() interface{} {
				return new(uint8)
			},
		},
		Uint8Return: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfUint8)
			},
		},
		ChReturnOfUint8: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfUint8, 1)
			},
		},
	}
}

type ApiDecouplerOfUint16ThenUint8 struct {
	pool PoolOfUint16ThenUint8
}

func NewApiDecouplerOfUint16ThenUint8() *ApiDecouplerOfUint16ThenUint8 {
	return &ApiDecouplerOfUint16ThenUint8{
		pool: NewPoolOfUint16ThenUint8Impl(),
	}
}

func (__ *ApiDecouplerOfUint16ThenUint8) ReturnError(rtn_ch chan<- *ReturnOfUint8, err error) {
	rtn := __.pool.GetReturnOfUint8()
	var other uint8
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfUint16ThenUint8) HandleOfUint16ThenUint8(ctx context.Context, req *WorkOfUint16ThenUint8, h func(ctx context.Context, arg uint16) (uint8, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfUint8()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfUint16ThenUint8) DoOfUint16ThenUint8(ctx context.Context, worker WorkerOfPushUint16ThenUint8, arg uint16) (uint8, error) {
	// ch := make(chan *ReturnOfUint8, 1)
	ch := __.pool.GetChReturnOfUint8()
	defer __.pool.PutChReturnOfUint8(ch)

	req := __.pool.GetWorkOfUint16ThenUint8()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfUint16ThenUint8(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfUint8(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfUint16ThenUint8 = func(ctx context.Context, arg uint16) (uint8, error)

type WorkerOfUint16ThenUint8 struct {
	api_syncer *ApiDecouplerOfUint16ThenUint8
	handler    WorkHandlerOfUint16ThenUint8

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfUint16ThenUint8
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfUint16ThenUint8(ctx context.Context, h WorkHandlerOfUint16ThenUint8, n int) *WorkerOfUint16ThenUint8 {
	__ := &WorkerOfUint16ThenUint8{
		api_syncer: NewApiDecouplerOfUint16ThenUint8(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfUint16ThenUint8, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfUint16ThenUint8{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfUint16ThenUint8(req.Context, req.WorkOfUint16ThenUint8, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfUint16ThenUint8) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfUint16ThenUint8) Push(ctx context.Context, req *WorkOfUint16ThenUint8) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfUint16ThenUint8)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfUint16ThenUint8 = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfUint16ThenUint8) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfUint16ThenUint8) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfUint16ThenUint8) Call(ctx context.Context, arg uint16) (uint8, error) {
	return __.api_syncer.DoOfUint16ThenUint8(ctx, __, arg)
}

type PoolOfUint16ThenUintptr interface {
	GetUint16Arg() *uint16
	PutUint16Arg(*uint16)
	GetUintptrReturn() *uintptr
	PutUintptrReturn(*uintptr)

	GetWorkOfUint16ThenUintptr() *WorkOfUint16ThenUintptr
	GetReturnOfUintptr() *ReturnOfUintptr
	PutWorkOfUint16ThenUintptr(*WorkOfUint16ThenUintptr)
	PutReturnOfUintptr(*ReturnOfUintptr)

	GetChReturnOfUintptr() chan *ReturnOfUintptr
	PutChReturnOfUintptr(chan *ReturnOfUintptr)
}

type PoolOfUint16ThenUintptrImpl struct {
	Uint16Arg         sync.Pool
	UintptrRtn        sync.Pool
	Uint16Work        sync.Pool
	UintptrReturn     sync.Pool
	ChReturnOfUintptr sync.Pool
}

func (__ *PoolOfUint16ThenUintptrImpl) GetUint16Arg() *uint16 {
	return __.Uint16Arg.Get().(*uint16)
}
func (__ *PoolOfUint16ThenUintptrImpl) PutUint16Arg(p *uint16) {
	__.Uint16Arg.Put(p)
}
func (__ *PoolOfUint16ThenUintptrImpl) GetUintptrReturn() *uintptr {
	return __.UintptrRtn.Get().(*uintptr)
}
func (__ *PoolOfUint16ThenUintptrImpl) PutUintptrReturn(p *uintptr) {
	__.UintptrRtn.Put(p)
}

func (__ *PoolOfUint16ThenUintptrImpl) GetWorkOfUint16ThenUintptr() *WorkOfUint16ThenUintptr {
	return __.Uint16Work.Get().(*WorkOfUint16ThenUintptr)
}
func (__ *PoolOfUint16ThenUintptrImpl) PutWorkOfUint16ThenUintptr(p *WorkOfUint16ThenUintptr) {
	__.Uint16Work.Put(p)
}
func (__ *PoolOfUint16ThenUintptrImpl) GetReturnOfUintptr() *ReturnOfUintptr {
	return __.UintptrReturn.Get().(*ReturnOfUintptr)
}
func (__ *PoolOfUint16ThenUintptrImpl) PutReturnOfUintptr(p *ReturnOfUintptr) {
	__.UintptrReturn.Put(p)
}

func (__ *PoolOfUint16ThenUintptrImpl) GetChReturnOfUintptr() chan *ReturnOfUintptr {
	return __.ChReturnOfUintptr.Get().(chan *ReturnOfUintptr)
}
func (__ *PoolOfUint16ThenUintptrImpl) PutChReturnOfUintptr(p chan *ReturnOfUintptr) {
	__.ChReturnOfUintptr.Put(p)
}

func NewPoolOfUint16ThenUintptrImpl() *PoolOfUint16ThenUintptrImpl {
	return &PoolOfUint16ThenUintptrImpl{
		Uint16Arg: sync.Pool{
			New: func() interface{} {
				return new(uint16)
			},
		},
		Uint16Work: sync.Pool{
			New: func() interface{} {
				return new(WorkOfUint16ThenUintptr)
			},
		},
		UintptrRtn: sync.Pool{
			New: func() interface{} {
				return new(uintptr)
			},
		},
		UintptrReturn: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfUintptr)
			},
		},
		ChReturnOfUintptr: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfUintptr, 1)
			},
		},
	}
}

type ApiDecouplerOfUint16ThenUintptr struct {
	pool PoolOfUint16ThenUintptr
}

func NewApiDecouplerOfUint16ThenUintptr() *ApiDecouplerOfUint16ThenUintptr {
	return &ApiDecouplerOfUint16ThenUintptr{
		pool: NewPoolOfUint16ThenUintptrImpl(),
	}
}

func (__ *ApiDecouplerOfUint16ThenUintptr) ReturnError(rtn_ch chan<- *ReturnOfUintptr, err error) {
	rtn := __.pool.GetReturnOfUintptr()
	var other uintptr
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfUint16ThenUintptr) HandleOfUint16ThenUintptr(ctx context.Context, req *WorkOfUint16ThenUintptr, h func(ctx context.Context, arg uint16) (uintptr, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfUintptr()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfUint16ThenUintptr) DoOfUint16ThenUintptr(ctx context.Context, worker WorkerOfPushUint16ThenUintptr, arg uint16) (uintptr, error) {
	// ch := make(chan *ReturnOfUintptr, 1)
	ch := __.pool.GetChReturnOfUintptr()
	defer __.pool.PutChReturnOfUintptr(ch)

	req := __.pool.GetWorkOfUint16ThenUintptr()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfUint16ThenUintptr(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfUintptr(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfUint16ThenUintptr = func(ctx context.Context, arg uint16) (uintptr, error)

type WorkerOfUint16ThenUintptr struct {
	api_syncer *ApiDecouplerOfUint16ThenUintptr
	handler    WorkHandlerOfUint16ThenUintptr

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfUint16ThenUintptr
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfUint16ThenUintptr(ctx context.Context, h WorkHandlerOfUint16ThenUintptr, n int) *WorkerOfUint16ThenUintptr {
	__ := &WorkerOfUint16ThenUintptr{
		api_syncer: NewApiDecouplerOfUint16ThenUintptr(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfUint16ThenUintptr, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfUint16ThenUintptr{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfUint16ThenUintptr(req.Context, req.WorkOfUint16ThenUintptr, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfUint16ThenUintptr) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfUint16ThenUintptr) Push(ctx context.Context, req *WorkOfUint16ThenUintptr) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfUint16ThenUintptr)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfUint16ThenUintptr = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfUint16ThenUintptr) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfUint16ThenUintptr) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfUint16ThenUintptr) Call(ctx context.Context, arg uint16) (uintptr, error) {
	return __.api_syncer.DoOfUint16ThenUintptr(ctx, __, arg)
}

type PoolOfUint16ThenInterface interface {
	GetUint16Arg() *uint16
	PutUint16Arg(*uint16)
	GetInterfaceReturn() *interface{}
	PutInterfaceReturn(*interface{})

	GetWorkOfUint16ThenInterface() *WorkOfUint16ThenInterface
	GetReturnOfInterface() *ReturnOfInterface
	PutWorkOfUint16ThenInterface(*WorkOfUint16ThenInterface)
	PutReturnOfInterface(*ReturnOfInterface)

	GetChReturnOfInterface() chan *ReturnOfInterface
	PutChReturnOfInterface(chan *ReturnOfInterface)
}

type PoolOfUint16ThenInterfaceImpl struct {
	Uint16Arg           sync.Pool
	InterfaceRtn        sync.Pool
	Uint16Work          sync.Pool
	InterfaceReturn     sync.Pool
	ChReturnOfInterface sync.Pool
}

func (__ *PoolOfUint16ThenInterfaceImpl) GetUint16Arg() *uint16 {
	return __.Uint16Arg.Get().(*uint16)
}
func (__ *PoolOfUint16ThenInterfaceImpl) PutUint16Arg(p *uint16) {
	__.Uint16Arg.Put(p)
}
func (__ *PoolOfUint16ThenInterfaceImpl) GetInterfaceReturn() *interface{} {
	return __.InterfaceRtn.Get().(*interface{})
}
func (__ *PoolOfUint16ThenInterfaceImpl) PutInterfaceReturn(p *interface{}) {
	__.InterfaceRtn.Put(p)
}

func (__ *PoolOfUint16ThenInterfaceImpl) GetWorkOfUint16ThenInterface() *WorkOfUint16ThenInterface {
	return __.Uint16Work.Get().(*WorkOfUint16ThenInterface)
}
func (__ *PoolOfUint16ThenInterfaceImpl) PutWorkOfUint16ThenInterface(p *WorkOfUint16ThenInterface) {
	__.Uint16Work.Put(p)
}
func (__ *PoolOfUint16ThenInterfaceImpl) GetReturnOfInterface() *ReturnOfInterface {
	return __.InterfaceReturn.Get().(*ReturnOfInterface)
}
func (__ *PoolOfUint16ThenInterfaceImpl) PutReturnOfInterface(p *ReturnOfInterface) {
	__.InterfaceReturn.Put(p)
}

func (__ *PoolOfUint16ThenInterfaceImpl) GetChReturnOfInterface() chan *ReturnOfInterface {
	return __.ChReturnOfInterface.Get().(chan *ReturnOfInterface)
}
func (__ *PoolOfUint16ThenInterfaceImpl) PutChReturnOfInterface(p chan *ReturnOfInterface) {
	__.ChReturnOfInterface.Put(p)
}

func NewPoolOfUint16ThenInterfaceImpl() *PoolOfUint16ThenInterfaceImpl {
	return &PoolOfUint16ThenInterfaceImpl{
		Uint16Arg: sync.Pool{
			New: func() interface{} {
				return new(uint16)
			},
		},
		Uint16Work: sync.Pool{
			New: func() interface{} {
				return new(WorkOfUint16ThenInterface)
			},
		},
		InterfaceRtn: sync.Pool{
			New: func() interface{} {
				return new(interface{})
			},
		},
		InterfaceReturn: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfInterface)
			},
		},
		ChReturnOfInterface: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfInterface, 1)
			},
		},
	}
}

type ApiDecouplerOfUint16ThenInterface struct {
	pool PoolOfUint16ThenInterface
}

func NewApiDecouplerOfUint16ThenInterface() *ApiDecouplerOfUint16ThenInterface {
	return &ApiDecouplerOfUint16ThenInterface{
		pool: NewPoolOfUint16ThenInterfaceImpl(),
	}
}

func (__ *ApiDecouplerOfUint16ThenInterface) ReturnError(rtn_ch chan<- *ReturnOfInterface, err error) {
	rtn := __.pool.GetReturnOfInterface()
	var other interface{}
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfUint16ThenInterface) HandleOfUint16ThenInterface(ctx context.Context, req *WorkOfUint16ThenInterface, h func(ctx context.Context, arg uint16) (interface{}, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfInterface()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfUint16ThenInterface) DoOfUint16ThenInterface(ctx context.Context, worker WorkerOfPushUint16ThenInterface, arg uint16) (interface{}, error) {
	// ch := make(chan *ReturnOfInterface, 1)
	ch := __.pool.GetChReturnOfInterface()
	defer __.pool.PutChReturnOfInterface(ch)

	req := __.pool.GetWorkOfUint16ThenInterface()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfUint16ThenInterface(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfInterface(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfUint16ThenInterface = func(ctx context.Context, arg uint16) (interface{}, error)

type WorkerOfUint16ThenInterface struct {
	api_syncer *ApiDecouplerOfUint16ThenInterface
	handler    WorkHandlerOfUint16ThenInterface

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfUint16ThenInterface
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfUint16ThenInterface(ctx context.Context, h WorkHandlerOfUint16ThenInterface, n int) *WorkerOfUint16ThenInterface {
	__ := &WorkerOfUint16ThenInterface{
		api_syncer: NewApiDecouplerOfUint16ThenInterface(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfUint16ThenInterface, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfUint16ThenInterface{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfUint16ThenInterface(req.Context, req.WorkOfUint16ThenInterface, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfUint16ThenInterface) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfUint16ThenInterface) Push(ctx context.Context, req *WorkOfUint16ThenInterface) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfUint16ThenInterface)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfUint16ThenInterface = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfUint16ThenInterface) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfUint16ThenInterface) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfUint16ThenInterface) Call(ctx context.Context, arg uint16) (interface{}, error) {
	return __.api_syncer.DoOfUint16ThenInterface(ctx, __, arg)
}

type PoolOfUint16ThenStruct interface {
	GetUint16Arg() *uint16
	PutUint16Arg(*uint16)
	GetStructReturn() *struct{}
	PutStructReturn(*struct{})

	GetWorkOfUint16ThenStruct() *WorkOfUint16ThenStruct
	GetReturnOfStruct() *ReturnOfStruct
	PutWorkOfUint16ThenStruct(*WorkOfUint16ThenStruct)
	PutReturnOfStruct(*ReturnOfStruct)

	GetChReturnOfStruct() chan *ReturnOfStruct
	PutChReturnOfStruct(chan *ReturnOfStruct)
}

type PoolOfUint16ThenStructImpl struct {
	Uint16Arg        sync.Pool
	StructRtn        sync.Pool
	Uint16Work       sync.Pool
	StructReturn     sync.Pool
	ChReturnOfStruct sync.Pool
}

func (__ *PoolOfUint16ThenStructImpl) GetUint16Arg() *uint16 {
	return __.Uint16Arg.Get().(*uint16)
}
func (__ *PoolOfUint16ThenStructImpl) PutUint16Arg(p *uint16) {
	__.Uint16Arg.Put(p)
}
func (__ *PoolOfUint16ThenStructImpl) GetStructReturn() *struct{} {
	return __.StructRtn.Get().(*struct{})
}
func (__ *PoolOfUint16ThenStructImpl) PutStructReturn(p *struct{}) {
	__.StructRtn.Put(p)
}

func (__ *PoolOfUint16ThenStructImpl) GetWorkOfUint16ThenStruct() *WorkOfUint16ThenStruct {
	return __.Uint16Work.Get().(*WorkOfUint16ThenStruct)
}
func (__ *PoolOfUint16ThenStructImpl) PutWorkOfUint16ThenStruct(p *WorkOfUint16ThenStruct) {
	__.Uint16Work.Put(p)
}
func (__ *PoolOfUint16ThenStructImpl) GetReturnOfStruct() *ReturnOfStruct {
	return __.StructReturn.Get().(*ReturnOfStruct)
}
func (__ *PoolOfUint16ThenStructImpl) PutReturnOfStruct(p *ReturnOfStruct) {
	__.StructReturn.Put(p)
}

func (__ *PoolOfUint16ThenStructImpl) GetChReturnOfStruct() chan *ReturnOfStruct {
	return __.ChReturnOfStruct.Get().(chan *ReturnOfStruct)
}
func (__ *PoolOfUint16ThenStructImpl) PutChReturnOfStruct(p chan *ReturnOfStruct) {
	__.ChReturnOfStruct.Put(p)
}

func NewPoolOfUint16ThenStructImpl() *PoolOfUint16ThenStructImpl {
	return &PoolOfUint16ThenStructImpl{
		Uint16Arg: sync.Pool{
			New: func() interface{} {
				return new(uint16)
			},
		},
		Uint16Work: sync.Pool{
			New: func() interface{} {
				return new(WorkOfUint16ThenStruct)
			},
		},
		StructRtn: sync.Pool{
			New: func() interface{} {
				return new(struct{})
			},
		},
		StructReturn: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfStruct)
			},
		},
		ChReturnOfStruct: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfStruct, 1)
			},
		},
	}
}

type ApiDecouplerOfUint16ThenStruct struct {
	pool PoolOfUint16ThenStruct
}

func NewApiDecouplerOfUint16ThenStruct() *ApiDecouplerOfUint16ThenStruct {
	return &ApiDecouplerOfUint16ThenStruct{
		pool: NewPoolOfUint16ThenStructImpl(),
	}
}

func (__ *ApiDecouplerOfUint16ThenStruct) ReturnError(rtn_ch chan<- *ReturnOfStruct, err error) {
	rtn := __.pool.GetReturnOfStruct()
	var other struct{}
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfUint16ThenStruct) HandleOfUint16ThenStruct(ctx context.Context, req *WorkOfUint16ThenStruct, h func(ctx context.Context, arg uint16) (struct{}, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfStruct()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfUint16ThenStruct) DoOfUint16ThenStruct(ctx context.Context, worker WorkerOfPushUint16ThenStruct, arg uint16) (struct{}, error) {
	// ch := make(chan *ReturnOfStruct, 1)
	ch := __.pool.GetChReturnOfStruct()
	defer __.pool.PutChReturnOfStruct(ch)

	req := __.pool.GetWorkOfUint16ThenStruct()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfUint16ThenStruct(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfStruct(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfUint16ThenStruct = func(ctx context.Context, arg uint16) (struct{}, error)

type WorkerOfUint16ThenStruct struct {
	api_syncer *ApiDecouplerOfUint16ThenStruct
	handler    WorkHandlerOfUint16ThenStruct

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfUint16ThenStruct
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfUint16ThenStruct(ctx context.Context, h WorkHandlerOfUint16ThenStruct, n int) *WorkerOfUint16ThenStruct {
	__ := &WorkerOfUint16ThenStruct{
		api_syncer: NewApiDecouplerOfUint16ThenStruct(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfUint16ThenStruct, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfUint16ThenStruct{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfUint16ThenStruct(req.Context, req.WorkOfUint16ThenStruct, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfUint16ThenStruct) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfUint16ThenStruct) Push(ctx context.Context, req *WorkOfUint16ThenStruct) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfUint16ThenStruct)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfUint16ThenStruct = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfUint16ThenStruct) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfUint16ThenStruct) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfUint16ThenStruct) Call(ctx context.Context, arg uint16) (struct{}, error) {
	return __.api_syncer.DoOfUint16ThenStruct(ctx, __, arg)
}

type PoolOfUint32ThenBool interface {
	GetUint32Arg() *uint32
	PutUint32Arg(*uint32)
	GetBoolReturn() *bool
	PutBoolReturn(*bool)

	GetWorkOfUint32ThenBool() *WorkOfUint32ThenBool
	GetReturnOfBool() *ReturnOfBool
	PutWorkOfUint32ThenBool(*WorkOfUint32ThenBool)
	PutReturnOfBool(*ReturnOfBool)

	GetChReturnOfBool() chan *ReturnOfBool
	PutChReturnOfBool(chan *ReturnOfBool)
}

type PoolOfUint32ThenBoolImpl struct {
	Uint32Arg      sync.Pool
	BoolRtn        sync.Pool
	Uint32Work     sync.Pool
	BoolReturn     sync.Pool
	ChReturnOfBool sync.Pool
}

func (__ *PoolOfUint32ThenBoolImpl) GetUint32Arg() *uint32 {
	return __.Uint32Arg.Get().(*uint32)
}
func (__ *PoolOfUint32ThenBoolImpl) PutUint32Arg(p *uint32) {
	__.Uint32Arg.Put(p)
}
func (__ *PoolOfUint32ThenBoolImpl) GetBoolReturn() *bool {
	return __.BoolRtn.Get().(*bool)
}
func (__ *PoolOfUint32ThenBoolImpl) PutBoolReturn(p *bool) {
	__.BoolRtn.Put(p)
}

func (__ *PoolOfUint32ThenBoolImpl) GetWorkOfUint32ThenBool() *WorkOfUint32ThenBool {
	return __.Uint32Work.Get().(*WorkOfUint32ThenBool)
}
func (__ *PoolOfUint32ThenBoolImpl) PutWorkOfUint32ThenBool(p *WorkOfUint32ThenBool) {
	__.Uint32Work.Put(p)
}
func (__ *PoolOfUint32ThenBoolImpl) GetReturnOfBool() *ReturnOfBool {
	return __.BoolReturn.Get().(*ReturnOfBool)
}
func (__ *PoolOfUint32ThenBoolImpl) PutReturnOfBool(p *ReturnOfBool) {
	__.BoolReturn.Put(p)
}

func (__ *PoolOfUint32ThenBoolImpl) GetChReturnOfBool() chan *ReturnOfBool {
	return __.ChReturnOfBool.Get().(chan *ReturnOfBool)
}
func (__ *PoolOfUint32ThenBoolImpl) PutChReturnOfBool(p chan *ReturnOfBool) {
	__.ChReturnOfBool.Put(p)
}

func NewPoolOfUint32ThenBoolImpl() *PoolOfUint32ThenBoolImpl {
	return &PoolOfUint32ThenBoolImpl{
		Uint32Arg: sync.Pool{
			New: func() interface{} {
				return new(uint32)
			},
		},
		Uint32Work: sync.Pool{
			New: func() interface{} {
				return new(WorkOfUint32ThenBool)
			},
		},
		BoolRtn: sync.Pool{
			New: func() interface{} {
				return new(bool)
			},
		},
		BoolReturn: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfBool)
			},
		},
		ChReturnOfBool: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfBool, 1)
			},
		},
	}
}

type ApiDecouplerOfUint32ThenBool struct {
	pool PoolOfUint32ThenBool
}

func NewApiDecouplerOfUint32ThenBool() *ApiDecouplerOfUint32ThenBool {
	return &ApiDecouplerOfUint32ThenBool{
		pool: NewPoolOfUint32ThenBoolImpl(),
	}
}

func (__ *ApiDecouplerOfUint32ThenBool) ReturnError(rtn_ch chan<- *ReturnOfBool, err error) {
	rtn := __.pool.GetReturnOfBool()
	var other bool
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfUint32ThenBool) HandleOfUint32ThenBool(ctx context.Context, req *WorkOfUint32ThenBool, h func(ctx context.Context, arg uint32) (bool, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfBool()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfUint32ThenBool) DoOfUint32ThenBool(ctx context.Context, worker WorkerOfPushUint32ThenBool, arg uint32) (bool, error) {
	// ch := make(chan *ReturnOfBool, 1)
	ch := __.pool.GetChReturnOfBool()
	defer __.pool.PutChReturnOfBool(ch)

	req := __.pool.GetWorkOfUint32ThenBool()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfUint32ThenBool(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfBool(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfUint32ThenBool = func(ctx context.Context, arg uint32) (bool, error)

type WorkerOfUint32ThenBool struct {
	api_syncer *ApiDecouplerOfUint32ThenBool
	handler    WorkHandlerOfUint32ThenBool

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfUint32ThenBool
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfUint32ThenBool(ctx context.Context, h WorkHandlerOfUint32ThenBool, n int) *WorkerOfUint32ThenBool {
	__ := &WorkerOfUint32ThenBool{
		api_syncer: NewApiDecouplerOfUint32ThenBool(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfUint32ThenBool, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfUint32ThenBool{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfUint32ThenBool(req.Context, req.WorkOfUint32ThenBool, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfUint32ThenBool) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfUint32ThenBool) Push(ctx context.Context, req *WorkOfUint32ThenBool) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfUint32ThenBool)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfUint32ThenBool = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfUint32ThenBool) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfUint32ThenBool) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfUint32ThenBool) Call(ctx context.Context, arg uint32) (bool, error) {
	return __.api_syncer.DoOfUint32ThenBool(ctx, __, arg)
}

type PoolOfUint32ThenByte interface {
	GetUint32Arg() *uint32
	PutUint32Arg(*uint32)
	GetByteReturn() *byte
	PutByteReturn(*byte)

	GetWorkOfUint32ThenByte() *WorkOfUint32ThenByte
	GetReturnOfByte() *ReturnOfByte
	PutWorkOfUint32ThenByte(*WorkOfUint32ThenByte)
	PutReturnOfByte(*ReturnOfByte)

	GetChReturnOfByte() chan *ReturnOfByte
	PutChReturnOfByte(chan *ReturnOfByte)
}

type PoolOfUint32ThenByteImpl struct {
	Uint32Arg      sync.Pool
	ByteRtn        sync.Pool
	Uint32Work     sync.Pool
	ByteReturn     sync.Pool
	ChReturnOfByte sync.Pool
}

func (__ *PoolOfUint32ThenByteImpl) GetUint32Arg() *uint32 {
	return __.Uint32Arg.Get().(*uint32)
}
func (__ *PoolOfUint32ThenByteImpl) PutUint32Arg(p *uint32) {
	__.Uint32Arg.Put(p)
}
func (__ *PoolOfUint32ThenByteImpl) GetByteReturn() *byte {
	return __.ByteRtn.Get().(*byte)
}
func (__ *PoolOfUint32ThenByteImpl) PutByteReturn(p *byte) {
	__.ByteRtn.Put(p)
}

func (__ *PoolOfUint32ThenByteImpl) GetWorkOfUint32ThenByte() *WorkOfUint32ThenByte {
	return __.Uint32Work.Get().(*WorkOfUint32ThenByte)
}
func (__ *PoolOfUint32ThenByteImpl) PutWorkOfUint32ThenByte(p *WorkOfUint32ThenByte) {
	__.Uint32Work.Put(p)
}
func (__ *PoolOfUint32ThenByteImpl) GetReturnOfByte() *ReturnOfByte {
	return __.ByteReturn.Get().(*ReturnOfByte)
}
func (__ *PoolOfUint32ThenByteImpl) PutReturnOfByte(p *ReturnOfByte) {
	__.ByteReturn.Put(p)
}

func (__ *PoolOfUint32ThenByteImpl) GetChReturnOfByte() chan *ReturnOfByte {
	return __.ChReturnOfByte.Get().(chan *ReturnOfByte)
}
func (__ *PoolOfUint32ThenByteImpl) PutChReturnOfByte(p chan *ReturnOfByte) {
	__.ChReturnOfByte.Put(p)
}

func NewPoolOfUint32ThenByteImpl() *PoolOfUint32ThenByteImpl {
	return &PoolOfUint32ThenByteImpl{
		Uint32Arg: sync.Pool{
			New: func() interface{} {
				return new(uint32)
			},
		},
		Uint32Work: sync.Pool{
			New: func() interface{} {
				return new(WorkOfUint32ThenByte)
			},
		},
		ByteRtn: sync.Pool{
			New: func() interface{} {
				return new(byte)
			},
		},
		ByteReturn: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfByte)
			},
		},
		ChReturnOfByte: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfByte, 1)
			},
		},
	}
}

type ApiDecouplerOfUint32ThenByte struct {
	pool PoolOfUint32ThenByte
}

func NewApiDecouplerOfUint32ThenByte() *ApiDecouplerOfUint32ThenByte {
	return &ApiDecouplerOfUint32ThenByte{
		pool: NewPoolOfUint32ThenByteImpl(),
	}
}

func (__ *ApiDecouplerOfUint32ThenByte) ReturnError(rtn_ch chan<- *ReturnOfByte, err error) {
	rtn := __.pool.GetReturnOfByte()
	var other byte
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfUint32ThenByte) HandleOfUint32ThenByte(ctx context.Context, req *WorkOfUint32ThenByte, h func(ctx context.Context, arg uint32) (byte, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfByte()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfUint32ThenByte) DoOfUint32ThenByte(ctx context.Context, worker WorkerOfPushUint32ThenByte, arg uint32) (byte, error) {
	// ch := make(chan *ReturnOfByte, 1)
	ch := __.pool.GetChReturnOfByte()
	defer __.pool.PutChReturnOfByte(ch)

	req := __.pool.GetWorkOfUint32ThenByte()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfUint32ThenByte(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfByte(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfUint32ThenByte = func(ctx context.Context, arg uint32) (byte, error)

type WorkerOfUint32ThenByte struct {
	api_syncer *ApiDecouplerOfUint32ThenByte
	handler    WorkHandlerOfUint32ThenByte

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfUint32ThenByte
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfUint32ThenByte(ctx context.Context, h WorkHandlerOfUint32ThenByte, n int) *WorkerOfUint32ThenByte {
	__ := &WorkerOfUint32ThenByte{
		api_syncer: NewApiDecouplerOfUint32ThenByte(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfUint32ThenByte, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfUint32ThenByte{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfUint32ThenByte(req.Context, req.WorkOfUint32ThenByte, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfUint32ThenByte) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfUint32ThenByte) Push(ctx context.Context, req *WorkOfUint32ThenByte) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfUint32ThenByte)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfUint32ThenByte = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfUint32ThenByte) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfUint32ThenByte) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfUint32ThenByte) Call(ctx context.Context, arg uint32) (byte, error) {
	return __.api_syncer.DoOfUint32ThenByte(ctx, __, arg)
}

type PoolOfUint32ThenComplex128 interface {
	GetUint32Arg() *uint32
	PutUint32Arg(*uint32)
	GetComplex128Return() *complex128
	PutComplex128Return(*complex128)

	GetWorkOfUint32ThenComplex128() *WorkOfUint32ThenComplex128
	GetReturnOfComplex128() *ReturnOfComplex128
	PutWorkOfUint32ThenComplex128(*WorkOfUint32ThenComplex128)
	PutReturnOfComplex128(*ReturnOfComplex128)

	GetChReturnOfComplex128() chan *ReturnOfComplex128
	PutChReturnOfComplex128(chan *ReturnOfComplex128)
}

type PoolOfUint32ThenComplex128Impl struct {
	Uint32Arg            sync.Pool
	Complex128Rtn        sync.Pool
	Uint32Work           sync.Pool
	Complex128Return     sync.Pool
	ChReturnOfComplex128 sync.Pool
}

func (__ *PoolOfUint32ThenComplex128Impl) GetUint32Arg() *uint32 {
	return __.Uint32Arg.Get().(*uint32)
}
func (__ *PoolOfUint32ThenComplex128Impl) PutUint32Arg(p *uint32) {
	__.Uint32Arg.Put(p)
}
func (__ *PoolOfUint32ThenComplex128Impl) GetComplex128Return() *complex128 {
	return __.Complex128Rtn.Get().(*complex128)
}
func (__ *PoolOfUint32ThenComplex128Impl) PutComplex128Return(p *complex128) {
	__.Complex128Rtn.Put(p)
}

func (__ *PoolOfUint32ThenComplex128Impl) GetWorkOfUint32ThenComplex128() *WorkOfUint32ThenComplex128 {
	return __.Uint32Work.Get().(*WorkOfUint32ThenComplex128)
}
func (__ *PoolOfUint32ThenComplex128Impl) PutWorkOfUint32ThenComplex128(p *WorkOfUint32ThenComplex128) {
	__.Uint32Work.Put(p)
}
func (__ *PoolOfUint32ThenComplex128Impl) GetReturnOfComplex128() *ReturnOfComplex128 {
	return __.Complex128Return.Get().(*ReturnOfComplex128)
}
func (__ *PoolOfUint32ThenComplex128Impl) PutReturnOfComplex128(p *ReturnOfComplex128) {
	__.Complex128Return.Put(p)
}

func (__ *PoolOfUint32ThenComplex128Impl) GetChReturnOfComplex128() chan *ReturnOfComplex128 {
	return __.ChReturnOfComplex128.Get().(chan *ReturnOfComplex128)
}
func (__ *PoolOfUint32ThenComplex128Impl) PutChReturnOfComplex128(p chan *ReturnOfComplex128) {
	__.ChReturnOfComplex128.Put(p)
}

func NewPoolOfUint32ThenComplex128Impl() *PoolOfUint32ThenComplex128Impl {
	return &PoolOfUint32ThenComplex128Impl{
		Uint32Arg: sync.Pool{
			New: func() interface{} {
				return new(uint32)
			},
		},
		Uint32Work: sync.Pool{
			New: func() interface{} {
				return new(WorkOfUint32ThenComplex128)
			},
		},
		Complex128Rtn: sync.Pool{
			New: func() interface{} {
				return new(complex128)
			},
		},
		Complex128Return: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfComplex128)
			},
		},
		ChReturnOfComplex128: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfComplex128, 1)
			},
		},
	}
}

type ApiDecouplerOfUint32ThenComplex128 struct {
	pool PoolOfUint32ThenComplex128
}

func NewApiDecouplerOfUint32ThenComplex128() *ApiDecouplerOfUint32ThenComplex128 {
	return &ApiDecouplerOfUint32ThenComplex128{
		pool: NewPoolOfUint32ThenComplex128Impl(),
	}
}

func (__ *ApiDecouplerOfUint32ThenComplex128) ReturnError(rtn_ch chan<- *ReturnOfComplex128, err error) {
	rtn := __.pool.GetReturnOfComplex128()
	var other complex128
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfUint32ThenComplex128) HandleOfUint32ThenComplex128(ctx context.Context, req *WorkOfUint32ThenComplex128, h func(ctx context.Context, arg uint32) (complex128, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfComplex128()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfUint32ThenComplex128) DoOfUint32ThenComplex128(ctx context.Context, worker WorkerOfPushUint32ThenComplex128, arg uint32) (complex128, error) {
	// ch := make(chan *ReturnOfComplex128, 1)
	ch := __.pool.GetChReturnOfComplex128()
	defer __.pool.PutChReturnOfComplex128(ch)

	req := __.pool.GetWorkOfUint32ThenComplex128()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfUint32ThenComplex128(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfComplex128(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfUint32ThenComplex128 = func(ctx context.Context, arg uint32) (complex128, error)

type WorkerOfUint32ThenComplex128 struct {
	api_syncer *ApiDecouplerOfUint32ThenComplex128
	handler    WorkHandlerOfUint32ThenComplex128

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfUint32ThenComplex128
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfUint32ThenComplex128(ctx context.Context, h WorkHandlerOfUint32ThenComplex128, n int) *WorkerOfUint32ThenComplex128 {
	__ := &WorkerOfUint32ThenComplex128{
		api_syncer: NewApiDecouplerOfUint32ThenComplex128(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfUint32ThenComplex128, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfUint32ThenComplex128{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfUint32ThenComplex128(req.Context, req.WorkOfUint32ThenComplex128, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfUint32ThenComplex128) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfUint32ThenComplex128) Push(ctx context.Context, req *WorkOfUint32ThenComplex128) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfUint32ThenComplex128)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfUint32ThenComplex128 = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfUint32ThenComplex128) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfUint32ThenComplex128) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfUint32ThenComplex128) Call(ctx context.Context, arg uint32) (complex128, error) {
	return __.api_syncer.DoOfUint32ThenComplex128(ctx, __, arg)
}

type PoolOfUint32ThenComplex64 interface {
	GetUint32Arg() *uint32
	PutUint32Arg(*uint32)
	GetComplex64Return() *complex64
	PutComplex64Return(*complex64)

	GetWorkOfUint32ThenComplex64() *WorkOfUint32ThenComplex64
	GetReturnOfComplex64() *ReturnOfComplex64
	PutWorkOfUint32ThenComplex64(*WorkOfUint32ThenComplex64)
	PutReturnOfComplex64(*ReturnOfComplex64)

	GetChReturnOfComplex64() chan *ReturnOfComplex64
	PutChReturnOfComplex64(chan *ReturnOfComplex64)
}

type PoolOfUint32ThenComplex64Impl struct {
	Uint32Arg           sync.Pool
	Complex64Rtn        sync.Pool
	Uint32Work          sync.Pool
	Complex64Return     sync.Pool
	ChReturnOfComplex64 sync.Pool
}

func (__ *PoolOfUint32ThenComplex64Impl) GetUint32Arg() *uint32 {
	return __.Uint32Arg.Get().(*uint32)
}
func (__ *PoolOfUint32ThenComplex64Impl) PutUint32Arg(p *uint32) {
	__.Uint32Arg.Put(p)
}
func (__ *PoolOfUint32ThenComplex64Impl) GetComplex64Return() *complex64 {
	return __.Complex64Rtn.Get().(*complex64)
}
func (__ *PoolOfUint32ThenComplex64Impl) PutComplex64Return(p *complex64) {
	__.Complex64Rtn.Put(p)
}

func (__ *PoolOfUint32ThenComplex64Impl) GetWorkOfUint32ThenComplex64() *WorkOfUint32ThenComplex64 {
	return __.Uint32Work.Get().(*WorkOfUint32ThenComplex64)
}
func (__ *PoolOfUint32ThenComplex64Impl) PutWorkOfUint32ThenComplex64(p *WorkOfUint32ThenComplex64) {
	__.Uint32Work.Put(p)
}
func (__ *PoolOfUint32ThenComplex64Impl) GetReturnOfComplex64() *ReturnOfComplex64 {
	return __.Complex64Return.Get().(*ReturnOfComplex64)
}
func (__ *PoolOfUint32ThenComplex64Impl) PutReturnOfComplex64(p *ReturnOfComplex64) {
	__.Complex64Return.Put(p)
}

func (__ *PoolOfUint32ThenComplex64Impl) GetChReturnOfComplex64() chan *ReturnOfComplex64 {
	return __.ChReturnOfComplex64.Get().(chan *ReturnOfComplex64)
}
func (__ *PoolOfUint32ThenComplex64Impl) PutChReturnOfComplex64(p chan *ReturnOfComplex64) {
	__.ChReturnOfComplex64.Put(p)
}

func NewPoolOfUint32ThenComplex64Impl() *PoolOfUint32ThenComplex64Impl {
	return &PoolOfUint32ThenComplex64Impl{
		Uint32Arg: sync.Pool{
			New: func() interface{} {
				return new(uint32)
			},
		},
		Uint32Work: sync.Pool{
			New: func() interface{} {
				return new(WorkOfUint32ThenComplex64)
			},
		},
		Complex64Rtn: sync.Pool{
			New: func() interface{} {
				return new(complex64)
			},
		},
		Complex64Return: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfComplex64)
			},
		},
		ChReturnOfComplex64: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfComplex64, 1)
			},
		},
	}
}

type ApiDecouplerOfUint32ThenComplex64 struct {
	pool PoolOfUint32ThenComplex64
}

func NewApiDecouplerOfUint32ThenComplex64() *ApiDecouplerOfUint32ThenComplex64 {
	return &ApiDecouplerOfUint32ThenComplex64{
		pool: NewPoolOfUint32ThenComplex64Impl(),
	}
}

func (__ *ApiDecouplerOfUint32ThenComplex64) ReturnError(rtn_ch chan<- *ReturnOfComplex64, err error) {
	rtn := __.pool.GetReturnOfComplex64()
	var other complex64
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfUint32ThenComplex64) HandleOfUint32ThenComplex64(ctx context.Context, req *WorkOfUint32ThenComplex64, h func(ctx context.Context, arg uint32) (complex64, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfComplex64()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfUint32ThenComplex64) DoOfUint32ThenComplex64(ctx context.Context, worker WorkerOfPushUint32ThenComplex64, arg uint32) (complex64, error) {
	// ch := make(chan *ReturnOfComplex64, 1)
	ch := __.pool.GetChReturnOfComplex64()
	defer __.pool.PutChReturnOfComplex64(ch)

	req := __.pool.GetWorkOfUint32ThenComplex64()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfUint32ThenComplex64(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfComplex64(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfUint32ThenComplex64 = func(ctx context.Context, arg uint32) (complex64, error)

type WorkerOfUint32ThenComplex64 struct {
	api_syncer *ApiDecouplerOfUint32ThenComplex64
	handler    WorkHandlerOfUint32ThenComplex64

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfUint32ThenComplex64
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfUint32ThenComplex64(ctx context.Context, h WorkHandlerOfUint32ThenComplex64, n int) *WorkerOfUint32ThenComplex64 {
	__ := &WorkerOfUint32ThenComplex64{
		api_syncer: NewApiDecouplerOfUint32ThenComplex64(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfUint32ThenComplex64, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfUint32ThenComplex64{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfUint32ThenComplex64(req.Context, req.WorkOfUint32ThenComplex64, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfUint32ThenComplex64) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfUint32ThenComplex64) Push(ctx context.Context, req *WorkOfUint32ThenComplex64) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfUint32ThenComplex64)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfUint32ThenComplex64 = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfUint32ThenComplex64) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfUint32ThenComplex64) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfUint32ThenComplex64) Call(ctx context.Context, arg uint32) (complex64, error) {
	return __.api_syncer.DoOfUint32ThenComplex64(ctx, __, arg)
}

type PoolOfUint32ThenError interface {
	GetUint32Arg() *uint32
	PutUint32Arg(*uint32)
	GetErrorReturn() *error
	PutErrorReturn(*error)

	GetWorkOfUint32ThenError() *WorkOfUint32ThenError
	GetReturnOfError() *ReturnOfError
	PutWorkOfUint32ThenError(*WorkOfUint32ThenError)
	PutReturnOfError(*ReturnOfError)

	GetChReturnOfError() chan *ReturnOfError
	PutChReturnOfError(chan *ReturnOfError)
}

type PoolOfUint32ThenErrorImpl struct {
	Uint32Arg       sync.Pool
	ErrorRtn        sync.Pool
	Uint32Work      sync.Pool
	ErrorReturn     sync.Pool
	ChReturnOfError sync.Pool
}

func (__ *PoolOfUint32ThenErrorImpl) GetUint32Arg() *uint32 {
	return __.Uint32Arg.Get().(*uint32)
}
func (__ *PoolOfUint32ThenErrorImpl) PutUint32Arg(p *uint32) {
	__.Uint32Arg.Put(p)
}
func (__ *PoolOfUint32ThenErrorImpl) GetErrorReturn() *error {
	return __.ErrorRtn.Get().(*error)
}
func (__ *PoolOfUint32ThenErrorImpl) PutErrorReturn(p *error) {
	__.ErrorRtn.Put(p)
}

func (__ *PoolOfUint32ThenErrorImpl) GetWorkOfUint32ThenError() *WorkOfUint32ThenError {
	return __.Uint32Work.Get().(*WorkOfUint32ThenError)
}
func (__ *PoolOfUint32ThenErrorImpl) PutWorkOfUint32ThenError(p *WorkOfUint32ThenError) {
	__.Uint32Work.Put(p)
}
func (__ *PoolOfUint32ThenErrorImpl) GetReturnOfError() *ReturnOfError {
	return __.ErrorReturn.Get().(*ReturnOfError)
}
func (__ *PoolOfUint32ThenErrorImpl) PutReturnOfError(p *ReturnOfError) {
	__.ErrorReturn.Put(p)
}

func (__ *PoolOfUint32ThenErrorImpl) GetChReturnOfError() chan *ReturnOfError {
	return __.ChReturnOfError.Get().(chan *ReturnOfError)
}
func (__ *PoolOfUint32ThenErrorImpl) PutChReturnOfError(p chan *ReturnOfError) {
	__.ChReturnOfError.Put(p)
}

func NewPoolOfUint32ThenErrorImpl() *PoolOfUint32ThenErrorImpl {
	return &PoolOfUint32ThenErrorImpl{
		Uint32Arg: sync.Pool{
			New: func() interface{} {
				return new(uint32)
			},
		},
		Uint32Work: sync.Pool{
			New: func() interface{} {
				return new(WorkOfUint32ThenError)
			},
		},
		ErrorRtn: sync.Pool{
			New: func() interface{} {
				return new(error)
			},
		},
		ErrorReturn: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfError)
			},
		},
		ChReturnOfError: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfError, 1)
			},
		},
	}
}

type ApiDecouplerOfUint32ThenError struct {
	pool PoolOfUint32ThenError
}

func NewApiDecouplerOfUint32ThenError() *ApiDecouplerOfUint32ThenError {
	return &ApiDecouplerOfUint32ThenError{
		pool: NewPoolOfUint32ThenErrorImpl(),
	}
}

func (__ *ApiDecouplerOfUint32ThenError) ReturnError(rtn_ch chan<- *ReturnOfError, err error) {
	rtn := __.pool.GetReturnOfError()
	var other error
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfUint32ThenError) HandleOfUint32ThenError(ctx context.Context, req *WorkOfUint32ThenError, h func(ctx context.Context, arg uint32) (error, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfError()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfUint32ThenError) DoOfUint32ThenError(ctx context.Context, worker WorkerOfPushUint32ThenError, arg uint32) (error, error) {
	// ch := make(chan *ReturnOfError, 1)
	ch := __.pool.GetChReturnOfError()
	defer __.pool.PutChReturnOfError(ch)

	req := __.pool.GetWorkOfUint32ThenError()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfUint32ThenError(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfError(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfUint32ThenError = func(ctx context.Context, arg uint32) (error, error)

type WorkerOfUint32ThenError struct {
	api_syncer *ApiDecouplerOfUint32ThenError
	handler    WorkHandlerOfUint32ThenError

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfUint32ThenError
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfUint32ThenError(ctx context.Context, h WorkHandlerOfUint32ThenError, n int) *WorkerOfUint32ThenError {
	__ := &WorkerOfUint32ThenError{
		api_syncer: NewApiDecouplerOfUint32ThenError(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfUint32ThenError, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfUint32ThenError{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfUint32ThenError(req.Context, req.WorkOfUint32ThenError, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfUint32ThenError) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfUint32ThenError) Push(ctx context.Context, req *WorkOfUint32ThenError) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfUint32ThenError)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfUint32ThenError = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfUint32ThenError) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfUint32ThenError) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfUint32ThenError) Call(ctx context.Context, arg uint32) (error, error) {
	return __.api_syncer.DoOfUint32ThenError(ctx, __, arg)
}

type PoolOfUint32ThenFloat32 interface {
	GetUint32Arg() *uint32
	PutUint32Arg(*uint32)
	GetFloat32Return() *float32
	PutFloat32Return(*float32)

	GetWorkOfUint32ThenFloat32() *WorkOfUint32ThenFloat32
	GetReturnOfFloat32() *ReturnOfFloat32
	PutWorkOfUint32ThenFloat32(*WorkOfUint32ThenFloat32)
	PutReturnOfFloat32(*ReturnOfFloat32)

	GetChReturnOfFloat32() chan *ReturnOfFloat32
	PutChReturnOfFloat32(chan *ReturnOfFloat32)
}

type PoolOfUint32ThenFloat32Impl struct {
	Uint32Arg         sync.Pool
	Float32Rtn        sync.Pool
	Uint32Work        sync.Pool
	Float32Return     sync.Pool
	ChReturnOfFloat32 sync.Pool
}

func (__ *PoolOfUint32ThenFloat32Impl) GetUint32Arg() *uint32 {
	return __.Uint32Arg.Get().(*uint32)
}
func (__ *PoolOfUint32ThenFloat32Impl) PutUint32Arg(p *uint32) {
	__.Uint32Arg.Put(p)
}
func (__ *PoolOfUint32ThenFloat32Impl) GetFloat32Return() *float32 {
	return __.Float32Rtn.Get().(*float32)
}
func (__ *PoolOfUint32ThenFloat32Impl) PutFloat32Return(p *float32) {
	__.Float32Rtn.Put(p)
}

func (__ *PoolOfUint32ThenFloat32Impl) GetWorkOfUint32ThenFloat32() *WorkOfUint32ThenFloat32 {
	return __.Uint32Work.Get().(*WorkOfUint32ThenFloat32)
}
func (__ *PoolOfUint32ThenFloat32Impl) PutWorkOfUint32ThenFloat32(p *WorkOfUint32ThenFloat32) {
	__.Uint32Work.Put(p)
}
func (__ *PoolOfUint32ThenFloat32Impl) GetReturnOfFloat32() *ReturnOfFloat32 {
	return __.Float32Return.Get().(*ReturnOfFloat32)
}
func (__ *PoolOfUint32ThenFloat32Impl) PutReturnOfFloat32(p *ReturnOfFloat32) {
	__.Float32Return.Put(p)
}

func (__ *PoolOfUint32ThenFloat32Impl) GetChReturnOfFloat32() chan *ReturnOfFloat32 {
	return __.ChReturnOfFloat32.Get().(chan *ReturnOfFloat32)
}
func (__ *PoolOfUint32ThenFloat32Impl) PutChReturnOfFloat32(p chan *ReturnOfFloat32) {
	__.ChReturnOfFloat32.Put(p)
}

func NewPoolOfUint32ThenFloat32Impl() *PoolOfUint32ThenFloat32Impl {
	return &PoolOfUint32ThenFloat32Impl{
		Uint32Arg: sync.Pool{
			New: func() interface{} {
				return new(uint32)
			},
		},
		Uint32Work: sync.Pool{
			New: func() interface{} {
				return new(WorkOfUint32ThenFloat32)
			},
		},
		Float32Rtn: sync.Pool{
			New: func() interface{} {
				return new(float32)
			},
		},
		Float32Return: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfFloat32)
			},
		},
		ChReturnOfFloat32: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfFloat32, 1)
			},
		},
	}
}

type ApiDecouplerOfUint32ThenFloat32 struct {
	pool PoolOfUint32ThenFloat32
}

func NewApiDecouplerOfUint32ThenFloat32() *ApiDecouplerOfUint32ThenFloat32 {
	return &ApiDecouplerOfUint32ThenFloat32{
		pool: NewPoolOfUint32ThenFloat32Impl(),
	}
}

func (__ *ApiDecouplerOfUint32ThenFloat32) ReturnError(rtn_ch chan<- *ReturnOfFloat32, err error) {
	rtn := __.pool.GetReturnOfFloat32()
	var other float32
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfUint32ThenFloat32) HandleOfUint32ThenFloat32(ctx context.Context, req *WorkOfUint32ThenFloat32, h func(ctx context.Context, arg uint32) (float32, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfFloat32()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfUint32ThenFloat32) DoOfUint32ThenFloat32(ctx context.Context, worker WorkerOfPushUint32ThenFloat32, arg uint32) (float32, error) {
	// ch := make(chan *ReturnOfFloat32, 1)
	ch := __.pool.GetChReturnOfFloat32()
	defer __.pool.PutChReturnOfFloat32(ch)

	req := __.pool.GetWorkOfUint32ThenFloat32()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfUint32ThenFloat32(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfFloat32(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfUint32ThenFloat32 = func(ctx context.Context, arg uint32) (float32, error)

type WorkerOfUint32ThenFloat32 struct {
	api_syncer *ApiDecouplerOfUint32ThenFloat32
	handler    WorkHandlerOfUint32ThenFloat32

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfUint32ThenFloat32
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfUint32ThenFloat32(ctx context.Context, h WorkHandlerOfUint32ThenFloat32, n int) *WorkerOfUint32ThenFloat32 {
	__ := &WorkerOfUint32ThenFloat32{
		api_syncer: NewApiDecouplerOfUint32ThenFloat32(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfUint32ThenFloat32, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfUint32ThenFloat32{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfUint32ThenFloat32(req.Context, req.WorkOfUint32ThenFloat32, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfUint32ThenFloat32) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfUint32ThenFloat32) Push(ctx context.Context, req *WorkOfUint32ThenFloat32) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfUint32ThenFloat32)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfUint32ThenFloat32 = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfUint32ThenFloat32) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfUint32ThenFloat32) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfUint32ThenFloat32) Call(ctx context.Context, arg uint32) (float32, error) {
	return __.api_syncer.DoOfUint32ThenFloat32(ctx, __, arg)
}

type PoolOfUint32ThenFloat64 interface {
	GetUint32Arg() *uint32
	PutUint32Arg(*uint32)
	GetFloat64Return() *float64
	PutFloat64Return(*float64)

	GetWorkOfUint32ThenFloat64() *WorkOfUint32ThenFloat64
	GetReturnOfFloat64() *ReturnOfFloat64
	PutWorkOfUint32ThenFloat64(*WorkOfUint32ThenFloat64)
	PutReturnOfFloat64(*ReturnOfFloat64)

	GetChReturnOfFloat64() chan *ReturnOfFloat64
	PutChReturnOfFloat64(chan *ReturnOfFloat64)
}

type PoolOfUint32ThenFloat64Impl struct {
	Uint32Arg         sync.Pool
	Float64Rtn        sync.Pool
	Uint32Work        sync.Pool
	Float64Return     sync.Pool
	ChReturnOfFloat64 sync.Pool
}

func (__ *PoolOfUint32ThenFloat64Impl) GetUint32Arg() *uint32 {
	return __.Uint32Arg.Get().(*uint32)
}
func (__ *PoolOfUint32ThenFloat64Impl) PutUint32Arg(p *uint32) {
	__.Uint32Arg.Put(p)
}
func (__ *PoolOfUint32ThenFloat64Impl) GetFloat64Return() *float64 {
	return __.Float64Rtn.Get().(*float64)
}
func (__ *PoolOfUint32ThenFloat64Impl) PutFloat64Return(p *float64) {
	__.Float64Rtn.Put(p)
}

func (__ *PoolOfUint32ThenFloat64Impl) GetWorkOfUint32ThenFloat64() *WorkOfUint32ThenFloat64 {
	return __.Uint32Work.Get().(*WorkOfUint32ThenFloat64)
}
func (__ *PoolOfUint32ThenFloat64Impl) PutWorkOfUint32ThenFloat64(p *WorkOfUint32ThenFloat64) {
	__.Uint32Work.Put(p)
}
func (__ *PoolOfUint32ThenFloat64Impl) GetReturnOfFloat64() *ReturnOfFloat64 {
	return __.Float64Return.Get().(*ReturnOfFloat64)
}
func (__ *PoolOfUint32ThenFloat64Impl) PutReturnOfFloat64(p *ReturnOfFloat64) {
	__.Float64Return.Put(p)
}

func (__ *PoolOfUint32ThenFloat64Impl) GetChReturnOfFloat64() chan *ReturnOfFloat64 {
	return __.ChReturnOfFloat64.Get().(chan *ReturnOfFloat64)
}
func (__ *PoolOfUint32ThenFloat64Impl) PutChReturnOfFloat64(p chan *ReturnOfFloat64) {
	__.ChReturnOfFloat64.Put(p)
}

func NewPoolOfUint32ThenFloat64Impl() *PoolOfUint32ThenFloat64Impl {
	return &PoolOfUint32ThenFloat64Impl{
		Uint32Arg: sync.Pool{
			New: func() interface{} {
				return new(uint32)
			},
		},
		Uint32Work: sync.Pool{
			New: func() interface{} {
				return new(WorkOfUint32ThenFloat64)
			},
		},
		Float64Rtn: sync.Pool{
			New: func() interface{} {
				return new(float64)
			},
		},
		Float64Return: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfFloat64)
			},
		},
		ChReturnOfFloat64: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfFloat64, 1)
			},
		},
	}
}

type ApiDecouplerOfUint32ThenFloat64 struct {
	pool PoolOfUint32ThenFloat64
}

func NewApiDecouplerOfUint32ThenFloat64() *ApiDecouplerOfUint32ThenFloat64 {
	return &ApiDecouplerOfUint32ThenFloat64{
		pool: NewPoolOfUint32ThenFloat64Impl(),
	}
}

func (__ *ApiDecouplerOfUint32ThenFloat64) ReturnError(rtn_ch chan<- *ReturnOfFloat64, err error) {
	rtn := __.pool.GetReturnOfFloat64()
	var other float64
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfUint32ThenFloat64) HandleOfUint32ThenFloat64(ctx context.Context, req *WorkOfUint32ThenFloat64, h func(ctx context.Context, arg uint32) (float64, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfFloat64()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfUint32ThenFloat64) DoOfUint32ThenFloat64(ctx context.Context, worker WorkerOfPushUint32ThenFloat64, arg uint32) (float64, error) {
	// ch := make(chan *ReturnOfFloat64, 1)
	ch := __.pool.GetChReturnOfFloat64()
	defer __.pool.PutChReturnOfFloat64(ch)

	req := __.pool.GetWorkOfUint32ThenFloat64()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfUint32ThenFloat64(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfFloat64(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfUint32ThenFloat64 = func(ctx context.Context, arg uint32) (float64, error)

type WorkerOfUint32ThenFloat64 struct {
	api_syncer *ApiDecouplerOfUint32ThenFloat64
	handler    WorkHandlerOfUint32ThenFloat64

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfUint32ThenFloat64
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfUint32ThenFloat64(ctx context.Context, h WorkHandlerOfUint32ThenFloat64, n int) *WorkerOfUint32ThenFloat64 {
	__ := &WorkerOfUint32ThenFloat64{
		api_syncer: NewApiDecouplerOfUint32ThenFloat64(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfUint32ThenFloat64, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfUint32ThenFloat64{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfUint32ThenFloat64(req.Context, req.WorkOfUint32ThenFloat64, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfUint32ThenFloat64) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfUint32ThenFloat64) Push(ctx context.Context, req *WorkOfUint32ThenFloat64) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfUint32ThenFloat64)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfUint32ThenFloat64 = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfUint32ThenFloat64) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfUint32ThenFloat64) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfUint32ThenFloat64) Call(ctx context.Context, arg uint32) (float64, error) {
	return __.api_syncer.DoOfUint32ThenFloat64(ctx, __, arg)
}

type PoolOfUint32ThenInt interface {
	GetUint32Arg() *uint32
	PutUint32Arg(*uint32)
	GetIntReturn() *int
	PutIntReturn(*int)

	GetWorkOfUint32ThenInt() *WorkOfUint32ThenInt
	GetReturnOfInt() *ReturnOfInt
	PutWorkOfUint32ThenInt(*WorkOfUint32ThenInt)
	PutReturnOfInt(*ReturnOfInt)

	GetChReturnOfInt() chan *ReturnOfInt
	PutChReturnOfInt(chan *ReturnOfInt)
}

type PoolOfUint32ThenIntImpl struct {
	Uint32Arg     sync.Pool
	IntRtn        sync.Pool
	Uint32Work    sync.Pool
	IntReturn     sync.Pool
	ChReturnOfInt sync.Pool
}

func (__ *PoolOfUint32ThenIntImpl) GetUint32Arg() *uint32 {
	return __.Uint32Arg.Get().(*uint32)
}
func (__ *PoolOfUint32ThenIntImpl) PutUint32Arg(p *uint32) {
	__.Uint32Arg.Put(p)
}
func (__ *PoolOfUint32ThenIntImpl) GetIntReturn() *int {
	return __.IntRtn.Get().(*int)
}
func (__ *PoolOfUint32ThenIntImpl) PutIntReturn(p *int) {
	__.IntRtn.Put(p)
}

func (__ *PoolOfUint32ThenIntImpl) GetWorkOfUint32ThenInt() *WorkOfUint32ThenInt {
	return __.Uint32Work.Get().(*WorkOfUint32ThenInt)
}
func (__ *PoolOfUint32ThenIntImpl) PutWorkOfUint32ThenInt(p *WorkOfUint32ThenInt) {
	__.Uint32Work.Put(p)
}
func (__ *PoolOfUint32ThenIntImpl) GetReturnOfInt() *ReturnOfInt {
	return __.IntReturn.Get().(*ReturnOfInt)
}
func (__ *PoolOfUint32ThenIntImpl) PutReturnOfInt(p *ReturnOfInt) {
	__.IntReturn.Put(p)
}

func (__ *PoolOfUint32ThenIntImpl) GetChReturnOfInt() chan *ReturnOfInt {
	return __.ChReturnOfInt.Get().(chan *ReturnOfInt)
}
func (__ *PoolOfUint32ThenIntImpl) PutChReturnOfInt(p chan *ReturnOfInt) {
	__.ChReturnOfInt.Put(p)
}

func NewPoolOfUint32ThenIntImpl() *PoolOfUint32ThenIntImpl {
	return &PoolOfUint32ThenIntImpl{
		Uint32Arg: sync.Pool{
			New: func() interface{} {
				return new(uint32)
			},
		},
		Uint32Work: sync.Pool{
			New: func() interface{} {
				return new(WorkOfUint32ThenInt)
			},
		},
		IntRtn: sync.Pool{
			New: func() interface{} {
				return new(int)
			},
		},
		IntReturn: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfInt)
			},
		},
		ChReturnOfInt: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfInt, 1)
			},
		},
	}
}

type ApiDecouplerOfUint32ThenInt struct {
	pool PoolOfUint32ThenInt
}

func NewApiDecouplerOfUint32ThenInt() *ApiDecouplerOfUint32ThenInt {
	return &ApiDecouplerOfUint32ThenInt{
		pool: NewPoolOfUint32ThenIntImpl(),
	}
}

func (__ *ApiDecouplerOfUint32ThenInt) ReturnError(rtn_ch chan<- *ReturnOfInt, err error) {
	rtn := __.pool.GetReturnOfInt()
	var other int
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfUint32ThenInt) HandleOfUint32ThenInt(ctx context.Context, req *WorkOfUint32ThenInt, h func(ctx context.Context, arg uint32) (int, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfInt()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfUint32ThenInt) DoOfUint32ThenInt(ctx context.Context, worker WorkerOfPushUint32ThenInt, arg uint32) (int, error) {
	// ch := make(chan *ReturnOfInt, 1)
	ch := __.pool.GetChReturnOfInt()
	defer __.pool.PutChReturnOfInt(ch)

	req := __.pool.GetWorkOfUint32ThenInt()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfUint32ThenInt(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfInt(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfUint32ThenInt = func(ctx context.Context, arg uint32) (int, error)

type WorkerOfUint32ThenInt struct {
	api_syncer *ApiDecouplerOfUint32ThenInt
	handler    WorkHandlerOfUint32ThenInt

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfUint32ThenInt
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfUint32ThenInt(ctx context.Context, h WorkHandlerOfUint32ThenInt, n int) *WorkerOfUint32ThenInt {
	__ := &WorkerOfUint32ThenInt{
		api_syncer: NewApiDecouplerOfUint32ThenInt(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfUint32ThenInt, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfUint32ThenInt{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfUint32ThenInt(req.Context, req.WorkOfUint32ThenInt, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfUint32ThenInt) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfUint32ThenInt) Push(ctx context.Context, req *WorkOfUint32ThenInt) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfUint32ThenInt)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfUint32ThenInt = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfUint32ThenInt) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfUint32ThenInt) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfUint32ThenInt) Call(ctx context.Context, arg uint32) (int, error) {
	return __.api_syncer.DoOfUint32ThenInt(ctx, __, arg)
}

type PoolOfUint32ThenInt16 interface {
	GetUint32Arg() *uint32
	PutUint32Arg(*uint32)
	GetInt16Return() *int16
	PutInt16Return(*int16)

	GetWorkOfUint32ThenInt16() *WorkOfUint32ThenInt16
	GetReturnOfInt16() *ReturnOfInt16
	PutWorkOfUint32ThenInt16(*WorkOfUint32ThenInt16)
	PutReturnOfInt16(*ReturnOfInt16)

	GetChReturnOfInt16() chan *ReturnOfInt16
	PutChReturnOfInt16(chan *ReturnOfInt16)
}

type PoolOfUint32ThenInt16Impl struct {
	Uint32Arg       sync.Pool
	Int16Rtn        sync.Pool
	Uint32Work      sync.Pool
	Int16Return     sync.Pool
	ChReturnOfInt16 sync.Pool
}

func (__ *PoolOfUint32ThenInt16Impl) GetUint32Arg() *uint32 {
	return __.Uint32Arg.Get().(*uint32)
}
func (__ *PoolOfUint32ThenInt16Impl) PutUint32Arg(p *uint32) {
	__.Uint32Arg.Put(p)
}
func (__ *PoolOfUint32ThenInt16Impl) GetInt16Return() *int16 {
	return __.Int16Rtn.Get().(*int16)
}
func (__ *PoolOfUint32ThenInt16Impl) PutInt16Return(p *int16) {
	__.Int16Rtn.Put(p)
}

func (__ *PoolOfUint32ThenInt16Impl) GetWorkOfUint32ThenInt16() *WorkOfUint32ThenInt16 {
	return __.Uint32Work.Get().(*WorkOfUint32ThenInt16)
}
func (__ *PoolOfUint32ThenInt16Impl) PutWorkOfUint32ThenInt16(p *WorkOfUint32ThenInt16) {
	__.Uint32Work.Put(p)
}
func (__ *PoolOfUint32ThenInt16Impl) GetReturnOfInt16() *ReturnOfInt16 {
	return __.Int16Return.Get().(*ReturnOfInt16)
}
func (__ *PoolOfUint32ThenInt16Impl) PutReturnOfInt16(p *ReturnOfInt16) {
	__.Int16Return.Put(p)
}

func (__ *PoolOfUint32ThenInt16Impl) GetChReturnOfInt16() chan *ReturnOfInt16 {
	return __.ChReturnOfInt16.Get().(chan *ReturnOfInt16)
}
func (__ *PoolOfUint32ThenInt16Impl) PutChReturnOfInt16(p chan *ReturnOfInt16) {
	__.ChReturnOfInt16.Put(p)
}

func NewPoolOfUint32ThenInt16Impl() *PoolOfUint32ThenInt16Impl {
	return &PoolOfUint32ThenInt16Impl{
		Uint32Arg: sync.Pool{
			New: func() interface{} {
				return new(uint32)
			},
		},
		Uint32Work: sync.Pool{
			New: func() interface{} {
				return new(WorkOfUint32ThenInt16)
			},
		},
		Int16Rtn: sync.Pool{
			New: func() interface{} {
				return new(int16)
			},
		},
		Int16Return: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfInt16)
			},
		},
		ChReturnOfInt16: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfInt16, 1)
			},
		},
	}
}

type ApiDecouplerOfUint32ThenInt16 struct {
	pool PoolOfUint32ThenInt16
}

func NewApiDecouplerOfUint32ThenInt16() *ApiDecouplerOfUint32ThenInt16 {
	return &ApiDecouplerOfUint32ThenInt16{
		pool: NewPoolOfUint32ThenInt16Impl(),
	}
}

func (__ *ApiDecouplerOfUint32ThenInt16) ReturnError(rtn_ch chan<- *ReturnOfInt16, err error) {
	rtn := __.pool.GetReturnOfInt16()
	var other int16
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfUint32ThenInt16) HandleOfUint32ThenInt16(ctx context.Context, req *WorkOfUint32ThenInt16, h func(ctx context.Context, arg uint32) (int16, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfInt16()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfUint32ThenInt16) DoOfUint32ThenInt16(ctx context.Context, worker WorkerOfPushUint32ThenInt16, arg uint32) (int16, error) {
	// ch := make(chan *ReturnOfInt16, 1)
	ch := __.pool.GetChReturnOfInt16()
	defer __.pool.PutChReturnOfInt16(ch)

	req := __.pool.GetWorkOfUint32ThenInt16()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfUint32ThenInt16(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfInt16(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfUint32ThenInt16 = func(ctx context.Context, arg uint32) (int16, error)

type WorkerOfUint32ThenInt16 struct {
	api_syncer *ApiDecouplerOfUint32ThenInt16
	handler    WorkHandlerOfUint32ThenInt16

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfUint32ThenInt16
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfUint32ThenInt16(ctx context.Context, h WorkHandlerOfUint32ThenInt16, n int) *WorkerOfUint32ThenInt16 {
	__ := &WorkerOfUint32ThenInt16{
		api_syncer: NewApiDecouplerOfUint32ThenInt16(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfUint32ThenInt16, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfUint32ThenInt16{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfUint32ThenInt16(req.Context, req.WorkOfUint32ThenInt16, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfUint32ThenInt16) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfUint32ThenInt16) Push(ctx context.Context, req *WorkOfUint32ThenInt16) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfUint32ThenInt16)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfUint32ThenInt16 = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfUint32ThenInt16) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfUint32ThenInt16) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfUint32ThenInt16) Call(ctx context.Context, arg uint32) (int16, error) {
	return __.api_syncer.DoOfUint32ThenInt16(ctx, __, arg)
}

type PoolOfUint32ThenInt32 interface {
	GetUint32Arg() *uint32
	PutUint32Arg(*uint32)
	GetInt32Return() *int32
	PutInt32Return(*int32)

	GetWorkOfUint32ThenInt32() *WorkOfUint32ThenInt32
	GetReturnOfInt32() *ReturnOfInt32
	PutWorkOfUint32ThenInt32(*WorkOfUint32ThenInt32)
	PutReturnOfInt32(*ReturnOfInt32)

	GetChReturnOfInt32() chan *ReturnOfInt32
	PutChReturnOfInt32(chan *ReturnOfInt32)
}

type PoolOfUint32ThenInt32Impl struct {
	Uint32Arg       sync.Pool
	Int32Rtn        sync.Pool
	Uint32Work      sync.Pool
	Int32Return     sync.Pool
	ChReturnOfInt32 sync.Pool
}

func (__ *PoolOfUint32ThenInt32Impl) GetUint32Arg() *uint32 {
	return __.Uint32Arg.Get().(*uint32)
}
func (__ *PoolOfUint32ThenInt32Impl) PutUint32Arg(p *uint32) {
	__.Uint32Arg.Put(p)
}
func (__ *PoolOfUint32ThenInt32Impl) GetInt32Return() *int32 {
	return __.Int32Rtn.Get().(*int32)
}
func (__ *PoolOfUint32ThenInt32Impl) PutInt32Return(p *int32) {
	__.Int32Rtn.Put(p)
}

func (__ *PoolOfUint32ThenInt32Impl) GetWorkOfUint32ThenInt32() *WorkOfUint32ThenInt32 {
	return __.Uint32Work.Get().(*WorkOfUint32ThenInt32)
}
func (__ *PoolOfUint32ThenInt32Impl) PutWorkOfUint32ThenInt32(p *WorkOfUint32ThenInt32) {
	__.Uint32Work.Put(p)
}
func (__ *PoolOfUint32ThenInt32Impl) GetReturnOfInt32() *ReturnOfInt32 {
	return __.Int32Return.Get().(*ReturnOfInt32)
}
func (__ *PoolOfUint32ThenInt32Impl) PutReturnOfInt32(p *ReturnOfInt32) {
	__.Int32Return.Put(p)
}

func (__ *PoolOfUint32ThenInt32Impl) GetChReturnOfInt32() chan *ReturnOfInt32 {
	return __.ChReturnOfInt32.Get().(chan *ReturnOfInt32)
}
func (__ *PoolOfUint32ThenInt32Impl) PutChReturnOfInt32(p chan *ReturnOfInt32) {
	__.ChReturnOfInt32.Put(p)
}

func NewPoolOfUint32ThenInt32Impl() *PoolOfUint32ThenInt32Impl {
	return &PoolOfUint32ThenInt32Impl{
		Uint32Arg: sync.Pool{
			New: func() interface{} {
				return new(uint32)
			},
		},
		Uint32Work: sync.Pool{
			New: func() interface{} {
				return new(WorkOfUint32ThenInt32)
			},
		},
		Int32Rtn: sync.Pool{
			New: func() interface{} {
				return new(int32)
			},
		},
		Int32Return: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfInt32)
			},
		},
		ChReturnOfInt32: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfInt32, 1)
			},
		},
	}
}

type ApiDecouplerOfUint32ThenInt32 struct {
	pool PoolOfUint32ThenInt32
}

func NewApiDecouplerOfUint32ThenInt32() *ApiDecouplerOfUint32ThenInt32 {
	return &ApiDecouplerOfUint32ThenInt32{
		pool: NewPoolOfUint32ThenInt32Impl(),
	}
}

func (__ *ApiDecouplerOfUint32ThenInt32) ReturnError(rtn_ch chan<- *ReturnOfInt32, err error) {
	rtn := __.pool.GetReturnOfInt32()
	var other int32
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfUint32ThenInt32) HandleOfUint32ThenInt32(ctx context.Context, req *WorkOfUint32ThenInt32, h func(ctx context.Context, arg uint32) (int32, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfInt32()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfUint32ThenInt32) DoOfUint32ThenInt32(ctx context.Context, worker WorkerOfPushUint32ThenInt32, arg uint32) (int32, error) {
	// ch := make(chan *ReturnOfInt32, 1)
	ch := __.pool.GetChReturnOfInt32()
	defer __.pool.PutChReturnOfInt32(ch)

	req := __.pool.GetWorkOfUint32ThenInt32()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfUint32ThenInt32(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfInt32(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfUint32ThenInt32 = func(ctx context.Context, arg uint32) (int32, error)

type WorkerOfUint32ThenInt32 struct {
	api_syncer *ApiDecouplerOfUint32ThenInt32
	handler    WorkHandlerOfUint32ThenInt32

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfUint32ThenInt32
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfUint32ThenInt32(ctx context.Context, h WorkHandlerOfUint32ThenInt32, n int) *WorkerOfUint32ThenInt32 {
	__ := &WorkerOfUint32ThenInt32{
		api_syncer: NewApiDecouplerOfUint32ThenInt32(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfUint32ThenInt32, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfUint32ThenInt32{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfUint32ThenInt32(req.Context, req.WorkOfUint32ThenInt32, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfUint32ThenInt32) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfUint32ThenInt32) Push(ctx context.Context, req *WorkOfUint32ThenInt32) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfUint32ThenInt32)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfUint32ThenInt32 = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfUint32ThenInt32) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfUint32ThenInt32) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfUint32ThenInt32) Call(ctx context.Context, arg uint32) (int32, error) {
	return __.api_syncer.DoOfUint32ThenInt32(ctx, __, arg)
}

type PoolOfUint32ThenInt64 interface {
	GetUint32Arg() *uint32
	PutUint32Arg(*uint32)
	GetInt64Return() *int64
	PutInt64Return(*int64)

	GetWorkOfUint32ThenInt64() *WorkOfUint32ThenInt64
	GetReturnOfInt64() *ReturnOfInt64
	PutWorkOfUint32ThenInt64(*WorkOfUint32ThenInt64)
	PutReturnOfInt64(*ReturnOfInt64)

	GetChReturnOfInt64() chan *ReturnOfInt64
	PutChReturnOfInt64(chan *ReturnOfInt64)
}

type PoolOfUint32ThenInt64Impl struct {
	Uint32Arg       sync.Pool
	Int64Rtn        sync.Pool
	Uint32Work      sync.Pool
	Int64Return     sync.Pool
	ChReturnOfInt64 sync.Pool
}

func (__ *PoolOfUint32ThenInt64Impl) GetUint32Arg() *uint32 {
	return __.Uint32Arg.Get().(*uint32)
}
func (__ *PoolOfUint32ThenInt64Impl) PutUint32Arg(p *uint32) {
	__.Uint32Arg.Put(p)
}
func (__ *PoolOfUint32ThenInt64Impl) GetInt64Return() *int64 {
	return __.Int64Rtn.Get().(*int64)
}
func (__ *PoolOfUint32ThenInt64Impl) PutInt64Return(p *int64) {
	__.Int64Rtn.Put(p)
}

func (__ *PoolOfUint32ThenInt64Impl) GetWorkOfUint32ThenInt64() *WorkOfUint32ThenInt64 {
	return __.Uint32Work.Get().(*WorkOfUint32ThenInt64)
}
func (__ *PoolOfUint32ThenInt64Impl) PutWorkOfUint32ThenInt64(p *WorkOfUint32ThenInt64) {
	__.Uint32Work.Put(p)
}
func (__ *PoolOfUint32ThenInt64Impl) GetReturnOfInt64() *ReturnOfInt64 {
	return __.Int64Return.Get().(*ReturnOfInt64)
}
func (__ *PoolOfUint32ThenInt64Impl) PutReturnOfInt64(p *ReturnOfInt64) {
	__.Int64Return.Put(p)
}

func (__ *PoolOfUint32ThenInt64Impl) GetChReturnOfInt64() chan *ReturnOfInt64 {
	return __.ChReturnOfInt64.Get().(chan *ReturnOfInt64)
}
func (__ *PoolOfUint32ThenInt64Impl) PutChReturnOfInt64(p chan *ReturnOfInt64) {
	__.ChReturnOfInt64.Put(p)
}

func NewPoolOfUint32ThenInt64Impl() *PoolOfUint32ThenInt64Impl {
	return &PoolOfUint32ThenInt64Impl{
		Uint32Arg: sync.Pool{
			New: func() interface{} {
				return new(uint32)
			},
		},
		Uint32Work: sync.Pool{
			New: func() interface{} {
				return new(WorkOfUint32ThenInt64)
			},
		},
		Int64Rtn: sync.Pool{
			New: func() interface{} {
				return new(int64)
			},
		},
		Int64Return: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfInt64)
			},
		},
		ChReturnOfInt64: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfInt64, 1)
			},
		},
	}
}

type ApiDecouplerOfUint32ThenInt64 struct {
	pool PoolOfUint32ThenInt64
}

func NewApiDecouplerOfUint32ThenInt64() *ApiDecouplerOfUint32ThenInt64 {
	return &ApiDecouplerOfUint32ThenInt64{
		pool: NewPoolOfUint32ThenInt64Impl(),
	}
}

func (__ *ApiDecouplerOfUint32ThenInt64) ReturnError(rtn_ch chan<- *ReturnOfInt64, err error) {
	rtn := __.pool.GetReturnOfInt64()
	var other int64
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfUint32ThenInt64) HandleOfUint32ThenInt64(ctx context.Context, req *WorkOfUint32ThenInt64, h func(ctx context.Context, arg uint32) (int64, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfInt64()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfUint32ThenInt64) DoOfUint32ThenInt64(ctx context.Context, worker WorkerOfPushUint32ThenInt64, arg uint32) (int64, error) {
	// ch := make(chan *ReturnOfInt64, 1)
	ch := __.pool.GetChReturnOfInt64()
	defer __.pool.PutChReturnOfInt64(ch)

	req := __.pool.GetWorkOfUint32ThenInt64()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfUint32ThenInt64(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfInt64(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfUint32ThenInt64 = func(ctx context.Context, arg uint32) (int64, error)

type WorkerOfUint32ThenInt64 struct {
	api_syncer *ApiDecouplerOfUint32ThenInt64
	handler    WorkHandlerOfUint32ThenInt64

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfUint32ThenInt64
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfUint32ThenInt64(ctx context.Context, h WorkHandlerOfUint32ThenInt64, n int) *WorkerOfUint32ThenInt64 {
	__ := &WorkerOfUint32ThenInt64{
		api_syncer: NewApiDecouplerOfUint32ThenInt64(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfUint32ThenInt64, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfUint32ThenInt64{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfUint32ThenInt64(req.Context, req.WorkOfUint32ThenInt64, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfUint32ThenInt64) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfUint32ThenInt64) Push(ctx context.Context, req *WorkOfUint32ThenInt64) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfUint32ThenInt64)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfUint32ThenInt64 = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfUint32ThenInt64) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfUint32ThenInt64) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfUint32ThenInt64) Call(ctx context.Context, arg uint32) (int64, error) {
	return __.api_syncer.DoOfUint32ThenInt64(ctx, __, arg)
}

type PoolOfUint32ThenInt8 interface {
	GetUint32Arg() *uint32
	PutUint32Arg(*uint32)
	GetInt8Return() *int8
	PutInt8Return(*int8)

	GetWorkOfUint32ThenInt8() *WorkOfUint32ThenInt8
	GetReturnOfInt8() *ReturnOfInt8
	PutWorkOfUint32ThenInt8(*WorkOfUint32ThenInt8)
	PutReturnOfInt8(*ReturnOfInt8)

	GetChReturnOfInt8() chan *ReturnOfInt8
	PutChReturnOfInt8(chan *ReturnOfInt8)
}

type PoolOfUint32ThenInt8Impl struct {
	Uint32Arg      sync.Pool
	Int8Rtn        sync.Pool
	Uint32Work     sync.Pool
	Int8Return     sync.Pool
	ChReturnOfInt8 sync.Pool
}

func (__ *PoolOfUint32ThenInt8Impl) GetUint32Arg() *uint32 {
	return __.Uint32Arg.Get().(*uint32)
}
func (__ *PoolOfUint32ThenInt8Impl) PutUint32Arg(p *uint32) {
	__.Uint32Arg.Put(p)
}
func (__ *PoolOfUint32ThenInt8Impl) GetInt8Return() *int8 {
	return __.Int8Rtn.Get().(*int8)
}
func (__ *PoolOfUint32ThenInt8Impl) PutInt8Return(p *int8) {
	__.Int8Rtn.Put(p)
}

func (__ *PoolOfUint32ThenInt8Impl) GetWorkOfUint32ThenInt8() *WorkOfUint32ThenInt8 {
	return __.Uint32Work.Get().(*WorkOfUint32ThenInt8)
}
func (__ *PoolOfUint32ThenInt8Impl) PutWorkOfUint32ThenInt8(p *WorkOfUint32ThenInt8) {
	__.Uint32Work.Put(p)
}
func (__ *PoolOfUint32ThenInt8Impl) GetReturnOfInt8() *ReturnOfInt8 {
	return __.Int8Return.Get().(*ReturnOfInt8)
}
func (__ *PoolOfUint32ThenInt8Impl) PutReturnOfInt8(p *ReturnOfInt8) {
	__.Int8Return.Put(p)
}

func (__ *PoolOfUint32ThenInt8Impl) GetChReturnOfInt8() chan *ReturnOfInt8 {
	return __.ChReturnOfInt8.Get().(chan *ReturnOfInt8)
}
func (__ *PoolOfUint32ThenInt8Impl) PutChReturnOfInt8(p chan *ReturnOfInt8) {
	__.ChReturnOfInt8.Put(p)
}

func NewPoolOfUint32ThenInt8Impl() *PoolOfUint32ThenInt8Impl {
	return &PoolOfUint32ThenInt8Impl{
		Uint32Arg: sync.Pool{
			New: func() interface{} {
				return new(uint32)
			},
		},
		Uint32Work: sync.Pool{
			New: func() interface{} {
				return new(WorkOfUint32ThenInt8)
			},
		},
		Int8Rtn: sync.Pool{
			New: func() interface{} {
				return new(int8)
			},
		},
		Int8Return: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfInt8)
			},
		},
		ChReturnOfInt8: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfInt8, 1)
			},
		},
	}
}

type ApiDecouplerOfUint32ThenInt8 struct {
	pool PoolOfUint32ThenInt8
}

func NewApiDecouplerOfUint32ThenInt8() *ApiDecouplerOfUint32ThenInt8 {
	return &ApiDecouplerOfUint32ThenInt8{
		pool: NewPoolOfUint32ThenInt8Impl(),
	}
}

func (__ *ApiDecouplerOfUint32ThenInt8) ReturnError(rtn_ch chan<- *ReturnOfInt8, err error) {
	rtn := __.pool.GetReturnOfInt8()
	var other int8
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfUint32ThenInt8) HandleOfUint32ThenInt8(ctx context.Context, req *WorkOfUint32ThenInt8, h func(ctx context.Context, arg uint32) (int8, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfInt8()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfUint32ThenInt8) DoOfUint32ThenInt8(ctx context.Context, worker WorkerOfPushUint32ThenInt8, arg uint32) (int8, error) {
	// ch := make(chan *ReturnOfInt8, 1)
	ch := __.pool.GetChReturnOfInt8()
	defer __.pool.PutChReturnOfInt8(ch)

	req := __.pool.GetWorkOfUint32ThenInt8()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfUint32ThenInt8(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfInt8(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfUint32ThenInt8 = func(ctx context.Context, arg uint32) (int8, error)

type WorkerOfUint32ThenInt8 struct {
	api_syncer *ApiDecouplerOfUint32ThenInt8
	handler    WorkHandlerOfUint32ThenInt8

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfUint32ThenInt8
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfUint32ThenInt8(ctx context.Context, h WorkHandlerOfUint32ThenInt8, n int) *WorkerOfUint32ThenInt8 {
	__ := &WorkerOfUint32ThenInt8{
		api_syncer: NewApiDecouplerOfUint32ThenInt8(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfUint32ThenInt8, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfUint32ThenInt8{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfUint32ThenInt8(req.Context, req.WorkOfUint32ThenInt8, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfUint32ThenInt8) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfUint32ThenInt8) Push(ctx context.Context, req *WorkOfUint32ThenInt8) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfUint32ThenInt8)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfUint32ThenInt8 = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfUint32ThenInt8) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfUint32ThenInt8) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfUint32ThenInt8) Call(ctx context.Context, arg uint32) (int8, error) {
	return __.api_syncer.DoOfUint32ThenInt8(ctx, __, arg)
}

type PoolOfUint32ThenRune interface {
	GetUint32Arg() *uint32
	PutUint32Arg(*uint32)
	GetRuneReturn() *rune
	PutRuneReturn(*rune)

	GetWorkOfUint32ThenRune() *WorkOfUint32ThenRune
	GetReturnOfRune() *ReturnOfRune
	PutWorkOfUint32ThenRune(*WorkOfUint32ThenRune)
	PutReturnOfRune(*ReturnOfRune)

	GetChReturnOfRune() chan *ReturnOfRune
	PutChReturnOfRune(chan *ReturnOfRune)
}

type PoolOfUint32ThenRuneImpl struct {
	Uint32Arg      sync.Pool
	RuneRtn        sync.Pool
	Uint32Work     sync.Pool
	RuneReturn     sync.Pool
	ChReturnOfRune sync.Pool
}

func (__ *PoolOfUint32ThenRuneImpl) GetUint32Arg() *uint32 {
	return __.Uint32Arg.Get().(*uint32)
}
func (__ *PoolOfUint32ThenRuneImpl) PutUint32Arg(p *uint32) {
	__.Uint32Arg.Put(p)
}
func (__ *PoolOfUint32ThenRuneImpl) GetRuneReturn() *rune {
	return __.RuneRtn.Get().(*rune)
}
func (__ *PoolOfUint32ThenRuneImpl) PutRuneReturn(p *rune) {
	__.RuneRtn.Put(p)
}

func (__ *PoolOfUint32ThenRuneImpl) GetWorkOfUint32ThenRune() *WorkOfUint32ThenRune {
	return __.Uint32Work.Get().(*WorkOfUint32ThenRune)
}
func (__ *PoolOfUint32ThenRuneImpl) PutWorkOfUint32ThenRune(p *WorkOfUint32ThenRune) {
	__.Uint32Work.Put(p)
}
func (__ *PoolOfUint32ThenRuneImpl) GetReturnOfRune() *ReturnOfRune {
	return __.RuneReturn.Get().(*ReturnOfRune)
}
func (__ *PoolOfUint32ThenRuneImpl) PutReturnOfRune(p *ReturnOfRune) {
	__.RuneReturn.Put(p)
}

func (__ *PoolOfUint32ThenRuneImpl) GetChReturnOfRune() chan *ReturnOfRune {
	return __.ChReturnOfRune.Get().(chan *ReturnOfRune)
}
func (__ *PoolOfUint32ThenRuneImpl) PutChReturnOfRune(p chan *ReturnOfRune) {
	__.ChReturnOfRune.Put(p)
}

func NewPoolOfUint32ThenRuneImpl() *PoolOfUint32ThenRuneImpl {
	return &PoolOfUint32ThenRuneImpl{
		Uint32Arg: sync.Pool{
			New: func() interface{} {
				return new(uint32)
			},
		},
		Uint32Work: sync.Pool{
			New: func() interface{} {
				return new(WorkOfUint32ThenRune)
			},
		},
		RuneRtn: sync.Pool{
			New: func() interface{} {
				return new(rune)
			},
		},
		RuneReturn: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfRune)
			},
		},
		ChReturnOfRune: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfRune, 1)
			},
		},
	}
}

type ApiDecouplerOfUint32ThenRune struct {
	pool PoolOfUint32ThenRune
}

func NewApiDecouplerOfUint32ThenRune() *ApiDecouplerOfUint32ThenRune {
	return &ApiDecouplerOfUint32ThenRune{
		pool: NewPoolOfUint32ThenRuneImpl(),
	}
}

func (__ *ApiDecouplerOfUint32ThenRune) ReturnError(rtn_ch chan<- *ReturnOfRune, err error) {
	rtn := __.pool.GetReturnOfRune()
	var other rune
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfUint32ThenRune) HandleOfUint32ThenRune(ctx context.Context, req *WorkOfUint32ThenRune, h func(ctx context.Context, arg uint32) (rune, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfRune()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfUint32ThenRune) DoOfUint32ThenRune(ctx context.Context, worker WorkerOfPushUint32ThenRune, arg uint32) (rune, error) {
	// ch := make(chan *ReturnOfRune, 1)
	ch := __.pool.GetChReturnOfRune()
	defer __.pool.PutChReturnOfRune(ch)

	req := __.pool.GetWorkOfUint32ThenRune()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfUint32ThenRune(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfRune(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfUint32ThenRune = func(ctx context.Context, arg uint32) (rune, error)

type WorkerOfUint32ThenRune struct {
	api_syncer *ApiDecouplerOfUint32ThenRune
	handler    WorkHandlerOfUint32ThenRune

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfUint32ThenRune
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfUint32ThenRune(ctx context.Context, h WorkHandlerOfUint32ThenRune, n int) *WorkerOfUint32ThenRune {
	__ := &WorkerOfUint32ThenRune{
		api_syncer: NewApiDecouplerOfUint32ThenRune(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfUint32ThenRune, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfUint32ThenRune{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfUint32ThenRune(req.Context, req.WorkOfUint32ThenRune, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfUint32ThenRune) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfUint32ThenRune) Push(ctx context.Context, req *WorkOfUint32ThenRune) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfUint32ThenRune)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfUint32ThenRune = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfUint32ThenRune) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfUint32ThenRune) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfUint32ThenRune) Call(ctx context.Context, arg uint32) (rune, error) {
	return __.api_syncer.DoOfUint32ThenRune(ctx, __, arg)
}

type PoolOfUint32ThenString interface {
	GetUint32Arg() *uint32
	PutUint32Arg(*uint32)
	GetStringReturn() *string
	PutStringReturn(*string)

	GetWorkOfUint32ThenString() *WorkOfUint32ThenString
	GetReturnOfString() *ReturnOfString
	PutWorkOfUint32ThenString(*WorkOfUint32ThenString)
	PutReturnOfString(*ReturnOfString)

	GetChReturnOfString() chan *ReturnOfString
	PutChReturnOfString(chan *ReturnOfString)
}

type PoolOfUint32ThenStringImpl struct {
	Uint32Arg        sync.Pool
	StringRtn        sync.Pool
	Uint32Work       sync.Pool
	StringReturn     sync.Pool
	ChReturnOfString sync.Pool
}

func (__ *PoolOfUint32ThenStringImpl) GetUint32Arg() *uint32 {
	return __.Uint32Arg.Get().(*uint32)
}
func (__ *PoolOfUint32ThenStringImpl) PutUint32Arg(p *uint32) {
	__.Uint32Arg.Put(p)
}
func (__ *PoolOfUint32ThenStringImpl) GetStringReturn() *string {
	return __.StringRtn.Get().(*string)
}
func (__ *PoolOfUint32ThenStringImpl) PutStringReturn(p *string) {
	__.StringRtn.Put(p)
}

func (__ *PoolOfUint32ThenStringImpl) GetWorkOfUint32ThenString() *WorkOfUint32ThenString {
	return __.Uint32Work.Get().(*WorkOfUint32ThenString)
}
func (__ *PoolOfUint32ThenStringImpl) PutWorkOfUint32ThenString(p *WorkOfUint32ThenString) {
	__.Uint32Work.Put(p)
}
func (__ *PoolOfUint32ThenStringImpl) GetReturnOfString() *ReturnOfString {
	return __.StringReturn.Get().(*ReturnOfString)
}
func (__ *PoolOfUint32ThenStringImpl) PutReturnOfString(p *ReturnOfString) {
	__.StringReturn.Put(p)
}

func (__ *PoolOfUint32ThenStringImpl) GetChReturnOfString() chan *ReturnOfString {
	return __.ChReturnOfString.Get().(chan *ReturnOfString)
}
func (__ *PoolOfUint32ThenStringImpl) PutChReturnOfString(p chan *ReturnOfString) {
	__.ChReturnOfString.Put(p)
}

func NewPoolOfUint32ThenStringImpl() *PoolOfUint32ThenStringImpl {
	return &PoolOfUint32ThenStringImpl{
		Uint32Arg: sync.Pool{
			New: func() interface{} {
				return new(uint32)
			},
		},
		Uint32Work: sync.Pool{
			New: func() interface{} {
				return new(WorkOfUint32ThenString)
			},
		},
		StringRtn: sync.Pool{
			New: func() interface{} {
				return new(string)
			},
		},
		StringReturn: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfString)
			},
		},
		ChReturnOfString: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfString, 1)
			},
		},
	}
}

type ApiDecouplerOfUint32ThenString struct {
	pool PoolOfUint32ThenString
}

func NewApiDecouplerOfUint32ThenString() *ApiDecouplerOfUint32ThenString {
	return &ApiDecouplerOfUint32ThenString{
		pool: NewPoolOfUint32ThenStringImpl(),
	}
}

func (__ *ApiDecouplerOfUint32ThenString) ReturnError(rtn_ch chan<- *ReturnOfString, err error) {
	rtn := __.pool.GetReturnOfString()
	var other string
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfUint32ThenString) HandleOfUint32ThenString(ctx context.Context, req *WorkOfUint32ThenString, h func(ctx context.Context, arg uint32) (string, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfString()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfUint32ThenString) DoOfUint32ThenString(ctx context.Context, worker WorkerOfPushUint32ThenString, arg uint32) (string, error) {
	// ch := make(chan *ReturnOfString, 1)
	ch := __.pool.GetChReturnOfString()
	defer __.pool.PutChReturnOfString(ch)

	req := __.pool.GetWorkOfUint32ThenString()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfUint32ThenString(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfString(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfUint32ThenString = func(ctx context.Context, arg uint32) (string, error)

type WorkerOfUint32ThenString struct {
	api_syncer *ApiDecouplerOfUint32ThenString
	handler    WorkHandlerOfUint32ThenString

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfUint32ThenString
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfUint32ThenString(ctx context.Context, h WorkHandlerOfUint32ThenString, n int) *WorkerOfUint32ThenString {
	__ := &WorkerOfUint32ThenString{
		api_syncer: NewApiDecouplerOfUint32ThenString(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfUint32ThenString, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfUint32ThenString{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfUint32ThenString(req.Context, req.WorkOfUint32ThenString, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfUint32ThenString) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfUint32ThenString) Push(ctx context.Context, req *WorkOfUint32ThenString) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfUint32ThenString)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfUint32ThenString = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfUint32ThenString) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfUint32ThenString) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfUint32ThenString) Call(ctx context.Context, arg uint32) (string, error) {
	return __.api_syncer.DoOfUint32ThenString(ctx, __, arg)
}

type PoolOfUint32ThenUint interface {
	GetUint32Arg() *uint32
	PutUint32Arg(*uint32)
	GetUintReturn() *uint
	PutUintReturn(*uint)

	GetWorkOfUint32ThenUint() *WorkOfUint32ThenUint
	GetReturnOfUint() *ReturnOfUint
	PutWorkOfUint32ThenUint(*WorkOfUint32ThenUint)
	PutReturnOfUint(*ReturnOfUint)

	GetChReturnOfUint() chan *ReturnOfUint
	PutChReturnOfUint(chan *ReturnOfUint)
}

type PoolOfUint32ThenUintImpl struct {
	Uint32Arg      sync.Pool
	UintRtn        sync.Pool
	Uint32Work     sync.Pool
	UintReturn     sync.Pool
	ChReturnOfUint sync.Pool
}

func (__ *PoolOfUint32ThenUintImpl) GetUint32Arg() *uint32 {
	return __.Uint32Arg.Get().(*uint32)
}
func (__ *PoolOfUint32ThenUintImpl) PutUint32Arg(p *uint32) {
	__.Uint32Arg.Put(p)
}
func (__ *PoolOfUint32ThenUintImpl) GetUintReturn() *uint {
	return __.UintRtn.Get().(*uint)
}
func (__ *PoolOfUint32ThenUintImpl) PutUintReturn(p *uint) {
	__.UintRtn.Put(p)
}

func (__ *PoolOfUint32ThenUintImpl) GetWorkOfUint32ThenUint() *WorkOfUint32ThenUint {
	return __.Uint32Work.Get().(*WorkOfUint32ThenUint)
}
func (__ *PoolOfUint32ThenUintImpl) PutWorkOfUint32ThenUint(p *WorkOfUint32ThenUint) {
	__.Uint32Work.Put(p)
}
func (__ *PoolOfUint32ThenUintImpl) GetReturnOfUint() *ReturnOfUint {
	return __.UintReturn.Get().(*ReturnOfUint)
}
func (__ *PoolOfUint32ThenUintImpl) PutReturnOfUint(p *ReturnOfUint) {
	__.UintReturn.Put(p)
}

func (__ *PoolOfUint32ThenUintImpl) GetChReturnOfUint() chan *ReturnOfUint {
	return __.ChReturnOfUint.Get().(chan *ReturnOfUint)
}
func (__ *PoolOfUint32ThenUintImpl) PutChReturnOfUint(p chan *ReturnOfUint) {
	__.ChReturnOfUint.Put(p)
}

func NewPoolOfUint32ThenUintImpl() *PoolOfUint32ThenUintImpl {
	return &PoolOfUint32ThenUintImpl{
		Uint32Arg: sync.Pool{
			New: func() interface{} {
				return new(uint32)
			},
		},
		Uint32Work: sync.Pool{
			New: func() interface{} {
				return new(WorkOfUint32ThenUint)
			},
		},
		UintRtn: sync.Pool{
			New: func() interface{} {
				return new(uint)
			},
		},
		UintReturn: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfUint)
			},
		},
		ChReturnOfUint: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfUint, 1)
			},
		},
	}
}

type ApiDecouplerOfUint32ThenUint struct {
	pool PoolOfUint32ThenUint
}

func NewApiDecouplerOfUint32ThenUint() *ApiDecouplerOfUint32ThenUint {
	return &ApiDecouplerOfUint32ThenUint{
		pool: NewPoolOfUint32ThenUintImpl(),
	}
}

func (__ *ApiDecouplerOfUint32ThenUint) ReturnError(rtn_ch chan<- *ReturnOfUint, err error) {
	rtn := __.pool.GetReturnOfUint()
	var other uint
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfUint32ThenUint) HandleOfUint32ThenUint(ctx context.Context, req *WorkOfUint32ThenUint, h func(ctx context.Context, arg uint32) (uint, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfUint()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfUint32ThenUint) DoOfUint32ThenUint(ctx context.Context, worker WorkerOfPushUint32ThenUint, arg uint32) (uint, error) {
	// ch := make(chan *ReturnOfUint, 1)
	ch := __.pool.GetChReturnOfUint()
	defer __.pool.PutChReturnOfUint(ch)

	req := __.pool.GetWorkOfUint32ThenUint()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfUint32ThenUint(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfUint(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfUint32ThenUint = func(ctx context.Context, arg uint32) (uint, error)

type WorkerOfUint32ThenUint struct {
	api_syncer *ApiDecouplerOfUint32ThenUint
	handler    WorkHandlerOfUint32ThenUint

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfUint32ThenUint
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfUint32ThenUint(ctx context.Context, h WorkHandlerOfUint32ThenUint, n int) *WorkerOfUint32ThenUint {
	__ := &WorkerOfUint32ThenUint{
		api_syncer: NewApiDecouplerOfUint32ThenUint(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfUint32ThenUint, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfUint32ThenUint{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfUint32ThenUint(req.Context, req.WorkOfUint32ThenUint, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfUint32ThenUint) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfUint32ThenUint) Push(ctx context.Context, req *WorkOfUint32ThenUint) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfUint32ThenUint)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfUint32ThenUint = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfUint32ThenUint) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfUint32ThenUint) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfUint32ThenUint) Call(ctx context.Context, arg uint32) (uint, error) {
	return __.api_syncer.DoOfUint32ThenUint(ctx, __, arg)
}

type PoolOfUint32ThenUint16 interface {
	GetUint32Arg() *uint32
	PutUint32Arg(*uint32)
	GetUint16Return() *uint16
	PutUint16Return(*uint16)

	GetWorkOfUint32ThenUint16() *WorkOfUint32ThenUint16
	GetReturnOfUint16() *ReturnOfUint16
	PutWorkOfUint32ThenUint16(*WorkOfUint32ThenUint16)
	PutReturnOfUint16(*ReturnOfUint16)

	GetChReturnOfUint16() chan *ReturnOfUint16
	PutChReturnOfUint16(chan *ReturnOfUint16)
}

type PoolOfUint32ThenUint16Impl struct {
	Uint32Arg        sync.Pool
	Uint16Rtn        sync.Pool
	Uint32Work       sync.Pool
	Uint16Return     sync.Pool
	ChReturnOfUint16 sync.Pool
}

func (__ *PoolOfUint32ThenUint16Impl) GetUint32Arg() *uint32 {
	return __.Uint32Arg.Get().(*uint32)
}
func (__ *PoolOfUint32ThenUint16Impl) PutUint32Arg(p *uint32) {
	__.Uint32Arg.Put(p)
}
func (__ *PoolOfUint32ThenUint16Impl) GetUint16Return() *uint16 {
	return __.Uint16Rtn.Get().(*uint16)
}
func (__ *PoolOfUint32ThenUint16Impl) PutUint16Return(p *uint16) {
	__.Uint16Rtn.Put(p)
}

func (__ *PoolOfUint32ThenUint16Impl) GetWorkOfUint32ThenUint16() *WorkOfUint32ThenUint16 {
	return __.Uint32Work.Get().(*WorkOfUint32ThenUint16)
}
func (__ *PoolOfUint32ThenUint16Impl) PutWorkOfUint32ThenUint16(p *WorkOfUint32ThenUint16) {
	__.Uint32Work.Put(p)
}
func (__ *PoolOfUint32ThenUint16Impl) GetReturnOfUint16() *ReturnOfUint16 {
	return __.Uint16Return.Get().(*ReturnOfUint16)
}
func (__ *PoolOfUint32ThenUint16Impl) PutReturnOfUint16(p *ReturnOfUint16) {
	__.Uint16Return.Put(p)
}

func (__ *PoolOfUint32ThenUint16Impl) GetChReturnOfUint16() chan *ReturnOfUint16 {
	return __.ChReturnOfUint16.Get().(chan *ReturnOfUint16)
}
func (__ *PoolOfUint32ThenUint16Impl) PutChReturnOfUint16(p chan *ReturnOfUint16) {
	__.ChReturnOfUint16.Put(p)
}

func NewPoolOfUint32ThenUint16Impl() *PoolOfUint32ThenUint16Impl {
	return &PoolOfUint32ThenUint16Impl{
		Uint32Arg: sync.Pool{
			New: func() interface{} {
				return new(uint32)
			},
		},
		Uint32Work: sync.Pool{
			New: func() interface{} {
				return new(WorkOfUint32ThenUint16)
			},
		},
		Uint16Rtn: sync.Pool{
			New: func() interface{} {
				return new(uint16)
			},
		},
		Uint16Return: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfUint16)
			},
		},
		ChReturnOfUint16: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfUint16, 1)
			},
		},
	}
}

type ApiDecouplerOfUint32ThenUint16 struct {
	pool PoolOfUint32ThenUint16
}

func NewApiDecouplerOfUint32ThenUint16() *ApiDecouplerOfUint32ThenUint16 {
	return &ApiDecouplerOfUint32ThenUint16{
		pool: NewPoolOfUint32ThenUint16Impl(),
	}
}

func (__ *ApiDecouplerOfUint32ThenUint16) ReturnError(rtn_ch chan<- *ReturnOfUint16, err error) {
	rtn := __.pool.GetReturnOfUint16()
	var other uint16
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfUint32ThenUint16) HandleOfUint32ThenUint16(ctx context.Context, req *WorkOfUint32ThenUint16, h func(ctx context.Context, arg uint32) (uint16, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfUint16()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfUint32ThenUint16) DoOfUint32ThenUint16(ctx context.Context, worker WorkerOfPushUint32ThenUint16, arg uint32) (uint16, error) {
	// ch := make(chan *ReturnOfUint16, 1)
	ch := __.pool.GetChReturnOfUint16()
	defer __.pool.PutChReturnOfUint16(ch)

	req := __.pool.GetWorkOfUint32ThenUint16()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfUint32ThenUint16(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfUint16(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfUint32ThenUint16 = func(ctx context.Context, arg uint32) (uint16, error)

type WorkerOfUint32ThenUint16 struct {
	api_syncer *ApiDecouplerOfUint32ThenUint16
	handler    WorkHandlerOfUint32ThenUint16

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfUint32ThenUint16
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfUint32ThenUint16(ctx context.Context, h WorkHandlerOfUint32ThenUint16, n int) *WorkerOfUint32ThenUint16 {
	__ := &WorkerOfUint32ThenUint16{
		api_syncer: NewApiDecouplerOfUint32ThenUint16(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfUint32ThenUint16, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfUint32ThenUint16{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfUint32ThenUint16(req.Context, req.WorkOfUint32ThenUint16, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfUint32ThenUint16) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfUint32ThenUint16) Push(ctx context.Context, req *WorkOfUint32ThenUint16) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfUint32ThenUint16)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfUint32ThenUint16 = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfUint32ThenUint16) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfUint32ThenUint16) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfUint32ThenUint16) Call(ctx context.Context, arg uint32) (uint16, error) {
	return __.api_syncer.DoOfUint32ThenUint16(ctx, __, arg)
}

type PoolOfUint32ThenUint32 interface {
	GetUint32Arg() *uint32
	PutUint32Arg(*uint32)
	GetUint32Return() *uint32
	PutUint32Return(*uint32)

	GetWorkOfUint32ThenUint32() *WorkOfUint32ThenUint32
	GetReturnOfUint32() *ReturnOfUint32
	PutWorkOfUint32ThenUint32(*WorkOfUint32ThenUint32)
	PutReturnOfUint32(*ReturnOfUint32)

	GetChReturnOfUint32() chan *ReturnOfUint32
	PutChReturnOfUint32(chan *ReturnOfUint32)
}

type PoolOfUint32ThenUint32Impl struct {
	Uint32Arg        sync.Pool
	Uint32Rtn        sync.Pool
	Uint32Work       sync.Pool
	Uint32Return     sync.Pool
	ChReturnOfUint32 sync.Pool
}

func (__ *PoolOfUint32ThenUint32Impl) GetUint32Arg() *uint32 {
	return __.Uint32Arg.Get().(*uint32)
}
func (__ *PoolOfUint32ThenUint32Impl) PutUint32Arg(p *uint32) {
	__.Uint32Arg.Put(p)
}
func (__ *PoolOfUint32ThenUint32Impl) GetUint32Return() *uint32 {
	return __.Uint32Rtn.Get().(*uint32)
}
func (__ *PoolOfUint32ThenUint32Impl) PutUint32Return(p *uint32) {
	__.Uint32Rtn.Put(p)
}

func (__ *PoolOfUint32ThenUint32Impl) GetWorkOfUint32ThenUint32() *WorkOfUint32ThenUint32 {
	return __.Uint32Work.Get().(*WorkOfUint32ThenUint32)
}
func (__ *PoolOfUint32ThenUint32Impl) PutWorkOfUint32ThenUint32(p *WorkOfUint32ThenUint32) {
	__.Uint32Work.Put(p)
}
func (__ *PoolOfUint32ThenUint32Impl) GetReturnOfUint32() *ReturnOfUint32 {
	return __.Uint32Return.Get().(*ReturnOfUint32)
}
func (__ *PoolOfUint32ThenUint32Impl) PutReturnOfUint32(p *ReturnOfUint32) {
	__.Uint32Return.Put(p)
}

func (__ *PoolOfUint32ThenUint32Impl) GetChReturnOfUint32() chan *ReturnOfUint32 {
	return __.ChReturnOfUint32.Get().(chan *ReturnOfUint32)
}
func (__ *PoolOfUint32ThenUint32Impl) PutChReturnOfUint32(p chan *ReturnOfUint32) {
	__.ChReturnOfUint32.Put(p)
}

func NewPoolOfUint32ThenUint32Impl() *PoolOfUint32ThenUint32Impl {
	return &PoolOfUint32ThenUint32Impl{
		Uint32Arg: sync.Pool{
			New: func() interface{} {
				return new(uint32)
			},
		},
		Uint32Work: sync.Pool{
			New: func() interface{} {
				return new(WorkOfUint32ThenUint32)
			},
		},
		Uint32Rtn: sync.Pool{
			New: func() interface{} {
				return new(uint32)
			},
		},
		Uint32Return: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfUint32)
			},
		},
		ChReturnOfUint32: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfUint32, 1)
			},
		},
	}
}

type ApiDecouplerOfUint32ThenUint32 struct {
	pool PoolOfUint32ThenUint32
}

func NewApiDecouplerOfUint32ThenUint32() *ApiDecouplerOfUint32ThenUint32 {
	return &ApiDecouplerOfUint32ThenUint32{
		pool: NewPoolOfUint32ThenUint32Impl(),
	}
}

func (__ *ApiDecouplerOfUint32ThenUint32) ReturnError(rtn_ch chan<- *ReturnOfUint32, err error) {
	rtn := __.pool.GetReturnOfUint32()
	var other uint32
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfUint32ThenUint32) HandleOfUint32ThenUint32(ctx context.Context, req *WorkOfUint32ThenUint32, h func(ctx context.Context, arg uint32) (uint32, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfUint32()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfUint32ThenUint32) DoOfUint32ThenUint32(ctx context.Context, worker WorkerOfPushUint32ThenUint32, arg uint32) (uint32, error) {
	// ch := make(chan *ReturnOfUint32, 1)
	ch := __.pool.GetChReturnOfUint32()
	defer __.pool.PutChReturnOfUint32(ch)

	req := __.pool.GetWorkOfUint32ThenUint32()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfUint32ThenUint32(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfUint32(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfUint32ThenUint32 = func(ctx context.Context, arg uint32) (uint32, error)

type WorkerOfUint32ThenUint32 struct {
	api_syncer *ApiDecouplerOfUint32ThenUint32
	handler    WorkHandlerOfUint32ThenUint32

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfUint32ThenUint32
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfUint32ThenUint32(ctx context.Context, h WorkHandlerOfUint32ThenUint32, n int) *WorkerOfUint32ThenUint32 {
	__ := &WorkerOfUint32ThenUint32{
		api_syncer: NewApiDecouplerOfUint32ThenUint32(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfUint32ThenUint32, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfUint32ThenUint32{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfUint32ThenUint32(req.Context, req.WorkOfUint32ThenUint32, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfUint32ThenUint32) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfUint32ThenUint32) Push(ctx context.Context, req *WorkOfUint32ThenUint32) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfUint32ThenUint32)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfUint32ThenUint32 = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfUint32ThenUint32) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfUint32ThenUint32) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfUint32ThenUint32) Call(ctx context.Context, arg uint32) (uint32, error) {
	return __.api_syncer.DoOfUint32ThenUint32(ctx, __, arg)
}

type PoolOfUint32ThenUint64 interface {
	GetUint32Arg() *uint32
	PutUint32Arg(*uint32)
	GetUint64Return() *uint64
	PutUint64Return(*uint64)

	GetWorkOfUint32ThenUint64() *WorkOfUint32ThenUint64
	GetReturnOfUint64() *ReturnOfUint64
	PutWorkOfUint32ThenUint64(*WorkOfUint32ThenUint64)
	PutReturnOfUint64(*ReturnOfUint64)

	GetChReturnOfUint64() chan *ReturnOfUint64
	PutChReturnOfUint64(chan *ReturnOfUint64)
}

type PoolOfUint32ThenUint64Impl struct {
	Uint32Arg        sync.Pool
	Uint64Rtn        sync.Pool
	Uint32Work       sync.Pool
	Uint64Return     sync.Pool
	ChReturnOfUint64 sync.Pool
}

func (__ *PoolOfUint32ThenUint64Impl) GetUint32Arg() *uint32 {
	return __.Uint32Arg.Get().(*uint32)
}
func (__ *PoolOfUint32ThenUint64Impl) PutUint32Arg(p *uint32) {
	__.Uint32Arg.Put(p)
}
func (__ *PoolOfUint32ThenUint64Impl) GetUint64Return() *uint64 {
	return __.Uint64Rtn.Get().(*uint64)
}
func (__ *PoolOfUint32ThenUint64Impl) PutUint64Return(p *uint64) {
	__.Uint64Rtn.Put(p)
}

func (__ *PoolOfUint32ThenUint64Impl) GetWorkOfUint32ThenUint64() *WorkOfUint32ThenUint64 {
	return __.Uint32Work.Get().(*WorkOfUint32ThenUint64)
}
func (__ *PoolOfUint32ThenUint64Impl) PutWorkOfUint32ThenUint64(p *WorkOfUint32ThenUint64) {
	__.Uint32Work.Put(p)
}
func (__ *PoolOfUint32ThenUint64Impl) GetReturnOfUint64() *ReturnOfUint64 {
	return __.Uint64Return.Get().(*ReturnOfUint64)
}
func (__ *PoolOfUint32ThenUint64Impl) PutReturnOfUint64(p *ReturnOfUint64) {
	__.Uint64Return.Put(p)
}

func (__ *PoolOfUint32ThenUint64Impl) GetChReturnOfUint64() chan *ReturnOfUint64 {
	return __.ChReturnOfUint64.Get().(chan *ReturnOfUint64)
}
func (__ *PoolOfUint32ThenUint64Impl) PutChReturnOfUint64(p chan *ReturnOfUint64) {
	__.ChReturnOfUint64.Put(p)
}

func NewPoolOfUint32ThenUint64Impl() *PoolOfUint32ThenUint64Impl {
	return &PoolOfUint32ThenUint64Impl{
		Uint32Arg: sync.Pool{
			New: func() interface{} {
				return new(uint32)
			},
		},
		Uint32Work: sync.Pool{
			New: func() interface{} {
				return new(WorkOfUint32ThenUint64)
			},
		},
		Uint64Rtn: sync.Pool{
			New: func() interface{} {
				return new(uint64)
			},
		},
		Uint64Return: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfUint64)
			},
		},
		ChReturnOfUint64: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfUint64, 1)
			},
		},
	}
}

type ApiDecouplerOfUint32ThenUint64 struct {
	pool PoolOfUint32ThenUint64
}

func NewApiDecouplerOfUint32ThenUint64() *ApiDecouplerOfUint32ThenUint64 {
	return &ApiDecouplerOfUint32ThenUint64{
		pool: NewPoolOfUint32ThenUint64Impl(),
	}
}

func (__ *ApiDecouplerOfUint32ThenUint64) ReturnError(rtn_ch chan<- *ReturnOfUint64, err error) {
	rtn := __.pool.GetReturnOfUint64()
	var other uint64
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfUint32ThenUint64) HandleOfUint32ThenUint64(ctx context.Context, req *WorkOfUint32ThenUint64, h func(ctx context.Context, arg uint32) (uint64, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfUint64()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfUint32ThenUint64) DoOfUint32ThenUint64(ctx context.Context, worker WorkerOfPushUint32ThenUint64, arg uint32) (uint64, error) {
	// ch := make(chan *ReturnOfUint64, 1)
	ch := __.pool.GetChReturnOfUint64()
	defer __.pool.PutChReturnOfUint64(ch)

	req := __.pool.GetWorkOfUint32ThenUint64()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfUint32ThenUint64(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfUint64(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfUint32ThenUint64 = func(ctx context.Context, arg uint32) (uint64, error)

type WorkerOfUint32ThenUint64 struct {
	api_syncer *ApiDecouplerOfUint32ThenUint64
	handler    WorkHandlerOfUint32ThenUint64

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfUint32ThenUint64
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfUint32ThenUint64(ctx context.Context, h WorkHandlerOfUint32ThenUint64, n int) *WorkerOfUint32ThenUint64 {
	__ := &WorkerOfUint32ThenUint64{
		api_syncer: NewApiDecouplerOfUint32ThenUint64(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfUint32ThenUint64, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfUint32ThenUint64{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfUint32ThenUint64(req.Context, req.WorkOfUint32ThenUint64, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfUint32ThenUint64) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfUint32ThenUint64) Push(ctx context.Context, req *WorkOfUint32ThenUint64) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfUint32ThenUint64)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfUint32ThenUint64 = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfUint32ThenUint64) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfUint32ThenUint64) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfUint32ThenUint64) Call(ctx context.Context, arg uint32) (uint64, error) {
	return __.api_syncer.DoOfUint32ThenUint64(ctx, __, arg)
}

type PoolOfUint32ThenUint8 interface {
	GetUint32Arg() *uint32
	PutUint32Arg(*uint32)
	GetUint8Return() *uint8
	PutUint8Return(*uint8)

	GetWorkOfUint32ThenUint8() *WorkOfUint32ThenUint8
	GetReturnOfUint8() *ReturnOfUint8
	PutWorkOfUint32ThenUint8(*WorkOfUint32ThenUint8)
	PutReturnOfUint8(*ReturnOfUint8)

	GetChReturnOfUint8() chan *ReturnOfUint8
	PutChReturnOfUint8(chan *ReturnOfUint8)
}

type PoolOfUint32ThenUint8Impl struct {
	Uint32Arg       sync.Pool
	Uint8Rtn        sync.Pool
	Uint32Work      sync.Pool
	Uint8Return     sync.Pool
	ChReturnOfUint8 sync.Pool
}

func (__ *PoolOfUint32ThenUint8Impl) GetUint32Arg() *uint32 {
	return __.Uint32Arg.Get().(*uint32)
}
func (__ *PoolOfUint32ThenUint8Impl) PutUint32Arg(p *uint32) {
	__.Uint32Arg.Put(p)
}
func (__ *PoolOfUint32ThenUint8Impl) GetUint8Return() *uint8 {
	return __.Uint8Rtn.Get().(*uint8)
}
func (__ *PoolOfUint32ThenUint8Impl) PutUint8Return(p *uint8) {
	__.Uint8Rtn.Put(p)
}

func (__ *PoolOfUint32ThenUint8Impl) GetWorkOfUint32ThenUint8() *WorkOfUint32ThenUint8 {
	return __.Uint32Work.Get().(*WorkOfUint32ThenUint8)
}
func (__ *PoolOfUint32ThenUint8Impl) PutWorkOfUint32ThenUint8(p *WorkOfUint32ThenUint8) {
	__.Uint32Work.Put(p)
}
func (__ *PoolOfUint32ThenUint8Impl) GetReturnOfUint8() *ReturnOfUint8 {
	return __.Uint8Return.Get().(*ReturnOfUint8)
}
func (__ *PoolOfUint32ThenUint8Impl) PutReturnOfUint8(p *ReturnOfUint8) {
	__.Uint8Return.Put(p)
}

func (__ *PoolOfUint32ThenUint8Impl) GetChReturnOfUint8() chan *ReturnOfUint8 {
	return __.ChReturnOfUint8.Get().(chan *ReturnOfUint8)
}
func (__ *PoolOfUint32ThenUint8Impl) PutChReturnOfUint8(p chan *ReturnOfUint8) {
	__.ChReturnOfUint8.Put(p)
}

func NewPoolOfUint32ThenUint8Impl() *PoolOfUint32ThenUint8Impl {
	return &PoolOfUint32ThenUint8Impl{
		Uint32Arg: sync.Pool{
			New: func() interface{} {
				return new(uint32)
			},
		},
		Uint32Work: sync.Pool{
			New: func() interface{} {
				return new(WorkOfUint32ThenUint8)
			},
		},
		Uint8Rtn: sync.Pool{
			New: func() interface{} {
				return new(uint8)
			},
		},
		Uint8Return: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfUint8)
			},
		},
		ChReturnOfUint8: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfUint8, 1)
			},
		},
	}
}

type ApiDecouplerOfUint32ThenUint8 struct {
	pool PoolOfUint32ThenUint8
}

func NewApiDecouplerOfUint32ThenUint8() *ApiDecouplerOfUint32ThenUint8 {
	return &ApiDecouplerOfUint32ThenUint8{
		pool: NewPoolOfUint32ThenUint8Impl(),
	}
}

func (__ *ApiDecouplerOfUint32ThenUint8) ReturnError(rtn_ch chan<- *ReturnOfUint8, err error) {
	rtn := __.pool.GetReturnOfUint8()
	var other uint8
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfUint32ThenUint8) HandleOfUint32ThenUint8(ctx context.Context, req *WorkOfUint32ThenUint8, h func(ctx context.Context, arg uint32) (uint8, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfUint8()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfUint32ThenUint8) DoOfUint32ThenUint8(ctx context.Context, worker WorkerOfPushUint32ThenUint8, arg uint32) (uint8, error) {
	// ch := make(chan *ReturnOfUint8, 1)
	ch := __.pool.GetChReturnOfUint8()
	defer __.pool.PutChReturnOfUint8(ch)

	req := __.pool.GetWorkOfUint32ThenUint8()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfUint32ThenUint8(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfUint8(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfUint32ThenUint8 = func(ctx context.Context, arg uint32) (uint8, error)

type WorkerOfUint32ThenUint8 struct {
	api_syncer *ApiDecouplerOfUint32ThenUint8
	handler    WorkHandlerOfUint32ThenUint8

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfUint32ThenUint8
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfUint32ThenUint8(ctx context.Context, h WorkHandlerOfUint32ThenUint8, n int) *WorkerOfUint32ThenUint8 {
	__ := &WorkerOfUint32ThenUint8{
		api_syncer: NewApiDecouplerOfUint32ThenUint8(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfUint32ThenUint8, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfUint32ThenUint8{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfUint32ThenUint8(req.Context, req.WorkOfUint32ThenUint8, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfUint32ThenUint8) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfUint32ThenUint8) Push(ctx context.Context, req *WorkOfUint32ThenUint8) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfUint32ThenUint8)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfUint32ThenUint8 = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfUint32ThenUint8) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfUint32ThenUint8) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfUint32ThenUint8) Call(ctx context.Context, arg uint32) (uint8, error) {
	return __.api_syncer.DoOfUint32ThenUint8(ctx, __, arg)
}

type PoolOfUint32ThenUintptr interface {
	GetUint32Arg() *uint32
	PutUint32Arg(*uint32)
	GetUintptrReturn() *uintptr
	PutUintptrReturn(*uintptr)

	GetWorkOfUint32ThenUintptr() *WorkOfUint32ThenUintptr
	GetReturnOfUintptr() *ReturnOfUintptr
	PutWorkOfUint32ThenUintptr(*WorkOfUint32ThenUintptr)
	PutReturnOfUintptr(*ReturnOfUintptr)

	GetChReturnOfUintptr() chan *ReturnOfUintptr
	PutChReturnOfUintptr(chan *ReturnOfUintptr)
}

type PoolOfUint32ThenUintptrImpl struct {
	Uint32Arg         sync.Pool
	UintptrRtn        sync.Pool
	Uint32Work        sync.Pool
	UintptrReturn     sync.Pool
	ChReturnOfUintptr sync.Pool
}

func (__ *PoolOfUint32ThenUintptrImpl) GetUint32Arg() *uint32 {
	return __.Uint32Arg.Get().(*uint32)
}
func (__ *PoolOfUint32ThenUintptrImpl) PutUint32Arg(p *uint32) {
	__.Uint32Arg.Put(p)
}
func (__ *PoolOfUint32ThenUintptrImpl) GetUintptrReturn() *uintptr {
	return __.UintptrRtn.Get().(*uintptr)
}
func (__ *PoolOfUint32ThenUintptrImpl) PutUintptrReturn(p *uintptr) {
	__.UintptrRtn.Put(p)
}

func (__ *PoolOfUint32ThenUintptrImpl) GetWorkOfUint32ThenUintptr() *WorkOfUint32ThenUintptr {
	return __.Uint32Work.Get().(*WorkOfUint32ThenUintptr)
}
func (__ *PoolOfUint32ThenUintptrImpl) PutWorkOfUint32ThenUintptr(p *WorkOfUint32ThenUintptr) {
	__.Uint32Work.Put(p)
}
func (__ *PoolOfUint32ThenUintptrImpl) GetReturnOfUintptr() *ReturnOfUintptr {
	return __.UintptrReturn.Get().(*ReturnOfUintptr)
}
func (__ *PoolOfUint32ThenUintptrImpl) PutReturnOfUintptr(p *ReturnOfUintptr) {
	__.UintptrReturn.Put(p)
}

func (__ *PoolOfUint32ThenUintptrImpl) GetChReturnOfUintptr() chan *ReturnOfUintptr {
	return __.ChReturnOfUintptr.Get().(chan *ReturnOfUintptr)
}
func (__ *PoolOfUint32ThenUintptrImpl) PutChReturnOfUintptr(p chan *ReturnOfUintptr) {
	__.ChReturnOfUintptr.Put(p)
}

func NewPoolOfUint32ThenUintptrImpl() *PoolOfUint32ThenUintptrImpl {
	return &PoolOfUint32ThenUintptrImpl{
		Uint32Arg: sync.Pool{
			New: func() interface{} {
				return new(uint32)
			},
		},
		Uint32Work: sync.Pool{
			New: func() interface{} {
				return new(WorkOfUint32ThenUintptr)
			},
		},
		UintptrRtn: sync.Pool{
			New: func() interface{} {
				return new(uintptr)
			},
		},
		UintptrReturn: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfUintptr)
			},
		},
		ChReturnOfUintptr: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfUintptr, 1)
			},
		},
	}
}

type ApiDecouplerOfUint32ThenUintptr struct {
	pool PoolOfUint32ThenUintptr
}

func NewApiDecouplerOfUint32ThenUintptr() *ApiDecouplerOfUint32ThenUintptr {
	return &ApiDecouplerOfUint32ThenUintptr{
		pool: NewPoolOfUint32ThenUintptrImpl(),
	}
}

func (__ *ApiDecouplerOfUint32ThenUintptr) ReturnError(rtn_ch chan<- *ReturnOfUintptr, err error) {
	rtn := __.pool.GetReturnOfUintptr()
	var other uintptr
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfUint32ThenUintptr) HandleOfUint32ThenUintptr(ctx context.Context, req *WorkOfUint32ThenUintptr, h func(ctx context.Context, arg uint32) (uintptr, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfUintptr()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfUint32ThenUintptr) DoOfUint32ThenUintptr(ctx context.Context, worker WorkerOfPushUint32ThenUintptr, arg uint32) (uintptr, error) {
	// ch := make(chan *ReturnOfUintptr, 1)
	ch := __.pool.GetChReturnOfUintptr()
	defer __.pool.PutChReturnOfUintptr(ch)

	req := __.pool.GetWorkOfUint32ThenUintptr()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfUint32ThenUintptr(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfUintptr(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfUint32ThenUintptr = func(ctx context.Context, arg uint32) (uintptr, error)

type WorkerOfUint32ThenUintptr struct {
	api_syncer *ApiDecouplerOfUint32ThenUintptr
	handler    WorkHandlerOfUint32ThenUintptr

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfUint32ThenUintptr
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfUint32ThenUintptr(ctx context.Context, h WorkHandlerOfUint32ThenUintptr, n int) *WorkerOfUint32ThenUintptr {
	__ := &WorkerOfUint32ThenUintptr{
		api_syncer: NewApiDecouplerOfUint32ThenUintptr(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfUint32ThenUintptr, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfUint32ThenUintptr{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfUint32ThenUintptr(req.Context, req.WorkOfUint32ThenUintptr, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfUint32ThenUintptr) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfUint32ThenUintptr) Push(ctx context.Context, req *WorkOfUint32ThenUintptr) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfUint32ThenUintptr)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfUint32ThenUintptr = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfUint32ThenUintptr) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfUint32ThenUintptr) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfUint32ThenUintptr) Call(ctx context.Context, arg uint32) (uintptr, error) {
	return __.api_syncer.DoOfUint32ThenUintptr(ctx, __, arg)
}

type PoolOfUint32ThenInterface interface {
	GetUint32Arg() *uint32
	PutUint32Arg(*uint32)
	GetInterfaceReturn() *interface{}
	PutInterfaceReturn(*interface{})

	GetWorkOfUint32ThenInterface() *WorkOfUint32ThenInterface
	GetReturnOfInterface() *ReturnOfInterface
	PutWorkOfUint32ThenInterface(*WorkOfUint32ThenInterface)
	PutReturnOfInterface(*ReturnOfInterface)

	GetChReturnOfInterface() chan *ReturnOfInterface
	PutChReturnOfInterface(chan *ReturnOfInterface)
}

type PoolOfUint32ThenInterfaceImpl struct {
	Uint32Arg           sync.Pool
	InterfaceRtn        sync.Pool
	Uint32Work          sync.Pool
	InterfaceReturn     sync.Pool
	ChReturnOfInterface sync.Pool
}

func (__ *PoolOfUint32ThenInterfaceImpl) GetUint32Arg() *uint32 {
	return __.Uint32Arg.Get().(*uint32)
}
func (__ *PoolOfUint32ThenInterfaceImpl) PutUint32Arg(p *uint32) {
	__.Uint32Arg.Put(p)
}
func (__ *PoolOfUint32ThenInterfaceImpl) GetInterfaceReturn() *interface{} {
	return __.InterfaceRtn.Get().(*interface{})
}
func (__ *PoolOfUint32ThenInterfaceImpl) PutInterfaceReturn(p *interface{}) {
	__.InterfaceRtn.Put(p)
}

func (__ *PoolOfUint32ThenInterfaceImpl) GetWorkOfUint32ThenInterface() *WorkOfUint32ThenInterface {
	return __.Uint32Work.Get().(*WorkOfUint32ThenInterface)
}
func (__ *PoolOfUint32ThenInterfaceImpl) PutWorkOfUint32ThenInterface(p *WorkOfUint32ThenInterface) {
	__.Uint32Work.Put(p)
}
func (__ *PoolOfUint32ThenInterfaceImpl) GetReturnOfInterface() *ReturnOfInterface {
	return __.InterfaceReturn.Get().(*ReturnOfInterface)
}
func (__ *PoolOfUint32ThenInterfaceImpl) PutReturnOfInterface(p *ReturnOfInterface) {
	__.InterfaceReturn.Put(p)
}

func (__ *PoolOfUint32ThenInterfaceImpl) GetChReturnOfInterface() chan *ReturnOfInterface {
	return __.ChReturnOfInterface.Get().(chan *ReturnOfInterface)
}
func (__ *PoolOfUint32ThenInterfaceImpl) PutChReturnOfInterface(p chan *ReturnOfInterface) {
	__.ChReturnOfInterface.Put(p)
}

func NewPoolOfUint32ThenInterfaceImpl() *PoolOfUint32ThenInterfaceImpl {
	return &PoolOfUint32ThenInterfaceImpl{
		Uint32Arg: sync.Pool{
			New: func() interface{} {
				return new(uint32)
			},
		},
		Uint32Work: sync.Pool{
			New: func() interface{} {
				return new(WorkOfUint32ThenInterface)
			},
		},
		InterfaceRtn: sync.Pool{
			New: func() interface{} {
				return new(interface{})
			},
		},
		InterfaceReturn: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfInterface)
			},
		},
		ChReturnOfInterface: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfInterface, 1)
			},
		},
	}
}

type ApiDecouplerOfUint32ThenInterface struct {
	pool PoolOfUint32ThenInterface
}

func NewApiDecouplerOfUint32ThenInterface() *ApiDecouplerOfUint32ThenInterface {
	return &ApiDecouplerOfUint32ThenInterface{
		pool: NewPoolOfUint32ThenInterfaceImpl(),
	}
}

func (__ *ApiDecouplerOfUint32ThenInterface) ReturnError(rtn_ch chan<- *ReturnOfInterface, err error) {
	rtn := __.pool.GetReturnOfInterface()
	var other interface{}
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfUint32ThenInterface) HandleOfUint32ThenInterface(ctx context.Context, req *WorkOfUint32ThenInterface, h func(ctx context.Context, arg uint32) (interface{}, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfInterface()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfUint32ThenInterface) DoOfUint32ThenInterface(ctx context.Context, worker WorkerOfPushUint32ThenInterface, arg uint32) (interface{}, error) {
	// ch := make(chan *ReturnOfInterface, 1)
	ch := __.pool.GetChReturnOfInterface()
	defer __.pool.PutChReturnOfInterface(ch)

	req := __.pool.GetWorkOfUint32ThenInterface()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfUint32ThenInterface(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfInterface(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfUint32ThenInterface = func(ctx context.Context, arg uint32) (interface{}, error)

type WorkerOfUint32ThenInterface struct {
	api_syncer *ApiDecouplerOfUint32ThenInterface
	handler    WorkHandlerOfUint32ThenInterface

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfUint32ThenInterface
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfUint32ThenInterface(ctx context.Context, h WorkHandlerOfUint32ThenInterface, n int) *WorkerOfUint32ThenInterface {
	__ := &WorkerOfUint32ThenInterface{
		api_syncer: NewApiDecouplerOfUint32ThenInterface(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfUint32ThenInterface, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfUint32ThenInterface{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfUint32ThenInterface(req.Context, req.WorkOfUint32ThenInterface, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfUint32ThenInterface) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfUint32ThenInterface) Push(ctx context.Context, req *WorkOfUint32ThenInterface) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfUint32ThenInterface)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfUint32ThenInterface = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfUint32ThenInterface) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfUint32ThenInterface) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfUint32ThenInterface) Call(ctx context.Context, arg uint32) (interface{}, error) {
	return __.api_syncer.DoOfUint32ThenInterface(ctx, __, arg)
}

type PoolOfUint32ThenStruct interface {
	GetUint32Arg() *uint32
	PutUint32Arg(*uint32)
	GetStructReturn() *struct{}
	PutStructReturn(*struct{})

	GetWorkOfUint32ThenStruct() *WorkOfUint32ThenStruct
	GetReturnOfStruct() *ReturnOfStruct
	PutWorkOfUint32ThenStruct(*WorkOfUint32ThenStruct)
	PutReturnOfStruct(*ReturnOfStruct)

	GetChReturnOfStruct() chan *ReturnOfStruct
	PutChReturnOfStruct(chan *ReturnOfStruct)
}

type PoolOfUint32ThenStructImpl struct {
	Uint32Arg        sync.Pool
	StructRtn        sync.Pool
	Uint32Work       sync.Pool
	StructReturn     sync.Pool
	ChReturnOfStruct sync.Pool
}

func (__ *PoolOfUint32ThenStructImpl) GetUint32Arg() *uint32 {
	return __.Uint32Arg.Get().(*uint32)
}
func (__ *PoolOfUint32ThenStructImpl) PutUint32Arg(p *uint32) {
	__.Uint32Arg.Put(p)
}
func (__ *PoolOfUint32ThenStructImpl) GetStructReturn() *struct{} {
	return __.StructRtn.Get().(*struct{})
}
func (__ *PoolOfUint32ThenStructImpl) PutStructReturn(p *struct{}) {
	__.StructRtn.Put(p)
}

func (__ *PoolOfUint32ThenStructImpl) GetWorkOfUint32ThenStruct() *WorkOfUint32ThenStruct {
	return __.Uint32Work.Get().(*WorkOfUint32ThenStruct)
}
func (__ *PoolOfUint32ThenStructImpl) PutWorkOfUint32ThenStruct(p *WorkOfUint32ThenStruct) {
	__.Uint32Work.Put(p)
}
func (__ *PoolOfUint32ThenStructImpl) GetReturnOfStruct() *ReturnOfStruct {
	return __.StructReturn.Get().(*ReturnOfStruct)
}
func (__ *PoolOfUint32ThenStructImpl) PutReturnOfStruct(p *ReturnOfStruct) {
	__.StructReturn.Put(p)
}

func (__ *PoolOfUint32ThenStructImpl) GetChReturnOfStruct() chan *ReturnOfStruct {
	return __.ChReturnOfStruct.Get().(chan *ReturnOfStruct)
}
func (__ *PoolOfUint32ThenStructImpl) PutChReturnOfStruct(p chan *ReturnOfStruct) {
	__.ChReturnOfStruct.Put(p)
}

func NewPoolOfUint32ThenStructImpl() *PoolOfUint32ThenStructImpl {
	return &PoolOfUint32ThenStructImpl{
		Uint32Arg: sync.Pool{
			New: func() interface{} {
				return new(uint32)
			},
		},
		Uint32Work: sync.Pool{
			New: func() interface{} {
				return new(WorkOfUint32ThenStruct)
			},
		},
		StructRtn: sync.Pool{
			New: func() interface{} {
				return new(struct{})
			},
		},
		StructReturn: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfStruct)
			},
		},
		ChReturnOfStruct: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfStruct, 1)
			},
		},
	}
}

type ApiDecouplerOfUint32ThenStruct struct {
	pool PoolOfUint32ThenStruct
}

func NewApiDecouplerOfUint32ThenStruct() *ApiDecouplerOfUint32ThenStruct {
	return &ApiDecouplerOfUint32ThenStruct{
		pool: NewPoolOfUint32ThenStructImpl(),
	}
}

func (__ *ApiDecouplerOfUint32ThenStruct) ReturnError(rtn_ch chan<- *ReturnOfStruct, err error) {
	rtn := __.pool.GetReturnOfStruct()
	var other struct{}
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfUint32ThenStruct) HandleOfUint32ThenStruct(ctx context.Context, req *WorkOfUint32ThenStruct, h func(ctx context.Context, arg uint32) (struct{}, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfStruct()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfUint32ThenStruct) DoOfUint32ThenStruct(ctx context.Context, worker WorkerOfPushUint32ThenStruct, arg uint32) (struct{}, error) {
	// ch := make(chan *ReturnOfStruct, 1)
	ch := __.pool.GetChReturnOfStruct()
	defer __.pool.PutChReturnOfStruct(ch)

	req := __.pool.GetWorkOfUint32ThenStruct()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfUint32ThenStruct(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfStruct(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfUint32ThenStruct = func(ctx context.Context, arg uint32) (struct{}, error)

type WorkerOfUint32ThenStruct struct {
	api_syncer *ApiDecouplerOfUint32ThenStruct
	handler    WorkHandlerOfUint32ThenStruct

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfUint32ThenStruct
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfUint32ThenStruct(ctx context.Context, h WorkHandlerOfUint32ThenStruct, n int) *WorkerOfUint32ThenStruct {
	__ := &WorkerOfUint32ThenStruct{
		api_syncer: NewApiDecouplerOfUint32ThenStruct(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfUint32ThenStruct, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfUint32ThenStruct{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfUint32ThenStruct(req.Context, req.WorkOfUint32ThenStruct, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfUint32ThenStruct) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfUint32ThenStruct) Push(ctx context.Context, req *WorkOfUint32ThenStruct) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfUint32ThenStruct)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfUint32ThenStruct = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfUint32ThenStruct) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfUint32ThenStruct) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfUint32ThenStruct) Call(ctx context.Context, arg uint32) (struct{}, error) {
	return __.api_syncer.DoOfUint32ThenStruct(ctx, __, arg)
}

type PoolOfUint64ThenBool interface {
	GetUint64Arg() *uint64
	PutUint64Arg(*uint64)
	GetBoolReturn() *bool
	PutBoolReturn(*bool)

	GetWorkOfUint64ThenBool() *WorkOfUint64ThenBool
	GetReturnOfBool() *ReturnOfBool
	PutWorkOfUint64ThenBool(*WorkOfUint64ThenBool)
	PutReturnOfBool(*ReturnOfBool)

	GetChReturnOfBool() chan *ReturnOfBool
	PutChReturnOfBool(chan *ReturnOfBool)
}

type PoolOfUint64ThenBoolImpl struct {
	Uint64Arg      sync.Pool
	BoolRtn        sync.Pool
	Uint64Work     sync.Pool
	BoolReturn     sync.Pool
	ChReturnOfBool sync.Pool
}

func (__ *PoolOfUint64ThenBoolImpl) GetUint64Arg() *uint64 {
	return __.Uint64Arg.Get().(*uint64)
}
func (__ *PoolOfUint64ThenBoolImpl) PutUint64Arg(p *uint64) {
	__.Uint64Arg.Put(p)
}
func (__ *PoolOfUint64ThenBoolImpl) GetBoolReturn() *bool {
	return __.BoolRtn.Get().(*bool)
}
func (__ *PoolOfUint64ThenBoolImpl) PutBoolReturn(p *bool) {
	__.BoolRtn.Put(p)
}

func (__ *PoolOfUint64ThenBoolImpl) GetWorkOfUint64ThenBool() *WorkOfUint64ThenBool {
	return __.Uint64Work.Get().(*WorkOfUint64ThenBool)
}
func (__ *PoolOfUint64ThenBoolImpl) PutWorkOfUint64ThenBool(p *WorkOfUint64ThenBool) {
	__.Uint64Work.Put(p)
}
func (__ *PoolOfUint64ThenBoolImpl) GetReturnOfBool() *ReturnOfBool {
	return __.BoolReturn.Get().(*ReturnOfBool)
}
func (__ *PoolOfUint64ThenBoolImpl) PutReturnOfBool(p *ReturnOfBool) {
	__.BoolReturn.Put(p)
}

func (__ *PoolOfUint64ThenBoolImpl) GetChReturnOfBool() chan *ReturnOfBool {
	return __.ChReturnOfBool.Get().(chan *ReturnOfBool)
}
func (__ *PoolOfUint64ThenBoolImpl) PutChReturnOfBool(p chan *ReturnOfBool) {
	__.ChReturnOfBool.Put(p)
}

func NewPoolOfUint64ThenBoolImpl() *PoolOfUint64ThenBoolImpl {
	return &PoolOfUint64ThenBoolImpl{
		Uint64Arg: sync.Pool{
			New: func() interface{} {
				return new(uint64)
			},
		},
		Uint64Work: sync.Pool{
			New: func() interface{} {
				return new(WorkOfUint64ThenBool)
			},
		},
		BoolRtn: sync.Pool{
			New: func() interface{} {
				return new(bool)
			},
		},
		BoolReturn: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfBool)
			},
		},
		ChReturnOfBool: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfBool, 1)
			},
		},
	}
}

type ApiDecouplerOfUint64ThenBool struct {
	pool PoolOfUint64ThenBool
}

func NewApiDecouplerOfUint64ThenBool() *ApiDecouplerOfUint64ThenBool {
	return &ApiDecouplerOfUint64ThenBool{
		pool: NewPoolOfUint64ThenBoolImpl(),
	}
}

func (__ *ApiDecouplerOfUint64ThenBool) ReturnError(rtn_ch chan<- *ReturnOfBool, err error) {
	rtn := __.pool.GetReturnOfBool()
	var other bool
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfUint64ThenBool) HandleOfUint64ThenBool(ctx context.Context, req *WorkOfUint64ThenBool, h func(ctx context.Context, arg uint64) (bool, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfBool()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfUint64ThenBool) DoOfUint64ThenBool(ctx context.Context, worker WorkerOfPushUint64ThenBool, arg uint64) (bool, error) {
	// ch := make(chan *ReturnOfBool, 1)
	ch := __.pool.GetChReturnOfBool()
	defer __.pool.PutChReturnOfBool(ch)

	req := __.pool.GetWorkOfUint64ThenBool()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfUint64ThenBool(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfBool(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfUint64ThenBool = func(ctx context.Context, arg uint64) (bool, error)

type WorkerOfUint64ThenBool struct {
	api_syncer *ApiDecouplerOfUint64ThenBool
	handler    WorkHandlerOfUint64ThenBool

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfUint64ThenBool
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfUint64ThenBool(ctx context.Context, h WorkHandlerOfUint64ThenBool, n int) *WorkerOfUint64ThenBool {
	__ := &WorkerOfUint64ThenBool{
		api_syncer: NewApiDecouplerOfUint64ThenBool(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfUint64ThenBool, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfUint64ThenBool{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfUint64ThenBool(req.Context, req.WorkOfUint64ThenBool, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfUint64ThenBool) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfUint64ThenBool) Push(ctx context.Context, req *WorkOfUint64ThenBool) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfUint64ThenBool)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfUint64ThenBool = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfUint64ThenBool) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfUint64ThenBool) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfUint64ThenBool) Call(ctx context.Context, arg uint64) (bool, error) {
	return __.api_syncer.DoOfUint64ThenBool(ctx, __, arg)
}

type PoolOfUint64ThenByte interface {
	GetUint64Arg() *uint64
	PutUint64Arg(*uint64)
	GetByteReturn() *byte
	PutByteReturn(*byte)

	GetWorkOfUint64ThenByte() *WorkOfUint64ThenByte
	GetReturnOfByte() *ReturnOfByte
	PutWorkOfUint64ThenByte(*WorkOfUint64ThenByte)
	PutReturnOfByte(*ReturnOfByte)

	GetChReturnOfByte() chan *ReturnOfByte
	PutChReturnOfByte(chan *ReturnOfByte)
}

type PoolOfUint64ThenByteImpl struct {
	Uint64Arg      sync.Pool
	ByteRtn        sync.Pool
	Uint64Work     sync.Pool
	ByteReturn     sync.Pool
	ChReturnOfByte sync.Pool
}

func (__ *PoolOfUint64ThenByteImpl) GetUint64Arg() *uint64 {
	return __.Uint64Arg.Get().(*uint64)
}
func (__ *PoolOfUint64ThenByteImpl) PutUint64Arg(p *uint64) {
	__.Uint64Arg.Put(p)
}
func (__ *PoolOfUint64ThenByteImpl) GetByteReturn() *byte {
	return __.ByteRtn.Get().(*byte)
}
func (__ *PoolOfUint64ThenByteImpl) PutByteReturn(p *byte) {
	__.ByteRtn.Put(p)
}

func (__ *PoolOfUint64ThenByteImpl) GetWorkOfUint64ThenByte() *WorkOfUint64ThenByte {
	return __.Uint64Work.Get().(*WorkOfUint64ThenByte)
}
func (__ *PoolOfUint64ThenByteImpl) PutWorkOfUint64ThenByte(p *WorkOfUint64ThenByte) {
	__.Uint64Work.Put(p)
}
func (__ *PoolOfUint64ThenByteImpl) GetReturnOfByte() *ReturnOfByte {
	return __.ByteReturn.Get().(*ReturnOfByte)
}
func (__ *PoolOfUint64ThenByteImpl) PutReturnOfByte(p *ReturnOfByte) {
	__.ByteReturn.Put(p)
}

func (__ *PoolOfUint64ThenByteImpl) GetChReturnOfByte() chan *ReturnOfByte {
	return __.ChReturnOfByte.Get().(chan *ReturnOfByte)
}
func (__ *PoolOfUint64ThenByteImpl) PutChReturnOfByte(p chan *ReturnOfByte) {
	__.ChReturnOfByte.Put(p)
}

func NewPoolOfUint64ThenByteImpl() *PoolOfUint64ThenByteImpl {
	return &PoolOfUint64ThenByteImpl{
		Uint64Arg: sync.Pool{
			New: func() interface{} {
				return new(uint64)
			},
		},
		Uint64Work: sync.Pool{
			New: func() interface{} {
				return new(WorkOfUint64ThenByte)
			},
		},
		ByteRtn: sync.Pool{
			New: func() interface{} {
				return new(byte)
			},
		},
		ByteReturn: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfByte)
			},
		},
		ChReturnOfByte: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfByte, 1)
			},
		},
	}
}

type ApiDecouplerOfUint64ThenByte struct {
	pool PoolOfUint64ThenByte
}

func NewApiDecouplerOfUint64ThenByte() *ApiDecouplerOfUint64ThenByte {
	return &ApiDecouplerOfUint64ThenByte{
		pool: NewPoolOfUint64ThenByteImpl(),
	}
}

func (__ *ApiDecouplerOfUint64ThenByte) ReturnError(rtn_ch chan<- *ReturnOfByte, err error) {
	rtn := __.pool.GetReturnOfByte()
	var other byte
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfUint64ThenByte) HandleOfUint64ThenByte(ctx context.Context, req *WorkOfUint64ThenByte, h func(ctx context.Context, arg uint64) (byte, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfByte()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfUint64ThenByte) DoOfUint64ThenByte(ctx context.Context, worker WorkerOfPushUint64ThenByte, arg uint64) (byte, error) {
	// ch := make(chan *ReturnOfByte, 1)
	ch := __.pool.GetChReturnOfByte()
	defer __.pool.PutChReturnOfByte(ch)

	req := __.pool.GetWorkOfUint64ThenByte()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfUint64ThenByte(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfByte(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfUint64ThenByte = func(ctx context.Context, arg uint64) (byte, error)

type WorkerOfUint64ThenByte struct {
	api_syncer *ApiDecouplerOfUint64ThenByte
	handler    WorkHandlerOfUint64ThenByte

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfUint64ThenByte
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfUint64ThenByte(ctx context.Context, h WorkHandlerOfUint64ThenByte, n int) *WorkerOfUint64ThenByte {
	__ := &WorkerOfUint64ThenByte{
		api_syncer: NewApiDecouplerOfUint64ThenByte(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfUint64ThenByte, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfUint64ThenByte{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfUint64ThenByte(req.Context, req.WorkOfUint64ThenByte, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfUint64ThenByte) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfUint64ThenByte) Push(ctx context.Context, req *WorkOfUint64ThenByte) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfUint64ThenByte)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfUint64ThenByte = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfUint64ThenByte) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfUint64ThenByte) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfUint64ThenByte) Call(ctx context.Context, arg uint64) (byte, error) {
	return __.api_syncer.DoOfUint64ThenByte(ctx, __, arg)
}

type PoolOfUint64ThenComplex128 interface {
	GetUint64Arg() *uint64
	PutUint64Arg(*uint64)
	GetComplex128Return() *complex128
	PutComplex128Return(*complex128)

	GetWorkOfUint64ThenComplex128() *WorkOfUint64ThenComplex128
	GetReturnOfComplex128() *ReturnOfComplex128
	PutWorkOfUint64ThenComplex128(*WorkOfUint64ThenComplex128)
	PutReturnOfComplex128(*ReturnOfComplex128)

	GetChReturnOfComplex128() chan *ReturnOfComplex128
	PutChReturnOfComplex128(chan *ReturnOfComplex128)
}

type PoolOfUint64ThenComplex128Impl struct {
	Uint64Arg            sync.Pool
	Complex128Rtn        sync.Pool
	Uint64Work           sync.Pool
	Complex128Return     sync.Pool
	ChReturnOfComplex128 sync.Pool
}

func (__ *PoolOfUint64ThenComplex128Impl) GetUint64Arg() *uint64 {
	return __.Uint64Arg.Get().(*uint64)
}
func (__ *PoolOfUint64ThenComplex128Impl) PutUint64Arg(p *uint64) {
	__.Uint64Arg.Put(p)
}
func (__ *PoolOfUint64ThenComplex128Impl) GetComplex128Return() *complex128 {
	return __.Complex128Rtn.Get().(*complex128)
}
func (__ *PoolOfUint64ThenComplex128Impl) PutComplex128Return(p *complex128) {
	__.Complex128Rtn.Put(p)
}

func (__ *PoolOfUint64ThenComplex128Impl) GetWorkOfUint64ThenComplex128() *WorkOfUint64ThenComplex128 {
	return __.Uint64Work.Get().(*WorkOfUint64ThenComplex128)
}
func (__ *PoolOfUint64ThenComplex128Impl) PutWorkOfUint64ThenComplex128(p *WorkOfUint64ThenComplex128) {
	__.Uint64Work.Put(p)
}
func (__ *PoolOfUint64ThenComplex128Impl) GetReturnOfComplex128() *ReturnOfComplex128 {
	return __.Complex128Return.Get().(*ReturnOfComplex128)
}
func (__ *PoolOfUint64ThenComplex128Impl) PutReturnOfComplex128(p *ReturnOfComplex128) {
	__.Complex128Return.Put(p)
}

func (__ *PoolOfUint64ThenComplex128Impl) GetChReturnOfComplex128() chan *ReturnOfComplex128 {
	return __.ChReturnOfComplex128.Get().(chan *ReturnOfComplex128)
}
func (__ *PoolOfUint64ThenComplex128Impl) PutChReturnOfComplex128(p chan *ReturnOfComplex128) {
	__.ChReturnOfComplex128.Put(p)
}

func NewPoolOfUint64ThenComplex128Impl() *PoolOfUint64ThenComplex128Impl {
	return &PoolOfUint64ThenComplex128Impl{
		Uint64Arg: sync.Pool{
			New: func() interface{} {
				return new(uint64)
			},
		},
		Uint64Work: sync.Pool{
			New: func() interface{} {
				return new(WorkOfUint64ThenComplex128)
			},
		},
		Complex128Rtn: sync.Pool{
			New: func() interface{} {
				return new(complex128)
			},
		},
		Complex128Return: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfComplex128)
			},
		},
		ChReturnOfComplex128: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfComplex128, 1)
			},
		},
	}
}

type ApiDecouplerOfUint64ThenComplex128 struct {
	pool PoolOfUint64ThenComplex128
}

func NewApiDecouplerOfUint64ThenComplex128() *ApiDecouplerOfUint64ThenComplex128 {
	return &ApiDecouplerOfUint64ThenComplex128{
		pool: NewPoolOfUint64ThenComplex128Impl(),
	}
}

func (__ *ApiDecouplerOfUint64ThenComplex128) ReturnError(rtn_ch chan<- *ReturnOfComplex128, err error) {
	rtn := __.pool.GetReturnOfComplex128()
	var other complex128
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfUint64ThenComplex128) HandleOfUint64ThenComplex128(ctx context.Context, req *WorkOfUint64ThenComplex128, h func(ctx context.Context, arg uint64) (complex128, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfComplex128()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfUint64ThenComplex128) DoOfUint64ThenComplex128(ctx context.Context, worker WorkerOfPushUint64ThenComplex128, arg uint64) (complex128, error) {
	// ch := make(chan *ReturnOfComplex128, 1)
	ch := __.pool.GetChReturnOfComplex128()
	defer __.pool.PutChReturnOfComplex128(ch)

	req := __.pool.GetWorkOfUint64ThenComplex128()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfUint64ThenComplex128(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfComplex128(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfUint64ThenComplex128 = func(ctx context.Context, arg uint64) (complex128, error)

type WorkerOfUint64ThenComplex128 struct {
	api_syncer *ApiDecouplerOfUint64ThenComplex128
	handler    WorkHandlerOfUint64ThenComplex128

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfUint64ThenComplex128
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfUint64ThenComplex128(ctx context.Context, h WorkHandlerOfUint64ThenComplex128, n int) *WorkerOfUint64ThenComplex128 {
	__ := &WorkerOfUint64ThenComplex128{
		api_syncer: NewApiDecouplerOfUint64ThenComplex128(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfUint64ThenComplex128, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfUint64ThenComplex128{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfUint64ThenComplex128(req.Context, req.WorkOfUint64ThenComplex128, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfUint64ThenComplex128) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfUint64ThenComplex128) Push(ctx context.Context, req *WorkOfUint64ThenComplex128) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfUint64ThenComplex128)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfUint64ThenComplex128 = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfUint64ThenComplex128) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfUint64ThenComplex128) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfUint64ThenComplex128) Call(ctx context.Context, arg uint64) (complex128, error) {
	return __.api_syncer.DoOfUint64ThenComplex128(ctx, __, arg)
}

type PoolOfUint64ThenComplex64 interface {
	GetUint64Arg() *uint64
	PutUint64Arg(*uint64)
	GetComplex64Return() *complex64
	PutComplex64Return(*complex64)

	GetWorkOfUint64ThenComplex64() *WorkOfUint64ThenComplex64
	GetReturnOfComplex64() *ReturnOfComplex64
	PutWorkOfUint64ThenComplex64(*WorkOfUint64ThenComplex64)
	PutReturnOfComplex64(*ReturnOfComplex64)

	GetChReturnOfComplex64() chan *ReturnOfComplex64
	PutChReturnOfComplex64(chan *ReturnOfComplex64)
}

type PoolOfUint64ThenComplex64Impl struct {
	Uint64Arg           sync.Pool
	Complex64Rtn        sync.Pool
	Uint64Work          sync.Pool
	Complex64Return     sync.Pool
	ChReturnOfComplex64 sync.Pool
}

func (__ *PoolOfUint64ThenComplex64Impl) GetUint64Arg() *uint64 {
	return __.Uint64Arg.Get().(*uint64)
}
func (__ *PoolOfUint64ThenComplex64Impl) PutUint64Arg(p *uint64) {
	__.Uint64Arg.Put(p)
}
func (__ *PoolOfUint64ThenComplex64Impl) GetComplex64Return() *complex64 {
	return __.Complex64Rtn.Get().(*complex64)
}
func (__ *PoolOfUint64ThenComplex64Impl) PutComplex64Return(p *complex64) {
	__.Complex64Rtn.Put(p)
}

func (__ *PoolOfUint64ThenComplex64Impl) GetWorkOfUint64ThenComplex64() *WorkOfUint64ThenComplex64 {
	return __.Uint64Work.Get().(*WorkOfUint64ThenComplex64)
}
func (__ *PoolOfUint64ThenComplex64Impl) PutWorkOfUint64ThenComplex64(p *WorkOfUint64ThenComplex64) {
	__.Uint64Work.Put(p)
}
func (__ *PoolOfUint64ThenComplex64Impl) GetReturnOfComplex64() *ReturnOfComplex64 {
	return __.Complex64Return.Get().(*ReturnOfComplex64)
}
func (__ *PoolOfUint64ThenComplex64Impl) PutReturnOfComplex64(p *ReturnOfComplex64) {
	__.Complex64Return.Put(p)
}

func (__ *PoolOfUint64ThenComplex64Impl) GetChReturnOfComplex64() chan *ReturnOfComplex64 {
	return __.ChReturnOfComplex64.Get().(chan *ReturnOfComplex64)
}
func (__ *PoolOfUint64ThenComplex64Impl) PutChReturnOfComplex64(p chan *ReturnOfComplex64) {
	__.ChReturnOfComplex64.Put(p)
}

func NewPoolOfUint64ThenComplex64Impl() *PoolOfUint64ThenComplex64Impl {
	return &PoolOfUint64ThenComplex64Impl{
		Uint64Arg: sync.Pool{
			New: func() interface{} {
				return new(uint64)
			},
		},
		Uint64Work: sync.Pool{
			New: func() interface{} {
				return new(WorkOfUint64ThenComplex64)
			},
		},
		Complex64Rtn: sync.Pool{
			New: func() interface{} {
				return new(complex64)
			},
		},
		Complex64Return: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfComplex64)
			},
		},
		ChReturnOfComplex64: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfComplex64, 1)
			},
		},
	}
}

type ApiDecouplerOfUint64ThenComplex64 struct {
	pool PoolOfUint64ThenComplex64
}

func NewApiDecouplerOfUint64ThenComplex64() *ApiDecouplerOfUint64ThenComplex64 {
	return &ApiDecouplerOfUint64ThenComplex64{
		pool: NewPoolOfUint64ThenComplex64Impl(),
	}
}

func (__ *ApiDecouplerOfUint64ThenComplex64) ReturnError(rtn_ch chan<- *ReturnOfComplex64, err error) {
	rtn := __.pool.GetReturnOfComplex64()
	var other complex64
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfUint64ThenComplex64) HandleOfUint64ThenComplex64(ctx context.Context, req *WorkOfUint64ThenComplex64, h func(ctx context.Context, arg uint64) (complex64, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfComplex64()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfUint64ThenComplex64) DoOfUint64ThenComplex64(ctx context.Context, worker WorkerOfPushUint64ThenComplex64, arg uint64) (complex64, error) {
	// ch := make(chan *ReturnOfComplex64, 1)
	ch := __.pool.GetChReturnOfComplex64()
	defer __.pool.PutChReturnOfComplex64(ch)

	req := __.pool.GetWorkOfUint64ThenComplex64()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfUint64ThenComplex64(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfComplex64(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfUint64ThenComplex64 = func(ctx context.Context, arg uint64) (complex64, error)

type WorkerOfUint64ThenComplex64 struct {
	api_syncer *ApiDecouplerOfUint64ThenComplex64
	handler    WorkHandlerOfUint64ThenComplex64

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfUint64ThenComplex64
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfUint64ThenComplex64(ctx context.Context, h WorkHandlerOfUint64ThenComplex64, n int) *WorkerOfUint64ThenComplex64 {
	__ := &WorkerOfUint64ThenComplex64{
		api_syncer: NewApiDecouplerOfUint64ThenComplex64(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfUint64ThenComplex64, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfUint64ThenComplex64{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfUint64ThenComplex64(req.Context, req.WorkOfUint64ThenComplex64, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfUint64ThenComplex64) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfUint64ThenComplex64) Push(ctx context.Context, req *WorkOfUint64ThenComplex64) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfUint64ThenComplex64)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfUint64ThenComplex64 = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfUint64ThenComplex64) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfUint64ThenComplex64) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfUint64ThenComplex64) Call(ctx context.Context, arg uint64) (complex64, error) {
	return __.api_syncer.DoOfUint64ThenComplex64(ctx, __, arg)
}

type PoolOfUint64ThenError interface {
	GetUint64Arg() *uint64
	PutUint64Arg(*uint64)
	GetErrorReturn() *error
	PutErrorReturn(*error)

	GetWorkOfUint64ThenError() *WorkOfUint64ThenError
	GetReturnOfError() *ReturnOfError
	PutWorkOfUint64ThenError(*WorkOfUint64ThenError)
	PutReturnOfError(*ReturnOfError)

	GetChReturnOfError() chan *ReturnOfError
	PutChReturnOfError(chan *ReturnOfError)
}

type PoolOfUint64ThenErrorImpl struct {
	Uint64Arg       sync.Pool
	ErrorRtn        sync.Pool
	Uint64Work      sync.Pool
	ErrorReturn     sync.Pool
	ChReturnOfError sync.Pool
}

func (__ *PoolOfUint64ThenErrorImpl) GetUint64Arg() *uint64 {
	return __.Uint64Arg.Get().(*uint64)
}
func (__ *PoolOfUint64ThenErrorImpl) PutUint64Arg(p *uint64) {
	__.Uint64Arg.Put(p)
}
func (__ *PoolOfUint64ThenErrorImpl) GetErrorReturn() *error {
	return __.ErrorRtn.Get().(*error)
}
func (__ *PoolOfUint64ThenErrorImpl) PutErrorReturn(p *error) {
	__.ErrorRtn.Put(p)
}

func (__ *PoolOfUint64ThenErrorImpl) GetWorkOfUint64ThenError() *WorkOfUint64ThenError {
	return __.Uint64Work.Get().(*WorkOfUint64ThenError)
}
func (__ *PoolOfUint64ThenErrorImpl) PutWorkOfUint64ThenError(p *WorkOfUint64ThenError) {
	__.Uint64Work.Put(p)
}
func (__ *PoolOfUint64ThenErrorImpl) GetReturnOfError() *ReturnOfError {
	return __.ErrorReturn.Get().(*ReturnOfError)
}
func (__ *PoolOfUint64ThenErrorImpl) PutReturnOfError(p *ReturnOfError) {
	__.ErrorReturn.Put(p)
}

func (__ *PoolOfUint64ThenErrorImpl) GetChReturnOfError() chan *ReturnOfError {
	return __.ChReturnOfError.Get().(chan *ReturnOfError)
}
func (__ *PoolOfUint64ThenErrorImpl) PutChReturnOfError(p chan *ReturnOfError) {
	__.ChReturnOfError.Put(p)
}

func NewPoolOfUint64ThenErrorImpl() *PoolOfUint64ThenErrorImpl {
	return &PoolOfUint64ThenErrorImpl{
		Uint64Arg: sync.Pool{
			New: func() interface{} {
				return new(uint64)
			},
		},
		Uint64Work: sync.Pool{
			New: func() interface{} {
				return new(WorkOfUint64ThenError)
			},
		},
		ErrorRtn: sync.Pool{
			New: func() interface{} {
				return new(error)
			},
		},
		ErrorReturn: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfError)
			},
		},
		ChReturnOfError: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfError, 1)
			},
		},
	}
}

type ApiDecouplerOfUint64ThenError struct {
	pool PoolOfUint64ThenError
}

func NewApiDecouplerOfUint64ThenError() *ApiDecouplerOfUint64ThenError {
	return &ApiDecouplerOfUint64ThenError{
		pool: NewPoolOfUint64ThenErrorImpl(),
	}
}

func (__ *ApiDecouplerOfUint64ThenError) ReturnError(rtn_ch chan<- *ReturnOfError, err error) {
	rtn := __.pool.GetReturnOfError()
	var other error
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfUint64ThenError) HandleOfUint64ThenError(ctx context.Context, req *WorkOfUint64ThenError, h func(ctx context.Context, arg uint64) (error, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfError()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfUint64ThenError) DoOfUint64ThenError(ctx context.Context, worker WorkerOfPushUint64ThenError, arg uint64) (error, error) {
	// ch := make(chan *ReturnOfError, 1)
	ch := __.pool.GetChReturnOfError()
	defer __.pool.PutChReturnOfError(ch)

	req := __.pool.GetWorkOfUint64ThenError()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfUint64ThenError(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfError(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfUint64ThenError = func(ctx context.Context, arg uint64) (error, error)

type WorkerOfUint64ThenError struct {
	api_syncer *ApiDecouplerOfUint64ThenError
	handler    WorkHandlerOfUint64ThenError

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfUint64ThenError
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfUint64ThenError(ctx context.Context, h WorkHandlerOfUint64ThenError, n int) *WorkerOfUint64ThenError {
	__ := &WorkerOfUint64ThenError{
		api_syncer: NewApiDecouplerOfUint64ThenError(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfUint64ThenError, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfUint64ThenError{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfUint64ThenError(req.Context, req.WorkOfUint64ThenError, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfUint64ThenError) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfUint64ThenError) Push(ctx context.Context, req *WorkOfUint64ThenError) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfUint64ThenError)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfUint64ThenError = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfUint64ThenError) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfUint64ThenError) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfUint64ThenError) Call(ctx context.Context, arg uint64) (error, error) {
	return __.api_syncer.DoOfUint64ThenError(ctx, __, arg)
}

type PoolOfUint64ThenFloat32 interface {
	GetUint64Arg() *uint64
	PutUint64Arg(*uint64)
	GetFloat32Return() *float32
	PutFloat32Return(*float32)

	GetWorkOfUint64ThenFloat32() *WorkOfUint64ThenFloat32
	GetReturnOfFloat32() *ReturnOfFloat32
	PutWorkOfUint64ThenFloat32(*WorkOfUint64ThenFloat32)
	PutReturnOfFloat32(*ReturnOfFloat32)

	GetChReturnOfFloat32() chan *ReturnOfFloat32
	PutChReturnOfFloat32(chan *ReturnOfFloat32)
}

type PoolOfUint64ThenFloat32Impl struct {
	Uint64Arg         sync.Pool
	Float32Rtn        sync.Pool
	Uint64Work        sync.Pool
	Float32Return     sync.Pool
	ChReturnOfFloat32 sync.Pool
}

func (__ *PoolOfUint64ThenFloat32Impl) GetUint64Arg() *uint64 {
	return __.Uint64Arg.Get().(*uint64)
}
func (__ *PoolOfUint64ThenFloat32Impl) PutUint64Arg(p *uint64) {
	__.Uint64Arg.Put(p)
}
func (__ *PoolOfUint64ThenFloat32Impl) GetFloat32Return() *float32 {
	return __.Float32Rtn.Get().(*float32)
}
func (__ *PoolOfUint64ThenFloat32Impl) PutFloat32Return(p *float32) {
	__.Float32Rtn.Put(p)
}

func (__ *PoolOfUint64ThenFloat32Impl) GetWorkOfUint64ThenFloat32() *WorkOfUint64ThenFloat32 {
	return __.Uint64Work.Get().(*WorkOfUint64ThenFloat32)
}
func (__ *PoolOfUint64ThenFloat32Impl) PutWorkOfUint64ThenFloat32(p *WorkOfUint64ThenFloat32) {
	__.Uint64Work.Put(p)
}
func (__ *PoolOfUint64ThenFloat32Impl) GetReturnOfFloat32() *ReturnOfFloat32 {
	return __.Float32Return.Get().(*ReturnOfFloat32)
}
func (__ *PoolOfUint64ThenFloat32Impl) PutReturnOfFloat32(p *ReturnOfFloat32) {
	__.Float32Return.Put(p)
}

func (__ *PoolOfUint64ThenFloat32Impl) GetChReturnOfFloat32() chan *ReturnOfFloat32 {
	return __.ChReturnOfFloat32.Get().(chan *ReturnOfFloat32)
}
func (__ *PoolOfUint64ThenFloat32Impl) PutChReturnOfFloat32(p chan *ReturnOfFloat32) {
	__.ChReturnOfFloat32.Put(p)
}

func NewPoolOfUint64ThenFloat32Impl() *PoolOfUint64ThenFloat32Impl {
	return &PoolOfUint64ThenFloat32Impl{
		Uint64Arg: sync.Pool{
			New: func() interface{} {
				return new(uint64)
			},
		},
		Uint64Work: sync.Pool{
			New: func() interface{} {
				return new(WorkOfUint64ThenFloat32)
			},
		},
		Float32Rtn: sync.Pool{
			New: func() interface{} {
				return new(float32)
			},
		},
		Float32Return: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfFloat32)
			},
		},
		ChReturnOfFloat32: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfFloat32, 1)
			},
		},
	}
}

type ApiDecouplerOfUint64ThenFloat32 struct {
	pool PoolOfUint64ThenFloat32
}

func NewApiDecouplerOfUint64ThenFloat32() *ApiDecouplerOfUint64ThenFloat32 {
	return &ApiDecouplerOfUint64ThenFloat32{
		pool: NewPoolOfUint64ThenFloat32Impl(),
	}
}

func (__ *ApiDecouplerOfUint64ThenFloat32) ReturnError(rtn_ch chan<- *ReturnOfFloat32, err error) {
	rtn := __.pool.GetReturnOfFloat32()
	var other float32
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfUint64ThenFloat32) HandleOfUint64ThenFloat32(ctx context.Context, req *WorkOfUint64ThenFloat32, h func(ctx context.Context, arg uint64) (float32, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfFloat32()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfUint64ThenFloat32) DoOfUint64ThenFloat32(ctx context.Context, worker WorkerOfPushUint64ThenFloat32, arg uint64) (float32, error) {
	// ch := make(chan *ReturnOfFloat32, 1)
	ch := __.pool.GetChReturnOfFloat32()
	defer __.pool.PutChReturnOfFloat32(ch)

	req := __.pool.GetWorkOfUint64ThenFloat32()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfUint64ThenFloat32(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfFloat32(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfUint64ThenFloat32 = func(ctx context.Context, arg uint64) (float32, error)

type WorkerOfUint64ThenFloat32 struct {
	api_syncer *ApiDecouplerOfUint64ThenFloat32
	handler    WorkHandlerOfUint64ThenFloat32

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfUint64ThenFloat32
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfUint64ThenFloat32(ctx context.Context, h WorkHandlerOfUint64ThenFloat32, n int) *WorkerOfUint64ThenFloat32 {
	__ := &WorkerOfUint64ThenFloat32{
		api_syncer: NewApiDecouplerOfUint64ThenFloat32(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfUint64ThenFloat32, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfUint64ThenFloat32{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfUint64ThenFloat32(req.Context, req.WorkOfUint64ThenFloat32, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfUint64ThenFloat32) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfUint64ThenFloat32) Push(ctx context.Context, req *WorkOfUint64ThenFloat32) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfUint64ThenFloat32)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfUint64ThenFloat32 = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfUint64ThenFloat32) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfUint64ThenFloat32) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfUint64ThenFloat32) Call(ctx context.Context, arg uint64) (float32, error) {
	return __.api_syncer.DoOfUint64ThenFloat32(ctx, __, arg)
}

type PoolOfUint64ThenFloat64 interface {
	GetUint64Arg() *uint64
	PutUint64Arg(*uint64)
	GetFloat64Return() *float64
	PutFloat64Return(*float64)

	GetWorkOfUint64ThenFloat64() *WorkOfUint64ThenFloat64
	GetReturnOfFloat64() *ReturnOfFloat64
	PutWorkOfUint64ThenFloat64(*WorkOfUint64ThenFloat64)
	PutReturnOfFloat64(*ReturnOfFloat64)

	GetChReturnOfFloat64() chan *ReturnOfFloat64
	PutChReturnOfFloat64(chan *ReturnOfFloat64)
}

type PoolOfUint64ThenFloat64Impl struct {
	Uint64Arg         sync.Pool
	Float64Rtn        sync.Pool
	Uint64Work        sync.Pool
	Float64Return     sync.Pool
	ChReturnOfFloat64 sync.Pool
}

func (__ *PoolOfUint64ThenFloat64Impl) GetUint64Arg() *uint64 {
	return __.Uint64Arg.Get().(*uint64)
}
func (__ *PoolOfUint64ThenFloat64Impl) PutUint64Arg(p *uint64) {
	__.Uint64Arg.Put(p)
}
func (__ *PoolOfUint64ThenFloat64Impl) GetFloat64Return() *float64 {
	return __.Float64Rtn.Get().(*float64)
}
func (__ *PoolOfUint64ThenFloat64Impl) PutFloat64Return(p *float64) {
	__.Float64Rtn.Put(p)
}

func (__ *PoolOfUint64ThenFloat64Impl) GetWorkOfUint64ThenFloat64() *WorkOfUint64ThenFloat64 {
	return __.Uint64Work.Get().(*WorkOfUint64ThenFloat64)
}
func (__ *PoolOfUint64ThenFloat64Impl) PutWorkOfUint64ThenFloat64(p *WorkOfUint64ThenFloat64) {
	__.Uint64Work.Put(p)
}
func (__ *PoolOfUint64ThenFloat64Impl) GetReturnOfFloat64() *ReturnOfFloat64 {
	return __.Float64Return.Get().(*ReturnOfFloat64)
}
func (__ *PoolOfUint64ThenFloat64Impl) PutReturnOfFloat64(p *ReturnOfFloat64) {
	__.Float64Return.Put(p)
}

func (__ *PoolOfUint64ThenFloat64Impl) GetChReturnOfFloat64() chan *ReturnOfFloat64 {
	return __.ChReturnOfFloat64.Get().(chan *ReturnOfFloat64)
}
func (__ *PoolOfUint64ThenFloat64Impl) PutChReturnOfFloat64(p chan *ReturnOfFloat64) {
	__.ChReturnOfFloat64.Put(p)
}

func NewPoolOfUint64ThenFloat64Impl() *PoolOfUint64ThenFloat64Impl {
	return &PoolOfUint64ThenFloat64Impl{
		Uint64Arg: sync.Pool{
			New: func() interface{} {
				return new(uint64)
			},
		},
		Uint64Work: sync.Pool{
			New: func() interface{} {
				return new(WorkOfUint64ThenFloat64)
			},
		},
		Float64Rtn: sync.Pool{
			New: func() interface{} {
				return new(float64)
			},
		},
		Float64Return: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfFloat64)
			},
		},
		ChReturnOfFloat64: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfFloat64, 1)
			},
		},
	}
}

type ApiDecouplerOfUint64ThenFloat64 struct {
	pool PoolOfUint64ThenFloat64
}

func NewApiDecouplerOfUint64ThenFloat64() *ApiDecouplerOfUint64ThenFloat64 {
	return &ApiDecouplerOfUint64ThenFloat64{
		pool: NewPoolOfUint64ThenFloat64Impl(),
	}
}

func (__ *ApiDecouplerOfUint64ThenFloat64) ReturnError(rtn_ch chan<- *ReturnOfFloat64, err error) {
	rtn := __.pool.GetReturnOfFloat64()
	var other float64
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfUint64ThenFloat64) HandleOfUint64ThenFloat64(ctx context.Context, req *WorkOfUint64ThenFloat64, h func(ctx context.Context, arg uint64) (float64, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfFloat64()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfUint64ThenFloat64) DoOfUint64ThenFloat64(ctx context.Context, worker WorkerOfPushUint64ThenFloat64, arg uint64) (float64, error) {
	// ch := make(chan *ReturnOfFloat64, 1)
	ch := __.pool.GetChReturnOfFloat64()
	defer __.pool.PutChReturnOfFloat64(ch)

	req := __.pool.GetWorkOfUint64ThenFloat64()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfUint64ThenFloat64(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfFloat64(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfUint64ThenFloat64 = func(ctx context.Context, arg uint64) (float64, error)

type WorkerOfUint64ThenFloat64 struct {
	api_syncer *ApiDecouplerOfUint64ThenFloat64
	handler    WorkHandlerOfUint64ThenFloat64

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfUint64ThenFloat64
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfUint64ThenFloat64(ctx context.Context, h WorkHandlerOfUint64ThenFloat64, n int) *WorkerOfUint64ThenFloat64 {
	__ := &WorkerOfUint64ThenFloat64{
		api_syncer: NewApiDecouplerOfUint64ThenFloat64(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfUint64ThenFloat64, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfUint64ThenFloat64{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfUint64ThenFloat64(req.Context, req.WorkOfUint64ThenFloat64, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfUint64ThenFloat64) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfUint64ThenFloat64) Push(ctx context.Context, req *WorkOfUint64ThenFloat64) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfUint64ThenFloat64)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfUint64ThenFloat64 = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfUint64ThenFloat64) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfUint64ThenFloat64) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfUint64ThenFloat64) Call(ctx context.Context, arg uint64) (float64, error) {
	return __.api_syncer.DoOfUint64ThenFloat64(ctx, __, arg)
}

type PoolOfUint64ThenInt interface {
	GetUint64Arg() *uint64
	PutUint64Arg(*uint64)
	GetIntReturn() *int
	PutIntReturn(*int)

	GetWorkOfUint64ThenInt() *WorkOfUint64ThenInt
	GetReturnOfInt() *ReturnOfInt
	PutWorkOfUint64ThenInt(*WorkOfUint64ThenInt)
	PutReturnOfInt(*ReturnOfInt)

	GetChReturnOfInt() chan *ReturnOfInt
	PutChReturnOfInt(chan *ReturnOfInt)
}

type PoolOfUint64ThenIntImpl struct {
	Uint64Arg     sync.Pool
	IntRtn        sync.Pool
	Uint64Work    sync.Pool
	IntReturn     sync.Pool
	ChReturnOfInt sync.Pool
}

func (__ *PoolOfUint64ThenIntImpl) GetUint64Arg() *uint64 {
	return __.Uint64Arg.Get().(*uint64)
}
func (__ *PoolOfUint64ThenIntImpl) PutUint64Arg(p *uint64) {
	__.Uint64Arg.Put(p)
}
func (__ *PoolOfUint64ThenIntImpl) GetIntReturn() *int {
	return __.IntRtn.Get().(*int)
}
func (__ *PoolOfUint64ThenIntImpl) PutIntReturn(p *int) {
	__.IntRtn.Put(p)
}

func (__ *PoolOfUint64ThenIntImpl) GetWorkOfUint64ThenInt() *WorkOfUint64ThenInt {
	return __.Uint64Work.Get().(*WorkOfUint64ThenInt)
}
func (__ *PoolOfUint64ThenIntImpl) PutWorkOfUint64ThenInt(p *WorkOfUint64ThenInt) {
	__.Uint64Work.Put(p)
}
func (__ *PoolOfUint64ThenIntImpl) GetReturnOfInt() *ReturnOfInt {
	return __.IntReturn.Get().(*ReturnOfInt)
}
func (__ *PoolOfUint64ThenIntImpl) PutReturnOfInt(p *ReturnOfInt) {
	__.IntReturn.Put(p)
}

func (__ *PoolOfUint64ThenIntImpl) GetChReturnOfInt() chan *ReturnOfInt {
	return __.ChReturnOfInt.Get().(chan *ReturnOfInt)
}
func (__ *PoolOfUint64ThenIntImpl) PutChReturnOfInt(p chan *ReturnOfInt) {
	__.ChReturnOfInt.Put(p)
}

func NewPoolOfUint64ThenIntImpl() *PoolOfUint64ThenIntImpl {
	return &PoolOfUint64ThenIntImpl{
		Uint64Arg: sync.Pool{
			New: func() interface{} {
				return new(uint64)
			},
		},
		Uint64Work: sync.Pool{
			New: func() interface{} {
				return new(WorkOfUint64ThenInt)
			},
		},
		IntRtn: sync.Pool{
			New: func() interface{} {
				return new(int)
			},
		},
		IntReturn: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfInt)
			},
		},
		ChReturnOfInt: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfInt, 1)
			},
		},
	}
}

type ApiDecouplerOfUint64ThenInt struct {
	pool PoolOfUint64ThenInt
}

func NewApiDecouplerOfUint64ThenInt() *ApiDecouplerOfUint64ThenInt {
	return &ApiDecouplerOfUint64ThenInt{
		pool: NewPoolOfUint64ThenIntImpl(),
	}
}

func (__ *ApiDecouplerOfUint64ThenInt) ReturnError(rtn_ch chan<- *ReturnOfInt, err error) {
	rtn := __.pool.GetReturnOfInt()
	var other int
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfUint64ThenInt) HandleOfUint64ThenInt(ctx context.Context, req *WorkOfUint64ThenInt, h func(ctx context.Context, arg uint64) (int, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfInt()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfUint64ThenInt) DoOfUint64ThenInt(ctx context.Context, worker WorkerOfPushUint64ThenInt, arg uint64) (int, error) {
	// ch := make(chan *ReturnOfInt, 1)
	ch := __.pool.GetChReturnOfInt()
	defer __.pool.PutChReturnOfInt(ch)

	req := __.pool.GetWorkOfUint64ThenInt()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfUint64ThenInt(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfInt(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfUint64ThenInt = func(ctx context.Context, arg uint64) (int, error)

type WorkerOfUint64ThenInt struct {
	api_syncer *ApiDecouplerOfUint64ThenInt
	handler    WorkHandlerOfUint64ThenInt

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfUint64ThenInt
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfUint64ThenInt(ctx context.Context, h WorkHandlerOfUint64ThenInt, n int) *WorkerOfUint64ThenInt {
	__ := &WorkerOfUint64ThenInt{
		api_syncer: NewApiDecouplerOfUint64ThenInt(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfUint64ThenInt, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfUint64ThenInt{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfUint64ThenInt(req.Context, req.WorkOfUint64ThenInt, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfUint64ThenInt) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfUint64ThenInt) Push(ctx context.Context, req *WorkOfUint64ThenInt) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfUint64ThenInt)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfUint64ThenInt = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfUint64ThenInt) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfUint64ThenInt) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfUint64ThenInt) Call(ctx context.Context, arg uint64) (int, error) {
	return __.api_syncer.DoOfUint64ThenInt(ctx, __, arg)
}

type PoolOfUint64ThenInt16 interface {
	GetUint64Arg() *uint64
	PutUint64Arg(*uint64)
	GetInt16Return() *int16
	PutInt16Return(*int16)

	GetWorkOfUint64ThenInt16() *WorkOfUint64ThenInt16
	GetReturnOfInt16() *ReturnOfInt16
	PutWorkOfUint64ThenInt16(*WorkOfUint64ThenInt16)
	PutReturnOfInt16(*ReturnOfInt16)

	GetChReturnOfInt16() chan *ReturnOfInt16
	PutChReturnOfInt16(chan *ReturnOfInt16)
}

type PoolOfUint64ThenInt16Impl struct {
	Uint64Arg       sync.Pool
	Int16Rtn        sync.Pool
	Uint64Work      sync.Pool
	Int16Return     sync.Pool
	ChReturnOfInt16 sync.Pool
}

func (__ *PoolOfUint64ThenInt16Impl) GetUint64Arg() *uint64 {
	return __.Uint64Arg.Get().(*uint64)
}
func (__ *PoolOfUint64ThenInt16Impl) PutUint64Arg(p *uint64) {
	__.Uint64Arg.Put(p)
}
func (__ *PoolOfUint64ThenInt16Impl) GetInt16Return() *int16 {
	return __.Int16Rtn.Get().(*int16)
}
func (__ *PoolOfUint64ThenInt16Impl) PutInt16Return(p *int16) {
	__.Int16Rtn.Put(p)
}

func (__ *PoolOfUint64ThenInt16Impl) GetWorkOfUint64ThenInt16() *WorkOfUint64ThenInt16 {
	return __.Uint64Work.Get().(*WorkOfUint64ThenInt16)
}
func (__ *PoolOfUint64ThenInt16Impl) PutWorkOfUint64ThenInt16(p *WorkOfUint64ThenInt16) {
	__.Uint64Work.Put(p)
}
func (__ *PoolOfUint64ThenInt16Impl) GetReturnOfInt16() *ReturnOfInt16 {
	return __.Int16Return.Get().(*ReturnOfInt16)
}
func (__ *PoolOfUint64ThenInt16Impl) PutReturnOfInt16(p *ReturnOfInt16) {
	__.Int16Return.Put(p)
}

func (__ *PoolOfUint64ThenInt16Impl) GetChReturnOfInt16() chan *ReturnOfInt16 {
	return __.ChReturnOfInt16.Get().(chan *ReturnOfInt16)
}
func (__ *PoolOfUint64ThenInt16Impl) PutChReturnOfInt16(p chan *ReturnOfInt16) {
	__.ChReturnOfInt16.Put(p)
}

func NewPoolOfUint64ThenInt16Impl() *PoolOfUint64ThenInt16Impl {
	return &PoolOfUint64ThenInt16Impl{
		Uint64Arg: sync.Pool{
			New: func() interface{} {
				return new(uint64)
			},
		},
		Uint64Work: sync.Pool{
			New: func() interface{} {
				return new(WorkOfUint64ThenInt16)
			},
		},
		Int16Rtn: sync.Pool{
			New: func() interface{} {
				return new(int16)
			},
		},
		Int16Return: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfInt16)
			},
		},
		ChReturnOfInt16: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfInt16, 1)
			},
		},
	}
}

type ApiDecouplerOfUint64ThenInt16 struct {
	pool PoolOfUint64ThenInt16
}

func NewApiDecouplerOfUint64ThenInt16() *ApiDecouplerOfUint64ThenInt16 {
	return &ApiDecouplerOfUint64ThenInt16{
		pool: NewPoolOfUint64ThenInt16Impl(),
	}
}

func (__ *ApiDecouplerOfUint64ThenInt16) ReturnError(rtn_ch chan<- *ReturnOfInt16, err error) {
	rtn := __.pool.GetReturnOfInt16()
	var other int16
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfUint64ThenInt16) HandleOfUint64ThenInt16(ctx context.Context, req *WorkOfUint64ThenInt16, h func(ctx context.Context, arg uint64) (int16, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfInt16()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfUint64ThenInt16) DoOfUint64ThenInt16(ctx context.Context, worker WorkerOfPushUint64ThenInt16, arg uint64) (int16, error) {
	// ch := make(chan *ReturnOfInt16, 1)
	ch := __.pool.GetChReturnOfInt16()
	defer __.pool.PutChReturnOfInt16(ch)

	req := __.pool.GetWorkOfUint64ThenInt16()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfUint64ThenInt16(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfInt16(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfUint64ThenInt16 = func(ctx context.Context, arg uint64) (int16, error)

type WorkerOfUint64ThenInt16 struct {
	api_syncer *ApiDecouplerOfUint64ThenInt16
	handler    WorkHandlerOfUint64ThenInt16

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfUint64ThenInt16
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfUint64ThenInt16(ctx context.Context, h WorkHandlerOfUint64ThenInt16, n int) *WorkerOfUint64ThenInt16 {
	__ := &WorkerOfUint64ThenInt16{
		api_syncer: NewApiDecouplerOfUint64ThenInt16(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfUint64ThenInt16, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfUint64ThenInt16{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfUint64ThenInt16(req.Context, req.WorkOfUint64ThenInt16, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfUint64ThenInt16) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfUint64ThenInt16) Push(ctx context.Context, req *WorkOfUint64ThenInt16) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfUint64ThenInt16)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfUint64ThenInt16 = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfUint64ThenInt16) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfUint64ThenInt16) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfUint64ThenInt16) Call(ctx context.Context, arg uint64) (int16, error) {
	return __.api_syncer.DoOfUint64ThenInt16(ctx, __, arg)
}

type PoolOfUint64ThenInt32 interface {
	GetUint64Arg() *uint64
	PutUint64Arg(*uint64)
	GetInt32Return() *int32
	PutInt32Return(*int32)

	GetWorkOfUint64ThenInt32() *WorkOfUint64ThenInt32
	GetReturnOfInt32() *ReturnOfInt32
	PutWorkOfUint64ThenInt32(*WorkOfUint64ThenInt32)
	PutReturnOfInt32(*ReturnOfInt32)

	GetChReturnOfInt32() chan *ReturnOfInt32
	PutChReturnOfInt32(chan *ReturnOfInt32)
}

type PoolOfUint64ThenInt32Impl struct {
	Uint64Arg       sync.Pool
	Int32Rtn        sync.Pool
	Uint64Work      sync.Pool
	Int32Return     sync.Pool
	ChReturnOfInt32 sync.Pool
}

func (__ *PoolOfUint64ThenInt32Impl) GetUint64Arg() *uint64 {
	return __.Uint64Arg.Get().(*uint64)
}
func (__ *PoolOfUint64ThenInt32Impl) PutUint64Arg(p *uint64) {
	__.Uint64Arg.Put(p)
}
func (__ *PoolOfUint64ThenInt32Impl) GetInt32Return() *int32 {
	return __.Int32Rtn.Get().(*int32)
}
func (__ *PoolOfUint64ThenInt32Impl) PutInt32Return(p *int32) {
	__.Int32Rtn.Put(p)
}

func (__ *PoolOfUint64ThenInt32Impl) GetWorkOfUint64ThenInt32() *WorkOfUint64ThenInt32 {
	return __.Uint64Work.Get().(*WorkOfUint64ThenInt32)
}
func (__ *PoolOfUint64ThenInt32Impl) PutWorkOfUint64ThenInt32(p *WorkOfUint64ThenInt32) {
	__.Uint64Work.Put(p)
}
func (__ *PoolOfUint64ThenInt32Impl) GetReturnOfInt32() *ReturnOfInt32 {
	return __.Int32Return.Get().(*ReturnOfInt32)
}
func (__ *PoolOfUint64ThenInt32Impl) PutReturnOfInt32(p *ReturnOfInt32) {
	__.Int32Return.Put(p)
}

func (__ *PoolOfUint64ThenInt32Impl) GetChReturnOfInt32() chan *ReturnOfInt32 {
	return __.ChReturnOfInt32.Get().(chan *ReturnOfInt32)
}
func (__ *PoolOfUint64ThenInt32Impl) PutChReturnOfInt32(p chan *ReturnOfInt32) {
	__.ChReturnOfInt32.Put(p)
}

func NewPoolOfUint64ThenInt32Impl() *PoolOfUint64ThenInt32Impl {
	return &PoolOfUint64ThenInt32Impl{
		Uint64Arg: sync.Pool{
			New: func() interface{} {
				return new(uint64)
			},
		},
		Uint64Work: sync.Pool{
			New: func() interface{} {
				return new(WorkOfUint64ThenInt32)
			},
		},
		Int32Rtn: sync.Pool{
			New: func() interface{} {
				return new(int32)
			},
		},
		Int32Return: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfInt32)
			},
		},
		ChReturnOfInt32: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfInt32, 1)
			},
		},
	}
}

type ApiDecouplerOfUint64ThenInt32 struct {
	pool PoolOfUint64ThenInt32
}

func NewApiDecouplerOfUint64ThenInt32() *ApiDecouplerOfUint64ThenInt32 {
	return &ApiDecouplerOfUint64ThenInt32{
		pool: NewPoolOfUint64ThenInt32Impl(),
	}
}

func (__ *ApiDecouplerOfUint64ThenInt32) ReturnError(rtn_ch chan<- *ReturnOfInt32, err error) {
	rtn := __.pool.GetReturnOfInt32()
	var other int32
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfUint64ThenInt32) HandleOfUint64ThenInt32(ctx context.Context, req *WorkOfUint64ThenInt32, h func(ctx context.Context, arg uint64) (int32, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfInt32()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfUint64ThenInt32) DoOfUint64ThenInt32(ctx context.Context, worker WorkerOfPushUint64ThenInt32, arg uint64) (int32, error) {
	// ch := make(chan *ReturnOfInt32, 1)
	ch := __.pool.GetChReturnOfInt32()
	defer __.pool.PutChReturnOfInt32(ch)

	req := __.pool.GetWorkOfUint64ThenInt32()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfUint64ThenInt32(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfInt32(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfUint64ThenInt32 = func(ctx context.Context, arg uint64) (int32, error)

type WorkerOfUint64ThenInt32 struct {
	api_syncer *ApiDecouplerOfUint64ThenInt32
	handler    WorkHandlerOfUint64ThenInt32

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfUint64ThenInt32
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfUint64ThenInt32(ctx context.Context, h WorkHandlerOfUint64ThenInt32, n int) *WorkerOfUint64ThenInt32 {
	__ := &WorkerOfUint64ThenInt32{
		api_syncer: NewApiDecouplerOfUint64ThenInt32(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfUint64ThenInt32, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfUint64ThenInt32{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfUint64ThenInt32(req.Context, req.WorkOfUint64ThenInt32, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfUint64ThenInt32) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfUint64ThenInt32) Push(ctx context.Context, req *WorkOfUint64ThenInt32) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfUint64ThenInt32)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfUint64ThenInt32 = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfUint64ThenInt32) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfUint64ThenInt32) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfUint64ThenInt32) Call(ctx context.Context, arg uint64) (int32, error) {
	return __.api_syncer.DoOfUint64ThenInt32(ctx, __, arg)
}

type PoolOfUint64ThenInt64 interface {
	GetUint64Arg() *uint64
	PutUint64Arg(*uint64)
	GetInt64Return() *int64
	PutInt64Return(*int64)

	GetWorkOfUint64ThenInt64() *WorkOfUint64ThenInt64
	GetReturnOfInt64() *ReturnOfInt64
	PutWorkOfUint64ThenInt64(*WorkOfUint64ThenInt64)
	PutReturnOfInt64(*ReturnOfInt64)

	GetChReturnOfInt64() chan *ReturnOfInt64
	PutChReturnOfInt64(chan *ReturnOfInt64)
}

type PoolOfUint64ThenInt64Impl struct {
	Uint64Arg       sync.Pool
	Int64Rtn        sync.Pool
	Uint64Work      sync.Pool
	Int64Return     sync.Pool
	ChReturnOfInt64 sync.Pool
}

func (__ *PoolOfUint64ThenInt64Impl) GetUint64Arg() *uint64 {
	return __.Uint64Arg.Get().(*uint64)
}
func (__ *PoolOfUint64ThenInt64Impl) PutUint64Arg(p *uint64) {
	__.Uint64Arg.Put(p)
}
func (__ *PoolOfUint64ThenInt64Impl) GetInt64Return() *int64 {
	return __.Int64Rtn.Get().(*int64)
}
func (__ *PoolOfUint64ThenInt64Impl) PutInt64Return(p *int64) {
	__.Int64Rtn.Put(p)
}

func (__ *PoolOfUint64ThenInt64Impl) GetWorkOfUint64ThenInt64() *WorkOfUint64ThenInt64 {
	return __.Uint64Work.Get().(*WorkOfUint64ThenInt64)
}
func (__ *PoolOfUint64ThenInt64Impl) PutWorkOfUint64ThenInt64(p *WorkOfUint64ThenInt64) {
	__.Uint64Work.Put(p)
}
func (__ *PoolOfUint64ThenInt64Impl) GetReturnOfInt64() *ReturnOfInt64 {
	return __.Int64Return.Get().(*ReturnOfInt64)
}
func (__ *PoolOfUint64ThenInt64Impl) PutReturnOfInt64(p *ReturnOfInt64) {
	__.Int64Return.Put(p)
}

func (__ *PoolOfUint64ThenInt64Impl) GetChReturnOfInt64() chan *ReturnOfInt64 {
	return __.ChReturnOfInt64.Get().(chan *ReturnOfInt64)
}
func (__ *PoolOfUint64ThenInt64Impl) PutChReturnOfInt64(p chan *ReturnOfInt64) {
	__.ChReturnOfInt64.Put(p)
}

func NewPoolOfUint64ThenInt64Impl() *PoolOfUint64ThenInt64Impl {
	return &PoolOfUint64ThenInt64Impl{
		Uint64Arg: sync.Pool{
			New: func() interface{} {
				return new(uint64)
			},
		},
		Uint64Work: sync.Pool{
			New: func() interface{} {
				return new(WorkOfUint64ThenInt64)
			},
		},
		Int64Rtn: sync.Pool{
			New: func() interface{} {
				return new(int64)
			},
		},
		Int64Return: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfInt64)
			},
		},
		ChReturnOfInt64: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfInt64, 1)
			},
		},
	}
}

type ApiDecouplerOfUint64ThenInt64 struct {
	pool PoolOfUint64ThenInt64
}

func NewApiDecouplerOfUint64ThenInt64() *ApiDecouplerOfUint64ThenInt64 {
	return &ApiDecouplerOfUint64ThenInt64{
		pool: NewPoolOfUint64ThenInt64Impl(),
	}
}

func (__ *ApiDecouplerOfUint64ThenInt64) ReturnError(rtn_ch chan<- *ReturnOfInt64, err error) {
	rtn := __.pool.GetReturnOfInt64()
	var other int64
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfUint64ThenInt64) HandleOfUint64ThenInt64(ctx context.Context, req *WorkOfUint64ThenInt64, h func(ctx context.Context, arg uint64) (int64, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfInt64()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfUint64ThenInt64) DoOfUint64ThenInt64(ctx context.Context, worker WorkerOfPushUint64ThenInt64, arg uint64) (int64, error) {
	// ch := make(chan *ReturnOfInt64, 1)
	ch := __.pool.GetChReturnOfInt64()
	defer __.pool.PutChReturnOfInt64(ch)

	req := __.pool.GetWorkOfUint64ThenInt64()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfUint64ThenInt64(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfInt64(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfUint64ThenInt64 = func(ctx context.Context, arg uint64) (int64, error)

type WorkerOfUint64ThenInt64 struct {
	api_syncer *ApiDecouplerOfUint64ThenInt64
	handler    WorkHandlerOfUint64ThenInt64

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfUint64ThenInt64
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfUint64ThenInt64(ctx context.Context, h WorkHandlerOfUint64ThenInt64, n int) *WorkerOfUint64ThenInt64 {
	__ := &WorkerOfUint64ThenInt64{
		api_syncer: NewApiDecouplerOfUint64ThenInt64(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfUint64ThenInt64, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfUint64ThenInt64{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfUint64ThenInt64(req.Context, req.WorkOfUint64ThenInt64, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfUint64ThenInt64) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfUint64ThenInt64) Push(ctx context.Context, req *WorkOfUint64ThenInt64) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfUint64ThenInt64)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfUint64ThenInt64 = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfUint64ThenInt64) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfUint64ThenInt64) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfUint64ThenInt64) Call(ctx context.Context, arg uint64) (int64, error) {
	return __.api_syncer.DoOfUint64ThenInt64(ctx, __, arg)
}

type PoolOfUint64ThenInt8 interface {
	GetUint64Arg() *uint64
	PutUint64Arg(*uint64)
	GetInt8Return() *int8
	PutInt8Return(*int8)

	GetWorkOfUint64ThenInt8() *WorkOfUint64ThenInt8
	GetReturnOfInt8() *ReturnOfInt8
	PutWorkOfUint64ThenInt8(*WorkOfUint64ThenInt8)
	PutReturnOfInt8(*ReturnOfInt8)

	GetChReturnOfInt8() chan *ReturnOfInt8
	PutChReturnOfInt8(chan *ReturnOfInt8)
}

type PoolOfUint64ThenInt8Impl struct {
	Uint64Arg      sync.Pool
	Int8Rtn        sync.Pool
	Uint64Work     sync.Pool
	Int8Return     sync.Pool
	ChReturnOfInt8 sync.Pool
}

func (__ *PoolOfUint64ThenInt8Impl) GetUint64Arg() *uint64 {
	return __.Uint64Arg.Get().(*uint64)
}
func (__ *PoolOfUint64ThenInt8Impl) PutUint64Arg(p *uint64) {
	__.Uint64Arg.Put(p)
}
func (__ *PoolOfUint64ThenInt8Impl) GetInt8Return() *int8 {
	return __.Int8Rtn.Get().(*int8)
}
func (__ *PoolOfUint64ThenInt8Impl) PutInt8Return(p *int8) {
	__.Int8Rtn.Put(p)
}

func (__ *PoolOfUint64ThenInt8Impl) GetWorkOfUint64ThenInt8() *WorkOfUint64ThenInt8 {
	return __.Uint64Work.Get().(*WorkOfUint64ThenInt8)
}
func (__ *PoolOfUint64ThenInt8Impl) PutWorkOfUint64ThenInt8(p *WorkOfUint64ThenInt8) {
	__.Uint64Work.Put(p)
}
func (__ *PoolOfUint64ThenInt8Impl) GetReturnOfInt8() *ReturnOfInt8 {
	return __.Int8Return.Get().(*ReturnOfInt8)
}
func (__ *PoolOfUint64ThenInt8Impl) PutReturnOfInt8(p *ReturnOfInt8) {
	__.Int8Return.Put(p)
}

func (__ *PoolOfUint64ThenInt8Impl) GetChReturnOfInt8() chan *ReturnOfInt8 {
	return __.ChReturnOfInt8.Get().(chan *ReturnOfInt8)
}
func (__ *PoolOfUint64ThenInt8Impl) PutChReturnOfInt8(p chan *ReturnOfInt8) {
	__.ChReturnOfInt8.Put(p)
}

func NewPoolOfUint64ThenInt8Impl() *PoolOfUint64ThenInt8Impl {
	return &PoolOfUint64ThenInt8Impl{
		Uint64Arg: sync.Pool{
			New: func() interface{} {
				return new(uint64)
			},
		},
		Uint64Work: sync.Pool{
			New: func() interface{} {
				return new(WorkOfUint64ThenInt8)
			},
		},
		Int8Rtn: sync.Pool{
			New: func() interface{} {
				return new(int8)
			},
		},
		Int8Return: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfInt8)
			},
		},
		ChReturnOfInt8: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfInt8, 1)
			},
		},
	}
}

type ApiDecouplerOfUint64ThenInt8 struct {
	pool PoolOfUint64ThenInt8
}

func NewApiDecouplerOfUint64ThenInt8() *ApiDecouplerOfUint64ThenInt8 {
	return &ApiDecouplerOfUint64ThenInt8{
		pool: NewPoolOfUint64ThenInt8Impl(),
	}
}

func (__ *ApiDecouplerOfUint64ThenInt8) ReturnError(rtn_ch chan<- *ReturnOfInt8, err error) {
	rtn := __.pool.GetReturnOfInt8()
	var other int8
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfUint64ThenInt8) HandleOfUint64ThenInt8(ctx context.Context, req *WorkOfUint64ThenInt8, h func(ctx context.Context, arg uint64) (int8, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfInt8()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfUint64ThenInt8) DoOfUint64ThenInt8(ctx context.Context, worker WorkerOfPushUint64ThenInt8, arg uint64) (int8, error) {
	// ch := make(chan *ReturnOfInt8, 1)
	ch := __.pool.GetChReturnOfInt8()
	defer __.pool.PutChReturnOfInt8(ch)

	req := __.pool.GetWorkOfUint64ThenInt8()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfUint64ThenInt8(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfInt8(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfUint64ThenInt8 = func(ctx context.Context, arg uint64) (int8, error)

type WorkerOfUint64ThenInt8 struct {
	api_syncer *ApiDecouplerOfUint64ThenInt8
	handler    WorkHandlerOfUint64ThenInt8

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfUint64ThenInt8
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfUint64ThenInt8(ctx context.Context, h WorkHandlerOfUint64ThenInt8, n int) *WorkerOfUint64ThenInt8 {
	__ := &WorkerOfUint64ThenInt8{
		api_syncer: NewApiDecouplerOfUint64ThenInt8(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfUint64ThenInt8, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfUint64ThenInt8{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfUint64ThenInt8(req.Context, req.WorkOfUint64ThenInt8, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfUint64ThenInt8) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfUint64ThenInt8) Push(ctx context.Context, req *WorkOfUint64ThenInt8) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfUint64ThenInt8)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfUint64ThenInt8 = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfUint64ThenInt8) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfUint64ThenInt8) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfUint64ThenInt8) Call(ctx context.Context, arg uint64) (int8, error) {
	return __.api_syncer.DoOfUint64ThenInt8(ctx, __, arg)
}

type PoolOfUint64ThenRune interface {
	GetUint64Arg() *uint64
	PutUint64Arg(*uint64)
	GetRuneReturn() *rune
	PutRuneReturn(*rune)

	GetWorkOfUint64ThenRune() *WorkOfUint64ThenRune
	GetReturnOfRune() *ReturnOfRune
	PutWorkOfUint64ThenRune(*WorkOfUint64ThenRune)
	PutReturnOfRune(*ReturnOfRune)

	GetChReturnOfRune() chan *ReturnOfRune
	PutChReturnOfRune(chan *ReturnOfRune)
}

type PoolOfUint64ThenRuneImpl struct {
	Uint64Arg      sync.Pool
	RuneRtn        sync.Pool
	Uint64Work     sync.Pool
	RuneReturn     sync.Pool
	ChReturnOfRune sync.Pool
}

func (__ *PoolOfUint64ThenRuneImpl) GetUint64Arg() *uint64 {
	return __.Uint64Arg.Get().(*uint64)
}
func (__ *PoolOfUint64ThenRuneImpl) PutUint64Arg(p *uint64) {
	__.Uint64Arg.Put(p)
}
func (__ *PoolOfUint64ThenRuneImpl) GetRuneReturn() *rune {
	return __.RuneRtn.Get().(*rune)
}
func (__ *PoolOfUint64ThenRuneImpl) PutRuneReturn(p *rune) {
	__.RuneRtn.Put(p)
}

func (__ *PoolOfUint64ThenRuneImpl) GetWorkOfUint64ThenRune() *WorkOfUint64ThenRune {
	return __.Uint64Work.Get().(*WorkOfUint64ThenRune)
}
func (__ *PoolOfUint64ThenRuneImpl) PutWorkOfUint64ThenRune(p *WorkOfUint64ThenRune) {
	__.Uint64Work.Put(p)
}
func (__ *PoolOfUint64ThenRuneImpl) GetReturnOfRune() *ReturnOfRune {
	return __.RuneReturn.Get().(*ReturnOfRune)
}
func (__ *PoolOfUint64ThenRuneImpl) PutReturnOfRune(p *ReturnOfRune) {
	__.RuneReturn.Put(p)
}

func (__ *PoolOfUint64ThenRuneImpl) GetChReturnOfRune() chan *ReturnOfRune {
	return __.ChReturnOfRune.Get().(chan *ReturnOfRune)
}
func (__ *PoolOfUint64ThenRuneImpl) PutChReturnOfRune(p chan *ReturnOfRune) {
	__.ChReturnOfRune.Put(p)
}

func NewPoolOfUint64ThenRuneImpl() *PoolOfUint64ThenRuneImpl {
	return &PoolOfUint64ThenRuneImpl{
		Uint64Arg: sync.Pool{
			New: func() interface{} {
				return new(uint64)
			},
		},
		Uint64Work: sync.Pool{
			New: func() interface{} {
				return new(WorkOfUint64ThenRune)
			},
		},
		RuneRtn: sync.Pool{
			New: func() interface{} {
				return new(rune)
			},
		},
		RuneReturn: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfRune)
			},
		},
		ChReturnOfRune: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfRune, 1)
			},
		},
	}
}

type ApiDecouplerOfUint64ThenRune struct {
	pool PoolOfUint64ThenRune
}

func NewApiDecouplerOfUint64ThenRune() *ApiDecouplerOfUint64ThenRune {
	return &ApiDecouplerOfUint64ThenRune{
		pool: NewPoolOfUint64ThenRuneImpl(),
	}
}

func (__ *ApiDecouplerOfUint64ThenRune) ReturnError(rtn_ch chan<- *ReturnOfRune, err error) {
	rtn := __.pool.GetReturnOfRune()
	var other rune
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfUint64ThenRune) HandleOfUint64ThenRune(ctx context.Context, req *WorkOfUint64ThenRune, h func(ctx context.Context, arg uint64) (rune, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfRune()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfUint64ThenRune) DoOfUint64ThenRune(ctx context.Context, worker WorkerOfPushUint64ThenRune, arg uint64) (rune, error) {
	// ch := make(chan *ReturnOfRune, 1)
	ch := __.pool.GetChReturnOfRune()
	defer __.pool.PutChReturnOfRune(ch)

	req := __.pool.GetWorkOfUint64ThenRune()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfUint64ThenRune(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfRune(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfUint64ThenRune = func(ctx context.Context, arg uint64) (rune, error)

type WorkerOfUint64ThenRune struct {
	api_syncer *ApiDecouplerOfUint64ThenRune
	handler    WorkHandlerOfUint64ThenRune

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfUint64ThenRune
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfUint64ThenRune(ctx context.Context, h WorkHandlerOfUint64ThenRune, n int) *WorkerOfUint64ThenRune {
	__ := &WorkerOfUint64ThenRune{
		api_syncer: NewApiDecouplerOfUint64ThenRune(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfUint64ThenRune, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfUint64ThenRune{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfUint64ThenRune(req.Context, req.WorkOfUint64ThenRune, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfUint64ThenRune) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfUint64ThenRune) Push(ctx context.Context, req *WorkOfUint64ThenRune) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfUint64ThenRune)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfUint64ThenRune = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfUint64ThenRune) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfUint64ThenRune) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfUint64ThenRune) Call(ctx context.Context, arg uint64) (rune, error) {
	return __.api_syncer.DoOfUint64ThenRune(ctx, __, arg)
}

type PoolOfUint64ThenString interface {
	GetUint64Arg() *uint64
	PutUint64Arg(*uint64)
	GetStringReturn() *string
	PutStringReturn(*string)

	GetWorkOfUint64ThenString() *WorkOfUint64ThenString
	GetReturnOfString() *ReturnOfString
	PutWorkOfUint64ThenString(*WorkOfUint64ThenString)
	PutReturnOfString(*ReturnOfString)

	GetChReturnOfString() chan *ReturnOfString
	PutChReturnOfString(chan *ReturnOfString)
}

type PoolOfUint64ThenStringImpl struct {
	Uint64Arg        sync.Pool
	StringRtn        sync.Pool
	Uint64Work       sync.Pool
	StringReturn     sync.Pool
	ChReturnOfString sync.Pool
}

func (__ *PoolOfUint64ThenStringImpl) GetUint64Arg() *uint64 {
	return __.Uint64Arg.Get().(*uint64)
}
func (__ *PoolOfUint64ThenStringImpl) PutUint64Arg(p *uint64) {
	__.Uint64Arg.Put(p)
}
func (__ *PoolOfUint64ThenStringImpl) GetStringReturn() *string {
	return __.StringRtn.Get().(*string)
}
func (__ *PoolOfUint64ThenStringImpl) PutStringReturn(p *string) {
	__.StringRtn.Put(p)
}

func (__ *PoolOfUint64ThenStringImpl) GetWorkOfUint64ThenString() *WorkOfUint64ThenString {
	return __.Uint64Work.Get().(*WorkOfUint64ThenString)
}
func (__ *PoolOfUint64ThenStringImpl) PutWorkOfUint64ThenString(p *WorkOfUint64ThenString) {
	__.Uint64Work.Put(p)
}
func (__ *PoolOfUint64ThenStringImpl) GetReturnOfString() *ReturnOfString {
	return __.StringReturn.Get().(*ReturnOfString)
}
func (__ *PoolOfUint64ThenStringImpl) PutReturnOfString(p *ReturnOfString) {
	__.StringReturn.Put(p)
}

func (__ *PoolOfUint64ThenStringImpl) GetChReturnOfString() chan *ReturnOfString {
	return __.ChReturnOfString.Get().(chan *ReturnOfString)
}
func (__ *PoolOfUint64ThenStringImpl) PutChReturnOfString(p chan *ReturnOfString) {
	__.ChReturnOfString.Put(p)
}

func NewPoolOfUint64ThenStringImpl() *PoolOfUint64ThenStringImpl {
	return &PoolOfUint64ThenStringImpl{
		Uint64Arg: sync.Pool{
			New: func() interface{} {
				return new(uint64)
			},
		},
		Uint64Work: sync.Pool{
			New: func() interface{} {
				return new(WorkOfUint64ThenString)
			},
		},
		StringRtn: sync.Pool{
			New: func() interface{} {
				return new(string)
			},
		},
		StringReturn: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfString)
			},
		},
		ChReturnOfString: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfString, 1)
			},
		},
	}
}

type ApiDecouplerOfUint64ThenString struct {
	pool PoolOfUint64ThenString
}

func NewApiDecouplerOfUint64ThenString() *ApiDecouplerOfUint64ThenString {
	return &ApiDecouplerOfUint64ThenString{
		pool: NewPoolOfUint64ThenStringImpl(),
	}
}

func (__ *ApiDecouplerOfUint64ThenString) ReturnError(rtn_ch chan<- *ReturnOfString, err error) {
	rtn := __.pool.GetReturnOfString()
	var other string
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfUint64ThenString) HandleOfUint64ThenString(ctx context.Context, req *WorkOfUint64ThenString, h func(ctx context.Context, arg uint64) (string, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfString()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfUint64ThenString) DoOfUint64ThenString(ctx context.Context, worker WorkerOfPushUint64ThenString, arg uint64) (string, error) {
	// ch := make(chan *ReturnOfString, 1)
	ch := __.pool.GetChReturnOfString()
	defer __.pool.PutChReturnOfString(ch)

	req := __.pool.GetWorkOfUint64ThenString()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfUint64ThenString(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfString(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfUint64ThenString = func(ctx context.Context, arg uint64) (string, error)

type WorkerOfUint64ThenString struct {
	api_syncer *ApiDecouplerOfUint64ThenString
	handler    WorkHandlerOfUint64ThenString

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfUint64ThenString
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfUint64ThenString(ctx context.Context, h WorkHandlerOfUint64ThenString, n int) *WorkerOfUint64ThenString {
	__ := &WorkerOfUint64ThenString{
		api_syncer: NewApiDecouplerOfUint64ThenString(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfUint64ThenString, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfUint64ThenString{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfUint64ThenString(req.Context, req.WorkOfUint64ThenString, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfUint64ThenString) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfUint64ThenString) Push(ctx context.Context, req *WorkOfUint64ThenString) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfUint64ThenString)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfUint64ThenString = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfUint64ThenString) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfUint64ThenString) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfUint64ThenString) Call(ctx context.Context, arg uint64) (string, error) {
	return __.api_syncer.DoOfUint64ThenString(ctx, __, arg)
}

type PoolOfUint64ThenUint interface {
	GetUint64Arg() *uint64
	PutUint64Arg(*uint64)
	GetUintReturn() *uint
	PutUintReturn(*uint)

	GetWorkOfUint64ThenUint() *WorkOfUint64ThenUint
	GetReturnOfUint() *ReturnOfUint
	PutWorkOfUint64ThenUint(*WorkOfUint64ThenUint)
	PutReturnOfUint(*ReturnOfUint)

	GetChReturnOfUint() chan *ReturnOfUint
	PutChReturnOfUint(chan *ReturnOfUint)
}

type PoolOfUint64ThenUintImpl struct {
	Uint64Arg      sync.Pool
	UintRtn        sync.Pool
	Uint64Work     sync.Pool
	UintReturn     sync.Pool
	ChReturnOfUint sync.Pool
}

func (__ *PoolOfUint64ThenUintImpl) GetUint64Arg() *uint64 {
	return __.Uint64Arg.Get().(*uint64)
}
func (__ *PoolOfUint64ThenUintImpl) PutUint64Arg(p *uint64) {
	__.Uint64Arg.Put(p)
}
func (__ *PoolOfUint64ThenUintImpl) GetUintReturn() *uint {
	return __.UintRtn.Get().(*uint)
}
func (__ *PoolOfUint64ThenUintImpl) PutUintReturn(p *uint) {
	__.UintRtn.Put(p)
}

func (__ *PoolOfUint64ThenUintImpl) GetWorkOfUint64ThenUint() *WorkOfUint64ThenUint {
	return __.Uint64Work.Get().(*WorkOfUint64ThenUint)
}
func (__ *PoolOfUint64ThenUintImpl) PutWorkOfUint64ThenUint(p *WorkOfUint64ThenUint) {
	__.Uint64Work.Put(p)
}
func (__ *PoolOfUint64ThenUintImpl) GetReturnOfUint() *ReturnOfUint {
	return __.UintReturn.Get().(*ReturnOfUint)
}
func (__ *PoolOfUint64ThenUintImpl) PutReturnOfUint(p *ReturnOfUint) {
	__.UintReturn.Put(p)
}

func (__ *PoolOfUint64ThenUintImpl) GetChReturnOfUint() chan *ReturnOfUint {
	return __.ChReturnOfUint.Get().(chan *ReturnOfUint)
}
func (__ *PoolOfUint64ThenUintImpl) PutChReturnOfUint(p chan *ReturnOfUint) {
	__.ChReturnOfUint.Put(p)
}

func NewPoolOfUint64ThenUintImpl() *PoolOfUint64ThenUintImpl {
	return &PoolOfUint64ThenUintImpl{
		Uint64Arg: sync.Pool{
			New: func() interface{} {
				return new(uint64)
			},
		},
		Uint64Work: sync.Pool{
			New: func() interface{} {
				return new(WorkOfUint64ThenUint)
			},
		},
		UintRtn: sync.Pool{
			New: func() interface{} {
				return new(uint)
			},
		},
		UintReturn: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfUint)
			},
		},
		ChReturnOfUint: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfUint, 1)
			},
		},
	}
}

type ApiDecouplerOfUint64ThenUint struct {
	pool PoolOfUint64ThenUint
}

func NewApiDecouplerOfUint64ThenUint() *ApiDecouplerOfUint64ThenUint {
	return &ApiDecouplerOfUint64ThenUint{
		pool: NewPoolOfUint64ThenUintImpl(),
	}
}

func (__ *ApiDecouplerOfUint64ThenUint) ReturnError(rtn_ch chan<- *ReturnOfUint, err error) {
	rtn := __.pool.GetReturnOfUint()
	var other uint
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfUint64ThenUint) HandleOfUint64ThenUint(ctx context.Context, req *WorkOfUint64ThenUint, h func(ctx context.Context, arg uint64) (uint, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfUint()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfUint64ThenUint) DoOfUint64ThenUint(ctx context.Context, worker WorkerOfPushUint64ThenUint, arg uint64) (uint, error) {
	// ch := make(chan *ReturnOfUint, 1)
	ch := __.pool.GetChReturnOfUint()
	defer __.pool.PutChReturnOfUint(ch)

	req := __.pool.GetWorkOfUint64ThenUint()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfUint64ThenUint(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfUint(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfUint64ThenUint = func(ctx context.Context, arg uint64) (uint, error)

type WorkerOfUint64ThenUint struct {
	api_syncer *ApiDecouplerOfUint64ThenUint
	handler    WorkHandlerOfUint64ThenUint

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfUint64ThenUint
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfUint64ThenUint(ctx context.Context, h WorkHandlerOfUint64ThenUint, n int) *WorkerOfUint64ThenUint {
	__ := &WorkerOfUint64ThenUint{
		api_syncer: NewApiDecouplerOfUint64ThenUint(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfUint64ThenUint, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfUint64ThenUint{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfUint64ThenUint(req.Context, req.WorkOfUint64ThenUint, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfUint64ThenUint) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfUint64ThenUint) Push(ctx context.Context, req *WorkOfUint64ThenUint) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfUint64ThenUint)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfUint64ThenUint = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfUint64ThenUint) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfUint64ThenUint) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfUint64ThenUint) Call(ctx context.Context, arg uint64) (uint, error) {
	return __.api_syncer.DoOfUint64ThenUint(ctx, __, arg)
}

type PoolOfUint64ThenUint16 interface {
	GetUint64Arg() *uint64
	PutUint64Arg(*uint64)
	GetUint16Return() *uint16
	PutUint16Return(*uint16)

	GetWorkOfUint64ThenUint16() *WorkOfUint64ThenUint16
	GetReturnOfUint16() *ReturnOfUint16
	PutWorkOfUint64ThenUint16(*WorkOfUint64ThenUint16)
	PutReturnOfUint16(*ReturnOfUint16)

	GetChReturnOfUint16() chan *ReturnOfUint16
	PutChReturnOfUint16(chan *ReturnOfUint16)
}

type PoolOfUint64ThenUint16Impl struct {
	Uint64Arg        sync.Pool
	Uint16Rtn        sync.Pool
	Uint64Work       sync.Pool
	Uint16Return     sync.Pool
	ChReturnOfUint16 sync.Pool
}

func (__ *PoolOfUint64ThenUint16Impl) GetUint64Arg() *uint64 {
	return __.Uint64Arg.Get().(*uint64)
}
func (__ *PoolOfUint64ThenUint16Impl) PutUint64Arg(p *uint64) {
	__.Uint64Arg.Put(p)
}
func (__ *PoolOfUint64ThenUint16Impl) GetUint16Return() *uint16 {
	return __.Uint16Rtn.Get().(*uint16)
}
func (__ *PoolOfUint64ThenUint16Impl) PutUint16Return(p *uint16) {
	__.Uint16Rtn.Put(p)
}

func (__ *PoolOfUint64ThenUint16Impl) GetWorkOfUint64ThenUint16() *WorkOfUint64ThenUint16 {
	return __.Uint64Work.Get().(*WorkOfUint64ThenUint16)
}
func (__ *PoolOfUint64ThenUint16Impl) PutWorkOfUint64ThenUint16(p *WorkOfUint64ThenUint16) {
	__.Uint64Work.Put(p)
}
func (__ *PoolOfUint64ThenUint16Impl) GetReturnOfUint16() *ReturnOfUint16 {
	return __.Uint16Return.Get().(*ReturnOfUint16)
}
func (__ *PoolOfUint64ThenUint16Impl) PutReturnOfUint16(p *ReturnOfUint16) {
	__.Uint16Return.Put(p)
}

func (__ *PoolOfUint64ThenUint16Impl) GetChReturnOfUint16() chan *ReturnOfUint16 {
	return __.ChReturnOfUint16.Get().(chan *ReturnOfUint16)
}
func (__ *PoolOfUint64ThenUint16Impl) PutChReturnOfUint16(p chan *ReturnOfUint16) {
	__.ChReturnOfUint16.Put(p)
}

func NewPoolOfUint64ThenUint16Impl() *PoolOfUint64ThenUint16Impl {
	return &PoolOfUint64ThenUint16Impl{
		Uint64Arg: sync.Pool{
			New: func() interface{} {
				return new(uint64)
			},
		},
		Uint64Work: sync.Pool{
			New: func() interface{} {
				return new(WorkOfUint64ThenUint16)
			},
		},
		Uint16Rtn: sync.Pool{
			New: func() interface{} {
				return new(uint16)
			},
		},
		Uint16Return: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfUint16)
			},
		},
		ChReturnOfUint16: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfUint16, 1)
			},
		},
	}
}

type ApiDecouplerOfUint64ThenUint16 struct {
	pool PoolOfUint64ThenUint16
}

func NewApiDecouplerOfUint64ThenUint16() *ApiDecouplerOfUint64ThenUint16 {
	return &ApiDecouplerOfUint64ThenUint16{
		pool: NewPoolOfUint64ThenUint16Impl(),
	}
}

func (__ *ApiDecouplerOfUint64ThenUint16) ReturnError(rtn_ch chan<- *ReturnOfUint16, err error) {
	rtn := __.pool.GetReturnOfUint16()
	var other uint16
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfUint64ThenUint16) HandleOfUint64ThenUint16(ctx context.Context, req *WorkOfUint64ThenUint16, h func(ctx context.Context, arg uint64) (uint16, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfUint16()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfUint64ThenUint16) DoOfUint64ThenUint16(ctx context.Context, worker WorkerOfPushUint64ThenUint16, arg uint64) (uint16, error) {
	// ch := make(chan *ReturnOfUint16, 1)
	ch := __.pool.GetChReturnOfUint16()
	defer __.pool.PutChReturnOfUint16(ch)

	req := __.pool.GetWorkOfUint64ThenUint16()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfUint64ThenUint16(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfUint16(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfUint64ThenUint16 = func(ctx context.Context, arg uint64) (uint16, error)

type WorkerOfUint64ThenUint16 struct {
	api_syncer *ApiDecouplerOfUint64ThenUint16
	handler    WorkHandlerOfUint64ThenUint16

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfUint64ThenUint16
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfUint64ThenUint16(ctx context.Context, h WorkHandlerOfUint64ThenUint16, n int) *WorkerOfUint64ThenUint16 {
	__ := &WorkerOfUint64ThenUint16{
		api_syncer: NewApiDecouplerOfUint64ThenUint16(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfUint64ThenUint16, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfUint64ThenUint16{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfUint64ThenUint16(req.Context, req.WorkOfUint64ThenUint16, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfUint64ThenUint16) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfUint64ThenUint16) Push(ctx context.Context, req *WorkOfUint64ThenUint16) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfUint64ThenUint16)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfUint64ThenUint16 = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfUint64ThenUint16) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfUint64ThenUint16) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfUint64ThenUint16) Call(ctx context.Context, arg uint64) (uint16, error) {
	return __.api_syncer.DoOfUint64ThenUint16(ctx, __, arg)
}

type PoolOfUint64ThenUint32 interface {
	GetUint64Arg() *uint64
	PutUint64Arg(*uint64)
	GetUint32Return() *uint32
	PutUint32Return(*uint32)

	GetWorkOfUint64ThenUint32() *WorkOfUint64ThenUint32
	GetReturnOfUint32() *ReturnOfUint32
	PutWorkOfUint64ThenUint32(*WorkOfUint64ThenUint32)
	PutReturnOfUint32(*ReturnOfUint32)

	GetChReturnOfUint32() chan *ReturnOfUint32
	PutChReturnOfUint32(chan *ReturnOfUint32)
}

type PoolOfUint64ThenUint32Impl struct {
	Uint64Arg        sync.Pool
	Uint32Rtn        sync.Pool
	Uint64Work       sync.Pool
	Uint32Return     sync.Pool
	ChReturnOfUint32 sync.Pool
}

func (__ *PoolOfUint64ThenUint32Impl) GetUint64Arg() *uint64 {
	return __.Uint64Arg.Get().(*uint64)
}
func (__ *PoolOfUint64ThenUint32Impl) PutUint64Arg(p *uint64) {
	__.Uint64Arg.Put(p)
}
func (__ *PoolOfUint64ThenUint32Impl) GetUint32Return() *uint32 {
	return __.Uint32Rtn.Get().(*uint32)
}
func (__ *PoolOfUint64ThenUint32Impl) PutUint32Return(p *uint32) {
	__.Uint32Rtn.Put(p)
}

func (__ *PoolOfUint64ThenUint32Impl) GetWorkOfUint64ThenUint32() *WorkOfUint64ThenUint32 {
	return __.Uint64Work.Get().(*WorkOfUint64ThenUint32)
}
func (__ *PoolOfUint64ThenUint32Impl) PutWorkOfUint64ThenUint32(p *WorkOfUint64ThenUint32) {
	__.Uint64Work.Put(p)
}
func (__ *PoolOfUint64ThenUint32Impl) GetReturnOfUint32() *ReturnOfUint32 {
	return __.Uint32Return.Get().(*ReturnOfUint32)
}
func (__ *PoolOfUint64ThenUint32Impl) PutReturnOfUint32(p *ReturnOfUint32) {
	__.Uint32Return.Put(p)
}

func (__ *PoolOfUint64ThenUint32Impl) GetChReturnOfUint32() chan *ReturnOfUint32 {
	return __.ChReturnOfUint32.Get().(chan *ReturnOfUint32)
}
func (__ *PoolOfUint64ThenUint32Impl) PutChReturnOfUint32(p chan *ReturnOfUint32) {
	__.ChReturnOfUint32.Put(p)
}

func NewPoolOfUint64ThenUint32Impl() *PoolOfUint64ThenUint32Impl {
	return &PoolOfUint64ThenUint32Impl{
		Uint64Arg: sync.Pool{
			New: func() interface{} {
				return new(uint64)
			},
		},
		Uint64Work: sync.Pool{
			New: func() interface{} {
				return new(WorkOfUint64ThenUint32)
			},
		},
		Uint32Rtn: sync.Pool{
			New: func() interface{} {
				return new(uint32)
			},
		},
		Uint32Return: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfUint32)
			},
		},
		ChReturnOfUint32: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfUint32, 1)
			},
		},
	}
}

type ApiDecouplerOfUint64ThenUint32 struct {
	pool PoolOfUint64ThenUint32
}

func NewApiDecouplerOfUint64ThenUint32() *ApiDecouplerOfUint64ThenUint32 {
	return &ApiDecouplerOfUint64ThenUint32{
		pool: NewPoolOfUint64ThenUint32Impl(),
	}
}

func (__ *ApiDecouplerOfUint64ThenUint32) ReturnError(rtn_ch chan<- *ReturnOfUint32, err error) {
	rtn := __.pool.GetReturnOfUint32()
	var other uint32
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfUint64ThenUint32) HandleOfUint64ThenUint32(ctx context.Context, req *WorkOfUint64ThenUint32, h func(ctx context.Context, arg uint64) (uint32, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfUint32()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfUint64ThenUint32) DoOfUint64ThenUint32(ctx context.Context, worker WorkerOfPushUint64ThenUint32, arg uint64) (uint32, error) {
	// ch := make(chan *ReturnOfUint32, 1)
	ch := __.pool.GetChReturnOfUint32()
	defer __.pool.PutChReturnOfUint32(ch)

	req := __.pool.GetWorkOfUint64ThenUint32()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfUint64ThenUint32(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfUint32(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfUint64ThenUint32 = func(ctx context.Context, arg uint64) (uint32, error)

type WorkerOfUint64ThenUint32 struct {
	api_syncer *ApiDecouplerOfUint64ThenUint32
	handler    WorkHandlerOfUint64ThenUint32

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfUint64ThenUint32
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfUint64ThenUint32(ctx context.Context, h WorkHandlerOfUint64ThenUint32, n int) *WorkerOfUint64ThenUint32 {
	__ := &WorkerOfUint64ThenUint32{
		api_syncer: NewApiDecouplerOfUint64ThenUint32(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfUint64ThenUint32, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfUint64ThenUint32{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfUint64ThenUint32(req.Context, req.WorkOfUint64ThenUint32, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfUint64ThenUint32) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfUint64ThenUint32) Push(ctx context.Context, req *WorkOfUint64ThenUint32) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfUint64ThenUint32)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfUint64ThenUint32 = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfUint64ThenUint32) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfUint64ThenUint32) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfUint64ThenUint32) Call(ctx context.Context, arg uint64) (uint32, error) {
	return __.api_syncer.DoOfUint64ThenUint32(ctx, __, arg)
}

type PoolOfUint64ThenUint64 interface {
	GetUint64Arg() *uint64
	PutUint64Arg(*uint64)
	GetUint64Return() *uint64
	PutUint64Return(*uint64)

	GetWorkOfUint64ThenUint64() *WorkOfUint64ThenUint64
	GetReturnOfUint64() *ReturnOfUint64
	PutWorkOfUint64ThenUint64(*WorkOfUint64ThenUint64)
	PutReturnOfUint64(*ReturnOfUint64)

	GetChReturnOfUint64() chan *ReturnOfUint64
	PutChReturnOfUint64(chan *ReturnOfUint64)
}

type PoolOfUint64ThenUint64Impl struct {
	Uint64Arg        sync.Pool
	Uint64Rtn        sync.Pool
	Uint64Work       sync.Pool
	Uint64Return     sync.Pool
	ChReturnOfUint64 sync.Pool
}

func (__ *PoolOfUint64ThenUint64Impl) GetUint64Arg() *uint64 {
	return __.Uint64Arg.Get().(*uint64)
}
func (__ *PoolOfUint64ThenUint64Impl) PutUint64Arg(p *uint64) {
	__.Uint64Arg.Put(p)
}
func (__ *PoolOfUint64ThenUint64Impl) GetUint64Return() *uint64 {
	return __.Uint64Rtn.Get().(*uint64)
}
func (__ *PoolOfUint64ThenUint64Impl) PutUint64Return(p *uint64) {
	__.Uint64Rtn.Put(p)
}

func (__ *PoolOfUint64ThenUint64Impl) GetWorkOfUint64ThenUint64() *WorkOfUint64ThenUint64 {
	return __.Uint64Work.Get().(*WorkOfUint64ThenUint64)
}
func (__ *PoolOfUint64ThenUint64Impl) PutWorkOfUint64ThenUint64(p *WorkOfUint64ThenUint64) {
	__.Uint64Work.Put(p)
}
func (__ *PoolOfUint64ThenUint64Impl) GetReturnOfUint64() *ReturnOfUint64 {
	return __.Uint64Return.Get().(*ReturnOfUint64)
}
func (__ *PoolOfUint64ThenUint64Impl) PutReturnOfUint64(p *ReturnOfUint64) {
	__.Uint64Return.Put(p)
}

func (__ *PoolOfUint64ThenUint64Impl) GetChReturnOfUint64() chan *ReturnOfUint64 {
	return __.ChReturnOfUint64.Get().(chan *ReturnOfUint64)
}
func (__ *PoolOfUint64ThenUint64Impl) PutChReturnOfUint64(p chan *ReturnOfUint64) {
	__.ChReturnOfUint64.Put(p)
}

func NewPoolOfUint64ThenUint64Impl() *PoolOfUint64ThenUint64Impl {
	return &PoolOfUint64ThenUint64Impl{
		Uint64Arg: sync.Pool{
			New: func() interface{} {
				return new(uint64)
			},
		},
		Uint64Work: sync.Pool{
			New: func() interface{} {
				return new(WorkOfUint64ThenUint64)
			},
		},
		Uint64Rtn: sync.Pool{
			New: func() interface{} {
				return new(uint64)
			},
		},
		Uint64Return: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfUint64)
			},
		},
		ChReturnOfUint64: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfUint64, 1)
			},
		},
	}
}

type ApiDecouplerOfUint64ThenUint64 struct {
	pool PoolOfUint64ThenUint64
}

func NewApiDecouplerOfUint64ThenUint64() *ApiDecouplerOfUint64ThenUint64 {
	return &ApiDecouplerOfUint64ThenUint64{
		pool: NewPoolOfUint64ThenUint64Impl(),
	}
}

func (__ *ApiDecouplerOfUint64ThenUint64) ReturnError(rtn_ch chan<- *ReturnOfUint64, err error) {
	rtn := __.pool.GetReturnOfUint64()
	var other uint64
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfUint64ThenUint64) HandleOfUint64ThenUint64(ctx context.Context, req *WorkOfUint64ThenUint64, h func(ctx context.Context, arg uint64) (uint64, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfUint64()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfUint64ThenUint64) DoOfUint64ThenUint64(ctx context.Context, worker WorkerOfPushUint64ThenUint64, arg uint64) (uint64, error) {
	// ch := make(chan *ReturnOfUint64, 1)
	ch := __.pool.GetChReturnOfUint64()
	defer __.pool.PutChReturnOfUint64(ch)

	req := __.pool.GetWorkOfUint64ThenUint64()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfUint64ThenUint64(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfUint64(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfUint64ThenUint64 = func(ctx context.Context, arg uint64) (uint64, error)

type WorkerOfUint64ThenUint64 struct {
	api_syncer *ApiDecouplerOfUint64ThenUint64
	handler    WorkHandlerOfUint64ThenUint64

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfUint64ThenUint64
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfUint64ThenUint64(ctx context.Context, h WorkHandlerOfUint64ThenUint64, n int) *WorkerOfUint64ThenUint64 {
	__ := &WorkerOfUint64ThenUint64{
		api_syncer: NewApiDecouplerOfUint64ThenUint64(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfUint64ThenUint64, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfUint64ThenUint64{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfUint64ThenUint64(req.Context, req.WorkOfUint64ThenUint64, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfUint64ThenUint64) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfUint64ThenUint64) Push(ctx context.Context, req *WorkOfUint64ThenUint64) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfUint64ThenUint64)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfUint64ThenUint64 = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfUint64ThenUint64) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfUint64ThenUint64) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfUint64ThenUint64) Call(ctx context.Context, arg uint64) (uint64, error) {
	return __.api_syncer.DoOfUint64ThenUint64(ctx, __, arg)
}

type PoolOfUint64ThenUint8 interface {
	GetUint64Arg() *uint64
	PutUint64Arg(*uint64)
	GetUint8Return() *uint8
	PutUint8Return(*uint8)

	GetWorkOfUint64ThenUint8() *WorkOfUint64ThenUint8
	GetReturnOfUint8() *ReturnOfUint8
	PutWorkOfUint64ThenUint8(*WorkOfUint64ThenUint8)
	PutReturnOfUint8(*ReturnOfUint8)

	GetChReturnOfUint8() chan *ReturnOfUint8
	PutChReturnOfUint8(chan *ReturnOfUint8)
}

type PoolOfUint64ThenUint8Impl struct {
	Uint64Arg       sync.Pool
	Uint8Rtn        sync.Pool
	Uint64Work      sync.Pool
	Uint8Return     sync.Pool
	ChReturnOfUint8 sync.Pool
}

func (__ *PoolOfUint64ThenUint8Impl) GetUint64Arg() *uint64 {
	return __.Uint64Arg.Get().(*uint64)
}
func (__ *PoolOfUint64ThenUint8Impl) PutUint64Arg(p *uint64) {
	__.Uint64Arg.Put(p)
}
func (__ *PoolOfUint64ThenUint8Impl) GetUint8Return() *uint8 {
	return __.Uint8Rtn.Get().(*uint8)
}
func (__ *PoolOfUint64ThenUint8Impl) PutUint8Return(p *uint8) {
	__.Uint8Rtn.Put(p)
}

func (__ *PoolOfUint64ThenUint8Impl) GetWorkOfUint64ThenUint8() *WorkOfUint64ThenUint8 {
	return __.Uint64Work.Get().(*WorkOfUint64ThenUint8)
}
func (__ *PoolOfUint64ThenUint8Impl) PutWorkOfUint64ThenUint8(p *WorkOfUint64ThenUint8) {
	__.Uint64Work.Put(p)
}
func (__ *PoolOfUint64ThenUint8Impl) GetReturnOfUint8() *ReturnOfUint8 {
	return __.Uint8Return.Get().(*ReturnOfUint8)
}
func (__ *PoolOfUint64ThenUint8Impl) PutReturnOfUint8(p *ReturnOfUint8) {
	__.Uint8Return.Put(p)
}

func (__ *PoolOfUint64ThenUint8Impl) GetChReturnOfUint8() chan *ReturnOfUint8 {
	return __.ChReturnOfUint8.Get().(chan *ReturnOfUint8)
}
func (__ *PoolOfUint64ThenUint8Impl) PutChReturnOfUint8(p chan *ReturnOfUint8) {
	__.ChReturnOfUint8.Put(p)
}

func NewPoolOfUint64ThenUint8Impl() *PoolOfUint64ThenUint8Impl {
	return &PoolOfUint64ThenUint8Impl{
		Uint64Arg: sync.Pool{
			New: func() interface{} {
				return new(uint64)
			},
		},
		Uint64Work: sync.Pool{
			New: func() interface{} {
				return new(WorkOfUint64ThenUint8)
			},
		},
		Uint8Rtn: sync.Pool{
			New: func() interface{} {
				return new(uint8)
			},
		},
		Uint8Return: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfUint8)
			},
		},
		ChReturnOfUint8: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfUint8, 1)
			},
		},
	}
}

type ApiDecouplerOfUint64ThenUint8 struct {
	pool PoolOfUint64ThenUint8
}

func NewApiDecouplerOfUint64ThenUint8() *ApiDecouplerOfUint64ThenUint8 {
	return &ApiDecouplerOfUint64ThenUint8{
		pool: NewPoolOfUint64ThenUint8Impl(),
	}
}

func (__ *ApiDecouplerOfUint64ThenUint8) ReturnError(rtn_ch chan<- *ReturnOfUint8, err error) {
	rtn := __.pool.GetReturnOfUint8()
	var other uint8
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfUint64ThenUint8) HandleOfUint64ThenUint8(ctx context.Context, req *WorkOfUint64ThenUint8, h func(ctx context.Context, arg uint64) (uint8, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfUint8()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfUint64ThenUint8) DoOfUint64ThenUint8(ctx context.Context, worker WorkerOfPushUint64ThenUint8, arg uint64) (uint8, error) {
	// ch := make(chan *ReturnOfUint8, 1)
	ch := __.pool.GetChReturnOfUint8()
	defer __.pool.PutChReturnOfUint8(ch)

	req := __.pool.GetWorkOfUint64ThenUint8()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfUint64ThenUint8(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfUint8(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfUint64ThenUint8 = func(ctx context.Context, arg uint64) (uint8, error)

type WorkerOfUint64ThenUint8 struct {
	api_syncer *ApiDecouplerOfUint64ThenUint8
	handler    WorkHandlerOfUint64ThenUint8

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfUint64ThenUint8
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfUint64ThenUint8(ctx context.Context, h WorkHandlerOfUint64ThenUint8, n int) *WorkerOfUint64ThenUint8 {
	__ := &WorkerOfUint64ThenUint8{
		api_syncer: NewApiDecouplerOfUint64ThenUint8(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfUint64ThenUint8, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfUint64ThenUint8{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfUint64ThenUint8(req.Context, req.WorkOfUint64ThenUint8, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfUint64ThenUint8) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfUint64ThenUint8) Push(ctx context.Context, req *WorkOfUint64ThenUint8) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfUint64ThenUint8)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfUint64ThenUint8 = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfUint64ThenUint8) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfUint64ThenUint8) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfUint64ThenUint8) Call(ctx context.Context, arg uint64) (uint8, error) {
	return __.api_syncer.DoOfUint64ThenUint8(ctx, __, arg)
}

type PoolOfUint64ThenUintptr interface {
	GetUint64Arg() *uint64
	PutUint64Arg(*uint64)
	GetUintptrReturn() *uintptr
	PutUintptrReturn(*uintptr)

	GetWorkOfUint64ThenUintptr() *WorkOfUint64ThenUintptr
	GetReturnOfUintptr() *ReturnOfUintptr
	PutWorkOfUint64ThenUintptr(*WorkOfUint64ThenUintptr)
	PutReturnOfUintptr(*ReturnOfUintptr)

	GetChReturnOfUintptr() chan *ReturnOfUintptr
	PutChReturnOfUintptr(chan *ReturnOfUintptr)
}

type PoolOfUint64ThenUintptrImpl struct {
	Uint64Arg         sync.Pool
	UintptrRtn        sync.Pool
	Uint64Work        sync.Pool
	UintptrReturn     sync.Pool
	ChReturnOfUintptr sync.Pool
}

func (__ *PoolOfUint64ThenUintptrImpl) GetUint64Arg() *uint64 {
	return __.Uint64Arg.Get().(*uint64)
}
func (__ *PoolOfUint64ThenUintptrImpl) PutUint64Arg(p *uint64) {
	__.Uint64Arg.Put(p)
}
func (__ *PoolOfUint64ThenUintptrImpl) GetUintptrReturn() *uintptr {
	return __.UintptrRtn.Get().(*uintptr)
}
func (__ *PoolOfUint64ThenUintptrImpl) PutUintptrReturn(p *uintptr) {
	__.UintptrRtn.Put(p)
}

func (__ *PoolOfUint64ThenUintptrImpl) GetWorkOfUint64ThenUintptr() *WorkOfUint64ThenUintptr {
	return __.Uint64Work.Get().(*WorkOfUint64ThenUintptr)
}
func (__ *PoolOfUint64ThenUintptrImpl) PutWorkOfUint64ThenUintptr(p *WorkOfUint64ThenUintptr) {
	__.Uint64Work.Put(p)
}
func (__ *PoolOfUint64ThenUintptrImpl) GetReturnOfUintptr() *ReturnOfUintptr {
	return __.UintptrReturn.Get().(*ReturnOfUintptr)
}
func (__ *PoolOfUint64ThenUintptrImpl) PutReturnOfUintptr(p *ReturnOfUintptr) {
	__.UintptrReturn.Put(p)
}

func (__ *PoolOfUint64ThenUintptrImpl) GetChReturnOfUintptr() chan *ReturnOfUintptr {
	return __.ChReturnOfUintptr.Get().(chan *ReturnOfUintptr)
}
func (__ *PoolOfUint64ThenUintptrImpl) PutChReturnOfUintptr(p chan *ReturnOfUintptr) {
	__.ChReturnOfUintptr.Put(p)
}

func NewPoolOfUint64ThenUintptrImpl() *PoolOfUint64ThenUintptrImpl {
	return &PoolOfUint64ThenUintptrImpl{
		Uint64Arg: sync.Pool{
			New: func() interface{} {
				return new(uint64)
			},
		},
		Uint64Work: sync.Pool{
			New: func() interface{} {
				return new(WorkOfUint64ThenUintptr)
			},
		},
		UintptrRtn: sync.Pool{
			New: func() interface{} {
				return new(uintptr)
			},
		},
		UintptrReturn: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfUintptr)
			},
		},
		ChReturnOfUintptr: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfUintptr, 1)
			},
		},
	}
}

type ApiDecouplerOfUint64ThenUintptr struct {
	pool PoolOfUint64ThenUintptr
}

func NewApiDecouplerOfUint64ThenUintptr() *ApiDecouplerOfUint64ThenUintptr {
	return &ApiDecouplerOfUint64ThenUintptr{
		pool: NewPoolOfUint64ThenUintptrImpl(),
	}
}

func (__ *ApiDecouplerOfUint64ThenUintptr) ReturnError(rtn_ch chan<- *ReturnOfUintptr, err error) {
	rtn := __.pool.GetReturnOfUintptr()
	var other uintptr
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfUint64ThenUintptr) HandleOfUint64ThenUintptr(ctx context.Context, req *WorkOfUint64ThenUintptr, h func(ctx context.Context, arg uint64) (uintptr, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfUintptr()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfUint64ThenUintptr) DoOfUint64ThenUintptr(ctx context.Context, worker WorkerOfPushUint64ThenUintptr, arg uint64) (uintptr, error) {
	// ch := make(chan *ReturnOfUintptr, 1)
	ch := __.pool.GetChReturnOfUintptr()
	defer __.pool.PutChReturnOfUintptr(ch)

	req := __.pool.GetWorkOfUint64ThenUintptr()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfUint64ThenUintptr(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfUintptr(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfUint64ThenUintptr = func(ctx context.Context, arg uint64) (uintptr, error)

type WorkerOfUint64ThenUintptr struct {
	api_syncer *ApiDecouplerOfUint64ThenUintptr
	handler    WorkHandlerOfUint64ThenUintptr

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfUint64ThenUintptr
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfUint64ThenUintptr(ctx context.Context, h WorkHandlerOfUint64ThenUintptr, n int) *WorkerOfUint64ThenUintptr {
	__ := &WorkerOfUint64ThenUintptr{
		api_syncer: NewApiDecouplerOfUint64ThenUintptr(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfUint64ThenUintptr, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfUint64ThenUintptr{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfUint64ThenUintptr(req.Context, req.WorkOfUint64ThenUintptr, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfUint64ThenUintptr) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfUint64ThenUintptr) Push(ctx context.Context, req *WorkOfUint64ThenUintptr) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfUint64ThenUintptr)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfUint64ThenUintptr = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfUint64ThenUintptr) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfUint64ThenUintptr) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfUint64ThenUintptr) Call(ctx context.Context, arg uint64) (uintptr, error) {
	return __.api_syncer.DoOfUint64ThenUintptr(ctx, __, arg)
}

type PoolOfUint64ThenInterface interface {
	GetUint64Arg() *uint64
	PutUint64Arg(*uint64)
	GetInterfaceReturn() *interface{}
	PutInterfaceReturn(*interface{})

	GetWorkOfUint64ThenInterface() *WorkOfUint64ThenInterface
	GetReturnOfInterface() *ReturnOfInterface
	PutWorkOfUint64ThenInterface(*WorkOfUint64ThenInterface)
	PutReturnOfInterface(*ReturnOfInterface)

	GetChReturnOfInterface() chan *ReturnOfInterface
	PutChReturnOfInterface(chan *ReturnOfInterface)
}

type PoolOfUint64ThenInterfaceImpl struct {
	Uint64Arg           sync.Pool
	InterfaceRtn        sync.Pool
	Uint64Work          sync.Pool
	InterfaceReturn     sync.Pool
	ChReturnOfInterface sync.Pool
}

func (__ *PoolOfUint64ThenInterfaceImpl) GetUint64Arg() *uint64 {
	return __.Uint64Arg.Get().(*uint64)
}
func (__ *PoolOfUint64ThenInterfaceImpl) PutUint64Arg(p *uint64) {
	__.Uint64Arg.Put(p)
}
func (__ *PoolOfUint64ThenInterfaceImpl) GetInterfaceReturn() *interface{} {
	return __.InterfaceRtn.Get().(*interface{})
}
func (__ *PoolOfUint64ThenInterfaceImpl) PutInterfaceReturn(p *interface{}) {
	__.InterfaceRtn.Put(p)
}

func (__ *PoolOfUint64ThenInterfaceImpl) GetWorkOfUint64ThenInterface() *WorkOfUint64ThenInterface {
	return __.Uint64Work.Get().(*WorkOfUint64ThenInterface)
}
func (__ *PoolOfUint64ThenInterfaceImpl) PutWorkOfUint64ThenInterface(p *WorkOfUint64ThenInterface) {
	__.Uint64Work.Put(p)
}
func (__ *PoolOfUint64ThenInterfaceImpl) GetReturnOfInterface() *ReturnOfInterface {
	return __.InterfaceReturn.Get().(*ReturnOfInterface)
}
func (__ *PoolOfUint64ThenInterfaceImpl) PutReturnOfInterface(p *ReturnOfInterface) {
	__.InterfaceReturn.Put(p)
}

func (__ *PoolOfUint64ThenInterfaceImpl) GetChReturnOfInterface() chan *ReturnOfInterface {
	return __.ChReturnOfInterface.Get().(chan *ReturnOfInterface)
}
func (__ *PoolOfUint64ThenInterfaceImpl) PutChReturnOfInterface(p chan *ReturnOfInterface) {
	__.ChReturnOfInterface.Put(p)
}

func NewPoolOfUint64ThenInterfaceImpl() *PoolOfUint64ThenInterfaceImpl {
	return &PoolOfUint64ThenInterfaceImpl{
		Uint64Arg: sync.Pool{
			New: func() interface{} {
				return new(uint64)
			},
		},
		Uint64Work: sync.Pool{
			New: func() interface{} {
				return new(WorkOfUint64ThenInterface)
			},
		},
		InterfaceRtn: sync.Pool{
			New: func() interface{} {
				return new(interface{})
			},
		},
		InterfaceReturn: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfInterface)
			},
		},
		ChReturnOfInterface: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfInterface, 1)
			},
		},
	}
}

type ApiDecouplerOfUint64ThenInterface struct {
	pool PoolOfUint64ThenInterface
}

func NewApiDecouplerOfUint64ThenInterface() *ApiDecouplerOfUint64ThenInterface {
	return &ApiDecouplerOfUint64ThenInterface{
		pool: NewPoolOfUint64ThenInterfaceImpl(),
	}
}

func (__ *ApiDecouplerOfUint64ThenInterface) ReturnError(rtn_ch chan<- *ReturnOfInterface, err error) {
	rtn := __.pool.GetReturnOfInterface()
	var other interface{}
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfUint64ThenInterface) HandleOfUint64ThenInterface(ctx context.Context, req *WorkOfUint64ThenInterface, h func(ctx context.Context, arg uint64) (interface{}, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfInterface()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfUint64ThenInterface) DoOfUint64ThenInterface(ctx context.Context, worker WorkerOfPushUint64ThenInterface, arg uint64) (interface{}, error) {
	// ch := make(chan *ReturnOfInterface, 1)
	ch := __.pool.GetChReturnOfInterface()
	defer __.pool.PutChReturnOfInterface(ch)

	req := __.pool.GetWorkOfUint64ThenInterface()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfUint64ThenInterface(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfInterface(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfUint64ThenInterface = func(ctx context.Context, arg uint64) (interface{}, error)

type WorkerOfUint64ThenInterface struct {
	api_syncer *ApiDecouplerOfUint64ThenInterface
	handler    WorkHandlerOfUint64ThenInterface

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfUint64ThenInterface
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfUint64ThenInterface(ctx context.Context, h WorkHandlerOfUint64ThenInterface, n int) *WorkerOfUint64ThenInterface {
	__ := &WorkerOfUint64ThenInterface{
		api_syncer: NewApiDecouplerOfUint64ThenInterface(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfUint64ThenInterface, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfUint64ThenInterface{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfUint64ThenInterface(req.Context, req.WorkOfUint64ThenInterface, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfUint64ThenInterface) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfUint64ThenInterface) Push(ctx context.Context, req *WorkOfUint64ThenInterface) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfUint64ThenInterface)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfUint64ThenInterface = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfUint64ThenInterface) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfUint64ThenInterface) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfUint64ThenInterface) Call(ctx context.Context, arg uint64) (interface{}, error) {
	return __.api_syncer.DoOfUint64ThenInterface(ctx, __, arg)
}

type PoolOfUint64ThenStruct interface {
	GetUint64Arg() *uint64
	PutUint64Arg(*uint64)
	GetStructReturn() *struct{}
	PutStructReturn(*struct{})

	GetWorkOfUint64ThenStruct() *WorkOfUint64ThenStruct
	GetReturnOfStruct() *ReturnOfStruct
	PutWorkOfUint64ThenStruct(*WorkOfUint64ThenStruct)
	PutReturnOfStruct(*ReturnOfStruct)

	GetChReturnOfStruct() chan *ReturnOfStruct
	PutChReturnOfStruct(chan *ReturnOfStruct)
}

type PoolOfUint64ThenStructImpl struct {
	Uint64Arg        sync.Pool
	StructRtn        sync.Pool
	Uint64Work       sync.Pool
	StructReturn     sync.Pool
	ChReturnOfStruct sync.Pool
}

func (__ *PoolOfUint64ThenStructImpl) GetUint64Arg() *uint64 {
	return __.Uint64Arg.Get().(*uint64)
}
func (__ *PoolOfUint64ThenStructImpl) PutUint64Arg(p *uint64) {
	__.Uint64Arg.Put(p)
}
func (__ *PoolOfUint64ThenStructImpl) GetStructReturn() *struct{} {
	return __.StructRtn.Get().(*struct{})
}
func (__ *PoolOfUint64ThenStructImpl) PutStructReturn(p *struct{}) {
	__.StructRtn.Put(p)
}

func (__ *PoolOfUint64ThenStructImpl) GetWorkOfUint64ThenStruct() *WorkOfUint64ThenStruct {
	return __.Uint64Work.Get().(*WorkOfUint64ThenStruct)
}
func (__ *PoolOfUint64ThenStructImpl) PutWorkOfUint64ThenStruct(p *WorkOfUint64ThenStruct) {
	__.Uint64Work.Put(p)
}
func (__ *PoolOfUint64ThenStructImpl) GetReturnOfStruct() *ReturnOfStruct {
	return __.StructReturn.Get().(*ReturnOfStruct)
}
func (__ *PoolOfUint64ThenStructImpl) PutReturnOfStruct(p *ReturnOfStruct) {
	__.StructReturn.Put(p)
}

func (__ *PoolOfUint64ThenStructImpl) GetChReturnOfStruct() chan *ReturnOfStruct {
	return __.ChReturnOfStruct.Get().(chan *ReturnOfStruct)
}
func (__ *PoolOfUint64ThenStructImpl) PutChReturnOfStruct(p chan *ReturnOfStruct) {
	__.ChReturnOfStruct.Put(p)
}

func NewPoolOfUint64ThenStructImpl() *PoolOfUint64ThenStructImpl {
	return &PoolOfUint64ThenStructImpl{
		Uint64Arg: sync.Pool{
			New: func() interface{} {
				return new(uint64)
			},
		},
		Uint64Work: sync.Pool{
			New: func() interface{} {
				return new(WorkOfUint64ThenStruct)
			},
		},
		StructRtn: sync.Pool{
			New: func() interface{} {
				return new(struct{})
			},
		},
		StructReturn: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfStruct)
			},
		},
		ChReturnOfStruct: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfStruct, 1)
			},
		},
	}
}

type ApiDecouplerOfUint64ThenStruct struct {
	pool PoolOfUint64ThenStruct
}

func NewApiDecouplerOfUint64ThenStruct() *ApiDecouplerOfUint64ThenStruct {
	return &ApiDecouplerOfUint64ThenStruct{
		pool: NewPoolOfUint64ThenStructImpl(),
	}
}

func (__ *ApiDecouplerOfUint64ThenStruct) ReturnError(rtn_ch chan<- *ReturnOfStruct, err error) {
	rtn := __.pool.GetReturnOfStruct()
	var other struct{}
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfUint64ThenStruct) HandleOfUint64ThenStruct(ctx context.Context, req *WorkOfUint64ThenStruct, h func(ctx context.Context, arg uint64) (struct{}, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfStruct()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfUint64ThenStruct) DoOfUint64ThenStruct(ctx context.Context, worker WorkerOfPushUint64ThenStruct, arg uint64) (struct{}, error) {
	// ch := make(chan *ReturnOfStruct, 1)
	ch := __.pool.GetChReturnOfStruct()
	defer __.pool.PutChReturnOfStruct(ch)

	req := __.pool.GetWorkOfUint64ThenStruct()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfUint64ThenStruct(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfStruct(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfUint64ThenStruct = func(ctx context.Context, arg uint64) (struct{}, error)

type WorkerOfUint64ThenStruct struct {
	api_syncer *ApiDecouplerOfUint64ThenStruct
	handler    WorkHandlerOfUint64ThenStruct

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfUint64ThenStruct
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfUint64ThenStruct(ctx context.Context, h WorkHandlerOfUint64ThenStruct, n int) *WorkerOfUint64ThenStruct {
	__ := &WorkerOfUint64ThenStruct{
		api_syncer: NewApiDecouplerOfUint64ThenStruct(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfUint64ThenStruct, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfUint64ThenStruct{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfUint64ThenStruct(req.Context, req.WorkOfUint64ThenStruct, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfUint64ThenStruct) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfUint64ThenStruct) Push(ctx context.Context, req *WorkOfUint64ThenStruct) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfUint64ThenStruct)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfUint64ThenStruct = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfUint64ThenStruct) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfUint64ThenStruct) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfUint64ThenStruct) Call(ctx context.Context, arg uint64) (struct{}, error) {
	return __.api_syncer.DoOfUint64ThenStruct(ctx, __, arg)
}

type PoolOfUint8ThenBool interface {
	GetUint8Arg() *uint8
	PutUint8Arg(*uint8)
	GetBoolReturn() *bool
	PutBoolReturn(*bool)

	GetWorkOfUint8ThenBool() *WorkOfUint8ThenBool
	GetReturnOfBool() *ReturnOfBool
	PutWorkOfUint8ThenBool(*WorkOfUint8ThenBool)
	PutReturnOfBool(*ReturnOfBool)

	GetChReturnOfBool() chan *ReturnOfBool
	PutChReturnOfBool(chan *ReturnOfBool)
}

type PoolOfUint8ThenBoolImpl struct {
	Uint8Arg       sync.Pool
	BoolRtn        sync.Pool
	Uint8Work      sync.Pool
	BoolReturn     sync.Pool
	ChReturnOfBool sync.Pool
}

func (__ *PoolOfUint8ThenBoolImpl) GetUint8Arg() *uint8 {
	return __.Uint8Arg.Get().(*uint8)
}
func (__ *PoolOfUint8ThenBoolImpl) PutUint8Arg(p *uint8) {
	__.Uint8Arg.Put(p)
}
func (__ *PoolOfUint8ThenBoolImpl) GetBoolReturn() *bool {
	return __.BoolRtn.Get().(*bool)
}
func (__ *PoolOfUint8ThenBoolImpl) PutBoolReturn(p *bool) {
	__.BoolRtn.Put(p)
}

func (__ *PoolOfUint8ThenBoolImpl) GetWorkOfUint8ThenBool() *WorkOfUint8ThenBool {
	return __.Uint8Work.Get().(*WorkOfUint8ThenBool)
}
func (__ *PoolOfUint8ThenBoolImpl) PutWorkOfUint8ThenBool(p *WorkOfUint8ThenBool) {
	__.Uint8Work.Put(p)
}
func (__ *PoolOfUint8ThenBoolImpl) GetReturnOfBool() *ReturnOfBool {
	return __.BoolReturn.Get().(*ReturnOfBool)
}
func (__ *PoolOfUint8ThenBoolImpl) PutReturnOfBool(p *ReturnOfBool) {
	__.BoolReturn.Put(p)
}

func (__ *PoolOfUint8ThenBoolImpl) GetChReturnOfBool() chan *ReturnOfBool {
	return __.ChReturnOfBool.Get().(chan *ReturnOfBool)
}
func (__ *PoolOfUint8ThenBoolImpl) PutChReturnOfBool(p chan *ReturnOfBool) {
	__.ChReturnOfBool.Put(p)
}

func NewPoolOfUint8ThenBoolImpl() *PoolOfUint8ThenBoolImpl {
	return &PoolOfUint8ThenBoolImpl{
		Uint8Arg: sync.Pool{
			New: func() interface{} {
				return new(uint8)
			},
		},
		Uint8Work: sync.Pool{
			New: func() interface{} {
				return new(WorkOfUint8ThenBool)
			},
		},
		BoolRtn: sync.Pool{
			New: func() interface{} {
				return new(bool)
			},
		},
		BoolReturn: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfBool)
			},
		},
		ChReturnOfBool: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfBool, 1)
			},
		},
	}
}

type ApiDecouplerOfUint8ThenBool struct {
	pool PoolOfUint8ThenBool
}

func NewApiDecouplerOfUint8ThenBool() *ApiDecouplerOfUint8ThenBool {
	return &ApiDecouplerOfUint8ThenBool{
		pool: NewPoolOfUint8ThenBoolImpl(),
	}
}

func (__ *ApiDecouplerOfUint8ThenBool) ReturnError(rtn_ch chan<- *ReturnOfBool, err error) {
	rtn := __.pool.GetReturnOfBool()
	var other bool
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfUint8ThenBool) HandleOfUint8ThenBool(ctx context.Context, req *WorkOfUint8ThenBool, h func(ctx context.Context, arg uint8) (bool, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfBool()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfUint8ThenBool) DoOfUint8ThenBool(ctx context.Context, worker WorkerOfPushUint8ThenBool, arg uint8) (bool, error) {
	// ch := make(chan *ReturnOfBool, 1)
	ch := __.pool.GetChReturnOfBool()
	defer __.pool.PutChReturnOfBool(ch)

	req := __.pool.GetWorkOfUint8ThenBool()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfUint8ThenBool(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfBool(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfUint8ThenBool = func(ctx context.Context, arg uint8) (bool, error)

type WorkerOfUint8ThenBool struct {
	api_syncer *ApiDecouplerOfUint8ThenBool
	handler    WorkHandlerOfUint8ThenBool

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfUint8ThenBool
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfUint8ThenBool(ctx context.Context, h WorkHandlerOfUint8ThenBool, n int) *WorkerOfUint8ThenBool {
	__ := &WorkerOfUint8ThenBool{
		api_syncer: NewApiDecouplerOfUint8ThenBool(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfUint8ThenBool, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfUint8ThenBool{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfUint8ThenBool(req.Context, req.WorkOfUint8ThenBool, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfUint8ThenBool) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfUint8ThenBool) Push(ctx context.Context, req *WorkOfUint8ThenBool) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfUint8ThenBool)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfUint8ThenBool = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfUint8ThenBool) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfUint8ThenBool) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfUint8ThenBool) Call(ctx context.Context, arg uint8) (bool, error) {
	return __.api_syncer.DoOfUint8ThenBool(ctx, __, arg)
}

type PoolOfUint8ThenByte interface {
	GetUint8Arg() *uint8
	PutUint8Arg(*uint8)
	GetByteReturn() *byte
	PutByteReturn(*byte)

	GetWorkOfUint8ThenByte() *WorkOfUint8ThenByte
	GetReturnOfByte() *ReturnOfByte
	PutWorkOfUint8ThenByte(*WorkOfUint8ThenByte)
	PutReturnOfByte(*ReturnOfByte)

	GetChReturnOfByte() chan *ReturnOfByte
	PutChReturnOfByte(chan *ReturnOfByte)
}

type PoolOfUint8ThenByteImpl struct {
	Uint8Arg       sync.Pool
	ByteRtn        sync.Pool
	Uint8Work      sync.Pool
	ByteReturn     sync.Pool
	ChReturnOfByte sync.Pool
}

func (__ *PoolOfUint8ThenByteImpl) GetUint8Arg() *uint8 {
	return __.Uint8Arg.Get().(*uint8)
}
func (__ *PoolOfUint8ThenByteImpl) PutUint8Arg(p *uint8) {
	__.Uint8Arg.Put(p)
}
func (__ *PoolOfUint8ThenByteImpl) GetByteReturn() *byte {
	return __.ByteRtn.Get().(*byte)
}
func (__ *PoolOfUint8ThenByteImpl) PutByteReturn(p *byte) {
	__.ByteRtn.Put(p)
}

func (__ *PoolOfUint8ThenByteImpl) GetWorkOfUint8ThenByte() *WorkOfUint8ThenByte {
	return __.Uint8Work.Get().(*WorkOfUint8ThenByte)
}
func (__ *PoolOfUint8ThenByteImpl) PutWorkOfUint8ThenByte(p *WorkOfUint8ThenByte) {
	__.Uint8Work.Put(p)
}
func (__ *PoolOfUint8ThenByteImpl) GetReturnOfByte() *ReturnOfByte {
	return __.ByteReturn.Get().(*ReturnOfByte)
}
func (__ *PoolOfUint8ThenByteImpl) PutReturnOfByte(p *ReturnOfByte) {
	__.ByteReturn.Put(p)
}

func (__ *PoolOfUint8ThenByteImpl) GetChReturnOfByte() chan *ReturnOfByte {
	return __.ChReturnOfByte.Get().(chan *ReturnOfByte)
}
func (__ *PoolOfUint8ThenByteImpl) PutChReturnOfByte(p chan *ReturnOfByte) {
	__.ChReturnOfByte.Put(p)
}

func NewPoolOfUint8ThenByteImpl() *PoolOfUint8ThenByteImpl {
	return &PoolOfUint8ThenByteImpl{
		Uint8Arg: sync.Pool{
			New: func() interface{} {
				return new(uint8)
			},
		},
		Uint8Work: sync.Pool{
			New: func() interface{} {
				return new(WorkOfUint8ThenByte)
			},
		},
		ByteRtn: sync.Pool{
			New: func() interface{} {
				return new(byte)
			},
		},
		ByteReturn: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfByte)
			},
		},
		ChReturnOfByte: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfByte, 1)
			},
		},
	}
}

type ApiDecouplerOfUint8ThenByte struct {
	pool PoolOfUint8ThenByte
}

func NewApiDecouplerOfUint8ThenByte() *ApiDecouplerOfUint8ThenByte {
	return &ApiDecouplerOfUint8ThenByte{
		pool: NewPoolOfUint8ThenByteImpl(),
	}
}

func (__ *ApiDecouplerOfUint8ThenByte) ReturnError(rtn_ch chan<- *ReturnOfByte, err error) {
	rtn := __.pool.GetReturnOfByte()
	var other byte
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfUint8ThenByte) HandleOfUint8ThenByte(ctx context.Context, req *WorkOfUint8ThenByte, h func(ctx context.Context, arg uint8) (byte, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfByte()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfUint8ThenByte) DoOfUint8ThenByte(ctx context.Context, worker WorkerOfPushUint8ThenByte, arg uint8) (byte, error) {
	// ch := make(chan *ReturnOfByte, 1)
	ch := __.pool.GetChReturnOfByte()
	defer __.pool.PutChReturnOfByte(ch)

	req := __.pool.GetWorkOfUint8ThenByte()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfUint8ThenByte(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfByte(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfUint8ThenByte = func(ctx context.Context, arg uint8) (byte, error)

type WorkerOfUint8ThenByte struct {
	api_syncer *ApiDecouplerOfUint8ThenByte
	handler    WorkHandlerOfUint8ThenByte

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfUint8ThenByte
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfUint8ThenByte(ctx context.Context, h WorkHandlerOfUint8ThenByte, n int) *WorkerOfUint8ThenByte {
	__ := &WorkerOfUint8ThenByte{
		api_syncer: NewApiDecouplerOfUint8ThenByte(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfUint8ThenByte, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfUint8ThenByte{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfUint8ThenByte(req.Context, req.WorkOfUint8ThenByte, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfUint8ThenByte) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfUint8ThenByte) Push(ctx context.Context, req *WorkOfUint8ThenByte) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfUint8ThenByte)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfUint8ThenByte = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfUint8ThenByte) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfUint8ThenByte) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfUint8ThenByte) Call(ctx context.Context, arg uint8) (byte, error) {
	return __.api_syncer.DoOfUint8ThenByte(ctx, __, arg)
}

type PoolOfUint8ThenComplex128 interface {
	GetUint8Arg() *uint8
	PutUint8Arg(*uint8)
	GetComplex128Return() *complex128
	PutComplex128Return(*complex128)

	GetWorkOfUint8ThenComplex128() *WorkOfUint8ThenComplex128
	GetReturnOfComplex128() *ReturnOfComplex128
	PutWorkOfUint8ThenComplex128(*WorkOfUint8ThenComplex128)
	PutReturnOfComplex128(*ReturnOfComplex128)

	GetChReturnOfComplex128() chan *ReturnOfComplex128
	PutChReturnOfComplex128(chan *ReturnOfComplex128)
}

type PoolOfUint8ThenComplex128Impl struct {
	Uint8Arg             sync.Pool
	Complex128Rtn        sync.Pool
	Uint8Work            sync.Pool
	Complex128Return     sync.Pool
	ChReturnOfComplex128 sync.Pool
}

func (__ *PoolOfUint8ThenComplex128Impl) GetUint8Arg() *uint8 {
	return __.Uint8Arg.Get().(*uint8)
}
func (__ *PoolOfUint8ThenComplex128Impl) PutUint8Arg(p *uint8) {
	__.Uint8Arg.Put(p)
}
func (__ *PoolOfUint8ThenComplex128Impl) GetComplex128Return() *complex128 {
	return __.Complex128Rtn.Get().(*complex128)
}
func (__ *PoolOfUint8ThenComplex128Impl) PutComplex128Return(p *complex128) {
	__.Complex128Rtn.Put(p)
}

func (__ *PoolOfUint8ThenComplex128Impl) GetWorkOfUint8ThenComplex128() *WorkOfUint8ThenComplex128 {
	return __.Uint8Work.Get().(*WorkOfUint8ThenComplex128)
}
func (__ *PoolOfUint8ThenComplex128Impl) PutWorkOfUint8ThenComplex128(p *WorkOfUint8ThenComplex128) {
	__.Uint8Work.Put(p)
}
func (__ *PoolOfUint8ThenComplex128Impl) GetReturnOfComplex128() *ReturnOfComplex128 {
	return __.Complex128Return.Get().(*ReturnOfComplex128)
}
func (__ *PoolOfUint8ThenComplex128Impl) PutReturnOfComplex128(p *ReturnOfComplex128) {
	__.Complex128Return.Put(p)
}

func (__ *PoolOfUint8ThenComplex128Impl) GetChReturnOfComplex128() chan *ReturnOfComplex128 {
	return __.ChReturnOfComplex128.Get().(chan *ReturnOfComplex128)
}
func (__ *PoolOfUint8ThenComplex128Impl) PutChReturnOfComplex128(p chan *ReturnOfComplex128) {
	__.ChReturnOfComplex128.Put(p)
}

func NewPoolOfUint8ThenComplex128Impl() *PoolOfUint8ThenComplex128Impl {
	return &PoolOfUint8ThenComplex128Impl{
		Uint8Arg: sync.Pool{
			New: func() interface{} {
				return new(uint8)
			},
		},
		Uint8Work: sync.Pool{
			New: func() interface{} {
				return new(WorkOfUint8ThenComplex128)
			},
		},
		Complex128Rtn: sync.Pool{
			New: func() interface{} {
				return new(complex128)
			},
		},
		Complex128Return: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfComplex128)
			},
		},
		ChReturnOfComplex128: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfComplex128, 1)
			},
		},
	}
}

type ApiDecouplerOfUint8ThenComplex128 struct {
	pool PoolOfUint8ThenComplex128
}

func NewApiDecouplerOfUint8ThenComplex128() *ApiDecouplerOfUint8ThenComplex128 {
	return &ApiDecouplerOfUint8ThenComplex128{
		pool: NewPoolOfUint8ThenComplex128Impl(),
	}
}

func (__ *ApiDecouplerOfUint8ThenComplex128) ReturnError(rtn_ch chan<- *ReturnOfComplex128, err error) {
	rtn := __.pool.GetReturnOfComplex128()
	var other complex128
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfUint8ThenComplex128) HandleOfUint8ThenComplex128(ctx context.Context, req *WorkOfUint8ThenComplex128, h func(ctx context.Context, arg uint8) (complex128, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfComplex128()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfUint8ThenComplex128) DoOfUint8ThenComplex128(ctx context.Context, worker WorkerOfPushUint8ThenComplex128, arg uint8) (complex128, error) {
	// ch := make(chan *ReturnOfComplex128, 1)
	ch := __.pool.GetChReturnOfComplex128()
	defer __.pool.PutChReturnOfComplex128(ch)

	req := __.pool.GetWorkOfUint8ThenComplex128()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfUint8ThenComplex128(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfComplex128(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfUint8ThenComplex128 = func(ctx context.Context, arg uint8) (complex128, error)

type WorkerOfUint8ThenComplex128 struct {
	api_syncer *ApiDecouplerOfUint8ThenComplex128
	handler    WorkHandlerOfUint8ThenComplex128

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfUint8ThenComplex128
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfUint8ThenComplex128(ctx context.Context, h WorkHandlerOfUint8ThenComplex128, n int) *WorkerOfUint8ThenComplex128 {
	__ := &WorkerOfUint8ThenComplex128{
		api_syncer: NewApiDecouplerOfUint8ThenComplex128(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfUint8ThenComplex128, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfUint8ThenComplex128{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfUint8ThenComplex128(req.Context, req.WorkOfUint8ThenComplex128, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfUint8ThenComplex128) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfUint8ThenComplex128) Push(ctx context.Context, req *WorkOfUint8ThenComplex128) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfUint8ThenComplex128)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfUint8ThenComplex128 = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfUint8ThenComplex128) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfUint8ThenComplex128) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfUint8ThenComplex128) Call(ctx context.Context, arg uint8) (complex128, error) {
	return __.api_syncer.DoOfUint8ThenComplex128(ctx, __, arg)
}

type PoolOfUint8ThenComplex64 interface {
	GetUint8Arg() *uint8
	PutUint8Arg(*uint8)
	GetComplex64Return() *complex64
	PutComplex64Return(*complex64)

	GetWorkOfUint8ThenComplex64() *WorkOfUint8ThenComplex64
	GetReturnOfComplex64() *ReturnOfComplex64
	PutWorkOfUint8ThenComplex64(*WorkOfUint8ThenComplex64)
	PutReturnOfComplex64(*ReturnOfComplex64)

	GetChReturnOfComplex64() chan *ReturnOfComplex64
	PutChReturnOfComplex64(chan *ReturnOfComplex64)
}

type PoolOfUint8ThenComplex64Impl struct {
	Uint8Arg            sync.Pool
	Complex64Rtn        sync.Pool
	Uint8Work           sync.Pool
	Complex64Return     sync.Pool
	ChReturnOfComplex64 sync.Pool
}

func (__ *PoolOfUint8ThenComplex64Impl) GetUint8Arg() *uint8 {
	return __.Uint8Arg.Get().(*uint8)
}
func (__ *PoolOfUint8ThenComplex64Impl) PutUint8Arg(p *uint8) {
	__.Uint8Arg.Put(p)
}
func (__ *PoolOfUint8ThenComplex64Impl) GetComplex64Return() *complex64 {
	return __.Complex64Rtn.Get().(*complex64)
}
func (__ *PoolOfUint8ThenComplex64Impl) PutComplex64Return(p *complex64) {
	__.Complex64Rtn.Put(p)
}

func (__ *PoolOfUint8ThenComplex64Impl) GetWorkOfUint8ThenComplex64() *WorkOfUint8ThenComplex64 {
	return __.Uint8Work.Get().(*WorkOfUint8ThenComplex64)
}
func (__ *PoolOfUint8ThenComplex64Impl) PutWorkOfUint8ThenComplex64(p *WorkOfUint8ThenComplex64) {
	__.Uint8Work.Put(p)
}
func (__ *PoolOfUint8ThenComplex64Impl) GetReturnOfComplex64() *ReturnOfComplex64 {
	return __.Complex64Return.Get().(*ReturnOfComplex64)
}
func (__ *PoolOfUint8ThenComplex64Impl) PutReturnOfComplex64(p *ReturnOfComplex64) {
	__.Complex64Return.Put(p)
}

func (__ *PoolOfUint8ThenComplex64Impl) GetChReturnOfComplex64() chan *ReturnOfComplex64 {
	return __.ChReturnOfComplex64.Get().(chan *ReturnOfComplex64)
}
func (__ *PoolOfUint8ThenComplex64Impl) PutChReturnOfComplex64(p chan *ReturnOfComplex64) {
	__.ChReturnOfComplex64.Put(p)
}

func NewPoolOfUint8ThenComplex64Impl() *PoolOfUint8ThenComplex64Impl {
	return &PoolOfUint8ThenComplex64Impl{
		Uint8Arg: sync.Pool{
			New: func() interface{} {
				return new(uint8)
			},
		},
		Uint8Work: sync.Pool{
			New: func() interface{} {
				return new(WorkOfUint8ThenComplex64)
			},
		},
		Complex64Rtn: sync.Pool{
			New: func() interface{} {
				return new(complex64)
			},
		},
		Complex64Return: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfComplex64)
			},
		},
		ChReturnOfComplex64: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfComplex64, 1)
			},
		},
	}
}

type ApiDecouplerOfUint8ThenComplex64 struct {
	pool PoolOfUint8ThenComplex64
}

func NewApiDecouplerOfUint8ThenComplex64() *ApiDecouplerOfUint8ThenComplex64 {
	return &ApiDecouplerOfUint8ThenComplex64{
		pool: NewPoolOfUint8ThenComplex64Impl(),
	}
}

func (__ *ApiDecouplerOfUint8ThenComplex64) ReturnError(rtn_ch chan<- *ReturnOfComplex64, err error) {
	rtn := __.pool.GetReturnOfComplex64()
	var other complex64
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfUint8ThenComplex64) HandleOfUint8ThenComplex64(ctx context.Context, req *WorkOfUint8ThenComplex64, h func(ctx context.Context, arg uint8) (complex64, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfComplex64()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfUint8ThenComplex64) DoOfUint8ThenComplex64(ctx context.Context, worker WorkerOfPushUint8ThenComplex64, arg uint8) (complex64, error) {
	// ch := make(chan *ReturnOfComplex64, 1)
	ch := __.pool.GetChReturnOfComplex64()
	defer __.pool.PutChReturnOfComplex64(ch)

	req := __.pool.GetWorkOfUint8ThenComplex64()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfUint8ThenComplex64(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfComplex64(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfUint8ThenComplex64 = func(ctx context.Context, arg uint8) (complex64, error)

type WorkerOfUint8ThenComplex64 struct {
	api_syncer *ApiDecouplerOfUint8ThenComplex64
	handler    WorkHandlerOfUint8ThenComplex64

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfUint8ThenComplex64
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfUint8ThenComplex64(ctx context.Context, h WorkHandlerOfUint8ThenComplex64, n int) *WorkerOfUint8ThenComplex64 {
	__ := &WorkerOfUint8ThenComplex64{
		api_syncer: NewApiDecouplerOfUint8ThenComplex64(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfUint8ThenComplex64, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfUint8ThenComplex64{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfUint8ThenComplex64(req.Context, req.WorkOfUint8ThenComplex64, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfUint8ThenComplex64) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfUint8ThenComplex64) Push(ctx context.Context, req *WorkOfUint8ThenComplex64) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfUint8ThenComplex64)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfUint8ThenComplex64 = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfUint8ThenComplex64) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfUint8ThenComplex64) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfUint8ThenComplex64) Call(ctx context.Context, arg uint8) (complex64, error) {
	return __.api_syncer.DoOfUint8ThenComplex64(ctx, __, arg)
}

type PoolOfUint8ThenError interface {
	GetUint8Arg() *uint8
	PutUint8Arg(*uint8)
	GetErrorReturn() *error
	PutErrorReturn(*error)

	GetWorkOfUint8ThenError() *WorkOfUint8ThenError
	GetReturnOfError() *ReturnOfError
	PutWorkOfUint8ThenError(*WorkOfUint8ThenError)
	PutReturnOfError(*ReturnOfError)

	GetChReturnOfError() chan *ReturnOfError
	PutChReturnOfError(chan *ReturnOfError)
}

type PoolOfUint8ThenErrorImpl struct {
	Uint8Arg        sync.Pool
	ErrorRtn        sync.Pool
	Uint8Work       sync.Pool
	ErrorReturn     sync.Pool
	ChReturnOfError sync.Pool
}

func (__ *PoolOfUint8ThenErrorImpl) GetUint8Arg() *uint8 {
	return __.Uint8Arg.Get().(*uint8)
}
func (__ *PoolOfUint8ThenErrorImpl) PutUint8Arg(p *uint8) {
	__.Uint8Arg.Put(p)
}
func (__ *PoolOfUint8ThenErrorImpl) GetErrorReturn() *error {
	return __.ErrorRtn.Get().(*error)
}
func (__ *PoolOfUint8ThenErrorImpl) PutErrorReturn(p *error) {
	__.ErrorRtn.Put(p)
}

func (__ *PoolOfUint8ThenErrorImpl) GetWorkOfUint8ThenError() *WorkOfUint8ThenError {
	return __.Uint8Work.Get().(*WorkOfUint8ThenError)
}
func (__ *PoolOfUint8ThenErrorImpl) PutWorkOfUint8ThenError(p *WorkOfUint8ThenError) {
	__.Uint8Work.Put(p)
}
func (__ *PoolOfUint8ThenErrorImpl) GetReturnOfError() *ReturnOfError {
	return __.ErrorReturn.Get().(*ReturnOfError)
}
func (__ *PoolOfUint8ThenErrorImpl) PutReturnOfError(p *ReturnOfError) {
	__.ErrorReturn.Put(p)
}

func (__ *PoolOfUint8ThenErrorImpl) GetChReturnOfError() chan *ReturnOfError {
	return __.ChReturnOfError.Get().(chan *ReturnOfError)
}
func (__ *PoolOfUint8ThenErrorImpl) PutChReturnOfError(p chan *ReturnOfError) {
	__.ChReturnOfError.Put(p)
}

func NewPoolOfUint8ThenErrorImpl() *PoolOfUint8ThenErrorImpl {
	return &PoolOfUint8ThenErrorImpl{
		Uint8Arg: sync.Pool{
			New: func() interface{} {
				return new(uint8)
			},
		},
		Uint8Work: sync.Pool{
			New: func() interface{} {
				return new(WorkOfUint8ThenError)
			},
		},
		ErrorRtn: sync.Pool{
			New: func() interface{} {
				return new(error)
			},
		},
		ErrorReturn: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfError)
			},
		},
		ChReturnOfError: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfError, 1)
			},
		},
	}
}

type ApiDecouplerOfUint8ThenError struct {
	pool PoolOfUint8ThenError
}

func NewApiDecouplerOfUint8ThenError() *ApiDecouplerOfUint8ThenError {
	return &ApiDecouplerOfUint8ThenError{
		pool: NewPoolOfUint8ThenErrorImpl(),
	}
}

func (__ *ApiDecouplerOfUint8ThenError) ReturnError(rtn_ch chan<- *ReturnOfError, err error) {
	rtn := __.pool.GetReturnOfError()
	var other error
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfUint8ThenError) HandleOfUint8ThenError(ctx context.Context, req *WorkOfUint8ThenError, h func(ctx context.Context, arg uint8) (error, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfError()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfUint8ThenError) DoOfUint8ThenError(ctx context.Context, worker WorkerOfPushUint8ThenError, arg uint8) (error, error) {
	// ch := make(chan *ReturnOfError, 1)
	ch := __.pool.GetChReturnOfError()
	defer __.pool.PutChReturnOfError(ch)

	req := __.pool.GetWorkOfUint8ThenError()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfUint8ThenError(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfError(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfUint8ThenError = func(ctx context.Context, arg uint8) (error, error)

type WorkerOfUint8ThenError struct {
	api_syncer *ApiDecouplerOfUint8ThenError
	handler    WorkHandlerOfUint8ThenError

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfUint8ThenError
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfUint8ThenError(ctx context.Context, h WorkHandlerOfUint8ThenError, n int) *WorkerOfUint8ThenError {
	__ := &WorkerOfUint8ThenError{
		api_syncer: NewApiDecouplerOfUint8ThenError(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfUint8ThenError, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfUint8ThenError{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfUint8ThenError(req.Context, req.WorkOfUint8ThenError, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfUint8ThenError) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfUint8ThenError) Push(ctx context.Context, req *WorkOfUint8ThenError) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfUint8ThenError)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfUint8ThenError = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfUint8ThenError) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfUint8ThenError) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfUint8ThenError) Call(ctx context.Context, arg uint8) (error, error) {
	return __.api_syncer.DoOfUint8ThenError(ctx, __, arg)
}

type PoolOfUint8ThenFloat32 interface {
	GetUint8Arg() *uint8
	PutUint8Arg(*uint8)
	GetFloat32Return() *float32
	PutFloat32Return(*float32)

	GetWorkOfUint8ThenFloat32() *WorkOfUint8ThenFloat32
	GetReturnOfFloat32() *ReturnOfFloat32
	PutWorkOfUint8ThenFloat32(*WorkOfUint8ThenFloat32)
	PutReturnOfFloat32(*ReturnOfFloat32)

	GetChReturnOfFloat32() chan *ReturnOfFloat32
	PutChReturnOfFloat32(chan *ReturnOfFloat32)
}

type PoolOfUint8ThenFloat32Impl struct {
	Uint8Arg          sync.Pool
	Float32Rtn        sync.Pool
	Uint8Work         sync.Pool
	Float32Return     sync.Pool
	ChReturnOfFloat32 sync.Pool
}

func (__ *PoolOfUint8ThenFloat32Impl) GetUint8Arg() *uint8 {
	return __.Uint8Arg.Get().(*uint8)
}
func (__ *PoolOfUint8ThenFloat32Impl) PutUint8Arg(p *uint8) {
	__.Uint8Arg.Put(p)
}
func (__ *PoolOfUint8ThenFloat32Impl) GetFloat32Return() *float32 {
	return __.Float32Rtn.Get().(*float32)
}
func (__ *PoolOfUint8ThenFloat32Impl) PutFloat32Return(p *float32) {
	__.Float32Rtn.Put(p)
}

func (__ *PoolOfUint8ThenFloat32Impl) GetWorkOfUint8ThenFloat32() *WorkOfUint8ThenFloat32 {
	return __.Uint8Work.Get().(*WorkOfUint8ThenFloat32)
}
func (__ *PoolOfUint8ThenFloat32Impl) PutWorkOfUint8ThenFloat32(p *WorkOfUint8ThenFloat32) {
	__.Uint8Work.Put(p)
}
func (__ *PoolOfUint8ThenFloat32Impl) GetReturnOfFloat32() *ReturnOfFloat32 {
	return __.Float32Return.Get().(*ReturnOfFloat32)
}
func (__ *PoolOfUint8ThenFloat32Impl) PutReturnOfFloat32(p *ReturnOfFloat32) {
	__.Float32Return.Put(p)
}

func (__ *PoolOfUint8ThenFloat32Impl) GetChReturnOfFloat32() chan *ReturnOfFloat32 {
	return __.ChReturnOfFloat32.Get().(chan *ReturnOfFloat32)
}
func (__ *PoolOfUint8ThenFloat32Impl) PutChReturnOfFloat32(p chan *ReturnOfFloat32) {
	__.ChReturnOfFloat32.Put(p)
}

func NewPoolOfUint8ThenFloat32Impl() *PoolOfUint8ThenFloat32Impl {
	return &PoolOfUint8ThenFloat32Impl{
		Uint8Arg: sync.Pool{
			New: func() interface{} {
				return new(uint8)
			},
		},
		Uint8Work: sync.Pool{
			New: func() interface{} {
				return new(WorkOfUint8ThenFloat32)
			},
		},
		Float32Rtn: sync.Pool{
			New: func() interface{} {
				return new(float32)
			},
		},
		Float32Return: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfFloat32)
			},
		},
		ChReturnOfFloat32: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfFloat32, 1)
			},
		},
	}
}

type ApiDecouplerOfUint8ThenFloat32 struct {
	pool PoolOfUint8ThenFloat32
}

func NewApiDecouplerOfUint8ThenFloat32() *ApiDecouplerOfUint8ThenFloat32 {
	return &ApiDecouplerOfUint8ThenFloat32{
		pool: NewPoolOfUint8ThenFloat32Impl(),
	}
}

func (__ *ApiDecouplerOfUint8ThenFloat32) ReturnError(rtn_ch chan<- *ReturnOfFloat32, err error) {
	rtn := __.pool.GetReturnOfFloat32()
	var other float32
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfUint8ThenFloat32) HandleOfUint8ThenFloat32(ctx context.Context, req *WorkOfUint8ThenFloat32, h func(ctx context.Context, arg uint8) (float32, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfFloat32()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfUint8ThenFloat32) DoOfUint8ThenFloat32(ctx context.Context, worker WorkerOfPushUint8ThenFloat32, arg uint8) (float32, error) {
	// ch := make(chan *ReturnOfFloat32, 1)
	ch := __.pool.GetChReturnOfFloat32()
	defer __.pool.PutChReturnOfFloat32(ch)

	req := __.pool.GetWorkOfUint8ThenFloat32()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfUint8ThenFloat32(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfFloat32(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfUint8ThenFloat32 = func(ctx context.Context, arg uint8) (float32, error)

type WorkerOfUint8ThenFloat32 struct {
	api_syncer *ApiDecouplerOfUint8ThenFloat32
	handler    WorkHandlerOfUint8ThenFloat32

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfUint8ThenFloat32
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfUint8ThenFloat32(ctx context.Context, h WorkHandlerOfUint8ThenFloat32, n int) *WorkerOfUint8ThenFloat32 {
	__ := &WorkerOfUint8ThenFloat32{
		api_syncer: NewApiDecouplerOfUint8ThenFloat32(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfUint8ThenFloat32, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfUint8ThenFloat32{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfUint8ThenFloat32(req.Context, req.WorkOfUint8ThenFloat32, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfUint8ThenFloat32) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfUint8ThenFloat32) Push(ctx context.Context, req *WorkOfUint8ThenFloat32) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfUint8ThenFloat32)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfUint8ThenFloat32 = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfUint8ThenFloat32) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfUint8ThenFloat32) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfUint8ThenFloat32) Call(ctx context.Context, arg uint8) (float32, error) {
	return __.api_syncer.DoOfUint8ThenFloat32(ctx, __, arg)
}

type PoolOfUint8ThenFloat64 interface {
	GetUint8Arg() *uint8
	PutUint8Arg(*uint8)
	GetFloat64Return() *float64
	PutFloat64Return(*float64)

	GetWorkOfUint8ThenFloat64() *WorkOfUint8ThenFloat64
	GetReturnOfFloat64() *ReturnOfFloat64
	PutWorkOfUint8ThenFloat64(*WorkOfUint8ThenFloat64)
	PutReturnOfFloat64(*ReturnOfFloat64)

	GetChReturnOfFloat64() chan *ReturnOfFloat64
	PutChReturnOfFloat64(chan *ReturnOfFloat64)
}

type PoolOfUint8ThenFloat64Impl struct {
	Uint8Arg          sync.Pool
	Float64Rtn        sync.Pool
	Uint8Work         sync.Pool
	Float64Return     sync.Pool
	ChReturnOfFloat64 sync.Pool
}

func (__ *PoolOfUint8ThenFloat64Impl) GetUint8Arg() *uint8 {
	return __.Uint8Arg.Get().(*uint8)
}
func (__ *PoolOfUint8ThenFloat64Impl) PutUint8Arg(p *uint8) {
	__.Uint8Arg.Put(p)
}
func (__ *PoolOfUint8ThenFloat64Impl) GetFloat64Return() *float64 {
	return __.Float64Rtn.Get().(*float64)
}
func (__ *PoolOfUint8ThenFloat64Impl) PutFloat64Return(p *float64) {
	__.Float64Rtn.Put(p)
}

func (__ *PoolOfUint8ThenFloat64Impl) GetWorkOfUint8ThenFloat64() *WorkOfUint8ThenFloat64 {
	return __.Uint8Work.Get().(*WorkOfUint8ThenFloat64)
}
func (__ *PoolOfUint8ThenFloat64Impl) PutWorkOfUint8ThenFloat64(p *WorkOfUint8ThenFloat64) {
	__.Uint8Work.Put(p)
}
func (__ *PoolOfUint8ThenFloat64Impl) GetReturnOfFloat64() *ReturnOfFloat64 {
	return __.Float64Return.Get().(*ReturnOfFloat64)
}
func (__ *PoolOfUint8ThenFloat64Impl) PutReturnOfFloat64(p *ReturnOfFloat64) {
	__.Float64Return.Put(p)
}

func (__ *PoolOfUint8ThenFloat64Impl) GetChReturnOfFloat64() chan *ReturnOfFloat64 {
	return __.ChReturnOfFloat64.Get().(chan *ReturnOfFloat64)
}
func (__ *PoolOfUint8ThenFloat64Impl) PutChReturnOfFloat64(p chan *ReturnOfFloat64) {
	__.ChReturnOfFloat64.Put(p)
}

func NewPoolOfUint8ThenFloat64Impl() *PoolOfUint8ThenFloat64Impl {
	return &PoolOfUint8ThenFloat64Impl{
		Uint8Arg: sync.Pool{
			New: func() interface{} {
				return new(uint8)
			},
		},
		Uint8Work: sync.Pool{
			New: func() interface{} {
				return new(WorkOfUint8ThenFloat64)
			},
		},
		Float64Rtn: sync.Pool{
			New: func() interface{} {
				return new(float64)
			},
		},
		Float64Return: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfFloat64)
			},
		},
		ChReturnOfFloat64: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfFloat64, 1)
			},
		},
	}
}

type ApiDecouplerOfUint8ThenFloat64 struct {
	pool PoolOfUint8ThenFloat64
}

func NewApiDecouplerOfUint8ThenFloat64() *ApiDecouplerOfUint8ThenFloat64 {
	return &ApiDecouplerOfUint8ThenFloat64{
		pool: NewPoolOfUint8ThenFloat64Impl(),
	}
}

func (__ *ApiDecouplerOfUint8ThenFloat64) ReturnError(rtn_ch chan<- *ReturnOfFloat64, err error) {
	rtn := __.pool.GetReturnOfFloat64()
	var other float64
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfUint8ThenFloat64) HandleOfUint8ThenFloat64(ctx context.Context, req *WorkOfUint8ThenFloat64, h func(ctx context.Context, arg uint8) (float64, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfFloat64()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfUint8ThenFloat64) DoOfUint8ThenFloat64(ctx context.Context, worker WorkerOfPushUint8ThenFloat64, arg uint8) (float64, error) {
	// ch := make(chan *ReturnOfFloat64, 1)
	ch := __.pool.GetChReturnOfFloat64()
	defer __.pool.PutChReturnOfFloat64(ch)

	req := __.pool.GetWorkOfUint8ThenFloat64()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfUint8ThenFloat64(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfFloat64(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfUint8ThenFloat64 = func(ctx context.Context, arg uint8) (float64, error)

type WorkerOfUint8ThenFloat64 struct {
	api_syncer *ApiDecouplerOfUint8ThenFloat64
	handler    WorkHandlerOfUint8ThenFloat64

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfUint8ThenFloat64
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfUint8ThenFloat64(ctx context.Context, h WorkHandlerOfUint8ThenFloat64, n int) *WorkerOfUint8ThenFloat64 {
	__ := &WorkerOfUint8ThenFloat64{
		api_syncer: NewApiDecouplerOfUint8ThenFloat64(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfUint8ThenFloat64, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfUint8ThenFloat64{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfUint8ThenFloat64(req.Context, req.WorkOfUint8ThenFloat64, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfUint8ThenFloat64) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfUint8ThenFloat64) Push(ctx context.Context, req *WorkOfUint8ThenFloat64) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfUint8ThenFloat64)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfUint8ThenFloat64 = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfUint8ThenFloat64) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfUint8ThenFloat64) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfUint8ThenFloat64) Call(ctx context.Context, arg uint8) (float64, error) {
	return __.api_syncer.DoOfUint8ThenFloat64(ctx, __, arg)
}

type PoolOfUint8ThenInt interface {
	GetUint8Arg() *uint8
	PutUint8Arg(*uint8)
	GetIntReturn() *int
	PutIntReturn(*int)

	GetWorkOfUint8ThenInt() *WorkOfUint8ThenInt
	GetReturnOfInt() *ReturnOfInt
	PutWorkOfUint8ThenInt(*WorkOfUint8ThenInt)
	PutReturnOfInt(*ReturnOfInt)

	GetChReturnOfInt() chan *ReturnOfInt
	PutChReturnOfInt(chan *ReturnOfInt)
}

type PoolOfUint8ThenIntImpl struct {
	Uint8Arg      sync.Pool
	IntRtn        sync.Pool
	Uint8Work     sync.Pool
	IntReturn     sync.Pool
	ChReturnOfInt sync.Pool
}

func (__ *PoolOfUint8ThenIntImpl) GetUint8Arg() *uint8 {
	return __.Uint8Arg.Get().(*uint8)
}
func (__ *PoolOfUint8ThenIntImpl) PutUint8Arg(p *uint8) {
	__.Uint8Arg.Put(p)
}
func (__ *PoolOfUint8ThenIntImpl) GetIntReturn() *int {
	return __.IntRtn.Get().(*int)
}
func (__ *PoolOfUint8ThenIntImpl) PutIntReturn(p *int) {
	__.IntRtn.Put(p)
}

func (__ *PoolOfUint8ThenIntImpl) GetWorkOfUint8ThenInt() *WorkOfUint8ThenInt {
	return __.Uint8Work.Get().(*WorkOfUint8ThenInt)
}
func (__ *PoolOfUint8ThenIntImpl) PutWorkOfUint8ThenInt(p *WorkOfUint8ThenInt) {
	__.Uint8Work.Put(p)
}
func (__ *PoolOfUint8ThenIntImpl) GetReturnOfInt() *ReturnOfInt {
	return __.IntReturn.Get().(*ReturnOfInt)
}
func (__ *PoolOfUint8ThenIntImpl) PutReturnOfInt(p *ReturnOfInt) {
	__.IntReturn.Put(p)
}

func (__ *PoolOfUint8ThenIntImpl) GetChReturnOfInt() chan *ReturnOfInt {
	return __.ChReturnOfInt.Get().(chan *ReturnOfInt)
}
func (__ *PoolOfUint8ThenIntImpl) PutChReturnOfInt(p chan *ReturnOfInt) {
	__.ChReturnOfInt.Put(p)
}

func NewPoolOfUint8ThenIntImpl() *PoolOfUint8ThenIntImpl {
	return &PoolOfUint8ThenIntImpl{
		Uint8Arg: sync.Pool{
			New: func() interface{} {
				return new(uint8)
			},
		},
		Uint8Work: sync.Pool{
			New: func() interface{} {
				return new(WorkOfUint8ThenInt)
			},
		},
		IntRtn: sync.Pool{
			New: func() interface{} {
				return new(int)
			},
		},
		IntReturn: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfInt)
			},
		},
		ChReturnOfInt: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfInt, 1)
			},
		},
	}
}

type ApiDecouplerOfUint8ThenInt struct {
	pool PoolOfUint8ThenInt
}

func NewApiDecouplerOfUint8ThenInt() *ApiDecouplerOfUint8ThenInt {
	return &ApiDecouplerOfUint8ThenInt{
		pool: NewPoolOfUint8ThenIntImpl(),
	}
}

func (__ *ApiDecouplerOfUint8ThenInt) ReturnError(rtn_ch chan<- *ReturnOfInt, err error) {
	rtn := __.pool.GetReturnOfInt()
	var other int
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfUint8ThenInt) HandleOfUint8ThenInt(ctx context.Context, req *WorkOfUint8ThenInt, h func(ctx context.Context, arg uint8) (int, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfInt()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfUint8ThenInt) DoOfUint8ThenInt(ctx context.Context, worker WorkerOfPushUint8ThenInt, arg uint8) (int, error) {
	// ch := make(chan *ReturnOfInt, 1)
	ch := __.pool.GetChReturnOfInt()
	defer __.pool.PutChReturnOfInt(ch)

	req := __.pool.GetWorkOfUint8ThenInt()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfUint8ThenInt(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfInt(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfUint8ThenInt = func(ctx context.Context, arg uint8) (int, error)

type WorkerOfUint8ThenInt struct {
	api_syncer *ApiDecouplerOfUint8ThenInt
	handler    WorkHandlerOfUint8ThenInt

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfUint8ThenInt
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfUint8ThenInt(ctx context.Context, h WorkHandlerOfUint8ThenInt, n int) *WorkerOfUint8ThenInt {
	__ := &WorkerOfUint8ThenInt{
		api_syncer: NewApiDecouplerOfUint8ThenInt(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfUint8ThenInt, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfUint8ThenInt{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfUint8ThenInt(req.Context, req.WorkOfUint8ThenInt, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfUint8ThenInt) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfUint8ThenInt) Push(ctx context.Context, req *WorkOfUint8ThenInt) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfUint8ThenInt)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfUint8ThenInt = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfUint8ThenInt) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfUint8ThenInt) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfUint8ThenInt) Call(ctx context.Context, arg uint8) (int, error) {
	return __.api_syncer.DoOfUint8ThenInt(ctx, __, arg)
}

type PoolOfUint8ThenInt16 interface {
	GetUint8Arg() *uint8
	PutUint8Arg(*uint8)
	GetInt16Return() *int16
	PutInt16Return(*int16)

	GetWorkOfUint8ThenInt16() *WorkOfUint8ThenInt16
	GetReturnOfInt16() *ReturnOfInt16
	PutWorkOfUint8ThenInt16(*WorkOfUint8ThenInt16)
	PutReturnOfInt16(*ReturnOfInt16)

	GetChReturnOfInt16() chan *ReturnOfInt16
	PutChReturnOfInt16(chan *ReturnOfInt16)
}

type PoolOfUint8ThenInt16Impl struct {
	Uint8Arg        sync.Pool
	Int16Rtn        sync.Pool
	Uint8Work       sync.Pool
	Int16Return     sync.Pool
	ChReturnOfInt16 sync.Pool
}

func (__ *PoolOfUint8ThenInt16Impl) GetUint8Arg() *uint8 {
	return __.Uint8Arg.Get().(*uint8)
}
func (__ *PoolOfUint8ThenInt16Impl) PutUint8Arg(p *uint8) {
	__.Uint8Arg.Put(p)
}
func (__ *PoolOfUint8ThenInt16Impl) GetInt16Return() *int16 {
	return __.Int16Rtn.Get().(*int16)
}
func (__ *PoolOfUint8ThenInt16Impl) PutInt16Return(p *int16) {
	__.Int16Rtn.Put(p)
}

func (__ *PoolOfUint8ThenInt16Impl) GetWorkOfUint8ThenInt16() *WorkOfUint8ThenInt16 {
	return __.Uint8Work.Get().(*WorkOfUint8ThenInt16)
}
func (__ *PoolOfUint8ThenInt16Impl) PutWorkOfUint8ThenInt16(p *WorkOfUint8ThenInt16) {
	__.Uint8Work.Put(p)
}
func (__ *PoolOfUint8ThenInt16Impl) GetReturnOfInt16() *ReturnOfInt16 {
	return __.Int16Return.Get().(*ReturnOfInt16)
}
func (__ *PoolOfUint8ThenInt16Impl) PutReturnOfInt16(p *ReturnOfInt16) {
	__.Int16Return.Put(p)
}

func (__ *PoolOfUint8ThenInt16Impl) GetChReturnOfInt16() chan *ReturnOfInt16 {
	return __.ChReturnOfInt16.Get().(chan *ReturnOfInt16)
}
func (__ *PoolOfUint8ThenInt16Impl) PutChReturnOfInt16(p chan *ReturnOfInt16) {
	__.ChReturnOfInt16.Put(p)
}

func NewPoolOfUint8ThenInt16Impl() *PoolOfUint8ThenInt16Impl {
	return &PoolOfUint8ThenInt16Impl{
		Uint8Arg: sync.Pool{
			New: func() interface{} {
				return new(uint8)
			},
		},
		Uint8Work: sync.Pool{
			New: func() interface{} {
				return new(WorkOfUint8ThenInt16)
			},
		},
		Int16Rtn: sync.Pool{
			New: func() interface{} {
				return new(int16)
			},
		},
		Int16Return: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfInt16)
			},
		},
		ChReturnOfInt16: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfInt16, 1)
			},
		},
	}
}

type ApiDecouplerOfUint8ThenInt16 struct {
	pool PoolOfUint8ThenInt16
}

func NewApiDecouplerOfUint8ThenInt16() *ApiDecouplerOfUint8ThenInt16 {
	return &ApiDecouplerOfUint8ThenInt16{
		pool: NewPoolOfUint8ThenInt16Impl(),
	}
}

func (__ *ApiDecouplerOfUint8ThenInt16) ReturnError(rtn_ch chan<- *ReturnOfInt16, err error) {
	rtn := __.pool.GetReturnOfInt16()
	var other int16
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfUint8ThenInt16) HandleOfUint8ThenInt16(ctx context.Context, req *WorkOfUint8ThenInt16, h func(ctx context.Context, arg uint8) (int16, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfInt16()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfUint8ThenInt16) DoOfUint8ThenInt16(ctx context.Context, worker WorkerOfPushUint8ThenInt16, arg uint8) (int16, error) {
	// ch := make(chan *ReturnOfInt16, 1)
	ch := __.pool.GetChReturnOfInt16()
	defer __.pool.PutChReturnOfInt16(ch)

	req := __.pool.GetWorkOfUint8ThenInt16()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfUint8ThenInt16(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfInt16(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfUint8ThenInt16 = func(ctx context.Context, arg uint8) (int16, error)

type WorkerOfUint8ThenInt16 struct {
	api_syncer *ApiDecouplerOfUint8ThenInt16
	handler    WorkHandlerOfUint8ThenInt16

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfUint8ThenInt16
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfUint8ThenInt16(ctx context.Context, h WorkHandlerOfUint8ThenInt16, n int) *WorkerOfUint8ThenInt16 {
	__ := &WorkerOfUint8ThenInt16{
		api_syncer: NewApiDecouplerOfUint8ThenInt16(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfUint8ThenInt16, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfUint8ThenInt16{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfUint8ThenInt16(req.Context, req.WorkOfUint8ThenInt16, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfUint8ThenInt16) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfUint8ThenInt16) Push(ctx context.Context, req *WorkOfUint8ThenInt16) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfUint8ThenInt16)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfUint8ThenInt16 = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfUint8ThenInt16) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfUint8ThenInt16) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfUint8ThenInt16) Call(ctx context.Context, arg uint8) (int16, error) {
	return __.api_syncer.DoOfUint8ThenInt16(ctx, __, arg)
}

type PoolOfUint8ThenInt32 interface {
	GetUint8Arg() *uint8
	PutUint8Arg(*uint8)
	GetInt32Return() *int32
	PutInt32Return(*int32)

	GetWorkOfUint8ThenInt32() *WorkOfUint8ThenInt32
	GetReturnOfInt32() *ReturnOfInt32
	PutWorkOfUint8ThenInt32(*WorkOfUint8ThenInt32)
	PutReturnOfInt32(*ReturnOfInt32)

	GetChReturnOfInt32() chan *ReturnOfInt32
	PutChReturnOfInt32(chan *ReturnOfInt32)
}

type PoolOfUint8ThenInt32Impl struct {
	Uint8Arg        sync.Pool
	Int32Rtn        sync.Pool
	Uint8Work       sync.Pool
	Int32Return     sync.Pool
	ChReturnOfInt32 sync.Pool
}

func (__ *PoolOfUint8ThenInt32Impl) GetUint8Arg() *uint8 {
	return __.Uint8Arg.Get().(*uint8)
}
func (__ *PoolOfUint8ThenInt32Impl) PutUint8Arg(p *uint8) {
	__.Uint8Arg.Put(p)
}
func (__ *PoolOfUint8ThenInt32Impl) GetInt32Return() *int32 {
	return __.Int32Rtn.Get().(*int32)
}
func (__ *PoolOfUint8ThenInt32Impl) PutInt32Return(p *int32) {
	__.Int32Rtn.Put(p)
}

func (__ *PoolOfUint8ThenInt32Impl) GetWorkOfUint8ThenInt32() *WorkOfUint8ThenInt32 {
	return __.Uint8Work.Get().(*WorkOfUint8ThenInt32)
}
func (__ *PoolOfUint8ThenInt32Impl) PutWorkOfUint8ThenInt32(p *WorkOfUint8ThenInt32) {
	__.Uint8Work.Put(p)
}
func (__ *PoolOfUint8ThenInt32Impl) GetReturnOfInt32() *ReturnOfInt32 {
	return __.Int32Return.Get().(*ReturnOfInt32)
}
func (__ *PoolOfUint8ThenInt32Impl) PutReturnOfInt32(p *ReturnOfInt32) {
	__.Int32Return.Put(p)
}

func (__ *PoolOfUint8ThenInt32Impl) GetChReturnOfInt32() chan *ReturnOfInt32 {
	return __.ChReturnOfInt32.Get().(chan *ReturnOfInt32)
}
func (__ *PoolOfUint8ThenInt32Impl) PutChReturnOfInt32(p chan *ReturnOfInt32) {
	__.ChReturnOfInt32.Put(p)
}

func NewPoolOfUint8ThenInt32Impl() *PoolOfUint8ThenInt32Impl {
	return &PoolOfUint8ThenInt32Impl{
		Uint8Arg: sync.Pool{
			New: func() interface{} {
				return new(uint8)
			},
		},
		Uint8Work: sync.Pool{
			New: func() interface{} {
				return new(WorkOfUint8ThenInt32)
			},
		},
		Int32Rtn: sync.Pool{
			New: func() interface{} {
				return new(int32)
			},
		},
		Int32Return: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfInt32)
			},
		},
		ChReturnOfInt32: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfInt32, 1)
			},
		},
	}
}

type ApiDecouplerOfUint8ThenInt32 struct {
	pool PoolOfUint8ThenInt32
}

func NewApiDecouplerOfUint8ThenInt32() *ApiDecouplerOfUint8ThenInt32 {
	return &ApiDecouplerOfUint8ThenInt32{
		pool: NewPoolOfUint8ThenInt32Impl(),
	}
}

func (__ *ApiDecouplerOfUint8ThenInt32) ReturnError(rtn_ch chan<- *ReturnOfInt32, err error) {
	rtn := __.pool.GetReturnOfInt32()
	var other int32
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfUint8ThenInt32) HandleOfUint8ThenInt32(ctx context.Context, req *WorkOfUint8ThenInt32, h func(ctx context.Context, arg uint8) (int32, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfInt32()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfUint8ThenInt32) DoOfUint8ThenInt32(ctx context.Context, worker WorkerOfPushUint8ThenInt32, arg uint8) (int32, error) {
	// ch := make(chan *ReturnOfInt32, 1)
	ch := __.pool.GetChReturnOfInt32()
	defer __.pool.PutChReturnOfInt32(ch)

	req := __.pool.GetWorkOfUint8ThenInt32()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfUint8ThenInt32(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfInt32(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfUint8ThenInt32 = func(ctx context.Context, arg uint8) (int32, error)

type WorkerOfUint8ThenInt32 struct {
	api_syncer *ApiDecouplerOfUint8ThenInt32
	handler    WorkHandlerOfUint8ThenInt32

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfUint8ThenInt32
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfUint8ThenInt32(ctx context.Context, h WorkHandlerOfUint8ThenInt32, n int) *WorkerOfUint8ThenInt32 {
	__ := &WorkerOfUint8ThenInt32{
		api_syncer: NewApiDecouplerOfUint8ThenInt32(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfUint8ThenInt32, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfUint8ThenInt32{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfUint8ThenInt32(req.Context, req.WorkOfUint8ThenInt32, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfUint8ThenInt32) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfUint8ThenInt32) Push(ctx context.Context, req *WorkOfUint8ThenInt32) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfUint8ThenInt32)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfUint8ThenInt32 = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfUint8ThenInt32) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfUint8ThenInt32) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfUint8ThenInt32) Call(ctx context.Context, arg uint8) (int32, error) {
	return __.api_syncer.DoOfUint8ThenInt32(ctx, __, arg)
}

type PoolOfUint8ThenInt64 interface {
	GetUint8Arg() *uint8
	PutUint8Arg(*uint8)
	GetInt64Return() *int64
	PutInt64Return(*int64)

	GetWorkOfUint8ThenInt64() *WorkOfUint8ThenInt64
	GetReturnOfInt64() *ReturnOfInt64
	PutWorkOfUint8ThenInt64(*WorkOfUint8ThenInt64)
	PutReturnOfInt64(*ReturnOfInt64)

	GetChReturnOfInt64() chan *ReturnOfInt64
	PutChReturnOfInt64(chan *ReturnOfInt64)
}

type PoolOfUint8ThenInt64Impl struct {
	Uint8Arg        sync.Pool
	Int64Rtn        sync.Pool
	Uint8Work       sync.Pool
	Int64Return     sync.Pool
	ChReturnOfInt64 sync.Pool
}

func (__ *PoolOfUint8ThenInt64Impl) GetUint8Arg() *uint8 {
	return __.Uint8Arg.Get().(*uint8)
}
func (__ *PoolOfUint8ThenInt64Impl) PutUint8Arg(p *uint8) {
	__.Uint8Arg.Put(p)
}
func (__ *PoolOfUint8ThenInt64Impl) GetInt64Return() *int64 {
	return __.Int64Rtn.Get().(*int64)
}
func (__ *PoolOfUint8ThenInt64Impl) PutInt64Return(p *int64) {
	__.Int64Rtn.Put(p)
}

func (__ *PoolOfUint8ThenInt64Impl) GetWorkOfUint8ThenInt64() *WorkOfUint8ThenInt64 {
	return __.Uint8Work.Get().(*WorkOfUint8ThenInt64)
}
func (__ *PoolOfUint8ThenInt64Impl) PutWorkOfUint8ThenInt64(p *WorkOfUint8ThenInt64) {
	__.Uint8Work.Put(p)
}
func (__ *PoolOfUint8ThenInt64Impl) GetReturnOfInt64() *ReturnOfInt64 {
	return __.Int64Return.Get().(*ReturnOfInt64)
}
func (__ *PoolOfUint8ThenInt64Impl) PutReturnOfInt64(p *ReturnOfInt64) {
	__.Int64Return.Put(p)
}

func (__ *PoolOfUint8ThenInt64Impl) GetChReturnOfInt64() chan *ReturnOfInt64 {
	return __.ChReturnOfInt64.Get().(chan *ReturnOfInt64)
}
func (__ *PoolOfUint8ThenInt64Impl) PutChReturnOfInt64(p chan *ReturnOfInt64) {
	__.ChReturnOfInt64.Put(p)
}

func NewPoolOfUint8ThenInt64Impl() *PoolOfUint8ThenInt64Impl {
	return &PoolOfUint8ThenInt64Impl{
		Uint8Arg: sync.Pool{
			New: func() interface{} {
				return new(uint8)
			},
		},
		Uint8Work: sync.Pool{
			New: func() interface{} {
				return new(WorkOfUint8ThenInt64)
			},
		},
		Int64Rtn: sync.Pool{
			New: func() interface{} {
				return new(int64)
			},
		},
		Int64Return: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfInt64)
			},
		},
		ChReturnOfInt64: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfInt64, 1)
			},
		},
	}
}

type ApiDecouplerOfUint8ThenInt64 struct {
	pool PoolOfUint8ThenInt64
}

func NewApiDecouplerOfUint8ThenInt64() *ApiDecouplerOfUint8ThenInt64 {
	return &ApiDecouplerOfUint8ThenInt64{
		pool: NewPoolOfUint8ThenInt64Impl(),
	}
}

func (__ *ApiDecouplerOfUint8ThenInt64) ReturnError(rtn_ch chan<- *ReturnOfInt64, err error) {
	rtn := __.pool.GetReturnOfInt64()
	var other int64
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfUint8ThenInt64) HandleOfUint8ThenInt64(ctx context.Context, req *WorkOfUint8ThenInt64, h func(ctx context.Context, arg uint8) (int64, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfInt64()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfUint8ThenInt64) DoOfUint8ThenInt64(ctx context.Context, worker WorkerOfPushUint8ThenInt64, arg uint8) (int64, error) {
	// ch := make(chan *ReturnOfInt64, 1)
	ch := __.pool.GetChReturnOfInt64()
	defer __.pool.PutChReturnOfInt64(ch)

	req := __.pool.GetWorkOfUint8ThenInt64()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfUint8ThenInt64(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfInt64(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfUint8ThenInt64 = func(ctx context.Context, arg uint8) (int64, error)

type WorkerOfUint8ThenInt64 struct {
	api_syncer *ApiDecouplerOfUint8ThenInt64
	handler    WorkHandlerOfUint8ThenInt64

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfUint8ThenInt64
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfUint8ThenInt64(ctx context.Context, h WorkHandlerOfUint8ThenInt64, n int) *WorkerOfUint8ThenInt64 {
	__ := &WorkerOfUint8ThenInt64{
		api_syncer: NewApiDecouplerOfUint8ThenInt64(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfUint8ThenInt64, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfUint8ThenInt64{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfUint8ThenInt64(req.Context, req.WorkOfUint8ThenInt64, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfUint8ThenInt64) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfUint8ThenInt64) Push(ctx context.Context, req *WorkOfUint8ThenInt64) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfUint8ThenInt64)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfUint8ThenInt64 = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfUint8ThenInt64) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfUint8ThenInt64) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfUint8ThenInt64) Call(ctx context.Context, arg uint8) (int64, error) {
	return __.api_syncer.DoOfUint8ThenInt64(ctx, __, arg)
}

type PoolOfUint8ThenInt8 interface {
	GetUint8Arg() *uint8
	PutUint8Arg(*uint8)
	GetInt8Return() *int8
	PutInt8Return(*int8)

	GetWorkOfUint8ThenInt8() *WorkOfUint8ThenInt8
	GetReturnOfInt8() *ReturnOfInt8
	PutWorkOfUint8ThenInt8(*WorkOfUint8ThenInt8)
	PutReturnOfInt8(*ReturnOfInt8)

	GetChReturnOfInt8() chan *ReturnOfInt8
	PutChReturnOfInt8(chan *ReturnOfInt8)
}

type PoolOfUint8ThenInt8Impl struct {
	Uint8Arg       sync.Pool
	Int8Rtn        sync.Pool
	Uint8Work      sync.Pool
	Int8Return     sync.Pool
	ChReturnOfInt8 sync.Pool
}

func (__ *PoolOfUint8ThenInt8Impl) GetUint8Arg() *uint8 {
	return __.Uint8Arg.Get().(*uint8)
}
func (__ *PoolOfUint8ThenInt8Impl) PutUint8Arg(p *uint8) {
	__.Uint8Arg.Put(p)
}
func (__ *PoolOfUint8ThenInt8Impl) GetInt8Return() *int8 {
	return __.Int8Rtn.Get().(*int8)
}
func (__ *PoolOfUint8ThenInt8Impl) PutInt8Return(p *int8) {
	__.Int8Rtn.Put(p)
}

func (__ *PoolOfUint8ThenInt8Impl) GetWorkOfUint8ThenInt8() *WorkOfUint8ThenInt8 {
	return __.Uint8Work.Get().(*WorkOfUint8ThenInt8)
}
func (__ *PoolOfUint8ThenInt8Impl) PutWorkOfUint8ThenInt8(p *WorkOfUint8ThenInt8) {
	__.Uint8Work.Put(p)
}
func (__ *PoolOfUint8ThenInt8Impl) GetReturnOfInt8() *ReturnOfInt8 {
	return __.Int8Return.Get().(*ReturnOfInt8)
}
func (__ *PoolOfUint8ThenInt8Impl) PutReturnOfInt8(p *ReturnOfInt8) {
	__.Int8Return.Put(p)
}

func (__ *PoolOfUint8ThenInt8Impl) GetChReturnOfInt8() chan *ReturnOfInt8 {
	return __.ChReturnOfInt8.Get().(chan *ReturnOfInt8)
}
func (__ *PoolOfUint8ThenInt8Impl) PutChReturnOfInt8(p chan *ReturnOfInt8) {
	__.ChReturnOfInt8.Put(p)
}

func NewPoolOfUint8ThenInt8Impl() *PoolOfUint8ThenInt8Impl {
	return &PoolOfUint8ThenInt8Impl{
		Uint8Arg: sync.Pool{
			New: func() interface{} {
				return new(uint8)
			},
		},
		Uint8Work: sync.Pool{
			New: func() interface{} {
				return new(WorkOfUint8ThenInt8)
			},
		},
		Int8Rtn: sync.Pool{
			New: func() interface{} {
				return new(int8)
			},
		},
		Int8Return: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfInt8)
			},
		},
		ChReturnOfInt8: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfInt8, 1)
			},
		},
	}
}

type ApiDecouplerOfUint8ThenInt8 struct {
	pool PoolOfUint8ThenInt8
}

func NewApiDecouplerOfUint8ThenInt8() *ApiDecouplerOfUint8ThenInt8 {
	return &ApiDecouplerOfUint8ThenInt8{
		pool: NewPoolOfUint8ThenInt8Impl(),
	}
}

func (__ *ApiDecouplerOfUint8ThenInt8) ReturnError(rtn_ch chan<- *ReturnOfInt8, err error) {
	rtn := __.pool.GetReturnOfInt8()
	var other int8
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfUint8ThenInt8) HandleOfUint8ThenInt8(ctx context.Context, req *WorkOfUint8ThenInt8, h func(ctx context.Context, arg uint8) (int8, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfInt8()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfUint8ThenInt8) DoOfUint8ThenInt8(ctx context.Context, worker WorkerOfPushUint8ThenInt8, arg uint8) (int8, error) {
	// ch := make(chan *ReturnOfInt8, 1)
	ch := __.pool.GetChReturnOfInt8()
	defer __.pool.PutChReturnOfInt8(ch)

	req := __.pool.GetWorkOfUint8ThenInt8()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfUint8ThenInt8(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfInt8(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfUint8ThenInt8 = func(ctx context.Context, arg uint8) (int8, error)

type WorkerOfUint8ThenInt8 struct {
	api_syncer *ApiDecouplerOfUint8ThenInt8
	handler    WorkHandlerOfUint8ThenInt8

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfUint8ThenInt8
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfUint8ThenInt8(ctx context.Context, h WorkHandlerOfUint8ThenInt8, n int) *WorkerOfUint8ThenInt8 {
	__ := &WorkerOfUint8ThenInt8{
		api_syncer: NewApiDecouplerOfUint8ThenInt8(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfUint8ThenInt8, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfUint8ThenInt8{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfUint8ThenInt8(req.Context, req.WorkOfUint8ThenInt8, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfUint8ThenInt8) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfUint8ThenInt8) Push(ctx context.Context, req *WorkOfUint8ThenInt8) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfUint8ThenInt8)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfUint8ThenInt8 = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfUint8ThenInt8) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfUint8ThenInt8) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfUint8ThenInt8) Call(ctx context.Context, arg uint8) (int8, error) {
	return __.api_syncer.DoOfUint8ThenInt8(ctx, __, arg)
}

type PoolOfUint8ThenRune interface {
	GetUint8Arg() *uint8
	PutUint8Arg(*uint8)
	GetRuneReturn() *rune
	PutRuneReturn(*rune)

	GetWorkOfUint8ThenRune() *WorkOfUint8ThenRune
	GetReturnOfRune() *ReturnOfRune
	PutWorkOfUint8ThenRune(*WorkOfUint8ThenRune)
	PutReturnOfRune(*ReturnOfRune)

	GetChReturnOfRune() chan *ReturnOfRune
	PutChReturnOfRune(chan *ReturnOfRune)
}

type PoolOfUint8ThenRuneImpl struct {
	Uint8Arg       sync.Pool
	RuneRtn        sync.Pool
	Uint8Work      sync.Pool
	RuneReturn     sync.Pool
	ChReturnOfRune sync.Pool
}

func (__ *PoolOfUint8ThenRuneImpl) GetUint8Arg() *uint8 {
	return __.Uint8Arg.Get().(*uint8)
}
func (__ *PoolOfUint8ThenRuneImpl) PutUint8Arg(p *uint8) {
	__.Uint8Arg.Put(p)
}
func (__ *PoolOfUint8ThenRuneImpl) GetRuneReturn() *rune {
	return __.RuneRtn.Get().(*rune)
}
func (__ *PoolOfUint8ThenRuneImpl) PutRuneReturn(p *rune) {
	__.RuneRtn.Put(p)
}

func (__ *PoolOfUint8ThenRuneImpl) GetWorkOfUint8ThenRune() *WorkOfUint8ThenRune {
	return __.Uint8Work.Get().(*WorkOfUint8ThenRune)
}
func (__ *PoolOfUint8ThenRuneImpl) PutWorkOfUint8ThenRune(p *WorkOfUint8ThenRune) {
	__.Uint8Work.Put(p)
}
func (__ *PoolOfUint8ThenRuneImpl) GetReturnOfRune() *ReturnOfRune {
	return __.RuneReturn.Get().(*ReturnOfRune)
}
func (__ *PoolOfUint8ThenRuneImpl) PutReturnOfRune(p *ReturnOfRune) {
	__.RuneReturn.Put(p)
}

func (__ *PoolOfUint8ThenRuneImpl) GetChReturnOfRune() chan *ReturnOfRune {
	return __.ChReturnOfRune.Get().(chan *ReturnOfRune)
}
func (__ *PoolOfUint8ThenRuneImpl) PutChReturnOfRune(p chan *ReturnOfRune) {
	__.ChReturnOfRune.Put(p)
}

func NewPoolOfUint8ThenRuneImpl() *PoolOfUint8ThenRuneImpl {
	return &PoolOfUint8ThenRuneImpl{
		Uint8Arg: sync.Pool{
			New: func() interface{} {
				return new(uint8)
			},
		},
		Uint8Work: sync.Pool{
			New: func() interface{} {
				return new(WorkOfUint8ThenRune)
			},
		},
		RuneRtn: sync.Pool{
			New: func() interface{} {
				return new(rune)
			},
		},
		RuneReturn: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfRune)
			},
		},
		ChReturnOfRune: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfRune, 1)
			},
		},
	}
}

type ApiDecouplerOfUint8ThenRune struct {
	pool PoolOfUint8ThenRune
}

func NewApiDecouplerOfUint8ThenRune() *ApiDecouplerOfUint8ThenRune {
	return &ApiDecouplerOfUint8ThenRune{
		pool: NewPoolOfUint8ThenRuneImpl(),
	}
}

func (__ *ApiDecouplerOfUint8ThenRune) ReturnError(rtn_ch chan<- *ReturnOfRune, err error) {
	rtn := __.pool.GetReturnOfRune()
	var other rune
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfUint8ThenRune) HandleOfUint8ThenRune(ctx context.Context, req *WorkOfUint8ThenRune, h func(ctx context.Context, arg uint8) (rune, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfRune()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfUint8ThenRune) DoOfUint8ThenRune(ctx context.Context, worker WorkerOfPushUint8ThenRune, arg uint8) (rune, error) {
	// ch := make(chan *ReturnOfRune, 1)
	ch := __.pool.GetChReturnOfRune()
	defer __.pool.PutChReturnOfRune(ch)

	req := __.pool.GetWorkOfUint8ThenRune()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfUint8ThenRune(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfRune(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfUint8ThenRune = func(ctx context.Context, arg uint8) (rune, error)

type WorkerOfUint8ThenRune struct {
	api_syncer *ApiDecouplerOfUint8ThenRune
	handler    WorkHandlerOfUint8ThenRune

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfUint8ThenRune
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfUint8ThenRune(ctx context.Context, h WorkHandlerOfUint8ThenRune, n int) *WorkerOfUint8ThenRune {
	__ := &WorkerOfUint8ThenRune{
		api_syncer: NewApiDecouplerOfUint8ThenRune(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfUint8ThenRune, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfUint8ThenRune{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfUint8ThenRune(req.Context, req.WorkOfUint8ThenRune, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfUint8ThenRune) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfUint8ThenRune) Push(ctx context.Context, req *WorkOfUint8ThenRune) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfUint8ThenRune)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfUint8ThenRune = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfUint8ThenRune) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfUint8ThenRune) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfUint8ThenRune) Call(ctx context.Context, arg uint8) (rune, error) {
	return __.api_syncer.DoOfUint8ThenRune(ctx, __, arg)
}

type PoolOfUint8ThenString interface {
	GetUint8Arg() *uint8
	PutUint8Arg(*uint8)
	GetStringReturn() *string
	PutStringReturn(*string)

	GetWorkOfUint8ThenString() *WorkOfUint8ThenString
	GetReturnOfString() *ReturnOfString
	PutWorkOfUint8ThenString(*WorkOfUint8ThenString)
	PutReturnOfString(*ReturnOfString)

	GetChReturnOfString() chan *ReturnOfString
	PutChReturnOfString(chan *ReturnOfString)
}

type PoolOfUint8ThenStringImpl struct {
	Uint8Arg         sync.Pool
	StringRtn        sync.Pool
	Uint8Work        sync.Pool
	StringReturn     sync.Pool
	ChReturnOfString sync.Pool
}

func (__ *PoolOfUint8ThenStringImpl) GetUint8Arg() *uint8 {
	return __.Uint8Arg.Get().(*uint8)
}
func (__ *PoolOfUint8ThenStringImpl) PutUint8Arg(p *uint8) {
	__.Uint8Arg.Put(p)
}
func (__ *PoolOfUint8ThenStringImpl) GetStringReturn() *string {
	return __.StringRtn.Get().(*string)
}
func (__ *PoolOfUint8ThenStringImpl) PutStringReturn(p *string) {
	__.StringRtn.Put(p)
}

func (__ *PoolOfUint8ThenStringImpl) GetWorkOfUint8ThenString() *WorkOfUint8ThenString {
	return __.Uint8Work.Get().(*WorkOfUint8ThenString)
}
func (__ *PoolOfUint8ThenStringImpl) PutWorkOfUint8ThenString(p *WorkOfUint8ThenString) {
	__.Uint8Work.Put(p)
}
func (__ *PoolOfUint8ThenStringImpl) GetReturnOfString() *ReturnOfString {
	return __.StringReturn.Get().(*ReturnOfString)
}
func (__ *PoolOfUint8ThenStringImpl) PutReturnOfString(p *ReturnOfString) {
	__.StringReturn.Put(p)
}

func (__ *PoolOfUint8ThenStringImpl) GetChReturnOfString() chan *ReturnOfString {
	return __.ChReturnOfString.Get().(chan *ReturnOfString)
}
func (__ *PoolOfUint8ThenStringImpl) PutChReturnOfString(p chan *ReturnOfString) {
	__.ChReturnOfString.Put(p)
}

func NewPoolOfUint8ThenStringImpl() *PoolOfUint8ThenStringImpl {
	return &PoolOfUint8ThenStringImpl{
		Uint8Arg: sync.Pool{
			New: func() interface{} {
				return new(uint8)
			},
		},
		Uint8Work: sync.Pool{
			New: func() interface{} {
				return new(WorkOfUint8ThenString)
			},
		},
		StringRtn: sync.Pool{
			New: func() interface{} {
				return new(string)
			},
		},
		StringReturn: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfString)
			},
		},
		ChReturnOfString: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfString, 1)
			},
		},
	}
}

type ApiDecouplerOfUint8ThenString struct {
	pool PoolOfUint8ThenString
}

func NewApiDecouplerOfUint8ThenString() *ApiDecouplerOfUint8ThenString {
	return &ApiDecouplerOfUint8ThenString{
		pool: NewPoolOfUint8ThenStringImpl(),
	}
}

func (__ *ApiDecouplerOfUint8ThenString) ReturnError(rtn_ch chan<- *ReturnOfString, err error) {
	rtn := __.pool.GetReturnOfString()
	var other string
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfUint8ThenString) HandleOfUint8ThenString(ctx context.Context, req *WorkOfUint8ThenString, h func(ctx context.Context, arg uint8) (string, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfString()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfUint8ThenString) DoOfUint8ThenString(ctx context.Context, worker WorkerOfPushUint8ThenString, arg uint8) (string, error) {
	// ch := make(chan *ReturnOfString, 1)
	ch := __.pool.GetChReturnOfString()
	defer __.pool.PutChReturnOfString(ch)

	req := __.pool.GetWorkOfUint8ThenString()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfUint8ThenString(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfString(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfUint8ThenString = func(ctx context.Context, arg uint8) (string, error)

type WorkerOfUint8ThenString struct {
	api_syncer *ApiDecouplerOfUint8ThenString
	handler    WorkHandlerOfUint8ThenString

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfUint8ThenString
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfUint8ThenString(ctx context.Context, h WorkHandlerOfUint8ThenString, n int) *WorkerOfUint8ThenString {
	__ := &WorkerOfUint8ThenString{
		api_syncer: NewApiDecouplerOfUint8ThenString(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfUint8ThenString, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfUint8ThenString{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfUint8ThenString(req.Context, req.WorkOfUint8ThenString, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfUint8ThenString) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfUint8ThenString) Push(ctx context.Context, req *WorkOfUint8ThenString) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfUint8ThenString)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfUint8ThenString = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfUint8ThenString) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfUint8ThenString) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfUint8ThenString) Call(ctx context.Context, arg uint8) (string, error) {
	return __.api_syncer.DoOfUint8ThenString(ctx, __, arg)
}

type PoolOfUint8ThenUint interface {
	GetUint8Arg() *uint8
	PutUint8Arg(*uint8)
	GetUintReturn() *uint
	PutUintReturn(*uint)

	GetWorkOfUint8ThenUint() *WorkOfUint8ThenUint
	GetReturnOfUint() *ReturnOfUint
	PutWorkOfUint8ThenUint(*WorkOfUint8ThenUint)
	PutReturnOfUint(*ReturnOfUint)

	GetChReturnOfUint() chan *ReturnOfUint
	PutChReturnOfUint(chan *ReturnOfUint)
}

type PoolOfUint8ThenUintImpl struct {
	Uint8Arg       sync.Pool
	UintRtn        sync.Pool
	Uint8Work      sync.Pool
	UintReturn     sync.Pool
	ChReturnOfUint sync.Pool
}

func (__ *PoolOfUint8ThenUintImpl) GetUint8Arg() *uint8 {
	return __.Uint8Arg.Get().(*uint8)
}
func (__ *PoolOfUint8ThenUintImpl) PutUint8Arg(p *uint8) {
	__.Uint8Arg.Put(p)
}
func (__ *PoolOfUint8ThenUintImpl) GetUintReturn() *uint {
	return __.UintRtn.Get().(*uint)
}
func (__ *PoolOfUint8ThenUintImpl) PutUintReturn(p *uint) {
	__.UintRtn.Put(p)
}

func (__ *PoolOfUint8ThenUintImpl) GetWorkOfUint8ThenUint() *WorkOfUint8ThenUint {
	return __.Uint8Work.Get().(*WorkOfUint8ThenUint)
}
func (__ *PoolOfUint8ThenUintImpl) PutWorkOfUint8ThenUint(p *WorkOfUint8ThenUint) {
	__.Uint8Work.Put(p)
}
func (__ *PoolOfUint8ThenUintImpl) GetReturnOfUint() *ReturnOfUint {
	return __.UintReturn.Get().(*ReturnOfUint)
}
func (__ *PoolOfUint8ThenUintImpl) PutReturnOfUint(p *ReturnOfUint) {
	__.UintReturn.Put(p)
}

func (__ *PoolOfUint8ThenUintImpl) GetChReturnOfUint() chan *ReturnOfUint {
	return __.ChReturnOfUint.Get().(chan *ReturnOfUint)
}
func (__ *PoolOfUint8ThenUintImpl) PutChReturnOfUint(p chan *ReturnOfUint) {
	__.ChReturnOfUint.Put(p)
}

func NewPoolOfUint8ThenUintImpl() *PoolOfUint8ThenUintImpl {
	return &PoolOfUint8ThenUintImpl{
		Uint8Arg: sync.Pool{
			New: func() interface{} {
				return new(uint8)
			},
		},
		Uint8Work: sync.Pool{
			New: func() interface{} {
				return new(WorkOfUint8ThenUint)
			},
		},
		UintRtn: sync.Pool{
			New: func() interface{} {
				return new(uint)
			},
		},
		UintReturn: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfUint)
			},
		},
		ChReturnOfUint: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfUint, 1)
			},
		},
	}
}

type ApiDecouplerOfUint8ThenUint struct {
	pool PoolOfUint8ThenUint
}

func NewApiDecouplerOfUint8ThenUint() *ApiDecouplerOfUint8ThenUint {
	return &ApiDecouplerOfUint8ThenUint{
		pool: NewPoolOfUint8ThenUintImpl(),
	}
}

func (__ *ApiDecouplerOfUint8ThenUint) ReturnError(rtn_ch chan<- *ReturnOfUint, err error) {
	rtn := __.pool.GetReturnOfUint()
	var other uint
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfUint8ThenUint) HandleOfUint8ThenUint(ctx context.Context, req *WorkOfUint8ThenUint, h func(ctx context.Context, arg uint8) (uint, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfUint()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfUint8ThenUint) DoOfUint8ThenUint(ctx context.Context, worker WorkerOfPushUint8ThenUint, arg uint8) (uint, error) {
	// ch := make(chan *ReturnOfUint, 1)
	ch := __.pool.GetChReturnOfUint()
	defer __.pool.PutChReturnOfUint(ch)

	req := __.pool.GetWorkOfUint8ThenUint()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfUint8ThenUint(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfUint(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfUint8ThenUint = func(ctx context.Context, arg uint8) (uint, error)

type WorkerOfUint8ThenUint struct {
	api_syncer *ApiDecouplerOfUint8ThenUint
	handler    WorkHandlerOfUint8ThenUint

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfUint8ThenUint
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfUint8ThenUint(ctx context.Context, h WorkHandlerOfUint8ThenUint, n int) *WorkerOfUint8ThenUint {
	__ := &WorkerOfUint8ThenUint{
		api_syncer: NewApiDecouplerOfUint8ThenUint(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfUint8ThenUint, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfUint8ThenUint{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfUint8ThenUint(req.Context, req.WorkOfUint8ThenUint, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfUint8ThenUint) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfUint8ThenUint) Push(ctx context.Context, req *WorkOfUint8ThenUint) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfUint8ThenUint)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfUint8ThenUint = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfUint8ThenUint) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfUint8ThenUint) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfUint8ThenUint) Call(ctx context.Context, arg uint8) (uint, error) {
	return __.api_syncer.DoOfUint8ThenUint(ctx, __, arg)
}

type PoolOfUint8ThenUint16 interface {
	GetUint8Arg() *uint8
	PutUint8Arg(*uint8)
	GetUint16Return() *uint16
	PutUint16Return(*uint16)

	GetWorkOfUint8ThenUint16() *WorkOfUint8ThenUint16
	GetReturnOfUint16() *ReturnOfUint16
	PutWorkOfUint8ThenUint16(*WorkOfUint8ThenUint16)
	PutReturnOfUint16(*ReturnOfUint16)

	GetChReturnOfUint16() chan *ReturnOfUint16
	PutChReturnOfUint16(chan *ReturnOfUint16)
}

type PoolOfUint8ThenUint16Impl struct {
	Uint8Arg         sync.Pool
	Uint16Rtn        sync.Pool
	Uint8Work        sync.Pool
	Uint16Return     sync.Pool
	ChReturnOfUint16 sync.Pool
}

func (__ *PoolOfUint8ThenUint16Impl) GetUint8Arg() *uint8 {
	return __.Uint8Arg.Get().(*uint8)
}
func (__ *PoolOfUint8ThenUint16Impl) PutUint8Arg(p *uint8) {
	__.Uint8Arg.Put(p)
}
func (__ *PoolOfUint8ThenUint16Impl) GetUint16Return() *uint16 {
	return __.Uint16Rtn.Get().(*uint16)
}
func (__ *PoolOfUint8ThenUint16Impl) PutUint16Return(p *uint16) {
	__.Uint16Rtn.Put(p)
}

func (__ *PoolOfUint8ThenUint16Impl) GetWorkOfUint8ThenUint16() *WorkOfUint8ThenUint16 {
	return __.Uint8Work.Get().(*WorkOfUint8ThenUint16)
}
func (__ *PoolOfUint8ThenUint16Impl) PutWorkOfUint8ThenUint16(p *WorkOfUint8ThenUint16) {
	__.Uint8Work.Put(p)
}
func (__ *PoolOfUint8ThenUint16Impl) GetReturnOfUint16() *ReturnOfUint16 {
	return __.Uint16Return.Get().(*ReturnOfUint16)
}
func (__ *PoolOfUint8ThenUint16Impl) PutReturnOfUint16(p *ReturnOfUint16) {
	__.Uint16Return.Put(p)
}

func (__ *PoolOfUint8ThenUint16Impl) GetChReturnOfUint16() chan *ReturnOfUint16 {
	return __.ChReturnOfUint16.Get().(chan *ReturnOfUint16)
}
func (__ *PoolOfUint8ThenUint16Impl) PutChReturnOfUint16(p chan *ReturnOfUint16) {
	__.ChReturnOfUint16.Put(p)
}

func NewPoolOfUint8ThenUint16Impl() *PoolOfUint8ThenUint16Impl {
	return &PoolOfUint8ThenUint16Impl{
		Uint8Arg: sync.Pool{
			New: func() interface{} {
				return new(uint8)
			},
		},
		Uint8Work: sync.Pool{
			New: func() interface{} {
				return new(WorkOfUint8ThenUint16)
			},
		},
		Uint16Rtn: sync.Pool{
			New: func() interface{} {
				return new(uint16)
			},
		},
		Uint16Return: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfUint16)
			},
		},
		ChReturnOfUint16: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfUint16, 1)
			},
		},
	}
}

type ApiDecouplerOfUint8ThenUint16 struct {
	pool PoolOfUint8ThenUint16
}

func NewApiDecouplerOfUint8ThenUint16() *ApiDecouplerOfUint8ThenUint16 {
	return &ApiDecouplerOfUint8ThenUint16{
		pool: NewPoolOfUint8ThenUint16Impl(),
	}
}

func (__ *ApiDecouplerOfUint8ThenUint16) ReturnError(rtn_ch chan<- *ReturnOfUint16, err error) {
	rtn := __.pool.GetReturnOfUint16()
	var other uint16
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfUint8ThenUint16) HandleOfUint8ThenUint16(ctx context.Context, req *WorkOfUint8ThenUint16, h func(ctx context.Context, arg uint8) (uint16, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfUint16()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfUint8ThenUint16) DoOfUint8ThenUint16(ctx context.Context, worker WorkerOfPushUint8ThenUint16, arg uint8) (uint16, error) {
	// ch := make(chan *ReturnOfUint16, 1)
	ch := __.pool.GetChReturnOfUint16()
	defer __.pool.PutChReturnOfUint16(ch)

	req := __.pool.GetWorkOfUint8ThenUint16()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfUint8ThenUint16(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfUint16(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfUint8ThenUint16 = func(ctx context.Context, arg uint8) (uint16, error)

type WorkerOfUint8ThenUint16 struct {
	api_syncer *ApiDecouplerOfUint8ThenUint16
	handler    WorkHandlerOfUint8ThenUint16

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfUint8ThenUint16
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfUint8ThenUint16(ctx context.Context, h WorkHandlerOfUint8ThenUint16, n int) *WorkerOfUint8ThenUint16 {
	__ := &WorkerOfUint8ThenUint16{
		api_syncer: NewApiDecouplerOfUint8ThenUint16(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfUint8ThenUint16, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfUint8ThenUint16{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfUint8ThenUint16(req.Context, req.WorkOfUint8ThenUint16, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfUint8ThenUint16) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfUint8ThenUint16) Push(ctx context.Context, req *WorkOfUint8ThenUint16) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfUint8ThenUint16)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfUint8ThenUint16 = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfUint8ThenUint16) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfUint8ThenUint16) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfUint8ThenUint16) Call(ctx context.Context, arg uint8) (uint16, error) {
	return __.api_syncer.DoOfUint8ThenUint16(ctx, __, arg)
}

type PoolOfUint8ThenUint32 interface {
	GetUint8Arg() *uint8
	PutUint8Arg(*uint8)
	GetUint32Return() *uint32
	PutUint32Return(*uint32)

	GetWorkOfUint8ThenUint32() *WorkOfUint8ThenUint32
	GetReturnOfUint32() *ReturnOfUint32
	PutWorkOfUint8ThenUint32(*WorkOfUint8ThenUint32)
	PutReturnOfUint32(*ReturnOfUint32)

	GetChReturnOfUint32() chan *ReturnOfUint32
	PutChReturnOfUint32(chan *ReturnOfUint32)
}

type PoolOfUint8ThenUint32Impl struct {
	Uint8Arg         sync.Pool
	Uint32Rtn        sync.Pool
	Uint8Work        sync.Pool
	Uint32Return     sync.Pool
	ChReturnOfUint32 sync.Pool
}

func (__ *PoolOfUint8ThenUint32Impl) GetUint8Arg() *uint8 {
	return __.Uint8Arg.Get().(*uint8)
}
func (__ *PoolOfUint8ThenUint32Impl) PutUint8Arg(p *uint8) {
	__.Uint8Arg.Put(p)
}
func (__ *PoolOfUint8ThenUint32Impl) GetUint32Return() *uint32 {
	return __.Uint32Rtn.Get().(*uint32)
}
func (__ *PoolOfUint8ThenUint32Impl) PutUint32Return(p *uint32) {
	__.Uint32Rtn.Put(p)
}

func (__ *PoolOfUint8ThenUint32Impl) GetWorkOfUint8ThenUint32() *WorkOfUint8ThenUint32 {
	return __.Uint8Work.Get().(*WorkOfUint8ThenUint32)
}
func (__ *PoolOfUint8ThenUint32Impl) PutWorkOfUint8ThenUint32(p *WorkOfUint8ThenUint32) {
	__.Uint8Work.Put(p)
}
func (__ *PoolOfUint8ThenUint32Impl) GetReturnOfUint32() *ReturnOfUint32 {
	return __.Uint32Return.Get().(*ReturnOfUint32)
}
func (__ *PoolOfUint8ThenUint32Impl) PutReturnOfUint32(p *ReturnOfUint32) {
	__.Uint32Return.Put(p)
}

func (__ *PoolOfUint8ThenUint32Impl) GetChReturnOfUint32() chan *ReturnOfUint32 {
	return __.ChReturnOfUint32.Get().(chan *ReturnOfUint32)
}
func (__ *PoolOfUint8ThenUint32Impl) PutChReturnOfUint32(p chan *ReturnOfUint32) {
	__.ChReturnOfUint32.Put(p)
}

func NewPoolOfUint8ThenUint32Impl() *PoolOfUint8ThenUint32Impl {
	return &PoolOfUint8ThenUint32Impl{
		Uint8Arg: sync.Pool{
			New: func() interface{} {
				return new(uint8)
			},
		},
		Uint8Work: sync.Pool{
			New: func() interface{} {
				return new(WorkOfUint8ThenUint32)
			},
		},
		Uint32Rtn: sync.Pool{
			New: func() interface{} {
				return new(uint32)
			},
		},
		Uint32Return: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfUint32)
			},
		},
		ChReturnOfUint32: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfUint32, 1)
			},
		},
	}
}

type ApiDecouplerOfUint8ThenUint32 struct {
	pool PoolOfUint8ThenUint32
}

func NewApiDecouplerOfUint8ThenUint32() *ApiDecouplerOfUint8ThenUint32 {
	return &ApiDecouplerOfUint8ThenUint32{
		pool: NewPoolOfUint8ThenUint32Impl(),
	}
}

func (__ *ApiDecouplerOfUint8ThenUint32) ReturnError(rtn_ch chan<- *ReturnOfUint32, err error) {
	rtn := __.pool.GetReturnOfUint32()
	var other uint32
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfUint8ThenUint32) HandleOfUint8ThenUint32(ctx context.Context, req *WorkOfUint8ThenUint32, h func(ctx context.Context, arg uint8) (uint32, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfUint32()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfUint8ThenUint32) DoOfUint8ThenUint32(ctx context.Context, worker WorkerOfPushUint8ThenUint32, arg uint8) (uint32, error) {
	// ch := make(chan *ReturnOfUint32, 1)
	ch := __.pool.GetChReturnOfUint32()
	defer __.pool.PutChReturnOfUint32(ch)

	req := __.pool.GetWorkOfUint8ThenUint32()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfUint8ThenUint32(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfUint32(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfUint8ThenUint32 = func(ctx context.Context, arg uint8) (uint32, error)

type WorkerOfUint8ThenUint32 struct {
	api_syncer *ApiDecouplerOfUint8ThenUint32
	handler    WorkHandlerOfUint8ThenUint32

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfUint8ThenUint32
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfUint8ThenUint32(ctx context.Context, h WorkHandlerOfUint8ThenUint32, n int) *WorkerOfUint8ThenUint32 {
	__ := &WorkerOfUint8ThenUint32{
		api_syncer: NewApiDecouplerOfUint8ThenUint32(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfUint8ThenUint32, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfUint8ThenUint32{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfUint8ThenUint32(req.Context, req.WorkOfUint8ThenUint32, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfUint8ThenUint32) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfUint8ThenUint32) Push(ctx context.Context, req *WorkOfUint8ThenUint32) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfUint8ThenUint32)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfUint8ThenUint32 = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfUint8ThenUint32) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfUint8ThenUint32) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfUint8ThenUint32) Call(ctx context.Context, arg uint8) (uint32, error) {
	return __.api_syncer.DoOfUint8ThenUint32(ctx, __, arg)
}

type PoolOfUint8ThenUint64 interface {
	GetUint8Arg() *uint8
	PutUint8Arg(*uint8)
	GetUint64Return() *uint64
	PutUint64Return(*uint64)

	GetWorkOfUint8ThenUint64() *WorkOfUint8ThenUint64
	GetReturnOfUint64() *ReturnOfUint64
	PutWorkOfUint8ThenUint64(*WorkOfUint8ThenUint64)
	PutReturnOfUint64(*ReturnOfUint64)

	GetChReturnOfUint64() chan *ReturnOfUint64
	PutChReturnOfUint64(chan *ReturnOfUint64)
}

type PoolOfUint8ThenUint64Impl struct {
	Uint8Arg         sync.Pool
	Uint64Rtn        sync.Pool
	Uint8Work        sync.Pool
	Uint64Return     sync.Pool
	ChReturnOfUint64 sync.Pool
}

func (__ *PoolOfUint8ThenUint64Impl) GetUint8Arg() *uint8 {
	return __.Uint8Arg.Get().(*uint8)
}
func (__ *PoolOfUint8ThenUint64Impl) PutUint8Arg(p *uint8) {
	__.Uint8Arg.Put(p)
}
func (__ *PoolOfUint8ThenUint64Impl) GetUint64Return() *uint64 {
	return __.Uint64Rtn.Get().(*uint64)
}
func (__ *PoolOfUint8ThenUint64Impl) PutUint64Return(p *uint64) {
	__.Uint64Rtn.Put(p)
}

func (__ *PoolOfUint8ThenUint64Impl) GetWorkOfUint8ThenUint64() *WorkOfUint8ThenUint64 {
	return __.Uint8Work.Get().(*WorkOfUint8ThenUint64)
}
func (__ *PoolOfUint8ThenUint64Impl) PutWorkOfUint8ThenUint64(p *WorkOfUint8ThenUint64) {
	__.Uint8Work.Put(p)
}
func (__ *PoolOfUint8ThenUint64Impl) GetReturnOfUint64() *ReturnOfUint64 {
	return __.Uint64Return.Get().(*ReturnOfUint64)
}
func (__ *PoolOfUint8ThenUint64Impl) PutReturnOfUint64(p *ReturnOfUint64) {
	__.Uint64Return.Put(p)
}

func (__ *PoolOfUint8ThenUint64Impl) GetChReturnOfUint64() chan *ReturnOfUint64 {
	return __.ChReturnOfUint64.Get().(chan *ReturnOfUint64)
}
func (__ *PoolOfUint8ThenUint64Impl) PutChReturnOfUint64(p chan *ReturnOfUint64) {
	__.ChReturnOfUint64.Put(p)
}

func NewPoolOfUint8ThenUint64Impl() *PoolOfUint8ThenUint64Impl {
	return &PoolOfUint8ThenUint64Impl{
		Uint8Arg: sync.Pool{
			New: func() interface{} {
				return new(uint8)
			},
		},
		Uint8Work: sync.Pool{
			New: func() interface{} {
				return new(WorkOfUint8ThenUint64)
			},
		},
		Uint64Rtn: sync.Pool{
			New: func() interface{} {
				return new(uint64)
			},
		},
		Uint64Return: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfUint64)
			},
		},
		ChReturnOfUint64: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfUint64, 1)
			},
		},
	}
}

type ApiDecouplerOfUint8ThenUint64 struct {
	pool PoolOfUint8ThenUint64
}

func NewApiDecouplerOfUint8ThenUint64() *ApiDecouplerOfUint8ThenUint64 {
	return &ApiDecouplerOfUint8ThenUint64{
		pool: NewPoolOfUint8ThenUint64Impl(),
	}
}

func (__ *ApiDecouplerOfUint8ThenUint64) ReturnError(rtn_ch chan<- *ReturnOfUint64, err error) {
	rtn := __.pool.GetReturnOfUint64()
	var other uint64
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfUint8ThenUint64) HandleOfUint8ThenUint64(ctx context.Context, req *WorkOfUint8ThenUint64, h func(ctx context.Context, arg uint8) (uint64, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfUint64()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfUint8ThenUint64) DoOfUint8ThenUint64(ctx context.Context, worker WorkerOfPushUint8ThenUint64, arg uint8) (uint64, error) {
	// ch := make(chan *ReturnOfUint64, 1)
	ch := __.pool.GetChReturnOfUint64()
	defer __.pool.PutChReturnOfUint64(ch)

	req := __.pool.GetWorkOfUint8ThenUint64()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfUint8ThenUint64(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfUint64(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfUint8ThenUint64 = func(ctx context.Context, arg uint8) (uint64, error)

type WorkerOfUint8ThenUint64 struct {
	api_syncer *ApiDecouplerOfUint8ThenUint64
	handler    WorkHandlerOfUint8ThenUint64

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfUint8ThenUint64
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfUint8ThenUint64(ctx context.Context, h WorkHandlerOfUint8ThenUint64, n int) *WorkerOfUint8ThenUint64 {
	__ := &WorkerOfUint8ThenUint64{
		api_syncer: NewApiDecouplerOfUint8ThenUint64(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfUint8ThenUint64, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfUint8ThenUint64{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfUint8ThenUint64(req.Context, req.WorkOfUint8ThenUint64, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfUint8ThenUint64) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfUint8ThenUint64) Push(ctx context.Context, req *WorkOfUint8ThenUint64) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfUint8ThenUint64)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfUint8ThenUint64 = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfUint8ThenUint64) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfUint8ThenUint64) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfUint8ThenUint64) Call(ctx context.Context, arg uint8) (uint64, error) {
	return __.api_syncer.DoOfUint8ThenUint64(ctx, __, arg)
}

type PoolOfUint8ThenUint8 interface {
	GetUint8Arg() *uint8
	PutUint8Arg(*uint8)
	GetUint8Return() *uint8
	PutUint8Return(*uint8)

	GetWorkOfUint8ThenUint8() *WorkOfUint8ThenUint8
	GetReturnOfUint8() *ReturnOfUint8
	PutWorkOfUint8ThenUint8(*WorkOfUint8ThenUint8)
	PutReturnOfUint8(*ReturnOfUint8)

	GetChReturnOfUint8() chan *ReturnOfUint8
	PutChReturnOfUint8(chan *ReturnOfUint8)
}

type PoolOfUint8ThenUint8Impl struct {
	Uint8Arg        sync.Pool
	Uint8Rtn        sync.Pool
	Uint8Work       sync.Pool
	Uint8Return     sync.Pool
	ChReturnOfUint8 sync.Pool
}

func (__ *PoolOfUint8ThenUint8Impl) GetUint8Arg() *uint8 {
	return __.Uint8Arg.Get().(*uint8)
}
func (__ *PoolOfUint8ThenUint8Impl) PutUint8Arg(p *uint8) {
	__.Uint8Arg.Put(p)
}
func (__ *PoolOfUint8ThenUint8Impl) GetUint8Return() *uint8 {
	return __.Uint8Rtn.Get().(*uint8)
}
func (__ *PoolOfUint8ThenUint8Impl) PutUint8Return(p *uint8) {
	__.Uint8Rtn.Put(p)
}

func (__ *PoolOfUint8ThenUint8Impl) GetWorkOfUint8ThenUint8() *WorkOfUint8ThenUint8 {
	return __.Uint8Work.Get().(*WorkOfUint8ThenUint8)
}
func (__ *PoolOfUint8ThenUint8Impl) PutWorkOfUint8ThenUint8(p *WorkOfUint8ThenUint8) {
	__.Uint8Work.Put(p)
}
func (__ *PoolOfUint8ThenUint8Impl) GetReturnOfUint8() *ReturnOfUint8 {
	return __.Uint8Return.Get().(*ReturnOfUint8)
}
func (__ *PoolOfUint8ThenUint8Impl) PutReturnOfUint8(p *ReturnOfUint8) {
	__.Uint8Return.Put(p)
}

func (__ *PoolOfUint8ThenUint8Impl) GetChReturnOfUint8() chan *ReturnOfUint8 {
	return __.ChReturnOfUint8.Get().(chan *ReturnOfUint8)
}
func (__ *PoolOfUint8ThenUint8Impl) PutChReturnOfUint8(p chan *ReturnOfUint8) {
	__.ChReturnOfUint8.Put(p)
}

func NewPoolOfUint8ThenUint8Impl() *PoolOfUint8ThenUint8Impl {
	return &PoolOfUint8ThenUint8Impl{
		Uint8Arg: sync.Pool{
			New: func() interface{} {
				return new(uint8)
			},
		},
		Uint8Work: sync.Pool{
			New: func() interface{} {
				return new(WorkOfUint8ThenUint8)
			},
		},
		Uint8Rtn: sync.Pool{
			New: func() interface{} {
				return new(uint8)
			},
		},
		Uint8Return: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfUint8)
			},
		},
		ChReturnOfUint8: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfUint8, 1)
			},
		},
	}
}

type ApiDecouplerOfUint8ThenUint8 struct {
	pool PoolOfUint8ThenUint8
}

func NewApiDecouplerOfUint8ThenUint8() *ApiDecouplerOfUint8ThenUint8 {
	return &ApiDecouplerOfUint8ThenUint8{
		pool: NewPoolOfUint8ThenUint8Impl(),
	}
}

func (__ *ApiDecouplerOfUint8ThenUint8) ReturnError(rtn_ch chan<- *ReturnOfUint8, err error) {
	rtn := __.pool.GetReturnOfUint8()
	var other uint8
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfUint8ThenUint8) HandleOfUint8ThenUint8(ctx context.Context, req *WorkOfUint8ThenUint8, h func(ctx context.Context, arg uint8) (uint8, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfUint8()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfUint8ThenUint8) DoOfUint8ThenUint8(ctx context.Context, worker WorkerOfPushUint8ThenUint8, arg uint8) (uint8, error) {
	// ch := make(chan *ReturnOfUint8, 1)
	ch := __.pool.GetChReturnOfUint8()
	defer __.pool.PutChReturnOfUint8(ch)

	req := __.pool.GetWorkOfUint8ThenUint8()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfUint8ThenUint8(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfUint8(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfUint8ThenUint8 = func(ctx context.Context, arg uint8) (uint8, error)

type WorkerOfUint8ThenUint8 struct {
	api_syncer *ApiDecouplerOfUint8ThenUint8
	handler    WorkHandlerOfUint8ThenUint8

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfUint8ThenUint8
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfUint8ThenUint8(ctx context.Context, h WorkHandlerOfUint8ThenUint8, n int) *WorkerOfUint8ThenUint8 {
	__ := &WorkerOfUint8ThenUint8{
		api_syncer: NewApiDecouplerOfUint8ThenUint8(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfUint8ThenUint8, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfUint8ThenUint8{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfUint8ThenUint8(req.Context, req.WorkOfUint8ThenUint8, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfUint8ThenUint8) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfUint8ThenUint8) Push(ctx context.Context, req *WorkOfUint8ThenUint8) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfUint8ThenUint8)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfUint8ThenUint8 = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfUint8ThenUint8) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfUint8ThenUint8) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfUint8ThenUint8) Call(ctx context.Context, arg uint8) (uint8, error) {
	return __.api_syncer.DoOfUint8ThenUint8(ctx, __, arg)
}

type PoolOfUint8ThenUintptr interface {
	GetUint8Arg() *uint8
	PutUint8Arg(*uint8)
	GetUintptrReturn() *uintptr
	PutUintptrReturn(*uintptr)

	GetWorkOfUint8ThenUintptr() *WorkOfUint8ThenUintptr
	GetReturnOfUintptr() *ReturnOfUintptr
	PutWorkOfUint8ThenUintptr(*WorkOfUint8ThenUintptr)
	PutReturnOfUintptr(*ReturnOfUintptr)

	GetChReturnOfUintptr() chan *ReturnOfUintptr
	PutChReturnOfUintptr(chan *ReturnOfUintptr)
}

type PoolOfUint8ThenUintptrImpl struct {
	Uint8Arg          sync.Pool
	UintptrRtn        sync.Pool
	Uint8Work         sync.Pool
	UintptrReturn     sync.Pool
	ChReturnOfUintptr sync.Pool
}

func (__ *PoolOfUint8ThenUintptrImpl) GetUint8Arg() *uint8 {
	return __.Uint8Arg.Get().(*uint8)
}
func (__ *PoolOfUint8ThenUintptrImpl) PutUint8Arg(p *uint8) {
	__.Uint8Arg.Put(p)
}
func (__ *PoolOfUint8ThenUintptrImpl) GetUintptrReturn() *uintptr {
	return __.UintptrRtn.Get().(*uintptr)
}
func (__ *PoolOfUint8ThenUintptrImpl) PutUintptrReturn(p *uintptr) {
	__.UintptrRtn.Put(p)
}

func (__ *PoolOfUint8ThenUintptrImpl) GetWorkOfUint8ThenUintptr() *WorkOfUint8ThenUintptr {
	return __.Uint8Work.Get().(*WorkOfUint8ThenUintptr)
}
func (__ *PoolOfUint8ThenUintptrImpl) PutWorkOfUint8ThenUintptr(p *WorkOfUint8ThenUintptr) {
	__.Uint8Work.Put(p)
}
func (__ *PoolOfUint8ThenUintptrImpl) GetReturnOfUintptr() *ReturnOfUintptr {
	return __.UintptrReturn.Get().(*ReturnOfUintptr)
}
func (__ *PoolOfUint8ThenUintptrImpl) PutReturnOfUintptr(p *ReturnOfUintptr) {
	__.UintptrReturn.Put(p)
}

func (__ *PoolOfUint8ThenUintptrImpl) GetChReturnOfUintptr() chan *ReturnOfUintptr {
	return __.ChReturnOfUintptr.Get().(chan *ReturnOfUintptr)
}
func (__ *PoolOfUint8ThenUintptrImpl) PutChReturnOfUintptr(p chan *ReturnOfUintptr) {
	__.ChReturnOfUintptr.Put(p)
}

func NewPoolOfUint8ThenUintptrImpl() *PoolOfUint8ThenUintptrImpl {
	return &PoolOfUint8ThenUintptrImpl{
		Uint8Arg: sync.Pool{
			New: func() interface{} {
				return new(uint8)
			},
		},
		Uint8Work: sync.Pool{
			New: func() interface{} {
				return new(WorkOfUint8ThenUintptr)
			},
		},
		UintptrRtn: sync.Pool{
			New: func() interface{} {
				return new(uintptr)
			},
		},
		UintptrReturn: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfUintptr)
			},
		},
		ChReturnOfUintptr: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfUintptr, 1)
			},
		},
	}
}

type ApiDecouplerOfUint8ThenUintptr struct {
	pool PoolOfUint8ThenUintptr
}

func NewApiDecouplerOfUint8ThenUintptr() *ApiDecouplerOfUint8ThenUintptr {
	return &ApiDecouplerOfUint8ThenUintptr{
		pool: NewPoolOfUint8ThenUintptrImpl(),
	}
}

func (__ *ApiDecouplerOfUint8ThenUintptr) ReturnError(rtn_ch chan<- *ReturnOfUintptr, err error) {
	rtn := __.pool.GetReturnOfUintptr()
	var other uintptr
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfUint8ThenUintptr) HandleOfUint8ThenUintptr(ctx context.Context, req *WorkOfUint8ThenUintptr, h func(ctx context.Context, arg uint8) (uintptr, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfUintptr()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfUint8ThenUintptr) DoOfUint8ThenUintptr(ctx context.Context, worker WorkerOfPushUint8ThenUintptr, arg uint8) (uintptr, error) {
	// ch := make(chan *ReturnOfUintptr, 1)
	ch := __.pool.GetChReturnOfUintptr()
	defer __.pool.PutChReturnOfUintptr(ch)

	req := __.pool.GetWorkOfUint8ThenUintptr()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfUint8ThenUintptr(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfUintptr(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfUint8ThenUintptr = func(ctx context.Context, arg uint8) (uintptr, error)

type WorkerOfUint8ThenUintptr struct {
	api_syncer *ApiDecouplerOfUint8ThenUintptr
	handler    WorkHandlerOfUint8ThenUintptr

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfUint8ThenUintptr
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfUint8ThenUintptr(ctx context.Context, h WorkHandlerOfUint8ThenUintptr, n int) *WorkerOfUint8ThenUintptr {
	__ := &WorkerOfUint8ThenUintptr{
		api_syncer: NewApiDecouplerOfUint8ThenUintptr(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfUint8ThenUintptr, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfUint8ThenUintptr{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfUint8ThenUintptr(req.Context, req.WorkOfUint8ThenUintptr, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfUint8ThenUintptr) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfUint8ThenUintptr) Push(ctx context.Context, req *WorkOfUint8ThenUintptr) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfUint8ThenUintptr)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfUint8ThenUintptr = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfUint8ThenUintptr) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfUint8ThenUintptr) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfUint8ThenUintptr) Call(ctx context.Context, arg uint8) (uintptr, error) {
	return __.api_syncer.DoOfUint8ThenUintptr(ctx, __, arg)
}

type PoolOfUint8ThenInterface interface {
	GetUint8Arg() *uint8
	PutUint8Arg(*uint8)
	GetInterfaceReturn() *interface{}
	PutInterfaceReturn(*interface{})

	GetWorkOfUint8ThenInterface() *WorkOfUint8ThenInterface
	GetReturnOfInterface() *ReturnOfInterface
	PutWorkOfUint8ThenInterface(*WorkOfUint8ThenInterface)
	PutReturnOfInterface(*ReturnOfInterface)

	GetChReturnOfInterface() chan *ReturnOfInterface
	PutChReturnOfInterface(chan *ReturnOfInterface)
}

type PoolOfUint8ThenInterfaceImpl struct {
	Uint8Arg            sync.Pool
	InterfaceRtn        sync.Pool
	Uint8Work           sync.Pool
	InterfaceReturn     sync.Pool
	ChReturnOfInterface sync.Pool
}

func (__ *PoolOfUint8ThenInterfaceImpl) GetUint8Arg() *uint8 {
	return __.Uint8Arg.Get().(*uint8)
}
func (__ *PoolOfUint8ThenInterfaceImpl) PutUint8Arg(p *uint8) {
	__.Uint8Arg.Put(p)
}
func (__ *PoolOfUint8ThenInterfaceImpl) GetInterfaceReturn() *interface{} {
	return __.InterfaceRtn.Get().(*interface{})
}
func (__ *PoolOfUint8ThenInterfaceImpl) PutInterfaceReturn(p *interface{}) {
	__.InterfaceRtn.Put(p)
}

func (__ *PoolOfUint8ThenInterfaceImpl) GetWorkOfUint8ThenInterface() *WorkOfUint8ThenInterface {
	return __.Uint8Work.Get().(*WorkOfUint8ThenInterface)
}
func (__ *PoolOfUint8ThenInterfaceImpl) PutWorkOfUint8ThenInterface(p *WorkOfUint8ThenInterface) {
	__.Uint8Work.Put(p)
}
func (__ *PoolOfUint8ThenInterfaceImpl) GetReturnOfInterface() *ReturnOfInterface {
	return __.InterfaceReturn.Get().(*ReturnOfInterface)
}
func (__ *PoolOfUint8ThenInterfaceImpl) PutReturnOfInterface(p *ReturnOfInterface) {
	__.InterfaceReturn.Put(p)
}

func (__ *PoolOfUint8ThenInterfaceImpl) GetChReturnOfInterface() chan *ReturnOfInterface {
	return __.ChReturnOfInterface.Get().(chan *ReturnOfInterface)
}
func (__ *PoolOfUint8ThenInterfaceImpl) PutChReturnOfInterface(p chan *ReturnOfInterface) {
	__.ChReturnOfInterface.Put(p)
}

func NewPoolOfUint8ThenInterfaceImpl() *PoolOfUint8ThenInterfaceImpl {
	return &PoolOfUint8ThenInterfaceImpl{
		Uint8Arg: sync.Pool{
			New: func() interface{} {
				return new(uint8)
			},
		},
		Uint8Work: sync.Pool{
			New: func() interface{} {
				return new(WorkOfUint8ThenInterface)
			},
		},
		InterfaceRtn: sync.Pool{
			New: func() interface{} {
				return new(interface{})
			},
		},
		InterfaceReturn: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfInterface)
			},
		},
		ChReturnOfInterface: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfInterface, 1)
			},
		},
	}
}

type ApiDecouplerOfUint8ThenInterface struct {
	pool PoolOfUint8ThenInterface
}

func NewApiDecouplerOfUint8ThenInterface() *ApiDecouplerOfUint8ThenInterface {
	return &ApiDecouplerOfUint8ThenInterface{
		pool: NewPoolOfUint8ThenInterfaceImpl(),
	}
}

func (__ *ApiDecouplerOfUint8ThenInterface) ReturnError(rtn_ch chan<- *ReturnOfInterface, err error) {
	rtn := __.pool.GetReturnOfInterface()
	var other interface{}
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfUint8ThenInterface) HandleOfUint8ThenInterface(ctx context.Context, req *WorkOfUint8ThenInterface, h func(ctx context.Context, arg uint8) (interface{}, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfInterface()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfUint8ThenInterface) DoOfUint8ThenInterface(ctx context.Context, worker WorkerOfPushUint8ThenInterface, arg uint8) (interface{}, error) {
	// ch := make(chan *ReturnOfInterface, 1)
	ch := __.pool.GetChReturnOfInterface()
	defer __.pool.PutChReturnOfInterface(ch)

	req := __.pool.GetWorkOfUint8ThenInterface()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfUint8ThenInterface(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfInterface(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfUint8ThenInterface = func(ctx context.Context, arg uint8) (interface{}, error)

type WorkerOfUint8ThenInterface struct {
	api_syncer *ApiDecouplerOfUint8ThenInterface
	handler    WorkHandlerOfUint8ThenInterface

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfUint8ThenInterface
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfUint8ThenInterface(ctx context.Context, h WorkHandlerOfUint8ThenInterface, n int) *WorkerOfUint8ThenInterface {
	__ := &WorkerOfUint8ThenInterface{
		api_syncer: NewApiDecouplerOfUint8ThenInterface(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfUint8ThenInterface, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfUint8ThenInterface{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfUint8ThenInterface(req.Context, req.WorkOfUint8ThenInterface, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfUint8ThenInterface) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfUint8ThenInterface) Push(ctx context.Context, req *WorkOfUint8ThenInterface) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfUint8ThenInterface)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfUint8ThenInterface = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfUint8ThenInterface) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfUint8ThenInterface) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfUint8ThenInterface) Call(ctx context.Context, arg uint8) (interface{}, error) {
	return __.api_syncer.DoOfUint8ThenInterface(ctx, __, arg)
}

type PoolOfUint8ThenStruct interface {
	GetUint8Arg() *uint8
	PutUint8Arg(*uint8)
	GetStructReturn() *struct{}
	PutStructReturn(*struct{})

	GetWorkOfUint8ThenStruct() *WorkOfUint8ThenStruct
	GetReturnOfStruct() *ReturnOfStruct
	PutWorkOfUint8ThenStruct(*WorkOfUint8ThenStruct)
	PutReturnOfStruct(*ReturnOfStruct)

	GetChReturnOfStruct() chan *ReturnOfStruct
	PutChReturnOfStruct(chan *ReturnOfStruct)
}

type PoolOfUint8ThenStructImpl struct {
	Uint8Arg         sync.Pool
	StructRtn        sync.Pool
	Uint8Work        sync.Pool
	StructReturn     sync.Pool
	ChReturnOfStruct sync.Pool
}

func (__ *PoolOfUint8ThenStructImpl) GetUint8Arg() *uint8 {
	return __.Uint8Arg.Get().(*uint8)
}
func (__ *PoolOfUint8ThenStructImpl) PutUint8Arg(p *uint8) {
	__.Uint8Arg.Put(p)
}
func (__ *PoolOfUint8ThenStructImpl) GetStructReturn() *struct{} {
	return __.StructRtn.Get().(*struct{})
}
func (__ *PoolOfUint8ThenStructImpl) PutStructReturn(p *struct{}) {
	__.StructRtn.Put(p)
}

func (__ *PoolOfUint8ThenStructImpl) GetWorkOfUint8ThenStruct() *WorkOfUint8ThenStruct {
	return __.Uint8Work.Get().(*WorkOfUint8ThenStruct)
}
func (__ *PoolOfUint8ThenStructImpl) PutWorkOfUint8ThenStruct(p *WorkOfUint8ThenStruct) {
	__.Uint8Work.Put(p)
}
func (__ *PoolOfUint8ThenStructImpl) GetReturnOfStruct() *ReturnOfStruct {
	return __.StructReturn.Get().(*ReturnOfStruct)
}
func (__ *PoolOfUint8ThenStructImpl) PutReturnOfStruct(p *ReturnOfStruct) {
	__.StructReturn.Put(p)
}

func (__ *PoolOfUint8ThenStructImpl) GetChReturnOfStruct() chan *ReturnOfStruct {
	return __.ChReturnOfStruct.Get().(chan *ReturnOfStruct)
}
func (__ *PoolOfUint8ThenStructImpl) PutChReturnOfStruct(p chan *ReturnOfStruct) {
	__.ChReturnOfStruct.Put(p)
}

func NewPoolOfUint8ThenStructImpl() *PoolOfUint8ThenStructImpl {
	return &PoolOfUint8ThenStructImpl{
		Uint8Arg: sync.Pool{
			New: func() interface{} {
				return new(uint8)
			},
		},
		Uint8Work: sync.Pool{
			New: func() interface{} {
				return new(WorkOfUint8ThenStruct)
			},
		},
		StructRtn: sync.Pool{
			New: func() interface{} {
				return new(struct{})
			},
		},
		StructReturn: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfStruct)
			},
		},
		ChReturnOfStruct: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfStruct, 1)
			},
		},
	}
}

type ApiDecouplerOfUint8ThenStruct struct {
	pool PoolOfUint8ThenStruct
}

func NewApiDecouplerOfUint8ThenStruct() *ApiDecouplerOfUint8ThenStruct {
	return &ApiDecouplerOfUint8ThenStruct{
		pool: NewPoolOfUint8ThenStructImpl(),
	}
}

func (__ *ApiDecouplerOfUint8ThenStruct) ReturnError(rtn_ch chan<- *ReturnOfStruct, err error) {
	rtn := __.pool.GetReturnOfStruct()
	var other struct{}
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfUint8ThenStruct) HandleOfUint8ThenStruct(ctx context.Context, req *WorkOfUint8ThenStruct, h func(ctx context.Context, arg uint8) (struct{}, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfStruct()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfUint8ThenStruct) DoOfUint8ThenStruct(ctx context.Context, worker WorkerOfPushUint8ThenStruct, arg uint8) (struct{}, error) {
	// ch := make(chan *ReturnOfStruct, 1)
	ch := __.pool.GetChReturnOfStruct()
	defer __.pool.PutChReturnOfStruct(ch)

	req := __.pool.GetWorkOfUint8ThenStruct()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfUint8ThenStruct(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfStruct(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfUint8ThenStruct = func(ctx context.Context, arg uint8) (struct{}, error)

type WorkerOfUint8ThenStruct struct {
	api_syncer *ApiDecouplerOfUint8ThenStruct
	handler    WorkHandlerOfUint8ThenStruct

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfUint8ThenStruct
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfUint8ThenStruct(ctx context.Context, h WorkHandlerOfUint8ThenStruct, n int) *WorkerOfUint8ThenStruct {
	__ := &WorkerOfUint8ThenStruct{
		api_syncer: NewApiDecouplerOfUint8ThenStruct(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfUint8ThenStruct, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfUint8ThenStruct{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfUint8ThenStruct(req.Context, req.WorkOfUint8ThenStruct, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfUint8ThenStruct) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfUint8ThenStruct) Push(ctx context.Context, req *WorkOfUint8ThenStruct) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfUint8ThenStruct)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfUint8ThenStruct = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfUint8ThenStruct) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfUint8ThenStruct) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfUint8ThenStruct) Call(ctx context.Context, arg uint8) (struct{}, error) {
	return __.api_syncer.DoOfUint8ThenStruct(ctx, __, arg)
}

type PoolOfUintptrThenBool interface {
	GetUintptrArg() *uintptr
	PutUintptrArg(*uintptr)
	GetBoolReturn() *bool
	PutBoolReturn(*bool)

	GetWorkOfUintptrThenBool() *WorkOfUintptrThenBool
	GetReturnOfBool() *ReturnOfBool
	PutWorkOfUintptrThenBool(*WorkOfUintptrThenBool)
	PutReturnOfBool(*ReturnOfBool)

	GetChReturnOfBool() chan *ReturnOfBool
	PutChReturnOfBool(chan *ReturnOfBool)
}

type PoolOfUintptrThenBoolImpl struct {
	UintptrArg     sync.Pool
	BoolRtn        sync.Pool
	UintptrWork    sync.Pool
	BoolReturn     sync.Pool
	ChReturnOfBool sync.Pool
}

func (__ *PoolOfUintptrThenBoolImpl) GetUintptrArg() *uintptr {
	return __.UintptrArg.Get().(*uintptr)
}
func (__ *PoolOfUintptrThenBoolImpl) PutUintptrArg(p *uintptr) {
	__.UintptrArg.Put(p)
}
func (__ *PoolOfUintptrThenBoolImpl) GetBoolReturn() *bool {
	return __.BoolRtn.Get().(*bool)
}
func (__ *PoolOfUintptrThenBoolImpl) PutBoolReturn(p *bool) {
	__.BoolRtn.Put(p)
}

func (__ *PoolOfUintptrThenBoolImpl) GetWorkOfUintptrThenBool() *WorkOfUintptrThenBool {
	return __.UintptrWork.Get().(*WorkOfUintptrThenBool)
}
func (__ *PoolOfUintptrThenBoolImpl) PutWorkOfUintptrThenBool(p *WorkOfUintptrThenBool) {
	__.UintptrWork.Put(p)
}
func (__ *PoolOfUintptrThenBoolImpl) GetReturnOfBool() *ReturnOfBool {
	return __.BoolReturn.Get().(*ReturnOfBool)
}
func (__ *PoolOfUintptrThenBoolImpl) PutReturnOfBool(p *ReturnOfBool) {
	__.BoolReturn.Put(p)
}

func (__ *PoolOfUintptrThenBoolImpl) GetChReturnOfBool() chan *ReturnOfBool {
	return __.ChReturnOfBool.Get().(chan *ReturnOfBool)
}
func (__ *PoolOfUintptrThenBoolImpl) PutChReturnOfBool(p chan *ReturnOfBool) {
	__.ChReturnOfBool.Put(p)
}

func NewPoolOfUintptrThenBoolImpl() *PoolOfUintptrThenBoolImpl {
	return &PoolOfUintptrThenBoolImpl{
		UintptrArg: sync.Pool{
			New: func() interface{} {
				return new(uintptr)
			},
		},
		UintptrWork: sync.Pool{
			New: func() interface{} {
				return new(WorkOfUintptrThenBool)
			},
		},
		BoolRtn: sync.Pool{
			New: func() interface{} {
				return new(bool)
			},
		},
		BoolReturn: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfBool)
			},
		},
		ChReturnOfBool: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfBool, 1)
			},
		},
	}
}

type ApiDecouplerOfUintptrThenBool struct {
	pool PoolOfUintptrThenBool
}

func NewApiDecouplerOfUintptrThenBool() *ApiDecouplerOfUintptrThenBool {
	return &ApiDecouplerOfUintptrThenBool{
		pool: NewPoolOfUintptrThenBoolImpl(),
	}
}

func (__ *ApiDecouplerOfUintptrThenBool) ReturnError(rtn_ch chan<- *ReturnOfBool, err error) {
	rtn := __.pool.GetReturnOfBool()
	var other bool
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfUintptrThenBool) HandleOfUintptrThenBool(ctx context.Context, req *WorkOfUintptrThenBool, h func(ctx context.Context, arg uintptr) (bool, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfBool()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfUintptrThenBool) DoOfUintptrThenBool(ctx context.Context, worker WorkerOfPushUintptrThenBool, arg uintptr) (bool, error) {
	// ch := make(chan *ReturnOfBool, 1)
	ch := __.pool.GetChReturnOfBool()
	defer __.pool.PutChReturnOfBool(ch)

	req := __.pool.GetWorkOfUintptrThenBool()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfUintptrThenBool(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfBool(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfUintptrThenBool = func(ctx context.Context, arg uintptr) (bool, error)

type WorkerOfUintptrThenBool struct {
	api_syncer *ApiDecouplerOfUintptrThenBool
	handler    WorkHandlerOfUintptrThenBool

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfUintptrThenBool
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfUintptrThenBool(ctx context.Context, h WorkHandlerOfUintptrThenBool, n int) *WorkerOfUintptrThenBool {
	__ := &WorkerOfUintptrThenBool{
		api_syncer: NewApiDecouplerOfUintptrThenBool(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfUintptrThenBool, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfUintptrThenBool{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfUintptrThenBool(req.Context, req.WorkOfUintptrThenBool, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfUintptrThenBool) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfUintptrThenBool) Push(ctx context.Context, req *WorkOfUintptrThenBool) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfUintptrThenBool)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfUintptrThenBool = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfUintptrThenBool) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfUintptrThenBool) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfUintptrThenBool) Call(ctx context.Context, arg uintptr) (bool, error) {
	return __.api_syncer.DoOfUintptrThenBool(ctx, __, arg)
}

type PoolOfUintptrThenByte interface {
	GetUintptrArg() *uintptr
	PutUintptrArg(*uintptr)
	GetByteReturn() *byte
	PutByteReturn(*byte)

	GetWorkOfUintptrThenByte() *WorkOfUintptrThenByte
	GetReturnOfByte() *ReturnOfByte
	PutWorkOfUintptrThenByte(*WorkOfUintptrThenByte)
	PutReturnOfByte(*ReturnOfByte)

	GetChReturnOfByte() chan *ReturnOfByte
	PutChReturnOfByte(chan *ReturnOfByte)
}

type PoolOfUintptrThenByteImpl struct {
	UintptrArg     sync.Pool
	ByteRtn        sync.Pool
	UintptrWork    sync.Pool
	ByteReturn     sync.Pool
	ChReturnOfByte sync.Pool
}

func (__ *PoolOfUintptrThenByteImpl) GetUintptrArg() *uintptr {
	return __.UintptrArg.Get().(*uintptr)
}
func (__ *PoolOfUintptrThenByteImpl) PutUintptrArg(p *uintptr) {
	__.UintptrArg.Put(p)
}
func (__ *PoolOfUintptrThenByteImpl) GetByteReturn() *byte {
	return __.ByteRtn.Get().(*byte)
}
func (__ *PoolOfUintptrThenByteImpl) PutByteReturn(p *byte) {
	__.ByteRtn.Put(p)
}

func (__ *PoolOfUintptrThenByteImpl) GetWorkOfUintptrThenByte() *WorkOfUintptrThenByte {
	return __.UintptrWork.Get().(*WorkOfUintptrThenByte)
}
func (__ *PoolOfUintptrThenByteImpl) PutWorkOfUintptrThenByte(p *WorkOfUintptrThenByte) {
	__.UintptrWork.Put(p)
}
func (__ *PoolOfUintptrThenByteImpl) GetReturnOfByte() *ReturnOfByte {
	return __.ByteReturn.Get().(*ReturnOfByte)
}
func (__ *PoolOfUintptrThenByteImpl) PutReturnOfByte(p *ReturnOfByte) {
	__.ByteReturn.Put(p)
}

func (__ *PoolOfUintptrThenByteImpl) GetChReturnOfByte() chan *ReturnOfByte {
	return __.ChReturnOfByte.Get().(chan *ReturnOfByte)
}
func (__ *PoolOfUintptrThenByteImpl) PutChReturnOfByte(p chan *ReturnOfByte) {
	__.ChReturnOfByte.Put(p)
}

func NewPoolOfUintptrThenByteImpl() *PoolOfUintptrThenByteImpl {
	return &PoolOfUintptrThenByteImpl{
		UintptrArg: sync.Pool{
			New: func() interface{} {
				return new(uintptr)
			},
		},
		UintptrWork: sync.Pool{
			New: func() interface{} {
				return new(WorkOfUintptrThenByte)
			},
		},
		ByteRtn: sync.Pool{
			New: func() interface{} {
				return new(byte)
			},
		},
		ByteReturn: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfByte)
			},
		},
		ChReturnOfByte: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfByte, 1)
			},
		},
	}
}

type ApiDecouplerOfUintptrThenByte struct {
	pool PoolOfUintptrThenByte
}

func NewApiDecouplerOfUintptrThenByte() *ApiDecouplerOfUintptrThenByte {
	return &ApiDecouplerOfUintptrThenByte{
		pool: NewPoolOfUintptrThenByteImpl(),
	}
}

func (__ *ApiDecouplerOfUintptrThenByte) ReturnError(rtn_ch chan<- *ReturnOfByte, err error) {
	rtn := __.pool.GetReturnOfByte()
	var other byte
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfUintptrThenByte) HandleOfUintptrThenByte(ctx context.Context, req *WorkOfUintptrThenByte, h func(ctx context.Context, arg uintptr) (byte, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfByte()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfUintptrThenByte) DoOfUintptrThenByte(ctx context.Context, worker WorkerOfPushUintptrThenByte, arg uintptr) (byte, error) {
	// ch := make(chan *ReturnOfByte, 1)
	ch := __.pool.GetChReturnOfByte()
	defer __.pool.PutChReturnOfByte(ch)

	req := __.pool.GetWorkOfUintptrThenByte()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfUintptrThenByte(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfByte(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfUintptrThenByte = func(ctx context.Context, arg uintptr) (byte, error)

type WorkerOfUintptrThenByte struct {
	api_syncer *ApiDecouplerOfUintptrThenByte
	handler    WorkHandlerOfUintptrThenByte

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfUintptrThenByte
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfUintptrThenByte(ctx context.Context, h WorkHandlerOfUintptrThenByte, n int) *WorkerOfUintptrThenByte {
	__ := &WorkerOfUintptrThenByte{
		api_syncer: NewApiDecouplerOfUintptrThenByte(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfUintptrThenByte, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfUintptrThenByte{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfUintptrThenByte(req.Context, req.WorkOfUintptrThenByte, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfUintptrThenByte) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfUintptrThenByte) Push(ctx context.Context, req *WorkOfUintptrThenByte) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfUintptrThenByte)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfUintptrThenByte = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfUintptrThenByte) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfUintptrThenByte) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfUintptrThenByte) Call(ctx context.Context, arg uintptr) (byte, error) {
	return __.api_syncer.DoOfUintptrThenByte(ctx, __, arg)
}

type PoolOfUintptrThenComplex128 interface {
	GetUintptrArg() *uintptr
	PutUintptrArg(*uintptr)
	GetComplex128Return() *complex128
	PutComplex128Return(*complex128)

	GetWorkOfUintptrThenComplex128() *WorkOfUintptrThenComplex128
	GetReturnOfComplex128() *ReturnOfComplex128
	PutWorkOfUintptrThenComplex128(*WorkOfUintptrThenComplex128)
	PutReturnOfComplex128(*ReturnOfComplex128)

	GetChReturnOfComplex128() chan *ReturnOfComplex128
	PutChReturnOfComplex128(chan *ReturnOfComplex128)
}

type PoolOfUintptrThenComplex128Impl struct {
	UintptrArg           sync.Pool
	Complex128Rtn        sync.Pool
	UintptrWork          sync.Pool
	Complex128Return     sync.Pool
	ChReturnOfComplex128 sync.Pool
}

func (__ *PoolOfUintptrThenComplex128Impl) GetUintptrArg() *uintptr {
	return __.UintptrArg.Get().(*uintptr)
}
func (__ *PoolOfUintptrThenComplex128Impl) PutUintptrArg(p *uintptr) {
	__.UintptrArg.Put(p)
}
func (__ *PoolOfUintptrThenComplex128Impl) GetComplex128Return() *complex128 {
	return __.Complex128Rtn.Get().(*complex128)
}
func (__ *PoolOfUintptrThenComplex128Impl) PutComplex128Return(p *complex128) {
	__.Complex128Rtn.Put(p)
}

func (__ *PoolOfUintptrThenComplex128Impl) GetWorkOfUintptrThenComplex128() *WorkOfUintptrThenComplex128 {
	return __.UintptrWork.Get().(*WorkOfUintptrThenComplex128)
}
func (__ *PoolOfUintptrThenComplex128Impl) PutWorkOfUintptrThenComplex128(p *WorkOfUintptrThenComplex128) {
	__.UintptrWork.Put(p)
}
func (__ *PoolOfUintptrThenComplex128Impl) GetReturnOfComplex128() *ReturnOfComplex128 {
	return __.Complex128Return.Get().(*ReturnOfComplex128)
}
func (__ *PoolOfUintptrThenComplex128Impl) PutReturnOfComplex128(p *ReturnOfComplex128) {
	__.Complex128Return.Put(p)
}

func (__ *PoolOfUintptrThenComplex128Impl) GetChReturnOfComplex128() chan *ReturnOfComplex128 {
	return __.ChReturnOfComplex128.Get().(chan *ReturnOfComplex128)
}
func (__ *PoolOfUintptrThenComplex128Impl) PutChReturnOfComplex128(p chan *ReturnOfComplex128) {
	__.ChReturnOfComplex128.Put(p)
}

func NewPoolOfUintptrThenComplex128Impl() *PoolOfUintptrThenComplex128Impl {
	return &PoolOfUintptrThenComplex128Impl{
		UintptrArg: sync.Pool{
			New: func() interface{} {
				return new(uintptr)
			},
		},
		UintptrWork: sync.Pool{
			New: func() interface{} {
				return new(WorkOfUintptrThenComplex128)
			},
		},
		Complex128Rtn: sync.Pool{
			New: func() interface{} {
				return new(complex128)
			},
		},
		Complex128Return: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfComplex128)
			},
		},
		ChReturnOfComplex128: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfComplex128, 1)
			},
		},
	}
}

type ApiDecouplerOfUintptrThenComplex128 struct {
	pool PoolOfUintptrThenComplex128
}

func NewApiDecouplerOfUintptrThenComplex128() *ApiDecouplerOfUintptrThenComplex128 {
	return &ApiDecouplerOfUintptrThenComplex128{
		pool: NewPoolOfUintptrThenComplex128Impl(),
	}
}

func (__ *ApiDecouplerOfUintptrThenComplex128) ReturnError(rtn_ch chan<- *ReturnOfComplex128, err error) {
	rtn := __.pool.GetReturnOfComplex128()
	var other complex128
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfUintptrThenComplex128) HandleOfUintptrThenComplex128(ctx context.Context, req *WorkOfUintptrThenComplex128, h func(ctx context.Context, arg uintptr) (complex128, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfComplex128()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfUintptrThenComplex128) DoOfUintptrThenComplex128(ctx context.Context, worker WorkerOfPushUintptrThenComplex128, arg uintptr) (complex128, error) {
	// ch := make(chan *ReturnOfComplex128, 1)
	ch := __.pool.GetChReturnOfComplex128()
	defer __.pool.PutChReturnOfComplex128(ch)

	req := __.pool.GetWorkOfUintptrThenComplex128()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfUintptrThenComplex128(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfComplex128(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfUintptrThenComplex128 = func(ctx context.Context, arg uintptr) (complex128, error)

type WorkerOfUintptrThenComplex128 struct {
	api_syncer *ApiDecouplerOfUintptrThenComplex128
	handler    WorkHandlerOfUintptrThenComplex128

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfUintptrThenComplex128
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfUintptrThenComplex128(ctx context.Context, h WorkHandlerOfUintptrThenComplex128, n int) *WorkerOfUintptrThenComplex128 {
	__ := &WorkerOfUintptrThenComplex128{
		api_syncer: NewApiDecouplerOfUintptrThenComplex128(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfUintptrThenComplex128, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfUintptrThenComplex128{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfUintptrThenComplex128(req.Context, req.WorkOfUintptrThenComplex128, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfUintptrThenComplex128) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfUintptrThenComplex128) Push(ctx context.Context, req *WorkOfUintptrThenComplex128) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfUintptrThenComplex128)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfUintptrThenComplex128 = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfUintptrThenComplex128) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfUintptrThenComplex128) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfUintptrThenComplex128) Call(ctx context.Context, arg uintptr) (complex128, error) {
	return __.api_syncer.DoOfUintptrThenComplex128(ctx, __, arg)
}

type PoolOfUintptrThenComplex64 interface {
	GetUintptrArg() *uintptr
	PutUintptrArg(*uintptr)
	GetComplex64Return() *complex64
	PutComplex64Return(*complex64)

	GetWorkOfUintptrThenComplex64() *WorkOfUintptrThenComplex64
	GetReturnOfComplex64() *ReturnOfComplex64
	PutWorkOfUintptrThenComplex64(*WorkOfUintptrThenComplex64)
	PutReturnOfComplex64(*ReturnOfComplex64)

	GetChReturnOfComplex64() chan *ReturnOfComplex64
	PutChReturnOfComplex64(chan *ReturnOfComplex64)
}

type PoolOfUintptrThenComplex64Impl struct {
	UintptrArg          sync.Pool
	Complex64Rtn        sync.Pool
	UintptrWork         sync.Pool
	Complex64Return     sync.Pool
	ChReturnOfComplex64 sync.Pool
}

func (__ *PoolOfUintptrThenComplex64Impl) GetUintptrArg() *uintptr {
	return __.UintptrArg.Get().(*uintptr)
}
func (__ *PoolOfUintptrThenComplex64Impl) PutUintptrArg(p *uintptr) {
	__.UintptrArg.Put(p)
}
func (__ *PoolOfUintptrThenComplex64Impl) GetComplex64Return() *complex64 {
	return __.Complex64Rtn.Get().(*complex64)
}
func (__ *PoolOfUintptrThenComplex64Impl) PutComplex64Return(p *complex64) {
	__.Complex64Rtn.Put(p)
}

func (__ *PoolOfUintptrThenComplex64Impl) GetWorkOfUintptrThenComplex64() *WorkOfUintptrThenComplex64 {
	return __.UintptrWork.Get().(*WorkOfUintptrThenComplex64)
}
func (__ *PoolOfUintptrThenComplex64Impl) PutWorkOfUintptrThenComplex64(p *WorkOfUintptrThenComplex64) {
	__.UintptrWork.Put(p)
}
func (__ *PoolOfUintptrThenComplex64Impl) GetReturnOfComplex64() *ReturnOfComplex64 {
	return __.Complex64Return.Get().(*ReturnOfComplex64)
}
func (__ *PoolOfUintptrThenComplex64Impl) PutReturnOfComplex64(p *ReturnOfComplex64) {
	__.Complex64Return.Put(p)
}

func (__ *PoolOfUintptrThenComplex64Impl) GetChReturnOfComplex64() chan *ReturnOfComplex64 {
	return __.ChReturnOfComplex64.Get().(chan *ReturnOfComplex64)
}
func (__ *PoolOfUintptrThenComplex64Impl) PutChReturnOfComplex64(p chan *ReturnOfComplex64) {
	__.ChReturnOfComplex64.Put(p)
}

func NewPoolOfUintptrThenComplex64Impl() *PoolOfUintptrThenComplex64Impl {
	return &PoolOfUintptrThenComplex64Impl{
		UintptrArg: sync.Pool{
			New: func() interface{} {
				return new(uintptr)
			},
		},
		UintptrWork: sync.Pool{
			New: func() interface{} {
				return new(WorkOfUintptrThenComplex64)
			},
		},
		Complex64Rtn: sync.Pool{
			New: func() interface{} {
				return new(complex64)
			},
		},
		Complex64Return: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfComplex64)
			},
		},
		ChReturnOfComplex64: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfComplex64, 1)
			},
		},
	}
}

type ApiDecouplerOfUintptrThenComplex64 struct {
	pool PoolOfUintptrThenComplex64
}

func NewApiDecouplerOfUintptrThenComplex64() *ApiDecouplerOfUintptrThenComplex64 {
	return &ApiDecouplerOfUintptrThenComplex64{
		pool: NewPoolOfUintptrThenComplex64Impl(),
	}
}

func (__ *ApiDecouplerOfUintptrThenComplex64) ReturnError(rtn_ch chan<- *ReturnOfComplex64, err error) {
	rtn := __.pool.GetReturnOfComplex64()
	var other complex64
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfUintptrThenComplex64) HandleOfUintptrThenComplex64(ctx context.Context, req *WorkOfUintptrThenComplex64, h func(ctx context.Context, arg uintptr) (complex64, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfComplex64()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfUintptrThenComplex64) DoOfUintptrThenComplex64(ctx context.Context, worker WorkerOfPushUintptrThenComplex64, arg uintptr) (complex64, error) {
	// ch := make(chan *ReturnOfComplex64, 1)
	ch := __.pool.GetChReturnOfComplex64()
	defer __.pool.PutChReturnOfComplex64(ch)

	req := __.pool.GetWorkOfUintptrThenComplex64()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfUintptrThenComplex64(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfComplex64(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfUintptrThenComplex64 = func(ctx context.Context, arg uintptr) (complex64, error)

type WorkerOfUintptrThenComplex64 struct {
	api_syncer *ApiDecouplerOfUintptrThenComplex64
	handler    WorkHandlerOfUintptrThenComplex64

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfUintptrThenComplex64
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfUintptrThenComplex64(ctx context.Context, h WorkHandlerOfUintptrThenComplex64, n int) *WorkerOfUintptrThenComplex64 {
	__ := &WorkerOfUintptrThenComplex64{
		api_syncer: NewApiDecouplerOfUintptrThenComplex64(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfUintptrThenComplex64, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfUintptrThenComplex64{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfUintptrThenComplex64(req.Context, req.WorkOfUintptrThenComplex64, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfUintptrThenComplex64) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfUintptrThenComplex64) Push(ctx context.Context, req *WorkOfUintptrThenComplex64) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfUintptrThenComplex64)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfUintptrThenComplex64 = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfUintptrThenComplex64) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfUintptrThenComplex64) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfUintptrThenComplex64) Call(ctx context.Context, arg uintptr) (complex64, error) {
	return __.api_syncer.DoOfUintptrThenComplex64(ctx, __, arg)
}

type PoolOfUintptrThenError interface {
	GetUintptrArg() *uintptr
	PutUintptrArg(*uintptr)
	GetErrorReturn() *error
	PutErrorReturn(*error)

	GetWorkOfUintptrThenError() *WorkOfUintptrThenError
	GetReturnOfError() *ReturnOfError
	PutWorkOfUintptrThenError(*WorkOfUintptrThenError)
	PutReturnOfError(*ReturnOfError)

	GetChReturnOfError() chan *ReturnOfError
	PutChReturnOfError(chan *ReturnOfError)
}

type PoolOfUintptrThenErrorImpl struct {
	UintptrArg      sync.Pool
	ErrorRtn        sync.Pool
	UintptrWork     sync.Pool
	ErrorReturn     sync.Pool
	ChReturnOfError sync.Pool
}

func (__ *PoolOfUintptrThenErrorImpl) GetUintptrArg() *uintptr {
	return __.UintptrArg.Get().(*uintptr)
}
func (__ *PoolOfUintptrThenErrorImpl) PutUintptrArg(p *uintptr) {
	__.UintptrArg.Put(p)
}
func (__ *PoolOfUintptrThenErrorImpl) GetErrorReturn() *error {
	return __.ErrorRtn.Get().(*error)
}
func (__ *PoolOfUintptrThenErrorImpl) PutErrorReturn(p *error) {
	__.ErrorRtn.Put(p)
}

func (__ *PoolOfUintptrThenErrorImpl) GetWorkOfUintptrThenError() *WorkOfUintptrThenError {
	return __.UintptrWork.Get().(*WorkOfUintptrThenError)
}
func (__ *PoolOfUintptrThenErrorImpl) PutWorkOfUintptrThenError(p *WorkOfUintptrThenError) {
	__.UintptrWork.Put(p)
}
func (__ *PoolOfUintptrThenErrorImpl) GetReturnOfError() *ReturnOfError {
	return __.ErrorReturn.Get().(*ReturnOfError)
}
func (__ *PoolOfUintptrThenErrorImpl) PutReturnOfError(p *ReturnOfError) {
	__.ErrorReturn.Put(p)
}

func (__ *PoolOfUintptrThenErrorImpl) GetChReturnOfError() chan *ReturnOfError {
	return __.ChReturnOfError.Get().(chan *ReturnOfError)
}
func (__ *PoolOfUintptrThenErrorImpl) PutChReturnOfError(p chan *ReturnOfError) {
	__.ChReturnOfError.Put(p)
}

func NewPoolOfUintptrThenErrorImpl() *PoolOfUintptrThenErrorImpl {
	return &PoolOfUintptrThenErrorImpl{
		UintptrArg: sync.Pool{
			New: func() interface{} {
				return new(uintptr)
			},
		},
		UintptrWork: sync.Pool{
			New: func() interface{} {
				return new(WorkOfUintptrThenError)
			},
		},
		ErrorRtn: sync.Pool{
			New: func() interface{} {
				return new(error)
			},
		},
		ErrorReturn: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfError)
			},
		},
		ChReturnOfError: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfError, 1)
			},
		},
	}
}

type ApiDecouplerOfUintptrThenError struct {
	pool PoolOfUintptrThenError
}

func NewApiDecouplerOfUintptrThenError() *ApiDecouplerOfUintptrThenError {
	return &ApiDecouplerOfUintptrThenError{
		pool: NewPoolOfUintptrThenErrorImpl(),
	}
}

func (__ *ApiDecouplerOfUintptrThenError) ReturnError(rtn_ch chan<- *ReturnOfError, err error) {
	rtn := __.pool.GetReturnOfError()
	var other error
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfUintptrThenError) HandleOfUintptrThenError(ctx context.Context, req *WorkOfUintptrThenError, h func(ctx context.Context, arg uintptr) (error, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfError()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfUintptrThenError) DoOfUintptrThenError(ctx context.Context, worker WorkerOfPushUintptrThenError, arg uintptr) (error, error) {
	// ch := make(chan *ReturnOfError, 1)
	ch := __.pool.GetChReturnOfError()
	defer __.pool.PutChReturnOfError(ch)

	req := __.pool.GetWorkOfUintptrThenError()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfUintptrThenError(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfError(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfUintptrThenError = func(ctx context.Context, arg uintptr) (error, error)

type WorkerOfUintptrThenError struct {
	api_syncer *ApiDecouplerOfUintptrThenError
	handler    WorkHandlerOfUintptrThenError

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfUintptrThenError
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfUintptrThenError(ctx context.Context, h WorkHandlerOfUintptrThenError, n int) *WorkerOfUintptrThenError {
	__ := &WorkerOfUintptrThenError{
		api_syncer: NewApiDecouplerOfUintptrThenError(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfUintptrThenError, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfUintptrThenError{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfUintptrThenError(req.Context, req.WorkOfUintptrThenError, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfUintptrThenError) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfUintptrThenError) Push(ctx context.Context, req *WorkOfUintptrThenError) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfUintptrThenError)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfUintptrThenError = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfUintptrThenError) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfUintptrThenError) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfUintptrThenError) Call(ctx context.Context, arg uintptr) (error, error) {
	return __.api_syncer.DoOfUintptrThenError(ctx, __, arg)
}

type PoolOfUintptrThenFloat32 interface {
	GetUintptrArg() *uintptr
	PutUintptrArg(*uintptr)
	GetFloat32Return() *float32
	PutFloat32Return(*float32)

	GetWorkOfUintptrThenFloat32() *WorkOfUintptrThenFloat32
	GetReturnOfFloat32() *ReturnOfFloat32
	PutWorkOfUintptrThenFloat32(*WorkOfUintptrThenFloat32)
	PutReturnOfFloat32(*ReturnOfFloat32)

	GetChReturnOfFloat32() chan *ReturnOfFloat32
	PutChReturnOfFloat32(chan *ReturnOfFloat32)
}

type PoolOfUintptrThenFloat32Impl struct {
	UintptrArg        sync.Pool
	Float32Rtn        sync.Pool
	UintptrWork       sync.Pool
	Float32Return     sync.Pool
	ChReturnOfFloat32 sync.Pool
}

func (__ *PoolOfUintptrThenFloat32Impl) GetUintptrArg() *uintptr {
	return __.UintptrArg.Get().(*uintptr)
}
func (__ *PoolOfUintptrThenFloat32Impl) PutUintptrArg(p *uintptr) {
	__.UintptrArg.Put(p)
}
func (__ *PoolOfUintptrThenFloat32Impl) GetFloat32Return() *float32 {
	return __.Float32Rtn.Get().(*float32)
}
func (__ *PoolOfUintptrThenFloat32Impl) PutFloat32Return(p *float32) {
	__.Float32Rtn.Put(p)
}

func (__ *PoolOfUintptrThenFloat32Impl) GetWorkOfUintptrThenFloat32() *WorkOfUintptrThenFloat32 {
	return __.UintptrWork.Get().(*WorkOfUintptrThenFloat32)
}
func (__ *PoolOfUintptrThenFloat32Impl) PutWorkOfUintptrThenFloat32(p *WorkOfUintptrThenFloat32) {
	__.UintptrWork.Put(p)
}
func (__ *PoolOfUintptrThenFloat32Impl) GetReturnOfFloat32() *ReturnOfFloat32 {
	return __.Float32Return.Get().(*ReturnOfFloat32)
}
func (__ *PoolOfUintptrThenFloat32Impl) PutReturnOfFloat32(p *ReturnOfFloat32) {
	__.Float32Return.Put(p)
}

func (__ *PoolOfUintptrThenFloat32Impl) GetChReturnOfFloat32() chan *ReturnOfFloat32 {
	return __.ChReturnOfFloat32.Get().(chan *ReturnOfFloat32)
}
func (__ *PoolOfUintptrThenFloat32Impl) PutChReturnOfFloat32(p chan *ReturnOfFloat32) {
	__.ChReturnOfFloat32.Put(p)
}

func NewPoolOfUintptrThenFloat32Impl() *PoolOfUintptrThenFloat32Impl {
	return &PoolOfUintptrThenFloat32Impl{
		UintptrArg: sync.Pool{
			New: func() interface{} {
				return new(uintptr)
			},
		},
		UintptrWork: sync.Pool{
			New: func() interface{} {
				return new(WorkOfUintptrThenFloat32)
			},
		},
		Float32Rtn: sync.Pool{
			New: func() interface{} {
				return new(float32)
			},
		},
		Float32Return: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfFloat32)
			},
		},
		ChReturnOfFloat32: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfFloat32, 1)
			},
		},
	}
}

type ApiDecouplerOfUintptrThenFloat32 struct {
	pool PoolOfUintptrThenFloat32
}

func NewApiDecouplerOfUintptrThenFloat32() *ApiDecouplerOfUintptrThenFloat32 {
	return &ApiDecouplerOfUintptrThenFloat32{
		pool: NewPoolOfUintptrThenFloat32Impl(),
	}
}

func (__ *ApiDecouplerOfUintptrThenFloat32) ReturnError(rtn_ch chan<- *ReturnOfFloat32, err error) {
	rtn := __.pool.GetReturnOfFloat32()
	var other float32
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfUintptrThenFloat32) HandleOfUintptrThenFloat32(ctx context.Context, req *WorkOfUintptrThenFloat32, h func(ctx context.Context, arg uintptr) (float32, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfFloat32()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfUintptrThenFloat32) DoOfUintptrThenFloat32(ctx context.Context, worker WorkerOfPushUintptrThenFloat32, arg uintptr) (float32, error) {
	// ch := make(chan *ReturnOfFloat32, 1)
	ch := __.pool.GetChReturnOfFloat32()
	defer __.pool.PutChReturnOfFloat32(ch)

	req := __.pool.GetWorkOfUintptrThenFloat32()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfUintptrThenFloat32(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfFloat32(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfUintptrThenFloat32 = func(ctx context.Context, arg uintptr) (float32, error)

type WorkerOfUintptrThenFloat32 struct {
	api_syncer *ApiDecouplerOfUintptrThenFloat32
	handler    WorkHandlerOfUintptrThenFloat32

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfUintptrThenFloat32
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfUintptrThenFloat32(ctx context.Context, h WorkHandlerOfUintptrThenFloat32, n int) *WorkerOfUintptrThenFloat32 {
	__ := &WorkerOfUintptrThenFloat32{
		api_syncer: NewApiDecouplerOfUintptrThenFloat32(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfUintptrThenFloat32, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfUintptrThenFloat32{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfUintptrThenFloat32(req.Context, req.WorkOfUintptrThenFloat32, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfUintptrThenFloat32) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfUintptrThenFloat32) Push(ctx context.Context, req *WorkOfUintptrThenFloat32) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfUintptrThenFloat32)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfUintptrThenFloat32 = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfUintptrThenFloat32) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfUintptrThenFloat32) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfUintptrThenFloat32) Call(ctx context.Context, arg uintptr) (float32, error) {
	return __.api_syncer.DoOfUintptrThenFloat32(ctx, __, arg)
}

type PoolOfUintptrThenFloat64 interface {
	GetUintptrArg() *uintptr
	PutUintptrArg(*uintptr)
	GetFloat64Return() *float64
	PutFloat64Return(*float64)

	GetWorkOfUintptrThenFloat64() *WorkOfUintptrThenFloat64
	GetReturnOfFloat64() *ReturnOfFloat64
	PutWorkOfUintptrThenFloat64(*WorkOfUintptrThenFloat64)
	PutReturnOfFloat64(*ReturnOfFloat64)

	GetChReturnOfFloat64() chan *ReturnOfFloat64
	PutChReturnOfFloat64(chan *ReturnOfFloat64)
}

type PoolOfUintptrThenFloat64Impl struct {
	UintptrArg        sync.Pool
	Float64Rtn        sync.Pool
	UintptrWork       sync.Pool
	Float64Return     sync.Pool
	ChReturnOfFloat64 sync.Pool
}

func (__ *PoolOfUintptrThenFloat64Impl) GetUintptrArg() *uintptr {
	return __.UintptrArg.Get().(*uintptr)
}
func (__ *PoolOfUintptrThenFloat64Impl) PutUintptrArg(p *uintptr) {
	__.UintptrArg.Put(p)
}
func (__ *PoolOfUintptrThenFloat64Impl) GetFloat64Return() *float64 {
	return __.Float64Rtn.Get().(*float64)
}
func (__ *PoolOfUintptrThenFloat64Impl) PutFloat64Return(p *float64) {
	__.Float64Rtn.Put(p)
}

func (__ *PoolOfUintptrThenFloat64Impl) GetWorkOfUintptrThenFloat64() *WorkOfUintptrThenFloat64 {
	return __.UintptrWork.Get().(*WorkOfUintptrThenFloat64)
}
func (__ *PoolOfUintptrThenFloat64Impl) PutWorkOfUintptrThenFloat64(p *WorkOfUintptrThenFloat64) {
	__.UintptrWork.Put(p)
}
func (__ *PoolOfUintptrThenFloat64Impl) GetReturnOfFloat64() *ReturnOfFloat64 {
	return __.Float64Return.Get().(*ReturnOfFloat64)
}
func (__ *PoolOfUintptrThenFloat64Impl) PutReturnOfFloat64(p *ReturnOfFloat64) {
	__.Float64Return.Put(p)
}

func (__ *PoolOfUintptrThenFloat64Impl) GetChReturnOfFloat64() chan *ReturnOfFloat64 {
	return __.ChReturnOfFloat64.Get().(chan *ReturnOfFloat64)
}
func (__ *PoolOfUintptrThenFloat64Impl) PutChReturnOfFloat64(p chan *ReturnOfFloat64) {
	__.ChReturnOfFloat64.Put(p)
}

func NewPoolOfUintptrThenFloat64Impl() *PoolOfUintptrThenFloat64Impl {
	return &PoolOfUintptrThenFloat64Impl{
		UintptrArg: sync.Pool{
			New: func() interface{} {
				return new(uintptr)
			},
		},
		UintptrWork: sync.Pool{
			New: func() interface{} {
				return new(WorkOfUintptrThenFloat64)
			},
		},
		Float64Rtn: sync.Pool{
			New: func() interface{} {
				return new(float64)
			},
		},
		Float64Return: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfFloat64)
			},
		},
		ChReturnOfFloat64: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfFloat64, 1)
			},
		},
	}
}

type ApiDecouplerOfUintptrThenFloat64 struct {
	pool PoolOfUintptrThenFloat64
}

func NewApiDecouplerOfUintptrThenFloat64() *ApiDecouplerOfUintptrThenFloat64 {
	return &ApiDecouplerOfUintptrThenFloat64{
		pool: NewPoolOfUintptrThenFloat64Impl(),
	}
}

func (__ *ApiDecouplerOfUintptrThenFloat64) ReturnError(rtn_ch chan<- *ReturnOfFloat64, err error) {
	rtn := __.pool.GetReturnOfFloat64()
	var other float64
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfUintptrThenFloat64) HandleOfUintptrThenFloat64(ctx context.Context, req *WorkOfUintptrThenFloat64, h func(ctx context.Context, arg uintptr) (float64, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfFloat64()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfUintptrThenFloat64) DoOfUintptrThenFloat64(ctx context.Context, worker WorkerOfPushUintptrThenFloat64, arg uintptr) (float64, error) {
	// ch := make(chan *ReturnOfFloat64, 1)
	ch := __.pool.GetChReturnOfFloat64()
	defer __.pool.PutChReturnOfFloat64(ch)

	req := __.pool.GetWorkOfUintptrThenFloat64()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfUintptrThenFloat64(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfFloat64(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfUintptrThenFloat64 = func(ctx context.Context, arg uintptr) (float64, error)

type WorkerOfUintptrThenFloat64 struct {
	api_syncer *ApiDecouplerOfUintptrThenFloat64
	handler    WorkHandlerOfUintptrThenFloat64

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfUintptrThenFloat64
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfUintptrThenFloat64(ctx context.Context, h WorkHandlerOfUintptrThenFloat64, n int) *WorkerOfUintptrThenFloat64 {
	__ := &WorkerOfUintptrThenFloat64{
		api_syncer: NewApiDecouplerOfUintptrThenFloat64(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfUintptrThenFloat64, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfUintptrThenFloat64{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfUintptrThenFloat64(req.Context, req.WorkOfUintptrThenFloat64, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfUintptrThenFloat64) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfUintptrThenFloat64) Push(ctx context.Context, req *WorkOfUintptrThenFloat64) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfUintptrThenFloat64)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfUintptrThenFloat64 = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfUintptrThenFloat64) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfUintptrThenFloat64) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfUintptrThenFloat64) Call(ctx context.Context, arg uintptr) (float64, error) {
	return __.api_syncer.DoOfUintptrThenFloat64(ctx, __, arg)
}

type PoolOfUintptrThenInt interface {
	GetUintptrArg() *uintptr
	PutUintptrArg(*uintptr)
	GetIntReturn() *int
	PutIntReturn(*int)

	GetWorkOfUintptrThenInt() *WorkOfUintptrThenInt
	GetReturnOfInt() *ReturnOfInt
	PutWorkOfUintptrThenInt(*WorkOfUintptrThenInt)
	PutReturnOfInt(*ReturnOfInt)

	GetChReturnOfInt() chan *ReturnOfInt
	PutChReturnOfInt(chan *ReturnOfInt)
}

type PoolOfUintptrThenIntImpl struct {
	UintptrArg    sync.Pool
	IntRtn        sync.Pool
	UintptrWork   sync.Pool
	IntReturn     sync.Pool
	ChReturnOfInt sync.Pool
}

func (__ *PoolOfUintptrThenIntImpl) GetUintptrArg() *uintptr {
	return __.UintptrArg.Get().(*uintptr)
}
func (__ *PoolOfUintptrThenIntImpl) PutUintptrArg(p *uintptr) {
	__.UintptrArg.Put(p)
}
func (__ *PoolOfUintptrThenIntImpl) GetIntReturn() *int {
	return __.IntRtn.Get().(*int)
}
func (__ *PoolOfUintptrThenIntImpl) PutIntReturn(p *int) {
	__.IntRtn.Put(p)
}

func (__ *PoolOfUintptrThenIntImpl) GetWorkOfUintptrThenInt() *WorkOfUintptrThenInt {
	return __.UintptrWork.Get().(*WorkOfUintptrThenInt)
}
func (__ *PoolOfUintptrThenIntImpl) PutWorkOfUintptrThenInt(p *WorkOfUintptrThenInt) {
	__.UintptrWork.Put(p)
}
func (__ *PoolOfUintptrThenIntImpl) GetReturnOfInt() *ReturnOfInt {
	return __.IntReturn.Get().(*ReturnOfInt)
}
func (__ *PoolOfUintptrThenIntImpl) PutReturnOfInt(p *ReturnOfInt) {
	__.IntReturn.Put(p)
}

func (__ *PoolOfUintptrThenIntImpl) GetChReturnOfInt() chan *ReturnOfInt {
	return __.ChReturnOfInt.Get().(chan *ReturnOfInt)
}
func (__ *PoolOfUintptrThenIntImpl) PutChReturnOfInt(p chan *ReturnOfInt) {
	__.ChReturnOfInt.Put(p)
}

func NewPoolOfUintptrThenIntImpl() *PoolOfUintptrThenIntImpl {
	return &PoolOfUintptrThenIntImpl{
		UintptrArg: sync.Pool{
			New: func() interface{} {
				return new(uintptr)
			},
		},
		UintptrWork: sync.Pool{
			New: func() interface{} {
				return new(WorkOfUintptrThenInt)
			},
		},
		IntRtn: sync.Pool{
			New: func() interface{} {
				return new(int)
			},
		},
		IntReturn: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfInt)
			},
		},
		ChReturnOfInt: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfInt, 1)
			},
		},
	}
}

type ApiDecouplerOfUintptrThenInt struct {
	pool PoolOfUintptrThenInt
}

func NewApiDecouplerOfUintptrThenInt() *ApiDecouplerOfUintptrThenInt {
	return &ApiDecouplerOfUintptrThenInt{
		pool: NewPoolOfUintptrThenIntImpl(),
	}
}

func (__ *ApiDecouplerOfUintptrThenInt) ReturnError(rtn_ch chan<- *ReturnOfInt, err error) {
	rtn := __.pool.GetReturnOfInt()
	var other int
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfUintptrThenInt) HandleOfUintptrThenInt(ctx context.Context, req *WorkOfUintptrThenInt, h func(ctx context.Context, arg uintptr) (int, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfInt()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfUintptrThenInt) DoOfUintptrThenInt(ctx context.Context, worker WorkerOfPushUintptrThenInt, arg uintptr) (int, error) {
	// ch := make(chan *ReturnOfInt, 1)
	ch := __.pool.GetChReturnOfInt()
	defer __.pool.PutChReturnOfInt(ch)

	req := __.pool.GetWorkOfUintptrThenInt()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfUintptrThenInt(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfInt(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfUintptrThenInt = func(ctx context.Context, arg uintptr) (int, error)

type WorkerOfUintptrThenInt struct {
	api_syncer *ApiDecouplerOfUintptrThenInt
	handler    WorkHandlerOfUintptrThenInt

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfUintptrThenInt
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfUintptrThenInt(ctx context.Context, h WorkHandlerOfUintptrThenInt, n int) *WorkerOfUintptrThenInt {
	__ := &WorkerOfUintptrThenInt{
		api_syncer: NewApiDecouplerOfUintptrThenInt(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfUintptrThenInt, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfUintptrThenInt{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfUintptrThenInt(req.Context, req.WorkOfUintptrThenInt, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfUintptrThenInt) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfUintptrThenInt) Push(ctx context.Context, req *WorkOfUintptrThenInt) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfUintptrThenInt)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfUintptrThenInt = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfUintptrThenInt) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfUintptrThenInt) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfUintptrThenInt) Call(ctx context.Context, arg uintptr) (int, error) {
	return __.api_syncer.DoOfUintptrThenInt(ctx, __, arg)
}

type PoolOfUintptrThenInt16 interface {
	GetUintptrArg() *uintptr
	PutUintptrArg(*uintptr)
	GetInt16Return() *int16
	PutInt16Return(*int16)

	GetWorkOfUintptrThenInt16() *WorkOfUintptrThenInt16
	GetReturnOfInt16() *ReturnOfInt16
	PutWorkOfUintptrThenInt16(*WorkOfUintptrThenInt16)
	PutReturnOfInt16(*ReturnOfInt16)

	GetChReturnOfInt16() chan *ReturnOfInt16
	PutChReturnOfInt16(chan *ReturnOfInt16)
}

type PoolOfUintptrThenInt16Impl struct {
	UintptrArg      sync.Pool
	Int16Rtn        sync.Pool
	UintptrWork     sync.Pool
	Int16Return     sync.Pool
	ChReturnOfInt16 sync.Pool
}

func (__ *PoolOfUintptrThenInt16Impl) GetUintptrArg() *uintptr {
	return __.UintptrArg.Get().(*uintptr)
}
func (__ *PoolOfUintptrThenInt16Impl) PutUintptrArg(p *uintptr) {
	__.UintptrArg.Put(p)
}
func (__ *PoolOfUintptrThenInt16Impl) GetInt16Return() *int16 {
	return __.Int16Rtn.Get().(*int16)
}
func (__ *PoolOfUintptrThenInt16Impl) PutInt16Return(p *int16) {
	__.Int16Rtn.Put(p)
}

func (__ *PoolOfUintptrThenInt16Impl) GetWorkOfUintptrThenInt16() *WorkOfUintptrThenInt16 {
	return __.UintptrWork.Get().(*WorkOfUintptrThenInt16)
}
func (__ *PoolOfUintptrThenInt16Impl) PutWorkOfUintptrThenInt16(p *WorkOfUintptrThenInt16) {
	__.UintptrWork.Put(p)
}
func (__ *PoolOfUintptrThenInt16Impl) GetReturnOfInt16() *ReturnOfInt16 {
	return __.Int16Return.Get().(*ReturnOfInt16)
}
func (__ *PoolOfUintptrThenInt16Impl) PutReturnOfInt16(p *ReturnOfInt16) {
	__.Int16Return.Put(p)
}

func (__ *PoolOfUintptrThenInt16Impl) GetChReturnOfInt16() chan *ReturnOfInt16 {
	return __.ChReturnOfInt16.Get().(chan *ReturnOfInt16)
}
func (__ *PoolOfUintptrThenInt16Impl) PutChReturnOfInt16(p chan *ReturnOfInt16) {
	__.ChReturnOfInt16.Put(p)
}

func NewPoolOfUintptrThenInt16Impl() *PoolOfUintptrThenInt16Impl {
	return &PoolOfUintptrThenInt16Impl{
		UintptrArg: sync.Pool{
			New: func() interface{} {
				return new(uintptr)
			},
		},
		UintptrWork: sync.Pool{
			New: func() interface{} {
				return new(WorkOfUintptrThenInt16)
			},
		},
		Int16Rtn: sync.Pool{
			New: func() interface{} {
				return new(int16)
			},
		},
		Int16Return: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfInt16)
			},
		},
		ChReturnOfInt16: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfInt16, 1)
			},
		},
	}
}

type ApiDecouplerOfUintptrThenInt16 struct {
	pool PoolOfUintptrThenInt16
}

func NewApiDecouplerOfUintptrThenInt16() *ApiDecouplerOfUintptrThenInt16 {
	return &ApiDecouplerOfUintptrThenInt16{
		pool: NewPoolOfUintptrThenInt16Impl(),
	}
}

func (__ *ApiDecouplerOfUintptrThenInt16) ReturnError(rtn_ch chan<- *ReturnOfInt16, err error) {
	rtn := __.pool.GetReturnOfInt16()
	var other int16
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfUintptrThenInt16) HandleOfUintptrThenInt16(ctx context.Context, req *WorkOfUintptrThenInt16, h func(ctx context.Context, arg uintptr) (int16, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfInt16()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfUintptrThenInt16) DoOfUintptrThenInt16(ctx context.Context, worker WorkerOfPushUintptrThenInt16, arg uintptr) (int16, error) {
	// ch := make(chan *ReturnOfInt16, 1)
	ch := __.pool.GetChReturnOfInt16()
	defer __.pool.PutChReturnOfInt16(ch)

	req := __.pool.GetWorkOfUintptrThenInt16()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfUintptrThenInt16(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfInt16(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfUintptrThenInt16 = func(ctx context.Context, arg uintptr) (int16, error)

type WorkerOfUintptrThenInt16 struct {
	api_syncer *ApiDecouplerOfUintptrThenInt16
	handler    WorkHandlerOfUintptrThenInt16

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfUintptrThenInt16
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfUintptrThenInt16(ctx context.Context, h WorkHandlerOfUintptrThenInt16, n int) *WorkerOfUintptrThenInt16 {
	__ := &WorkerOfUintptrThenInt16{
		api_syncer: NewApiDecouplerOfUintptrThenInt16(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfUintptrThenInt16, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfUintptrThenInt16{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfUintptrThenInt16(req.Context, req.WorkOfUintptrThenInt16, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfUintptrThenInt16) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfUintptrThenInt16) Push(ctx context.Context, req *WorkOfUintptrThenInt16) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfUintptrThenInt16)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfUintptrThenInt16 = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfUintptrThenInt16) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfUintptrThenInt16) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfUintptrThenInt16) Call(ctx context.Context, arg uintptr) (int16, error) {
	return __.api_syncer.DoOfUintptrThenInt16(ctx, __, arg)
}

type PoolOfUintptrThenInt32 interface {
	GetUintptrArg() *uintptr
	PutUintptrArg(*uintptr)
	GetInt32Return() *int32
	PutInt32Return(*int32)

	GetWorkOfUintptrThenInt32() *WorkOfUintptrThenInt32
	GetReturnOfInt32() *ReturnOfInt32
	PutWorkOfUintptrThenInt32(*WorkOfUintptrThenInt32)
	PutReturnOfInt32(*ReturnOfInt32)

	GetChReturnOfInt32() chan *ReturnOfInt32
	PutChReturnOfInt32(chan *ReturnOfInt32)
}

type PoolOfUintptrThenInt32Impl struct {
	UintptrArg      sync.Pool
	Int32Rtn        sync.Pool
	UintptrWork     sync.Pool
	Int32Return     sync.Pool
	ChReturnOfInt32 sync.Pool
}

func (__ *PoolOfUintptrThenInt32Impl) GetUintptrArg() *uintptr {
	return __.UintptrArg.Get().(*uintptr)
}
func (__ *PoolOfUintptrThenInt32Impl) PutUintptrArg(p *uintptr) {
	__.UintptrArg.Put(p)
}
func (__ *PoolOfUintptrThenInt32Impl) GetInt32Return() *int32 {
	return __.Int32Rtn.Get().(*int32)
}
func (__ *PoolOfUintptrThenInt32Impl) PutInt32Return(p *int32) {
	__.Int32Rtn.Put(p)
}

func (__ *PoolOfUintptrThenInt32Impl) GetWorkOfUintptrThenInt32() *WorkOfUintptrThenInt32 {
	return __.UintptrWork.Get().(*WorkOfUintptrThenInt32)
}
func (__ *PoolOfUintptrThenInt32Impl) PutWorkOfUintptrThenInt32(p *WorkOfUintptrThenInt32) {
	__.UintptrWork.Put(p)
}
func (__ *PoolOfUintptrThenInt32Impl) GetReturnOfInt32() *ReturnOfInt32 {
	return __.Int32Return.Get().(*ReturnOfInt32)
}
func (__ *PoolOfUintptrThenInt32Impl) PutReturnOfInt32(p *ReturnOfInt32) {
	__.Int32Return.Put(p)
}

func (__ *PoolOfUintptrThenInt32Impl) GetChReturnOfInt32() chan *ReturnOfInt32 {
	return __.ChReturnOfInt32.Get().(chan *ReturnOfInt32)
}
func (__ *PoolOfUintptrThenInt32Impl) PutChReturnOfInt32(p chan *ReturnOfInt32) {
	__.ChReturnOfInt32.Put(p)
}

func NewPoolOfUintptrThenInt32Impl() *PoolOfUintptrThenInt32Impl {
	return &PoolOfUintptrThenInt32Impl{
		UintptrArg: sync.Pool{
			New: func() interface{} {
				return new(uintptr)
			},
		},
		UintptrWork: sync.Pool{
			New: func() interface{} {
				return new(WorkOfUintptrThenInt32)
			},
		},
		Int32Rtn: sync.Pool{
			New: func() interface{} {
				return new(int32)
			},
		},
		Int32Return: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfInt32)
			},
		},
		ChReturnOfInt32: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfInt32, 1)
			},
		},
	}
}

type ApiDecouplerOfUintptrThenInt32 struct {
	pool PoolOfUintptrThenInt32
}

func NewApiDecouplerOfUintptrThenInt32() *ApiDecouplerOfUintptrThenInt32 {
	return &ApiDecouplerOfUintptrThenInt32{
		pool: NewPoolOfUintptrThenInt32Impl(),
	}
}

func (__ *ApiDecouplerOfUintptrThenInt32) ReturnError(rtn_ch chan<- *ReturnOfInt32, err error) {
	rtn := __.pool.GetReturnOfInt32()
	var other int32
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfUintptrThenInt32) HandleOfUintptrThenInt32(ctx context.Context, req *WorkOfUintptrThenInt32, h func(ctx context.Context, arg uintptr) (int32, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfInt32()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfUintptrThenInt32) DoOfUintptrThenInt32(ctx context.Context, worker WorkerOfPushUintptrThenInt32, arg uintptr) (int32, error) {
	// ch := make(chan *ReturnOfInt32, 1)
	ch := __.pool.GetChReturnOfInt32()
	defer __.pool.PutChReturnOfInt32(ch)

	req := __.pool.GetWorkOfUintptrThenInt32()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfUintptrThenInt32(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfInt32(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfUintptrThenInt32 = func(ctx context.Context, arg uintptr) (int32, error)

type WorkerOfUintptrThenInt32 struct {
	api_syncer *ApiDecouplerOfUintptrThenInt32
	handler    WorkHandlerOfUintptrThenInt32

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfUintptrThenInt32
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfUintptrThenInt32(ctx context.Context, h WorkHandlerOfUintptrThenInt32, n int) *WorkerOfUintptrThenInt32 {
	__ := &WorkerOfUintptrThenInt32{
		api_syncer: NewApiDecouplerOfUintptrThenInt32(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfUintptrThenInt32, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfUintptrThenInt32{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfUintptrThenInt32(req.Context, req.WorkOfUintptrThenInt32, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfUintptrThenInt32) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfUintptrThenInt32) Push(ctx context.Context, req *WorkOfUintptrThenInt32) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfUintptrThenInt32)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfUintptrThenInt32 = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfUintptrThenInt32) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfUintptrThenInt32) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfUintptrThenInt32) Call(ctx context.Context, arg uintptr) (int32, error) {
	return __.api_syncer.DoOfUintptrThenInt32(ctx, __, arg)
}

type PoolOfUintptrThenInt64 interface {
	GetUintptrArg() *uintptr
	PutUintptrArg(*uintptr)
	GetInt64Return() *int64
	PutInt64Return(*int64)

	GetWorkOfUintptrThenInt64() *WorkOfUintptrThenInt64
	GetReturnOfInt64() *ReturnOfInt64
	PutWorkOfUintptrThenInt64(*WorkOfUintptrThenInt64)
	PutReturnOfInt64(*ReturnOfInt64)

	GetChReturnOfInt64() chan *ReturnOfInt64
	PutChReturnOfInt64(chan *ReturnOfInt64)
}

type PoolOfUintptrThenInt64Impl struct {
	UintptrArg      sync.Pool
	Int64Rtn        sync.Pool
	UintptrWork     sync.Pool
	Int64Return     sync.Pool
	ChReturnOfInt64 sync.Pool
}

func (__ *PoolOfUintptrThenInt64Impl) GetUintptrArg() *uintptr {
	return __.UintptrArg.Get().(*uintptr)
}
func (__ *PoolOfUintptrThenInt64Impl) PutUintptrArg(p *uintptr) {
	__.UintptrArg.Put(p)
}
func (__ *PoolOfUintptrThenInt64Impl) GetInt64Return() *int64 {
	return __.Int64Rtn.Get().(*int64)
}
func (__ *PoolOfUintptrThenInt64Impl) PutInt64Return(p *int64) {
	__.Int64Rtn.Put(p)
}

func (__ *PoolOfUintptrThenInt64Impl) GetWorkOfUintptrThenInt64() *WorkOfUintptrThenInt64 {
	return __.UintptrWork.Get().(*WorkOfUintptrThenInt64)
}
func (__ *PoolOfUintptrThenInt64Impl) PutWorkOfUintptrThenInt64(p *WorkOfUintptrThenInt64) {
	__.UintptrWork.Put(p)
}
func (__ *PoolOfUintptrThenInt64Impl) GetReturnOfInt64() *ReturnOfInt64 {
	return __.Int64Return.Get().(*ReturnOfInt64)
}
func (__ *PoolOfUintptrThenInt64Impl) PutReturnOfInt64(p *ReturnOfInt64) {
	__.Int64Return.Put(p)
}

func (__ *PoolOfUintptrThenInt64Impl) GetChReturnOfInt64() chan *ReturnOfInt64 {
	return __.ChReturnOfInt64.Get().(chan *ReturnOfInt64)
}
func (__ *PoolOfUintptrThenInt64Impl) PutChReturnOfInt64(p chan *ReturnOfInt64) {
	__.ChReturnOfInt64.Put(p)
}

func NewPoolOfUintptrThenInt64Impl() *PoolOfUintptrThenInt64Impl {
	return &PoolOfUintptrThenInt64Impl{
		UintptrArg: sync.Pool{
			New: func() interface{} {
				return new(uintptr)
			},
		},
		UintptrWork: sync.Pool{
			New: func() interface{} {
				return new(WorkOfUintptrThenInt64)
			},
		},
		Int64Rtn: sync.Pool{
			New: func() interface{} {
				return new(int64)
			},
		},
		Int64Return: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfInt64)
			},
		},
		ChReturnOfInt64: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfInt64, 1)
			},
		},
	}
}

type ApiDecouplerOfUintptrThenInt64 struct {
	pool PoolOfUintptrThenInt64
}

func NewApiDecouplerOfUintptrThenInt64() *ApiDecouplerOfUintptrThenInt64 {
	return &ApiDecouplerOfUintptrThenInt64{
		pool: NewPoolOfUintptrThenInt64Impl(),
	}
}

func (__ *ApiDecouplerOfUintptrThenInt64) ReturnError(rtn_ch chan<- *ReturnOfInt64, err error) {
	rtn := __.pool.GetReturnOfInt64()
	var other int64
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfUintptrThenInt64) HandleOfUintptrThenInt64(ctx context.Context, req *WorkOfUintptrThenInt64, h func(ctx context.Context, arg uintptr) (int64, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfInt64()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfUintptrThenInt64) DoOfUintptrThenInt64(ctx context.Context, worker WorkerOfPushUintptrThenInt64, arg uintptr) (int64, error) {
	// ch := make(chan *ReturnOfInt64, 1)
	ch := __.pool.GetChReturnOfInt64()
	defer __.pool.PutChReturnOfInt64(ch)

	req := __.pool.GetWorkOfUintptrThenInt64()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfUintptrThenInt64(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfInt64(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfUintptrThenInt64 = func(ctx context.Context, arg uintptr) (int64, error)

type WorkerOfUintptrThenInt64 struct {
	api_syncer *ApiDecouplerOfUintptrThenInt64
	handler    WorkHandlerOfUintptrThenInt64

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfUintptrThenInt64
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfUintptrThenInt64(ctx context.Context, h WorkHandlerOfUintptrThenInt64, n int) *WorkerOfUintptrThenInt64 {
	__ := &WorkerOfUintptrThenInt64{
		api_syncer: NewApiDecouplerOfUintptrThenInt64(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfUintptrThenInt64, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfUintptrThenInt64{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfUintptrThenInt64(req.Context, req.WorkOfUintptrThenInt64, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfUintptrThenInt64) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfUintptrThenInt64) Push(ctx context.Context, req *WorkOfUintptrThenInt64) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfUintptrThenInt64)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfUintptrThenInt64 = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfUintptrThenInt64) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfUintptrThenInt64) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfUintptrThenInt64) Call(ctx context.Context, arg uintptr) (int64, error) {
	return __.api_syncer.DoOfUintptrThenInt64(ctx, __, arg)
}

type PoolOfUintptrThenInt8 interface {
	GetUintptrArg() *uintptr
	PutUintptrArg(*uintptr)
	GetInt8Return() *int8
	PutInt8Return(*int8)

	GetWorkOfUintptrThenInt8() *WorkOfUintptrThenInt8
	GetReturnOfInt8() *ReturnOfInt8
	PutWorkOfUintptrThenInt8(*WorkOfUintptrThenInt8)
	PutReturnOfInt8(*ReturnOfInt8)

	GetChReturnOfInt8() chan *ReturnOfInt8
	PutChReturnOfInt8(chan *ReturnOfInt8)
}

type PoolOfUintptrThenInt8Impl struct {
	UintptrArg     sync.Pool
	Int8Rtn        sync.Pool
	UintptrWork    sync.Pool
	Int8Return     sync.Pool
	ChReturnOfInt8 sync.Pool
}

func (__ *PoolOfUintptrThenInt8Impl) GetUintptrArg() *uintptr {
	return __.UintptrArg.Get().(*uintptr)
}
func (__ *PoolOfUintptrThenInt8Impl) PutUintptrArg(p *uintptr) {
	__.UintptrArg.Put(p)
}
func (__ *PoolOfUintptrThenInt8Impl) GetInt8Return() *int8 {
	return __.Int8Rtn.Get().(*int8)
}
func (__ *PoolOfUintptrThenInt8Impl) PutInt8Return(p *int8) {
	__.Int8Rtn.Put(p)
}

func (__ *PoolOfUintptrThenInt8Impl) GetWorkOfUintptrThenInt8() *WorkOfUintptrThenInt8 {
	return __.UintptrWork.Get().(*WorkOfUintptrThenInt8)
}
func (__ *PoolOfUintptrThenInt8Impl) PutWorkOfUintptrThenInt8(p *WorkOfUintptrThenInt8) {
	__.UintptrWork.Put(p)
}
func (__ *PoolOfUintptrThenInt8Impl) GetReturnOfInt8() *ReturnOfInt8 {
	return __.Int8Return.Get().(*ReturnOfInt8)
}
func (__ *PoolOfUintptrThenInt8Impl) PutReturnOfInt8(p *ReturnOfInt8) {
	__.Int8Return.Put(p)
}

func (__ *PoolOfUintptrThenInt8Impl) GetChReturnOfInt8() chan *ReturnOfInt8 {
	return __.ChReturnOfInt8.Get().(chan *ReturnOfInt8)
}
func (__ *PoolOfUintptrThenInt8Impl) PutChReturnOfInt8(p chan *ReturnOfInt8) {
	__.ChReturnOfInt8.Put(p)
}

func NewPoolOfUintptrThenInt8Impl() *PoolOfUintptrThenInt8Impl {
	return &PoolOfUintptrThenInt8Impl{
		UintptrArg: sync.Pool{
			New: func() interface{} {
				return new(uintptr)
			},
		},
		UintptrWork: sync.Pool{
			New: func() interface{} {
				return new(WorkOfUintptrThenInt8)
			},
		},
		Int8Rtn: sync.Pool{
			New: func() interface{} {
				return new(int8)
			},
		},
		Int8Return: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfInt8)
			},
		},
		ChReturnOfInt8: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfInt8, 1)
			},
		},
	}
}

type ApiDecouplerOfUintptrThenInt8 struct {
	pool PoolOfUintptrThenInt8
}

func NewApiDecouplerOfUintptrThenInt8() *ApiDecouplerOfUintptrThenInt8 {
	return &ApiDecouplerOfUintptrThenInt8{
		pool: NewPoolOfUintptrThenInt8Impl(),
	}
}

func (__ *ApiDecouplerOfUintptrThenInt8) ReturnError(rtn_ch chan<- *ReturnOfInt8, err error) {
	rtn := __.pool.GetReturnOfInt8()
	var other int8
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfUintptrThenInt8) HandleOfUintptrThenInt8(ctx context.Context, req *WorkOfUintptrThenInt8, h func(ctx context.Context, arg uintptr) (int8, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfInt8()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfUintptrThenInt8) DoOfUintptrThenInt8(ctx context.Context, worker WorkerOfPushUintptrThenInt8, arg uintptr) (int8, error) {
	// ch := make(chan *ReturnOfInt8, 1)
	ch := __.pool.GetChReturnOfInt8()
	defer __.pool.PutChReturnOfInt8(ch)

	req := __.pool.GetWorkOfUintptrThenInt8()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfUintptrThenInt8(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfInt8(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfUintptrThenInt8 = func(ctx context.Context, arg uintptr) (int8, error)

type WorkerOfUintptrThenInt8 struct {
	api_syncer *ApiDecouplerOfUintptrThenInt8
	handler    WorkHandlerOfUintptrThenInt8

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfUintptrThenInt8
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfUintptrThenInt8(ctx context.Context, h WorkHandlerOfUintptrThenInt8, n int) *WorkerOfUintptrThenInt8 {
	__ := &WorkerOfUintptrThenInt8{
		api_syncer: NewApiDecouplerOfUintptrThenInt8(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfUintptrThenInt8, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfUintptrThenInt8{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfUintptrThenInt8(req.Context, req.WorkOfUintptrThenInt8, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfUintptrThenInt8) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfUintptrThenInt8) Push(ctx context.Context, req *WorkOfUintptrThenInt8) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfUintptrThenInt8)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfUintptrThenInt8 = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfUintptrThenInt8) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfUintptrThenInt8) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfUintptrThenInt8) Call(ctx context.Context, arg uintptr) (int8, error) {
	return __.api_syncer.DoOfUintptrThenInt8(ctx, __, arg)
}

type PoolOfUintptrThenRune interface {
	GetUintptrArg() *uintptr
	PutUintptrArg(*uintptr)
	GetRuneReturn() *rune
	PutRuneReturn(*rune)

	GetWorkOfUintptrThenRune() *WorkOfUintptrThenRune
	GetReturnOfRune() *ReturnOfRune
	PutWorkOfUintptrThenRune(*WorkOfUintptrThenRune)
	PutReturnOfRune(*ReturnOfRune)

	GetChReturnOfRune() chan *ReturnOfRune
	PutChReturnOfRune(chan *ReturnOfRune)
}

type PoolOfUintptrThenRuneImpl struct {
	UintptrArg     sync.Pool
	RuneRtn        sync.Pool
	UintptrWork    sync.Pool
	RuneReturn     sync.Pool
	ChReturnOfRune sync.Pool
}

func (__ *PoolOfUintptrThenRuneImpl) GetUintptrArg() *uintptr {
	return __.UintptrArg.Get().(*uintptr)
}
func (__ *PoolOfUintptrThenRuneImpl) PutUintptrArg(p *uintptr) {
	__.UintptrArg.Put(p)
}
func (__ *PoolOfUintptrThenRuneImpl) GetRuneReturn() *rune {
	return __.RuneRtn.Get().(*rune)
}
func (__ *PoolOfUintptrThenRuneImpl) PutRuneReturn(p *rune) {
	__.RuneRtn.Put(p)
}

func (__ *PoolOfUintptrThenRuneImpl) GetWorkOfUintptrThenRune() *WorkOfUintptrThenRune {
	return __.UintptrWork.Get().(*WorkOfUintptrThenRune)
}
func (__ *PoolOfUintptrThenRuneImpl) PutWorkOfUintptrThenRune(p *WorkOfUintptrThenRune) {
	__.UintptrWork.Put(p)
}
func (__ *PoolOfUintptrThenRuneImpl) GetReturnOfRune() *ReturnOfRune {
	return __.RuneReturn.Get().(*ReturnOfRune)
}
func (__ *PoolOfUintptrThenRuneImpl) PutReturnOfRune(p *ReturnOfRune) {
	__.RuneReturn.Put(p)
}

func (__ *PoolOfUintptrThenRuneImpl) GetChReturnOfRune() chan *ReturnOfRune {
	return __.ChReturnOfRune.Get().(chan *ReturnOfRune)
}
func (__ *PoolOfUintptrThenRuneImpl) PutChReturnOfRune(p chan *ReturnOfRune) {
	__.ChReturnOfRune.Put(p)
}

func NewPoolOfUintptrThenRuneImpl() *PoolOfUintptrThenRuneImpl {
	return &PoolOfUintptrThenRuneImpl{
		UintptrArg: sync.Pool{
			New: func() interface{} {
				return new(uintptr)
			},
		},
		UintptrWork: sync.Pool{
			New: func() interface{} {
				return new(WorkOfUintptrThenRune)
			},
		},
		RuneRtn: sync.Pool{
			New: func() interface{} {
				return new(rune)
			},
		},
		RuneReturn: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfRune)
			},
		},
		ChReturnOfRune: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfRune, 1)
			},
		},
	}
}

type ApiDecouplerOfUintptrThenRune struct {
	pool PoolOfUintptrThenRune
}

func NewApiDecouplerOfUintptrThenRune() *ApiDecouplerOfUintptrThenRune {
	return &ApiDecouplerOfUintptrThenRune{
		pool: NewPoolOfUintptrThenRuneImpl(),
	}
}

func (__ *ApiDecouplerOfUintptrThenRune) ReturnError(rtn_ch chan<- *ReturnOfRune, err error) {
	rtn := __.pool.GetReturnOfRune()
	var other rune
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfUintptrThenRune) HandleOfUintptrThenRune(ctx context.Context, req *WorkOfUintptrThenRune, h func(ctx context.Context, arg uintptr) (rune, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfRune()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfUintptrThenRune) DoOfUintptrThenRune(ctx context.Context, worker WorkerOfPushUintptrThenRune, arg uintptr) (rune, error) {
	// ch := make(chan *ReturnOfRune, 1)
	ch := __.pool.GetChReturnOfRune()
	defer __.pool.PutChReturnOfRune(ch)

	req := __.pool.GetWorkOfUintptrThenRune()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfUintptrThenRune(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfRune(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfUintptrThenRune = func(ctx context.Context, arg uintptr) (rune, error)

type WorkerOfUintptrThenRune struct {
	api_syncer *ApiDecouplerOfUintptrThenRune
	handler    WorkHandlerOfUintptrThenRune

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfUintptrThenRune
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfUintptrThenRune(ctx context.Context, h WorkHandlerOfUintptrThenRune, n int) *WorkerOfUintptrThenRune {
	__ := &WorkerOfUintptrThenRune{
		api_syncer: NewApiDecouplerOfUintptrThenRune(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfUintptrThenRune, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfUintptrThenRune{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfUintptrThenRune(req.Context, req.WorkOfUintptrThenRune, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfUintptrThenRune) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfUintptrThenRune) Push(ctx context.Context, req *WorkOfUintptrThenRune) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfUintptrThenRune)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfUintptrThenRune = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfUintptrThenRune) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfUintptrThenRune) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfUintptrThenRune) Call(ctx context.Context, arg uintptr) (rune, error) {
	return __.api_syncer.DoOfUintptrThenRune(ctx, __, arg)
}

type PoolOfUintptrThenString interface {
	GetUintptrArg() *uintptr
	PutUintptrArg(*uintptr)
	GetStringReturn() *string
	PutStringReturn(*string)

	GetWorkOfUintptrThenString() *WorkOfUintptrThenString
	GetReturnOfString() *ReturnOfString
	PutWorkOfUintptrThenString(*WorkOfUintptrThenString)
	PutReturnOfString(*ReturnOfString)

	GetChReturnOfString() chan *ReturnOfString
	PutChReturnOfString(chan *ReturnOfString)
}

type PoolOfUintptrThenStringImpl struct {
	UintptrArg       sync.Pool
	StringRtn        sync.Pool
	UintptrWork      sync.Pool
	StringReturn     sync.Pool
	ChReturnOfString sync.Pool
}

func (__ *PoolOfUintptrThenStringImpl) GetUintptrArg() *uintptr {
	return __.UintptrArg.Get().(*uintptr)
}
func (__ *PoolOfUintptrThenStringImpl) PutUintptrArg(p *uintptr) {
	__.UintptrArg.Put(p)
}
func (__ *PoolOfUintptrThenStringImpl) GetStringReturn() *string {
	return __.StringRtn.Get().(*string)
}
func (__ *PoolOfUintptrThenStringImpl) PutStringReturn(p *string) {
	__.StringRtn.Put(p)
}

func (__ *PoolOfUintptrThenStringImpl) GetWorkOfUintptrThenString() *WorkOfUintptrThenString {
	return __.UintptrWork.Get().(*WorkOfUintptrThenString)
}
func (__ *PoolOfUintptrThenStringImpl) PutWorkOfUintptrThenString(p *WorkOfUintptrThenString) {
	__.UintptrWork.Put(p)
}
func (__ *PoolOfUintptrThenStringImpl) GetReturnOfString() *ReturnOfString {
	return __.StringReturn.Get().(*ReturnOfString)
}
func (__ *PoolOfUintptrThenStringImpl) PutReturnOfString(p *ReturnOfString) {
	__.StringReturn.Put(p)
}

func (__ *PoolOfUintptrThenStringImpl) GetChReturnOfString() chan *ReturnOfString {
	return __.ChReturnOfString.Get().(chan *ReturnOfString)
}
func (__ *PoolOfUintptrThenStringImpl) PutChReturnOfString(p chan *ReturnOfString) {
	__.ChReturnOfString.Put(p)
}

func NewPoolOfUintptrThenStringImpl() *PoolOfUintptrThenStringImpl {
	return &PoolOfUintptrThenStringImpl{
		UintptrArg: sync.Pool{
			New: func() interface{} {
				return new(uintptr)
			},
		},
		UintptrWork: sync.Pool{
			New: func() interface{} {
				return new(WorkOfUintptrThenString)
			},
		},
		StringRtn: sync.Pool{
			New: func() interface{} {
				return new(string)
			},
		},
		StringReturn: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfString)
			},
		},
		ChReturnOfString: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfString, 1)
			},
		},
	}
}

type ApiDecouplerOfUintptrThenString struct {
	pool PoolOfUintptrThenString
}

func NewApiDecouplerOfUintptrThenString() *ApiDecouplerOfUintptrThenString {
	return &ApiDecouplerOfUintptrThenString{
		pool: NewPoolOfUintptrThenStringImpl(),
	}
}

func (__ *ApiDecouplerOfUintptrThenString) ReturnError(rtn_ch chan<- *ReturnOfString, err error) {
	rtn := __.pool.GetReturnOfString()
	var other string
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfUintptrThenString) HandleOfUintptrThenString(ctx context.Context, req *WorkOfUintptrThenString, h func(ctx context.Context, arg uintptr) (string, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfString()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfUintptrThenString) DoOfUintptrThenString(ctx context.Context, worker WorkerOfPushUintptrThenString, arg uintptr) (string, error) {
	// ch := make(chan *ReturnOfString, 1)
	ch := __.pool.GetChReturnOfString()
	defer __.pool.PutChReturnOfString(ch)

	req := __.pool.GetWorkOfUintptrThenString()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfUintptrThenString(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfString(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfUintptrThenString = func(ctx context.Context, arg uintptr) (string, error)

type WorkerOfUintptrThenString struct {
	api_syncer *ApiDecouplerOfUintptrThenString
	handler    WorkHandlerOfUintptrThenString

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfUintptrThenString
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfUintptrThenString(ctx context.Context, h WorkHandlerOfUintptrThenString, n int) *WorkerOfUintptrThenString {
	__ := &WorkerOfUintptrThenString{
		api_syncer: NewApiDecouplerOfUintptrThenString(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfUintptrThenString, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfUintptrThenString{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfUintptrThenString(req.Context, req.WorkOfUintptrThenString, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfUintptrThenString) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfUintptrThenString) Push(ctx context.Context, req *WorkOfUintptrThenString) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfUintptrThenString)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfUintptrThenString = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfUintptrThenString) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfUintptrThenString) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfUintptrThenString) Call(ctx context.Context, arg uintptr) (string, error) {
	return __.api_syncer.DoOfUintptrThenString(ctx, __, arg)
}

type PoolOfUintptrThenUint interface {
	GetUintptrArg() *uintptr
	PutUintptrArg(*uintptr)
	GetUintReturn() *uint
	PutUintReturn(*uint)

	GetWorkOfUintptrThenUint() *WorkOfUintptrThenUint
	GetReturnOfUint() *ReturnOfUint
	PutWorkOfUintptrThenUint(*WorkOfUintptrThenUint)
	PutReturnOfUint(*ReturnOfUint)

	GetChReturnOfUint() chan *ReturnOfUint
	PutChReturnOfUint(chan *ReturnOfUint)
}

type PoolOfUintptrThenUintImpl struct {
	UintptrArg     sync.Pool
	UintRtn        sync.Pool
	UintptrWork    sync.Pool
	UintReturn     sync.Pool
	ChReturnOfUint sync.Pool
}

func (__ *PoolOfUintptrThenUintImpl) GetUintptrArg() *uintptr {
	return __.UintptrArg.Get().(*uintptr)
}
func (__ *PoolOfUintptrThenUintImpl) PutUintptrArg(p *uintptr) {
	__.UintptrArg.Put(p)
}
func (__ *PoolOfUintptrThenUintImpl) GetUintReturn() *uint {
	return __.UintRtn.Get().(*uint)
}
func (__ *PoolOfUintptrThenUintImpl) PutUintReturn(p *uint) {
	__.UintRtn.Put(p)
}

func (__ *PoolOfUintptrThenUintImpl) GetWorkOfUintptrThenUint() *WorkOfUintptrThenUint {
	return __.UintptrWork.Get().(*WorkOfUintptrThenUint)
}
func (__ *PoolOfUintptrThenUintImpl) PutWorkOfUintptrThenUint(p *WorkOfUintptrThenUint) {
	__.UintptrWork.Put(p)
}
func (__ *PoolOfUintptrThenUintImpl) GetReturnOfUint() *ReturnOfUint {
	return __.UintReturn.Get().(*ReturnOfUint)
}
func (__ *PoolOfUintptrThenUintImpl) PutReturnOfUint(p *ReturnOfUint) {
	__.UintReturn.Put(p)
}

func (__ *PoolOfUintptrThenUintImpl) GetChReturnOfUint() chan *ReturnOfUint {
	return __.ChReturnOfUint.Get().(chan *ReturnOfUint)
}
func (__ *PoolOfUintptrThenUintImpl) PutChReturnOfUint(p chan *ReturnOfUint) {
	__.ChReturnOfUint.Put(p)
}

func NewPoolOfUintptrThenUintImpl() *PoolOfUintptrThenUintImpl {
	return &PoolOfUintptrThenUintImpl{
		UintptrArg: sync.Pool{
			New: func() interface{} {
				return new(uintptr)
			},
		},
		UintptrWork: sync.Pool{
			New: func() interface{} {
				return new(WorkOfUintptrThenUint)
			},
		},
		UintRtn: sync.Pool{
			New: func() interface{} {
				return new(uint)
			},
		},
		UintReturn: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfUint)
			},
		},
		ChReturnOfUint: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfUint, 1)
			},
		},
	}
}

type ApiDecouplerOfUintptrThenUint struct {
	pool PoolOfUintptrThenUint
}

func NewApiDecouplerOfUintptrThenUint() *ApiDecouplerOfUintptrThenUint {
	return &ApiDecouplerOfUintptrThenUint{
		pool: NewPoolOfUintptrThenUintImpl(),
	}
}

func (__ *ApiDecouplerOfUintptrThenUint) ReturnError(rtn_ch chan<- *ReturnOfUint, err error) {
	rtn := __.pool.GetReturnOfUint()
	var other uint
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfUintptrThenUint) HandleOfUintptrThenUint(ctx context.Context, req *WorkOfUintptrThenUint, h func(ctx context.Context, arg uintptr) (uint, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfUint()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfUintptrThenUint) DoOfUintptrThenUint(ctx context.Context, worker WorkerOfPushUintptrThenUint, arg uintptr) (uint, error) {
	// ch := make(chan *ReturnOfUint, 1)
	ch := __.pool.GetChReturnOfUint()
	defer __.pool.PutChReturnOfUint(ch)

	req := __.pool.GetWorkOfUintptrThenUint()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfUintptrThenUint(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfUint(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfUintptrThenUint = func(ctx context.Context, arg uintptr) (uint, error)

type WorkerOfUintptrThenUint struct {
	api_syncer *ApiDecouplerOfUintptrThenUint
	handler    WorkHandlerOfUintptrThenUint

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfUintptrThenUint
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfUintptrThenUint(ctx context.Context, h WorkHandlerOfUintptrThenUint, n int) *WorkerOfUintptrThenUint {
	__ := &WorkerOfUintptrThenUint{
		api_syncer: NewApiDecouplerOfUintptrThenUint(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfUintptrThenUint, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfUintptrThenUint{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfUintptrThenUint(req.Context, req.WorkOfUintptrThenUint, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfUintptrThenUint) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfUintptrThenUint) Push(ctx context.Context, req *WorkOfUintptrThenUint) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfUintptrThenUint)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfUintptrThenUint = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfUintptrThenUint) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfUintptrThenUint) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfUintptrThenUint) Call(ctx context.Context, arg uintptr) (uint, error) {
	return __.api_syncer.DoOfUintptrThenUint(ctx, __, arg)
}

type PoolOfUintptrThenUint16 interface {
	GetUintptrArg() *uintptr
	PutUintptrArg(*uintptr)
	GetUint16Return() *uint16
	PutUint16Return(*uint16)

	GetWorkOfUintptrThenUint16() *WorkOfUintptrThenUint16
	GetReturnOfUint16() *ReturnOfUint16
	PutWorkOfUintptrThenUint16(*WorkOfUintptrThenUint16)
	PutReturnOfUint16(*ReturnOfUint16)

	GetChReturnOfUint16() chan *ReturnOfUint16
	PutChReturnOfUint16(chan *ReturnOfUint16)
}

type PoolOfUintptrThenUint16Impl struct {
	UintptrArg       sync.Pool
	Uint16Rtn        sync.Pool
	UintptrWork      sync.Pool
	Uint16Return     sync.Pool
	ChReturnOfUint16 sync.Pool
}

func (__ *PoolOfUintptrThenUint16Impl) GetUintptrArg() *uintptr {
	return __.UintptrArg.Get().(*uintptr)
}
func (__ *PoolOfUintptrThenUint16Impl) PutUintptrArg(p *uintptr) {
	__.UintptrArg.Put(p)
}
func (__ *PoolOfUintptrThenUint16Impl) GetUint16Return() *uint16 {
	return __.Uint16Rtn.Get().(*uint16)
}
func (__ *PoolOfUintptrThenUint16Impl) PutUint16Return(p *uint16) {
	__.Uint16Rtn.Put(p)
}

func (__ *PoolOfUintptrThenUint16Impl) GetWorkOfUintptrThenUint16() *WorkOfUintptrThenUint16 {
	return __.UintptrWork.Get().(*WorkOfUintptrThenUint16)
}
func (__ *PoolOfUintptrThenUint16Impl) PutWorkOfUintptrThenUint16(p *WorkOfUintptrThenUint16) {
	__.UintptrWork.Put(p)
}
func (__ *PoolOfUintptrThenUint16Impl) GetReturnOfUint16() *ReturnOfUint16 {
	return __.Uint16Return.Get().(*ReturnOfUint16)
}
func (__ *PoolOfUintptrThenUint16Impl) PutReturnOfUint16(p *ReturnOfUint16) {
	__.Uint16Return.Put(p)
}

func (__ *PoolOfUintptrThenUint16Impl) GetChReturnOfUint16() chan *ReturnOfUint16 {
	return __.ChReturnOfUint16.Get().(chan *ReturnOfUint16)
}
func (__ *PoolOfUintptrThenUint16Impl) PutChReturnOfUint16(p chan *ReturnOfUint16) {
	__.ChReturnOfUint16.Put(p)
}

func NewPoolOfUintptrThenUint16Impl() *PoolOfUintptrThenUint16Impl {
	return &PoolOfUintptrThenUint16Impl{
		UintptrArg: sync.Pool{
			New: func() interface{} {
				return new(uintptr)
			},
		},
		UintptrWork: sync.Pool{
			New: func() interface{} {
				return new(WorkOfUintptrThenUint16)
			},
		},
		Uint16Rtn: sync.Pool{
			New: func() interface{} {
				return new(uint16)
			},
		},
		Uint16Return: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfUint16)
			},
		},
		ChReturnOfUint16: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfUint16, 1)
			},
		},
	}
}

type ApiDecouplerOfUintptrThenUint16 struct {
	pool PoolOfUintptrThenUint16
}

func NewApiDecouplerOfUintptrThenUint16() *ApiDecouplerOfUintptrThenUint16 {
	return &ApiDecouplerOfUintptrThenUint16{
		pool: NewPoolOfUintptrThenUint16Impl(),
	}
}

func (__ *ApiDecouplerOfUintptrThenUint16) ReturnError(rtn_ch chan<- *ReturnOfUint16, err error) {
	rtn := __.pool.GetReturnOfUint16()
	var other uint16
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfUintptrThenUint16) HandleOfUintptrThenUint16(ctx context.Context, req *WorkOfUintptrThenUint16, h func(ctx context.Context, arg uintptr) (uint16, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfUint16()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfUintptrThenUint16) DoOfUintptrThenUint16(ctx context.Context, worker WorkerOfPushUintptrThenUint16, arg uintptr) (uint16, error) {
	// ch := make(chan *ReturnOfUint16, 1)
	ch := __.pool.GetChReturnOfUint16()
	defer __.pool.PutChReturnOfUint16(ch)

	req := __.pool.GetWorkOfUintptrThenUint16()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfUintptrThenUint16(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfUint16(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfUintptrThenUint16 = func(ctx context.Context, arg uintptr) (uint16, error)

type WorkerOfUintptrThenUint16 struct {
	api_syncer *ApiDecouplerOfUintptrThenUint16
	handler    WorkHandlerOfUintptrThenUint16

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfUintptrThenUint16
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfUintptrThenUint16(ctx context.Context, h WorkHandlerOfUintptrThenUint16, n int) *WorkerOfUintptrThenUint16 {
	__ := &WorkerOfUintptrThenUint16{
		api_syncer: NewApiDecouplerOfUintptrThenUint16(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfUintptrThenUint16, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfUintptrThenUint16{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfUintptrThenUint16(req.Context, req.WorkOfUintptrThenUint16, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfUintptrThenUint16) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfUintptrThenUint16) Push(ctx context.Context, req *WorkOfUintptrThenUint16) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfUintptrThenUint16)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfUintptrThenUint16 = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfUintptrThenUint16) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfUintptrThenUint16) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfUintptrThenUint16) Call(ctx context.Context, arg uintptr) (uint16, error) {
	return __.api_syncer.DoOfUintptrThenUint16(ctx, __, arg)
}

type PoolOfUintptrThenUint32 interface {
	GetUintptrArg() *uintptr
	PutUintptrArg(*uintptr)
	GetUint32Return() *uint32
	PutUint32Return(*uint32)

	GetWorkOfUintptrThenUint32() *WorkOfUintptrThenUint32
	GetReturnOfUint32() *ReturnOfUint32
	PutWorkOfUintptrThenUint32(*WorkOfUintptrThenUint32)
	PutReturnOfUint32(*ReturnOfUint32)

	GetChReturnOfUint32() chan *ReturnOfUint32
	PutChReturnOfUint32(chan *ReturnOfUint32)
}

type PoolOfUintptrThenUint32Impl struct {
	UintptrArg       sync.Pool
	Uint32Rtn        sync.Pool
	UintptrWork      sync.Pool
	Uint32Return     sync.Pool
	ChReturnOfUint32 sync.Pool
}

func (__ *PoolOfUintptrThenUint32Impl) GetUintptrArg() *uintptr {
	return __.UintptrArg.Get().(*uintptr)
}
func (__ *PoolOfUintptrThenUint32Impl) PutUintptrArg(p *uintptr) {
	__.UintptrArg.Put(p)
}
func (__ *PoolOfUintptrThenUint32Impl) GetUint32Return() *uint32 {
	return __.Uint32Rtn.Get().(*uint32)
}
func (__ *PoolOfUintptrThenUint32Impl) PutUint32Return(p *uint32) {
	__.Uint32Rtn.Put(p)
}

func (__ *PoolOfUintptrThenUint32Impl) GetWorkOfUintptrThenUint32() *WorkOfUintptrThenUint32 {
	return __.UintptrWork.Get().(*WorkOfUintptrThenUint32)
}
func (__ *PoolOfUintptrThenUint32Impl) PutWorkOfUintptrThenUint32(p *WorkOfUintptrThenUint32) {
	__.UintptrWork.Put(p)
}
func (__ *PoolOfUintptrThenUint32Impl) GetReturnOfUint32() *ReturnOfUint32 {
	return __.Uint32Return.Get().(*ReturnOfUint32)
}
func (__ *PoolOfUintptrThenUint32Impl) PutReturnOfUint32(p *ReturnOfUint32) {
	__.Uint32Return.Put(p)
}

func (__ *PoolOfUintptrThenUint32Impl) GetChReturnOfUint32() chan *ReturnOfUint32 {
	return __.ChReturnOfUint32.Get().(chan *ReturnOfUint32)
}
func (__ *PoolOfUintptrThenUint32Impl) PutChReturnOfUint32(p chan *ReturnOfUint32) {
	__.ChReturnOfUint32.Put(p)
}

func NewPoolOfUintptrThenUint32Impl() *PoolOfUintptrThenUint32Impl {
	return &PoolOfUintptrThenUint32Impl{
		UintptrArg: sync.Pool{
			New: func() interface{} {
				return new(uintptr)
			},
		},
		UintptrWork: sync.Pool{
			New: func() interface{} {
				return new(WorkOfUintptrThenUint32)
			},
		},
		Uint32Rtn: sync.Pool{
			New: func() interface{} {
				return new(uint32)
			},
		},
		Uint32Return: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfUint32)
			},
		},
		ChReturnOfUint32: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfUint32, 1)
			},
		},
	}
}

type ApiDecouplerOfUintptrThenUint32 struct {
	pool PoolOfUintptrThenUint32
}

func NewApiDecouplerOfUintptrThenUint32() *ApiDecouplerOfUintptrThenUint32 {
	return &ApiDecouplerOfUintptrThenUint32{
		pool: NewPoolOfUintptrThenUint32Impl(),
	}
}

func (__ *ApiDecouplerOfUintptrThenUint32) ReturnError(rtn_ch chan<- *ReturnOfUint32, err error) {
	rtn := __.pool.GetReturnOfUint32()
	var other uint32
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfUintptrThenUint32) HandleOfUintptrThenUint32(ctx context.Context, req *WorkOfUintptrThenUint32, h func(ctx context.Context, arg uintptr) (uint32, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfUint32()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfUintptrThenUint32) DoOfUintptrThenUint32(ctx context.Context, worker WorkerOfPushUintptrThenUint32, arg uintptr) (uint32, error) {
	// ch := make(chan *ReturnOfUint32, 1)
	ch := __.pool.GetChReturnOfUint32()
	defer __.pool.PutChReturnOfUint32(ch)

	req := __.pool.GetWorkOfUintptrThenUint32()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfUintptrThenUint32(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfUint32(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfUintptrThenUint32 = func(ctx context.Context, arg uintptr) (uint32, error)

type WorkerOfUintptrThenUint32 struct {
	api_syncer *ApiDecouplerOfUintptrThenUint32
	handler    WorkHandlerOfUintptrThenUint32

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfUintptrThenUint32
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfUintptrThenUint32(ctx context.Context, h WorkHandlerOfUintptrThenUint32, n int) *WorkerOfUintptrThenUint32 {
	__ := &WorkerOfUintptrThenUint32{
		api_syncer: NewApiDecouplerOfUintptrThenUint32(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfUintptrThenUint32, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfUintptrThenUint32{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfUintptrThenUint32(req.Context, req.WorkOfUintptrThenUint32, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfUintptrThenUint32) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfUintptrThenUint32) Push(ctx context.Context, req *WorkOfUintptrThenUint32) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfUintptrThenUint32)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfUintptrThenUint32 = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfUintptrThenUint32) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfUintptrThenUint32) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfUintptrThenUint32) Call(ctx context.Context, arg uintptr) (uint32, error) {
	return __.api_syncer.DoOfUintptrThenUint32(ctx, __, arg)
}

type PoolOfUintptrThenUint64 interface {
	GetUintptrArg() *uintptr
	PutUintptrArg(*uintptr)
	GetUint64Return() *uint64
	PutUint64Return(*uint64)

	GetWorkOfUintptrThenUint64() *WorkOfUintptrThenUint64
	GetReturnOfUint64() *ReturnOfUint64
	PutWorkOfUintptrThenUint64(*WorkOfUintptrThenUint64)
	PutReturnOfUint64(*ReturnOfUint64)

	GetChReturnOfUint64() chan *ReturnOfUint64
	PutChReturnOfUint64(chan *ReturnOfUint64)
}

type PoolOfUintptrThenUint64Impl struct {
	UintptrArg       sync.Pool
	Uint64Rtn        sync.Pool
	UintptrWork      sync.Pool
	Uint64Return     sync.Pool
	ChReturnOfUint64 sync.Pool
}

func (__ *PoolOfUintptrThenUint64Impl) GetUintptrArg() *uintptr {
	return __.UintptrArg.Get().(*uintptr)
}
func (__ *PoolOfUintptrThenUint64Impl) PutUintptrArg(p *uintptr) {
	__.UintptrArg.Put(p)
}
func (__ *PoolOfUintptrThenUint64Impl) GetUint64Return() *uint64 {
	return __.Uint64Rtn.Get().(*uint64)
}
func (__ *PoolOfUintptrThenUint64Impl) PutUint64Return(p *uint64) {
	__.Uint64Rtn.Put(p)
}

func (__ *PoolOfUintptrThenUint64Impl) GetWorkOfUintptrThenUint64() *WorkOfUintptrThenUint64 {
	return __.UintptrWork.Get().(*WorkOfUintptrThenUint64)
}
func (__ *PoolOfUintptrThenUint64Impl) PutWorkOfUintptrThenUint64(p *WorkOfUintptrThenUint64) {
	__.UintptrWork.Put(p)
}
func (__ *PoolOfUintptrThenUint64Impl) GetReturnOfUint64() *ReturnOfUint64 {
	return __.Uint64Return.Get().(*ReturnOfUint64)
}
func (__ *PoolOfUintptrThenUint64Impl) PutReturnOfUint64(p *ReturnOfUint64) {
	__.Uint64Return.Put(p)
}

func (__ *PoolOfUintptrThenUint64Impl) GetChReturnOfUint64() chan *ReturnOfUint64 {
	return __.ChReturnOfUint64.Get().(chan *ReturnOfUint64)
}
func (__ *PoolOfUintptrThenUint64Impl) PutChReturnOfUint64(p chan *ReturnOfUint64) {
	__.ChReturnOfUint64.Put(p)
}

func NewPoolOfUintptrThenUint64Impl() *PoolOfUintptrThenUint64Impl {
	return &PoolOfUintptrThenUint64Impl{
		UintptrArg: sync.Pool{
			New: func() interface{} {
				return new(uintptr)
			},
		},
		UintptrWork: sync.Pool{
			New: func() interface{} {
				return new(WorkOfUintptrThenUint64)
			},
		},
		Uint64Rtn: sync.Pool{
			New: func() interface{} {
				return new(uint64)
			},
		},
		Uint64Return: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfUint64)
			},
		},
		ChReturnOfUint64: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfUint64, 1)
			},
		},
	}
}

type ApiDecouplerOfUintptrThenUint64 struct {
	pool PoolOfUintptrThenUint64
}

func NewApiDecouplerOfUintptrThenUint64() *ApiDecouplerOfUintptrThenUint64 {
	return &ApiDecouplerOfUintptrThenUint64{
		pool: NewPoolOfUintptrThenUint64Impl(),
	}
}

func (__ *ApiDecouplerOfUintptrThenUint64) ReturnError(rtn_ch chan<- *ReturnOfUint64, err error) {
	rtn := __.pool.GetReturnOfUint64()
	var other uint64
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfUintptrThenUint64) HandleOfUintptrThenUint64(ctx context.Context, req *WorkOfUintptrThenUint64, h func(ctx context.Context, arg uintptr) (uint64, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfUint64()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfUintptrThenUint64) DoOfUintptrThenUint64(ctx context.Context, worker WorkerOfPushUintptrThenUint64, arg uintptr) (uint64, error) {
	// ch := make(chan *ReturnOfUint64, 1)
	ch := __.pool.GetChReturnOfUint64()
	defer __.pool.PutChReturnOfUint64(ch)

	req := __.pool.GetWorkOfUintptrThenUint64()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfUintptrThenUint64(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfUint64(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfUintptrThenUint64 = func(ctx context.Context, arg uintptr) (uint64, error)

type WorkerOfUintptrThenUint64 struct {
	api_syncer *ApiDecouplerOfUintptrThenUint64
	handler    WorkHandlerOfUintptrThenUint64

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfUintptrThenUint64
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfUintptrThenUint64(ctx context.Context, h WorkHandlerOfUintptrThenUint64, n int) *WorkerOfUintptrThenUint64 {
	__ := &WorkerOfUintptrThenUint64{
		api_syncer: NewApiDecouplerOfUintptrThenUint64(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfUintptrThenUint64, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfUintptrThenUint64{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfUintptrThenUint64(req.Context, req.WorkOfUintptrThenUint64, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfUintptrThenUint64) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfUintptrThenUint64) Push(ctx context.Context, req *WorkOfUintptrThenUint64) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfUintptrThenUint64)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfUintptrThenUint64 = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfUintptrThenUint64) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfUintptrThenUint64) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfUintptrThenUint64) Call(ctx context.Context, arg uintptr) (uint64, error) {
	return __.api_syncer.DoOfUintptrThenUint64(ctx, __, arg)
}

type PoolOfUintptrThenUint8 interface {
	GetUintptrArg() *uintptr
	PutUintptrArg(*uintptr)
	GetUint8Return() *uint8
	PutUint8Return(*uint8)

	GetWorkOfUintptrThenUint8() *WorkOfUintptrThenUint8
	GetReturnOfUint8() *ReturnOfUint8
	PutWorkOfUintptrThenUint8(*WorkOfUintptrThenUint8)
	PutReturnOfUint8(*ReturnOfUint8)

	GetChReturnOfUint8() chan *ReturnOfUint8
	PutChReturnOfUint8(chan *ReturnOfUint8)
}

type PoolOfUintptrThenUint8Impl struct {
	UintptrArg      sync.Pool
	Uint8Rtn        sync.Pool
	UintptrWork     sync.Pool
	Uint8Return     sync.Pool
	ChReturnOfUint8 sync.Pool
}

func (__ *PoolOfUintptrThenUint8Impl) GetUintptrArg() *uintptr {
	return __.UintptrArg.Get().(*uintptr)
}
func (__ *PoolOfUintptrThenUint8Impl) PutUintptrArg(p *uintptr) {
	__.UintptrArg.Put(p)
}
func (__ *PoolOfUintptrThenUint8Impl) GetUint8Return() *uint8 {
	return __.Uint8Rtn.Get().(*uint8)
}
func (__ *PoolOfUintptrThenUint8Impl) PutUint8Return(p *uint8) {
	__.Uint8Rtn.Put(p)
}

func (__ *PoolOfUintptrThenUint8Impl) GetWorkOfUintptrThenUint8() *WorkOfUintptrThenUint8 {
	return __.UintptrWork.Get().(*WorkOfUintptrThenUint8)
}
func (__ *PoolOfUintptrThenUint8Impl) PutWorkOfUintptrThenUint8(p *WorkOfUintptrThenUint8) {
	__.UintptrWork.Put(p)
}
func (__ *PoolOfUintptrThenUint8Impl) GetReturnOfUint8() *ReturnOfUint8 {
	return __.Uint8Return.Get().(*ReturnOfUint8)
}
func (__ *PoolOfUintptrThenUint8Impl) PutReturnOfUint8(p *ReturnOfUint8) {
	__.Uint8Return.Put(p)
}

func (__ *PoolOfUintptrThenUint8Impl) GetChReturnOfUint8() chan *ReturnOfUint8 {
	return __.ChReturnOfUint8.Get().(chan *ReturnOfUint8)
}
func (__ *PoolOfUintptrThenUint8Impl) PutChReturnOfUint8(p chan *ReturnOfUint8) {
	__.ChReturnOfUint8.Put(p)
}

func NewPoolOfUintptrThenUint8Impl() *PoolOfUintptrThenUint8Impl {
	return &PoolOfUintptrThenUint8Impl{
		UintptrArg: sync.Pool{
			New: func() interface{} {
				return new(uintptr)
			},
		},
		UintptrWork: sync.Pool{
			New: func() interface{} {
				return new(WorkOfUintptrThenUint8)
			},
		},
		Uint8Rtn: sync.Pool{
			New: func() interface{} {
				return new(uint8)
			},
		},
		Uint8Return: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfUint8)
			},
		},
		ChReturnOfUint8: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfUint8, 1)
			},
		},
	}
}

type ApiDecouplerOfUintptrThenUint8 struct {
	pool PoolOfUintptrThenUint8
}

func NewApiDecouplerOfUintptrThenUint8() *ApiDecouplerOfUintptrThenUint8 {
	return &ApiDecouplerOfUintptrThenUint8{
		pool: NewPoolOfUintptrThenUint8Impl(),
	}
}

func (__ *ApiDecouplerOfUintptrThenUint8) ReturnError(rtn_ch chan<- *ReturnOfUint8, err error) {
	rtn := __.pool.GetReturnOfUint8()
	var other uint8
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfUintptrThenUint8) HandleOfUintptrThenUint8(ctx context.Context, req *WorkOfUintptrThenUint8, h func(ctx context.Context, arg uintptr) (uint8, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfUint8()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfUintptrThenUint8) DoOfUintptrThenUint8(ctx context.Context, worker WorkerOfPushUintptrThenUint8, arg uintptr) (uint8, error) {
	// ch := make(chan *ReturnOfUint8, 1)
	ch := __.pool.GetChReturnOfUint8()
	defer __.pool.PutChReturnOfUint8(ch)

	req := __.pool.GetWorkOfUintptrThenUint8()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfUintptrThenUint8(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfUint8(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfUintptrThenUint8 = func(ctx context.Context, arg uintptr) (uint8, error)

type WorkerOfUintptrThenUint8 struct {
	api_syncer *ApiDecouplerOfUintptrThenUint8
	handler    WorkHandlerOfUintptrThenUint8

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfUintptrThenUint8
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfUintptrThenUint8(ctx context.Context, h WorkHandlerOfUintptrThenUint8, n int) *WorkerOfUintptrThenUint8 {
	__ := &WorkerOfUintptrThenUint8{
		api_syncer: NewApiDecouplerOfUintptrThenUint8(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfUintptrThenUint8, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfUintptrThenUint8{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfUintptrThenUint8(req.Context, req.WorkOfUintptrThenUint8, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfUintptrThenUint8) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfUintptrThenUint8) Push(ctx context.Context, req *WorkOfUintptrThenUint8) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfUintptrThenUint8)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfUintptrThenUint8 = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfUintptrThenUint8) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfUintptrThenUint8) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfUintptrThenUint8) Call(ctx context.Context, arg uintptr) (uint8, error) {
	return __.api_syncer.DoOfUintptrThenUint8(ctx, __, arg)
}

type PoolOfUintptrThenUintptr interface {
	GetUintptrArg() *uintptr
	PutUintptrArg(*uintptr)
	GetUintptrReturn() *uintptr
	PutUintptrReturn(*uintptr)

	GetWorkOfUintptrThenUintptr() *WorkOfUintptrThenUintptr
	GetReturnOfUintptr() *ReturnOfUintptr
	PutWorkOfUintptrThenUintptr(*WorkOfUintptrThenUintptr)
	PutReturnOfUintptr(*ReturnOfUintptr)

	GetChReturnOfUintptr() chan *ReturnOfUintptr
	PutChReturnOfUintptr(chan *ReturnOfUintptr)
}

type PoolOfUintptrThenUintptrImpl struct {
	UintptrArg        sync.Pool
	UintptrRtn        sync.Pool
	UintptrWork       sync.Pool
	UintptrReturn     sync.Pool
	ChReturnOfUintptr sync.Pool
}

func (__ *PoolOfUintptrThenUintptrImpl) GetUintptrArg() *uintptr {
	return __.UintptrArg.Get().(*uintptr)
}
func (__ *PoolOfUintptrThenUintptrImpl) PutUintptrArg(p *uintptr) {
	__.UintptrArg.Put(p)
}
func (__ *PoolOfUintptrThenUintptrImpl) GetUintptrReturn() *uintptr {
	return __.UintptrRtn.Get().(*uintptr)
}
func (__ *PoolOfUintptrThenUintptrImpl) PutUintptrReturn(p *uintptr) {
	__.UintptrRtn.Put(p)
}

func (__ *PoolOfUintptrThenUintptrImpl) GetWorkOfUintptrThenUintptr() *WorkOfUintptrThenUintptr {
	return __.UintptrWork.Get().(*WorkOfUintptrThenUintptr)
}
func (__ *PoolOfUintptrThenUintptrImpl) PutWorkOfUintptrThenUintptr(p *WorkOfUintptrThenUintptr) {
	__.UintptrWork.Put(p)
}
func (__ *PoolOfUintptrThenUintptrImpl) GetReturnOfUintptr() *ReturnOfUintptr {
	return __.UintptrReturn.Get().(*ReturnOfUintptr)
}
func (__ *PoolOfUintptrThenUintptrImpl) PutReturnOfUintptr(p *ReturnOfUintptr) {
	__.UintptrReturn.Put(p)
}

func (__ *PoolOfUintptrThenUintptrImpl) GetChReturnOfUintptr() chan *ReturnOfUintptr {
	return __.ChReturnOfUintptr.Get().(chan *ReturnOfUintptr)
}
func (__ *PoolOfUintptrThenUintptrImpl) PutChReturnOfUintptr(p chan *ReturnOfUintptr) {
	__.ChReturnOfUintptr.Put(p)
}

func NewPoolOfUintptrThenUintptrImpl() *PoolOfUintptrThenUintptrImpl {
	return &PoolOfUintptrThenUintptrImpl{
		UintptrArg: sync.Pool{
			New: func() interface{} {
				return new(uintptr)
			},
		},
		UintptrWork: sync.Pool{
			New: func() interface{} {
				return new(WorkOfUintptrThenUintptr)
			},
		},
		UintptrRtn: sync.Pool{
			New: func() interface{} {
				return new(uintptr)
			},
		},
		UintptrReturn: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfUintptr)
			},
		},
		ChReturnOfUintptr: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfUintptr, 1)
			},
		},
	}
}

type ApiDecouplerOfUintptrThenUintptr struct {
	pool PoolOfUintptrThenUintptr
}

func NewApiDecouplerOfUintptrThenUintptr() *ApiDecouplerOfUintptrThenUintptr {
	return &ApiDecouplerOfUintptrThenUintptr{
		pool: NewPoolOfUintptrThenUintptrImpl(),
	}
}

func (__ *ApiDecouplerOfUintptrThenUintptr) ReturnError(rtn_ch chan<- *ReturnOfUintptr, err error) {
	rtn := __.pool.GetReturnOfUintptr()
	var other uintptr
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfUintptrThenUintptr) HandleOfUintptrThenUintptr(ctx context.Context, req *WorkOfUintptrThenUintptr, h func(ctx context.Context, arg uintptr) (uintptr, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfUintptr()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfUintptrThenUintptr) DoOfUintptrThenUintptr(ctx context.Context, worker WorkerOfPushUintptrThenUintptr, arg uintptr) (uintptr, error) {
	// ch := make(chan *ReturnOfUintptr, 1)
	ch := __.pool.GetChReturnOfUintptr()
	defer __.pool.PutChReturnOfUintptr(ch)

	req := __.pool.GetWorkOfUintptrThenUintptr()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfUintptrThenUintptr(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfUintptr(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfUintptrThenUintptr = func(ctx context.Context, arg uintptr) (uintptr, error)

type WorkerOfUintptrThenUintptr struct {
	api_syncer *ApiDecouplerOfUintptrThenUintptr
	handler    WorkHandlerOfUintptrThenUintptr

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfUintptrThenUintptr
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfUintptrThenUintptr(ctx context.Context, h WorkHandlerOfUintptrThenUintptr, n int) *WorkerOfUintptrThenUintptr {
	__ := &WorkerOfUintptrThenUintptr{
		api_syncer: NewApiDecouplerOfUintptrThenUintptr(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfUintptrThenUintptr, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfUintptrThenUintptr{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfUintptrThenUintptr(req.Context, req.WorkOfUintptrThenUintptr, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfUintptrThenUintptr) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfUintptrThenUintptr) Push(ctx context.Context, req *WorkOfUintptrThenUintptr) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfUintptrThenUintptr)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfUintptrThenUintptr = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfUintptrThenUintptr) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfUintptrThenUintptr) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfUintptrThenUintptr) Call(ctx context.Context, arg uintptr) (uintptr, error) {
	return __.api_syncer.DoOfUintptrThenUintptr(ctx, __, arg)
}

type PoolOfUintptrThenInterface interface {
	GetUintptrArg() *uintptr
	PutUintptrArg(*uintptr)
	GetInterfaceReturn() *interface{}
	PutInterfaceReturn(*interface{})

	GetWorkOfUintptrThenInterface() *WorkOfUintptrThenInterface
	GetReturnOfInterface() *ReturnOfInterface
	PutWorkOfUintptrThenInterface(*WorkOfUintptrThenInterface)
	PutReturnOfInterface(*ReturnOfInterface)

	GetChReturnOfInterface() chan *ReturnOfInterface
	PutChReturnOfInterface(chan *ReturnOfInterface)
}

type PoolOfUintptrThenInterfaceImpl struct {
	UintptrArg          sync.Pool
	InterfaceRtn        sync.Pool
	UintptrWork         sync.Pool
	InterfaceReturn     sync.Pool
	ChReturnOfInterface sync.Pool
}

func (__ *PoolOfUintptrThenInterfaceImpl) GetUintptrArg() *uintptr {
	return __.UintptrArg.Get().(*uintptr)
}
func (__ *PoolOfUintptrThenInterfaceImpl) PutUintptrArg(p *uintptr) {
	__.UintptrArg.Put(p)
}
func (__ *PoolOfUintptrThenInterfaceImpl) GetInterfaceReturn() *interface{} {
	return __.InterfaceRtn.Get().(*interface{})
}
func (__ *PoolOfUintptrThenInterfaceImpl) PutInterfaceReturn(p *interface{}) {
	__.InterfaceRtn.Put(p)
}

func (__ *PoolOfUintptrThenInterfaceImpl) GetWorkOfUintptrThenInterface() *WorkOfUintptrThenInterface {
	return __.UintptrWork.Get().(*WorkOfUintptrThenInterface)
}
func (__ *PoolOfUintptrThenInterfaceImpl) PutWorkOfUintptrThenInterface(p *WorkOfUintptrThenInterface) {
	__.UintptrWork.Put(p)
}
func (__ *PoolOfUintptrThenInterfaceImpl) GetReturnOfInterface() *ReturnOfInterface {
	return __.InterfaceReturn.Get().(*ReturnOfInterface)
}
func (__ *PoolOfUintptrThenInterfaceImpl) PutReturnOfInterface(p *ReturnOfInterface) {
	__.InterfaceReturn.Put(p)
}

func (__ *PoolOfUintptrThenInterfaceImpl) GetChReturnOfInterface() chan *ReturnOfInterface {
	return __.ChReturnOfInterface.Get().(chan *ReturnOfInterface)
}
func (__ *PoolOfUintptrThenInterfaceImpl) PutChReturnOfInterface(p chan *ReturnOfInterface) {
	__.ChReturnOfInterface.Put(p)
}

func NewPoolOfUintptrThenInterfaceImpl() *PoolOfUintptrThenInterfaceImpl {
	return &PoolOfUintptrThenInterfaceImpl{
		UintptrArg: sync.Pool{
			New: func() interface{} {
				return new(uintptr)
			},
		},
		UintptrWork: sync.Pool{
			New: func() interface{} {
				return new(WorkOfUintptrThenInterface)
			},
		},
		InterfaceRtn: sync.Pool{
			New: func() interface{} {
				return new(interface{})
			},
		},
		InterfaceReturn: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfInterface)
			},
		},
		ChReturnOfInterface: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfInterface, 1)
			},
		},
	}
}

type ApiDecouplerOfUintptrThenInterface struct {
	pool PoolOfUintptrThenInterface
}

func NewApiDecouplerOfUintptrThenInterface() *ApiDecouplerOfUintptrThenInterface {
	return &ApiDecouplerOfUintptrThenInterface{
		pool: NewPoolOfUintptrThenInterfaceImpl(),
	}
}

func (__ *ApiDecouplerOfUintptrThenInterface) ReturnError(rtn_ch chan<- *ReturnOfInterface, err error) {
	rtn := __.pool.GetReturnOfInterface()
	var other interface{}
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfUintptrThenInterface) HandleOfUintptrThenInterface(ctx context.Context, req *WorkOfUintptrThenInterface, h func(ctx context.Context, arg uintptr) (interface{}, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfInterface()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfUintptrThenInterface) DoOfUintptrThenInterface(ctx context.Context, worker WorkerOfPushUintptrThenInterface, arg uintptr) (interface{}, error) {
	// ch := make(chan *ReturnOfInterface, 1)
	ch := __.pool.GetChReturnOfInterface()
	defer __.pool.PutChReturnOfInterface(ch)

	req := __.pool.GetWorkOfUintptrThenInterface()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfUintptrThenInterface(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfInterface(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfUintptrThenInterface = func(ctx context.Context, arg uintptr) (interface{}, error)

type WorkerOfUintptrThenInterface struct {
	api_syncer *ApiDecouplerOfUintptrThenInterface
	handler    WorkHandlerOfUintptrThenInterface

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfUintptrThenInterface
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfUintptrThenInterface(ctx context.Context, h WorkHandlerOfUintptrThenInterface, n int) *WorkerOfUintptrThenInterface {
	__ := &WorkerOfUintptrThenInterface{
		api_syncer: NewApiDecouplerOfUintptrThenInterface(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfUintptrThenInterface, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfUintptrThenInterface{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfUintptrThenInterface(req.Context, req.WorkOfUintptrThenInterface, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfUintptrThenInterface) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfUintptrThenInterface) Push(ctx context.Context, req *WorkOfUintptrThenInterface) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfUintptrThenInterface)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfUintptrThenInterface = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfUintptrThenInterface) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfUintptrThenInterface) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfUintptrThenInterface) Call(ctx context.Context, arg uintptr) (interface{}, error) {
	return __.api_syncer.DoOfUintptrThenInterface(ctx, __, arg)
}

type PoolOfUintptrThenStruct interface {
	GetUintptrArg() *uintptr
	PutUintptrArg(*uintptr)
	GetStructReturn() *struct{}
	PutStructReturn(*struct{})

	GetWorkOfUintptrThenStruct() *WorkOfUintptrThenStruct
	GetReturnOfStruct() *ReturnOfStruct
	PutWorkOfUintptrThenStruct(*WorkOfUintptrThenStruct)
	PutReturnOfStruct(*ReturnOfStruct)

	GetChReturnOfStruct() chan *ReturnOfStruct
	PutChReturnOfStruct(chan *ReturnOfStruct)
}

type PoolOfUintptrThenStructImpl struct {
	UintptrArg       sync.Pool
	StructRtn        sync.Pool
	UintptrWork      sync.Pool
	StructReturn     sync.Pool
	ChReturnOfStruct sync.Pool
}

func (__ *PoolOfUintptrThenStructImpl) GetUintptrArg() *uintptr {
	return __.UintptrArg.Get().(*uintptr)
}
func (__ *PoolOfUintptrThenStructImpl) PutUintptrArg(p *uintptr) {
	__.UintptrArg.Put(p)
}
func (__ *PoolOfUintptrThenStructImpl) GetStructReturn() *struct{} {
	return __.StructRtn.Get().(*struct{})
}
func (__ *PoolOfUintptrThenStructImpl) PutStructReturn(p *struct{}) {
	__.StructRtn.Put(p)
}

func (__ *PoolOfUintptrThenStructImpl) GetWorkOfUintptrThenStruct() *WorkOfUintptrThenStruct {
	return __.UintptrWork.Get().(*WorkOfUintptrThenStruct)
}
func (__ *PoolOfUintptrThenStructImpl) PutWorkOfUintptrThenStruct(p *WorkOfUintptrThenStruct) {
	__.UintptrWork.Put(p)
}
func (__ *PoolOfUintptrThenStructImpl) GetReturnOfStruct() *ReturnOfStruct {
	return __.StructReturn.Get().(*ReturnOfStruct)
}
func (__ *PoolOfUintptrThenStructImpl) PutReturnOfStruct(p *ReturnOfStruct) {
	__.StructReturn.Put(p)
}

func (__ *PoolOfUintptrThenStructImpl) GetChReturnOfStruct() chan *ReturnOfStruct {
	return __.ChReturnOfStruct.Get().(chan *ReturnOfStruct)
}
func (__ *PoolOfUintptrThenStructImpl) PutChReturnOfStruct(p chan *ReturnOfStruct) {
	__.ChReturnOfStruct.Put(p)
}

func NewPoolOfUintptrThenStructImpl() *PoolOfUintptrThenStructImpl {
	return &PoolOfUintptrThenStructImpl{
		UintptrArg: sync.Pool{
			New: func() interface{} {
				return new(uintptr)
			},
		},
		UintptrWork: sync.Pool{
			New: func() interface{} {
				return new(WorkOfUintptrThenStruct)
			},
		},
		StructRtn: sync.Pool{
			New: func() interface{} {
				return new(struct{})
			},
		},
		StructReturn: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfStruct)
			},
		},
		ChReturnOfStruct: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfStruct, 1)
			},
		},
	}
}

type ApiDecouplerOfUintptrThenStruct struct {
	pool PoolOfUintptrThenStruct
}

func NewApiDecouplerOfUintptrThenStruct() *ApiDecouplerOfUintptrThenStruct {
	return &ApiDecouplerOfUintptrThenStruct{
		pool: NewPoolOfUintptrThenStructImpl(),
	}
}

func (__ *ApiDecouplerOfUintptrThenStruct) ReturnError(rtn_ch chan<- *ReturnOfStruct, err error) {
	rtn := __.pool.GetReturnOfStruct()
	var other struct{}
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfUintptrThenStruct) HandleOfUintptrThenStruct(ctx context.Context, req *WorkOfUintptrThenStruct, h func(ctx context.Context, arg uintptr) (struct{}, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfStruct()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfUintptrThenStruct) DoOfUintptrThenStruct(ctx context.Context, worker WorkerOfPushUintptrThenStruct, arg uintptr) (struct{}, error) {
	// ch := make(chan *ReturnOfStruct, 1)
	ch := __.pool.GetChReturnOfStruct()
	defer __.pool.PutChReturnOfStruct(ch)

	req := __.pool.GetWorkOfUintptrThenStruct()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfUintptrThenStruct(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfStruct(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfUintptrThenStruct = func(ctx context.Context, arg uintptr) (struct{}, error)

type WorkerOfUintptrThenStruct struct {
	api_syncer *ApiDecouplerOfUintptrThenStruct
	handler    WorkHandlerOfUintptrThenStruct

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfUintptrThenStruct
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfUintptrThenStruct(ctx context.Context, h WorkHandlerOfUintptrThenStruct, n int) *WorkerOfUintptrThenStruct {
	__ := &WorkerOfUintptrThenStruct{
		api_syncer: NewApiDecouplerOfUintptrThenStruct(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfUintptrThenStruct, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfUintptrThenStruct{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfUintptrThenStruct(req.Context, req.WorkOfUintptrThenStruct, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfUintptrThenStruct) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfUintptrThenStruct) Push(ctx context.Context, req *WorkOfUintptrThenStruct) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfUintptrThenStruct)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfUintptrThenStruct = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfUintptrThenStruct) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfUintptrThenStruct) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfUintptrThenStruct) Call(ctx context.Context, arg uintptr) (struct{}, error) {
	return __.api_syncer.DoOfUintptrThenStruct(ctx, __, arg)
}

type PoolOfInterfaceThenBool interface {
	GetInterfaceArg() *interface{}
	PutInterfaceArg(*interface{})
	GetBoolReturn() *bool
	PutBoolReturn(*bool)

	GetWorkOfInterfaceThenBool() *WorkOfInterfaceThenBool
	GetReturnOfBool() *ReturnOfBool
	PutWorkOfInterfaceThenBool(*WorkOfInterfaceThenBool)
	PutReturnOfBool(*ReturnOfBool)

	GetChReturnOfBool() chan *ReturnOfBool
	PutChReturnOfBool(chan *ReturnOfBool)
}

type PoolOfInterfaceThenBoolImpl struct {
	InterfaceArg   sync.Pool
	BoolRtn        sync.Pool
	InterfaceWork  sync.Pool
	BoolReturn     sync.Pool
	ChReturnOfBool sync.Pool
}

func (__ *PoolOfInterfaceThenBoolImpl) GetInterfaceArg() *interface{} {
	return __.InterfaceArg.Get().(*interface{})
}
func (__ *PoolOfInterfaceThenBoolImpl) PutInterfaceArg(p *interface{}) {
	__.InterfaceArg.Put(p)
}
func (__ *PoolOfInterfaceThenBoolImpl) GetBoolReturn() *bool {
	return __.BoolRtn.Get().(*bool)
}
func (__ *PoolOfInterfaceThenBoolImpl) PutBoolReturn(p *bool) {
	__.BoolRtn.Put(p)
}

func (__ *PoolOfInterfaceThenBoolImpl) GetWorkOfInterfaceThenBool() *WorkOfInterfaceThenBool {
	return __.InterfaceWork.Get().(*WorkOfInterfaceThenBool)
}
func (__ *PoolOfInterfaceThenBoolImpl) PutWorkOfInterfaceThenBool(p *WorkOfInterfaceThenBool) {
	__.InterfaceWork.Put(p)
}
func (__ *PoolOfInterfaceThenBoolImpl) GetReturnOfBool() *ReturnOfBool {
	return __.BoolReturn.Get().(*ReturnOfBool)
}
func (__ *PoolOfInterfaceThenBoolImpl) PutReturnOfBool(p *ReturnOfBool) {
	__.BoolReturn.Put(p)
}

func (__ *PoolOfInterfaceThenBoolImpl) GetChReturnOfBool() chan *ReturnOfBool {
	return __.ChReturnOfBool.Get().(chan *ReturnOfBool)
}
func (__ *PoolOfInterfaceThenBoolImpl) PutChReturnOfBool(p chan *ReturnOfBool) {
	__.ChReturnOfBool.Put(p)
}

func NewPoolOfInterfaceThenBoolImpl() *PoolOfInterfaceThenBoolImpl {
	return &PoolOfInterfaceThenBoolImpl{
		InterfaceArg: sync.Pool{
			New: func() interface{} {
				return new(interface{})
			},
		},
		InterfaceWork: sync.Pool{
			New: func() interface{} {
				return new(WorkOfInterfaceThenBool)
			},
		},
		BoolRtn: sync.Pool{
			New: func() interface{} {
				return new(bool)
			},
		},
		BoolReturn: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfBool)
			},
		},
		ChReturnOfBool: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfBool, 1)
			},
		},
	}
}

type ApiDecouplerOfInterfaceThenBool struct {
	pool PoolOfInterfaceThenBool
}

func NewApiDecouplerOfInterfaceThenBool() *ApiDecouplerOfInterfaceThenBool {
	return &ApiDecouplerOfInterfaceThenBool{
		pool: NewPoolOfInterfaceThenBoolImpl(),
	}
}

func (__ *ApiDecouplerOfInterfaceThenBool) ReturnError(rtn_ch chan<- *ReturnOfBool, err error) {
	rtn := __.pool.GetReturnOfBool()
	var other bool
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfInterfaceThenBool) HandleOfInterfaceThenBool(ctx context.Context, req *WorkOfInterfaceThenBool, h func(ctx context.Context, arg interface{}) (bool, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfBool()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfInterfaceThenBool) DoOfInterfaceThenBool(ctx context.Context, worker WorkerOfPushInterfaceThenBool, arg interface{}) (bool, error) {
	// ch := make(chan *ReturnOfBool, 1)
	ch := __.pool.GetChReturnOfBool()
	defer __.pool.PutChReturnOfBool(ch)

	req := __.pool.GetWorkOfInterfaceThenBool()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfInterfaceThenBool(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfBool(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfInterfaceThenBool = func(ctx context.Context, arg interface{}) (bool, error)

type WorkerOfInterfaceThenBool struct {
	api_syncer *ApiDecouplerOfInterfaceThenBool
	handler    WorkHandlerOfInterfaceThenBool

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfInterfaceThenBool
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfInterfaceThenBool(ctx context.Context, h WorkHandlerOfInterfaceThenBool, n int) *WorkerOfInterfaceThenBool {
	__ := &WorkerOfInterfaceThenBool{
		api_syncer: NewApiDecouplerOfInterfaceThenBool(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfInterfaceThenBool, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfInterfaceThenBool{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfInterfaceThenBool(req.Context, req.WorkOfInterfaceThenBool, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfInterfaceThenBool) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfInterfaceThenBool) Push(ctx context.Context, req *WorkOfInterfaceThenBool) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfInterfaceThenBool)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfInterfaceThenBool = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfInterfaceThenBool) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfInterfaceThenBool) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfInterfaceThenBool) Call(ctx context.Context, arg interface{}) (bool, error) {
	return __.api_syncer.DoOfInterfaceThenBool(ctx, __, arg)
}

type PoolOfInterfaceThenByte interface {
	GetInterfaceArg() *interface{}
	PutInterfaceArg(*interface{})
	GetByteReturn() *byte
	PutByteReturn(*byte)

	GetWorkOfInterfaceThenByte() *WorkOfInterfaceThenByte
	GetReturnOfByte() *ReturnOfByte
	PutWorkOfInterfaceThenByte(*WorkOfInterfaceThenByte)
	PutReturnOfByte(*ReturnOfByte)

	GetChReturnOfByte() chan *ReturnOfByte
	PutChReturnOfByte(chan *ReturnOfByte)
}

type PoolOfInterfaceThenByteImpl struct {
	InterfaceArg   sync.Pool
	ByteRtn        sync.Pool
	InterfaceWork  sync.Pool
	ByteReturn     sync.Pool
	ChReturnOfByte sync.Pool
}

func (__ *PoolOfInterfaceThenByteImpl) GetInterfaceArg() *interface{} {
	return __.InterfaceArg.Get().(*interface{})
}
func (__ *PoolOfInterfaceThenByteImpl) PutInterfaceArg(p *interface{}) {
	__.InterfaceArg.Put(p)
}
func (__ *PoolOfInterfaceThenByteImpl) GetByteReturn() *byte {
	return __.ByteRtn.Get().(*byte)
}
func (__ *PoolOfInterfaceThenByteImpl) PutByteReturn(p *byte) {
	__.ByteRtn.Put(p)
}

func (__ *PoolOfInterfaceThenByteImpl) GetWorkOfInterfaceThenByte() *WorkOfInterfaceThenByte {
	return __.InterfaceWork.Get().(*WorkOfInterfaceThenByte)
}
func (__ *PoolOfInterfaceThenByteImpl) PutWorkOfInterfaceThenByte(p *WorkOfInterfaceThenByte) {
	__.InterfaceWork.Put(p)
}
func (__ *PoolOfInterfaceThenByteImpl) GetReturnOfByte() *ReturnOfByte {
	return __.ByteReturn.Get().(*ReturnOfByte)
}
func (__ *PoolOfInterfaceThenByteImpl) PutReturnOfByte(p *ReturnOfByte) {
	__.ByteReturn.Put(p)
}

func (__ *PoolOfInterfaceThenByteImpl) GetChReturnOfByte() chan *ReturnOfByte {
	return __.ChReturnOfByte.Get().(chan *ReturnOfByte)
}
func (__ *PoolOfInterfaceThenByteImpl) PutChReturnOfByte(p chan *ReturnOfByte) {
	__.ChReturnOfByte.Put(p)
}

func NewPoolOfInterfaceThenByteImpl() *PoolOfInterfaceThenByteImpl {
	return &PoolOfInterfaceThenByteImpl{
		InterfaceArg: sync.Pool{
			New: func() interface{} {
				return new(interface{})
			},
		},
		InterfaceWork: sync.Pool{
			New: func() interface{} {
				return new(WorkOfInterfaceThenByte)
			},
		},
		ByteRtn: sync.Pool{
			New: func() interface{} {
				return new(byte)
			},
		},
		ByteReturn: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfByte)
			},
		},
		ChReturnOfByte: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfByte, 1)
			},
		},
	}
}

type ApiDecouplerOfInterfaceThenByte struct {
	pool PoolOfInterfaceThenByte
}

func NewApiDecouplerOfInterfaceThenByte() *ApiDecouplerOfInterfaceThenByte {
	return &ApiDecouplerOfInterfaceThenByte{
		pool: NewPoolOfInterfaceThenByteImpl(),
	}
}

func (__ *ApiDecouplerOfInterfaceThenByte) ReturnError(rtn_ch chan<- *ReturnOfByte, err error) {
	rtn := __.pool.GetReturnOfByte()
	var other byte
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfInterfaceThenByte) HandleOfInterfaceThenByte(ctx context.Context, req *WorkOfInterfaceThenByte, h func(ctx context.Context, arg interface{}) (byte, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfByte()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfInterfaceThenByte) DoOfInterfaceThenByte(ctx context.Context, worker WorkerOfPushInterfaceThenByte, arg interface{}) (byte, error) {
	// ch := make(chan *ReturnOfByte, 1)
	ch := __.pool.GetChReturnOfByte()
	defer __.pool.PutChReturnOfByte(ch)

	req := __.pool.GetWorkOfInterfaceThenByte()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfInterfaceThenByte(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfByte(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfInterfaceThenByte = func(ctx context.Context, arg interface{}) (byte, error)

type WorkerOfInterfaceThenByte struct {
	api_syncer *ApiDecouplerOfInterfaceThenByte
	handler    WorkHandlerOfInterfaceThenByte

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfInterfaceThenByte
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfInterfaceThenByte(ctx context.Context, h WorkHandlerOfInterfaceThenByte, n int) *WorkerOfInterfaceThenByte {
	__ := &WorkerOfInterfaceThenByte{
		api_syncer: NewApiDecouplerOfInterfaceThenByte(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfInterfaceThenByte, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfInterfaceThenByte{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfInterfaceThenByte(req.Context, req.WorkOfInterfaceThenByte, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfInterfaceThenByte) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfInterfaceThenByte) Push(ctx context.Context, req *WorkOfInterfaceThenByte) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfInterfaceThenByte)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfInterfaceThenByte = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfInterfaceThenByte) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfInterfaceThenByte) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfInterfaceThenByte) Call(ctx context.Context, arg interface{}) (byte, error) {
	return __.api_syncer.DoOfInterfaceThenByte(ctx, __, arg)
}

type PoolOfInterfaceThenComplex128 interface {
	GetInterfaceArg() *interface{}
	PutInterfaceArg(*interface{})
	GetComplex128Return() *complex128
	PutComplex128Return(*complex128)

	GetWorkOfInterfaceThenComplex128() *WorkOfInterfaceThenComplex128
	GetReturnOfComplex128() *ReturnOfComplex128
	PutWorkOfInterfaceThenComplex128(*WorkOfInterfaceThenComplex128)
	PutReturnOfComplex128(*ReturnOfComplex128)

	GetChReturnOfComplex128() chan *ReturnOfComplex128
	PutChReturnOfComplex128(chan *ReturnOfComplex128)
}

type PoolOfInterfaceThenComplex128Impl struct {
	InterfaceArg         sync.Pool
	Complex128Rtn        sync.Pool
	InterfaceWork        sync.Pool
	Complex128Return     sync.Pool
	ChReturnOfComplex128 sync.Pool
}

func (__ *PoolOfInterfaceThenComplex128Impl) GetInterfaceArg() *interface{} {
	return __.InterfaceArg.Get().(*interface{})
}
func (__ *PoolOfInterfaceThenComplex128Impl) PutInterfaceArg(p *interface{}) {
	__.InterfaceArg.Put(p)
}
func (__ *PoolOfInterfaceThenComplex128Impl) GetComplex128Return() *complex128 {
	return __.Complex128Rtn.Get().(*complex128)
}
func (__ *PoolOfInterfaceThenComplex128Impl) PutComplex128Return(p *complex128) {
	__.Complex128Rtn.Put(p)
}

func (__ *PoolOfInterfaceThenComplex128Impl) GetWorkOfInterfaceThenComplex128() *WorkOfInterfaceThenComplex128 {
	return __.InterfaceWork.Get().(*WorkOfInterfaceThenComplex128)
}
func (__ *PoolOfInterfaceThenComplex128Impl) PutWorkOfInterfaceThenComplex128(p *WorkOfInterfaceThenComplex128) {
	__.InterfaceWork.Put(p)
}
func (__ *PoolOfInterfaceThenComplex128Impl) GetReturnOfComplex128() *ReturnOfComplex128 {
	return __.Complex128Return.Get().(*ReturnOfComplex128)
}
func (__ *PoolOfInterfaceThenComplex128Impl) PutReturnOfComplex128(p *ReturnOfComplex128) {
	__.Complex128Return.Put(p)
}

func (__ *PoolOfInterfaceThenComplex128Impl) GetChReturnOfComplex128() chan *ReturnOfComplex128 {
	return __.ChReturnOfComplex128.Get().(chan *ReturnOfComplex128)
}
func (__ *PoolOfInterfaceThenComplex128Impl) PutChReturnOfComplex128(p chan *ReturnOfComplex128) {
	__.ChReturnOfComplex128.Put(p)
}

func NewPoolOfInterfaceThenComplex128Impl() *PoolOfInterfaceThenComplex128Impl {
	return &PoolOfInterfaceThenComplex128Impl{
		InterfaceArg: sync.Pool{
			New: func() interface{} {
				return new(interface{})
			},
		},
		InterfaceWork: sync.Pool{
			New: func() interface{} {
				return new(WorkOfInterfaceThenComplex128)
			},
		},
		Complex128Rtn: sync.Pool{
			New: func() interface{} {
				return new(complex128)
			},
		},
		Complex128Return: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfComplex128)
			},
		},
		ChReturnOfComplex128: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfComplex128, 1)
			},
		},
	}
}

type ApiDecouplerOfInterfaceThenComplex128 struct {
	pool PoolOfInterfaceThenComplex128
}

func NewApiDecouplerOfInterfaceThenComplex128() *ApiDecouplerOfInterfaceThenComplex128 {
	return &ApiDecouplerOfInterfaceThenComplex128{
		pool: NewPoolOfInterfaceThenComplex128Impl(),
	}
}

func (__ *ApiDecouplerOfInterfaceThenComplex128) ReturnError(rtn_ch chan<- *ReturnOfComplex128, err error) {
	rtn := __.pool.GetReturnOfComplex128()
	var other complex128
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfInterfaceThenComplex128) HandleOfInterfaceThenComplex128(ctx context.Context, req *WorkOfInterfaceThenComplex128, h func(ctx context.Context, arg interface{}) (complex128, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfComplex128()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfInterfaceThenComplex128) DoOfInterfaceThenComplex128(ctx context.Context, worker WorkerOfPushInterfaceThenComplex128, arg interface{}) (complex128, error) {
	// ch := make(chan *ReturnOfComplex128, 1)
	ch := __.pool.GetChReturnOfComplex128()
	defer __.pool.PutChReturnOfComplex128(ch)

	req := __.pool.GetWorkOfInterfaceThenComplex128()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfInterfaceThenComplex128(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfComplex128(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfInterfaceThenComplex128 = func(ctx context.Context, arg interface{}) (complex128, error)

type WorkerOfInterfaceThenComplex128 struct {
	api_syncer *ApiDecouplerOfInterfaceThenComplex128
	handler    WorkHandlerOfInterfaceThenComplex128

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfInterfaceThenComplex128
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfInterfaceThenComplex128(ctx context.Context, h WorkHandlerOfInterfaceThenComplex128, n int) *WorkerOfInterfaceThenComplex128 {
	__ := &WorkerOfInterfaceThenComplex128{
		api_syncer: NewApiDecouplerOfInterfaceThenComplex128(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfInterfaceThenComplex128, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfInterfaceThenComplex128{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfInterfaceThenComplex128(req.Context, req.WorkOfInterfaceThenComplex128, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfInterfaceThenComplex128) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfInterfaceThenComplex128) Push(ctx context.Context, req *WorkOfInterfaceThenComplex128) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfInterfaceThenComplex128)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfInterfaceThenComplex128 = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfInterfaceThenComplex128) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfInterfaceThenComplex128) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfInterfaceThenComplex128) Call(ctx context.Context, arg interface{}) (complex128, error) {
	return __.api_syncer.DoOfInterfaceThenComplex128(ctx, __, arg)
}

type PoolOfInterfaceThenComplex64 interface {
	GetInterfaceArg() *interface{}
	PutInterfaceArg(*interface{})
	GetComplex64Return() *complex64
	PutComplex64Return(*complex64)

	GetWorkOfInterfaceThenComplex64() *WorkOfInterfaceThenComplex64
	GetReturnOfComplex64() *ReturnOfComplex64
	PutWorkOfInterfaceThenComplex64(*WorkOfInterfaceThenComplex64)
	PutReturnOfComplex64(*ReturnOfComplex64)

	GetChReturnOfComplex64() chan *ReturnOfComplex64
	PutChReturnOfComplex64(chan *ReturnOfComplex64)
}

type PoolOfInterfaceThenComplex64Impl struct {
	InterfaceArg        sync.Pool
	Complex64Rtn        sync.Pool
	InterfaceWork       sync.Pool
	Complex64Return     sync.Pool
	ChReturnOfComplex64 sync.Pool
}

func (__ *PoolOfInterfaceThenComplex64Impl) GetInterfaceArg() *interface{} {
	return __.InterfaceArg.Get().(*interface{})
}
func (__ *PoolOfInterfaceThenComplex64Impl) PutInterfaceArg(p *interface{}) {
	__.InterfaceArg.Put(p)
}
func (__ *PoolOfInterfaceThenComplex64Impl) GetComplex64Return() *complex64 {
	return __.Complex64Rtn.Get().(*complex64)
}
func (__ *PoolOfInterfaceThenComplex64Impl) PutComplex64Return(p *complex64) {
	__.Complex64Rtn.Put(p)
}

func (__ *PoolOfInterfaceThenComplex64Impl) GetWorkOfInterfaceThenComplex64() *WorkOfInterfaceThenComplex64 {
	return __.InterfaceWork.Get().(*WorkOfInterfaceThenComplex64)
}
func (__ *PoolOfInterfaceThenComplex64Impl) PutWorkOfInterfaceThenComplex64(p *WorkOfInterfaceThenComplex64) {
	__.InterfaceWork.Put(p)
}
func (__ *PoolOfInterfaceThenComplex64Impl) GetReturnOfComplex64() *ReturnOfComplex64 {
	return __.Complex64Return.Get().(*ReturnOfComplex64)
}
func (__ *PoolOfInterfaceThenComplex64Impl) PutReturnOfComplex64(p *ReturnOfComplex64) {
	__.Complex64Return.Put(p)
}

func (__ *PoolOfInterfaceThenComplex64Impl) GetChReturnOfComplex64() chan *ReturnOfComplex64 {
	return __.ChReturnOfComplex64.Get().(chan *ReturnOfComplex64)
}
func (__ *PoolOfInterfaceThenComplex64Impl) PutChReturnOfComplex64(p chan *ReturnOfComplex64) {
	__.ChReturnOfComplex64.Put(p)
}

func NewPoolOfInterfaceThenComplex64Impl() *PoolOfInterfaceThenComplex64Impl {
	return &PoolOfInterfaceThenComplex64Impl{
		InterfaceArg: sync.Pool{
			New: func() interface{} {
				return new(interface{})
			},
		},
		InterfaceWork: sync.Pool{
			New: func() interface{} {
				return new(WorkOfInterfaceThenComplex64)
			},
		},
		Complex64Rtn: sync.Pool{
			New: func() interface{} {
				return new(complex64)
			},
		},
		Complex64Return: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfComplex64)
			},
		},
		ChReturnOfComplex64: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfComplex64, 1)
			},
		},
	}
}

type ApiDecouplerOfInterfaceThenComplex64 struct {
	pool PoolOfInterfaceThenComplex64
}

func NewApiDecouplerOfInterfaceThenComplex64() *ApiDecouplerOfInterfaceThenComplex64 {
	return &ApiDecouplerOfInterfaceThenComplex64{
		pool: NewPoolOfInterfaceThenComplex64Impl(),
	}
}

func (__ *ApiDecouplerOfInterfaceThenComplex64) ReturnError(rtn_ch chan<- *ReturnOfComplex64, err error) {
	rtn := __.pool.GetReturnOfComplex64()
	var other complex64
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfInterfaceThenComplex64) HandleOfInterfaceThenComplex64(ctx context.Context, req *WorkOfInterfaceThenComplex64, h func(ctx context.Context, arg interface{}) (complex64, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfComplex64()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfInterfaceThenComplex64) DoOfInterfaceThenComplex64(ctx context.Context, worker WorkerOfPushInterfaceThenComplex64, arg interface{}) (complex64, error) {
	// ch := make(chan *ReturnOfComplex64, 1)
	ch := __.pool.GetChReturnOfComplex64()
	defer __.pool.PutChReturnOfComplex64(ch)

	req := __.pool.GetWorkOfInterfaceThenComplex64()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfInterfaceThenComplex64(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfComplex64(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfInterfaceThenComplex64 = func(ctx context.Context, arg interface{}) (complex64, error)

type WorkerOfInterfaceThenComplex64 struct {
	api_syncer *ApiDecouplerOfInterfaceThenComplex64
	handler    WorkHandlerOfInterfaceThenComplex64

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfInterfaceThenComplex64
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfInterfaceThenComplex64(ctx context.Context, h WorkHandlerOfInterfaceThenComplex64, n int) *WorkerOfInterfaceThenComplex64 {
	__ := &WorkerOfInterfaceThenComplex64{
		api_syncer: NewApiDecouplerOfInterfaceThenComplex64(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfInterfaceThenComplex64, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfInterfaceThenComplex64{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfInterfaceThenComplex64(req.Context, req.WorkOfInterfaceThenComplex64, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfInterfaceThenComplex64) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfInterfaceThenComplex64) Push(ctx context.Context, req *WorkOfInterfaceThenComplex64) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfInterfaceThenComplex64)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfInterfaceThenComplex64 = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfInterfaceThenComplex64) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfInterfaceThenComplex64) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfInterfaceThenComplex64) Call(ctx context.Context, arg interface{}) (complex64, error) {
	return __.api_syncer.DoOfInterfaceThenComplex64(ctx, __, arg)
}

type PoolOfInterfaceThenError interface {
	GetInterfaceArg() *interface{}
	PutInterfaceArg(*interface{})
	GetErrorReturn() *error
	PutErrorReturn(*error)

	GetWorkOfInterfaceThenError() *WorkOfInterfaceThenError
	GetReturnOfError() *ReturnOfError
	PutWorkOfInterfaceThenError(*WorkOfInterfaceThenError)
	PutReturnOfError(*ReturnOfError)

	GetChReturnOfError() chan *ReturnOfError
	PutChReturnOfError(chan *ReturnOfError)
}

type PoolOfInterfaceThenErrorImpl struct {
	InterfaceArg    sync.Pool
	ErrorRtn        sync.Pool
	InterfaceWork   sync.Pool
	ErrorReturn     sync.Pool
	ChReturnOfError sync.Pool
}

func (__ *PoolOfInterfaceThenErrorImpl) GetInterfaceArg() *interface{} {
	return __.InterfaceArg.Get().(*interface{})
}
func (__ *PoolOfInterfaceThenErrorImpl) PutInterfaceArg(p *interface{}) {
	__.InterfaceArg.Put(p)
}
func (__ *PoolOfInterfaceThenErrorImpl) GetErrorReturn() *error {
	return __.ErrorRtn.Get().(*error)
}
func (__ *PoolOfInterfaceThenErrorImpl) PutErrorReturn(p *error) {
	__.ErrorRtn.Put(p)
}

func (__ *PoolOfInterfaceThenErrorImpl) GetWorkOfInterfaceThenError() *WorkOfInterfaceThenError {
	return __.InterfaceWork.Get().(*WorkOfInterfaceThenError)
}
func (__ *PoolOfInterfaceThenErrorImpl) PutWorkOfInterfaceThenError(p *WorkOfInterfaceThenError) {
	__.InterfaceWork.Put(p)
}
func (__ *PoolOfInterfaceThenErrorImpl) GetReturnOfError() *ReturnOfError {
	return __.ErrorReturn.Get().(*ReturnOfError)
}
func (__ *PoolOfInterfaceThenErrorImpl) PutReturnOfError(p *ReturnOfError) {
	__.ErrorReturn.Put(p)
}

func (__ *PoolOfInterfaceThenErrorImpl) GetChReturnOfError() chan *ReturnOfError {
	return __.ChReturnOfError.Get().(chan *ReturnOfError)
}
func (__ *PoolOfInterfaceThenErrorImpl) PutChReturnOfError(p chan *ReturnOfError) {
	__.ChReturnOfError.Put(p)
}

func NewPoolOfInterfaceThenErrorImpl() *PoolOfInterfaceThenErrorImpl {
	return &PoolOfInterfaceThenErrorImpl{
		InterfaceArg: sync.Pool{
			New: func() interface{} {
				return new(interface{})
			},
		},
		InterfaceWork: sync.Pool{
			New: func() interface{} {
				return new(WorkOfInterfaceThenError)
			},
		},
		ErrorRtn: sync.Pool{
			New: func() interface{} {
				return new(error)
			},
		},
		ErrorReturn: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfError)
			},
		},
		ChReturnOfError: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfError, 1)
			},
		},
	}
}

type ApiDecouplerOfInterfaceThenError struct {
	pool PoolOfInterfaceThenError
}

func NewApiDecouplerOfInterfaceThenError() *ApiDecouplerOfInterfaceThenError {
	return &ApiDecouplerOfInterfaceThenError{
		pool: NewPoolOfInterfaceThenErrorImpl(),
	}
}

func (__ *ApiDecouplerOfInterfaceThenError) ReturnError(rtn_ch chan<- *ReturnOfError, err error) {
	rtn := __.pool.GetReturnOfError()
	var other error
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfInterfaceThenError) HandleOfInterfaceThenError(ctx context.Context, req *WorkOfInterfaceThenError, h func(ctx context.Context, arg interface{}) (error, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfError()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfInterfaceThenError) DoOfInterfaceThenError(ctx context.Context, worker WorkerOfPushInterfaceThenError, arg interface{}) (error, error) {
	// ch := make(chan *ReturnOfError, 1)
	ch := __.pool.GetChReturnOfError()
	defer __.pool.PutChReturnOfError(ch)

	req := __.pool.GetWorkOfInterfaceThenError()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfInterfaceThenError(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfError(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfInterfaceThenError = func(ctx context.Context, arg interface{}) (error, error)

type WorkerOfInterfaceThenError struct {
	api_syncer *ApiDecouplerOfInterfaceThenError
	handler    WorkHandlerOfInterfaceThenError

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfInterfaceThenError
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfInterfaceThenError(ctx context.Context, h WorkHandlerOfInterfaceThenError, n int) *WorkerOfInterfaceThenError {
	__ := &WorkerOfInterfaceThenError{
		api_syncer: NewApiDecouplerOfInterfaceThenError(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfInterfaceThenError, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfInterfaceThenError{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfInterfaceThenError(req.Context, req.WorkOfInterfaceThenError, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfInterfaceThenError) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfInterfaceThenError) Push(ctx context.Context, req *WorkOfInterfaceThenError) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfInterfaceThenError)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfInterfaceThenError = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfInterfaceThenError) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfInterfaceThenError) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfInterfaceThenError) Call(ctx context.Context, arg interface{}) (error, error) {
	return __.api_syncer.DoOfInterfaceThenError(ctx, __, arg)
}

type PoolOfInterfaceThenFloat32 interface {
	GetInterfaceArg() *interface{}
	PutInterfaceArg(*interface{})
	GetFloat32Return() *float32
	PutFloat32Return(*float32)

	GetWorkOfInterfaceThenFloat32() *WorkOfInterfaceThenFloat32
	GetReturnOfFloat32() *ReturnOfFloat32
	PutWorkOfInterfaceThenFloat32(*WorkOfInterfaceThenFloat32)
	PutReturnOfFloat32(*ReturnOfFloat32)

	GetChReturnOfFloat32() chan *ReturnOfFloat32
	PutChReturnOfFloat32(chan *ReturnOfFloat32)
}

type PoolOfInterfaceThenFloat32Impl struct {
	InterfaceArg      sync.Pool
	Float32Rtn        sync.Pool
	InterfaceWork     sync.Pool
	Float32Return     sync.Pool
	ChReturnOfFloat32 sync.Pool
}

func (__ *PoolOfInterfaceThenFloat32Impl) GetInterfaceArg() *interface{} {
	return __.InterfaceArg.Get().(*interface{})
}
func (__ *PoolOfInterfaceThenFloat32Impl) PutInterfaceArg(p *interface{}) {
	__.InterfaceArg.Put(p)
}
func (__ *PoolOfInterfaceThenFloat32Impl) GetFloat32Return() *float32 {
	return __.Float32Rtn.Get().(*float32)
}
func (__ *PoolOfInterfaceThenFloat32Impl) PutFloat32Return(p *float32) {
	__.Float32Rtn.Put(p)
}

func (__ *PoolOfInterfaceThenFloat32Impl) GetWorkOfInterfaceThenFloat32() *WorkOfInterfaceThenFloat32 {
	return __.InterfaceWork.Get().(*WorkOfInterfaceThenFloat32)
}
func (__ *PoolOfInterfaceThenFloat32Impl) PutWorkOfInterfaceThenFloat32(p *WorkOfInterfaceThenFloat32) {
	__.InterfaceWork.Put(p)
}
func (__ *PoolOfInterfaceThenFloat32Impl) GetReturnOfFloat32() *ReturnOfFloat32 {
	return __.Float32Return.Get().(*ReturnOfFloat32)
}
func (__ *PoolOfInterfaceThenFloat32Impl) PutReturnOfFloat32(p *ReturnOfFloat32) {
	__.Float32Return.Put(p)
}

func (__ *PoolOfInterfaceThenFloat32Impl) GetChReturnOfFloat32() chan *ReturnOfFloat32 {
	return __.ChReturnOfFloat32.Get().(chan *ReturnOfFloat32)
}
func (__ *PoolOfInterfaceThenFloat32Impl) PutChReturnOfFloat32(p chan *ReturnOfFloat32) {
	__.ChReturnOfFloat32.Put(p)
}

func NewPoolOfInterfaceThenFloat32Impl() *PoolOfInterfaceThenFloat32Impl {
	return &PoolOfInterfaceThenFloat32Impl{
		InterfaceArg: sync.Pool{
			New: func() interface{} {
				return new(interface{})
			},
		},
		InterfaceWork: sync.Pool{
			New: func() interface{} {
				return new(WorkOfInterfaceThenFloat32)
			},
		},
		Float32Rtn: sync.Pool{
			New: func() interface{} {
				return new(float32)
			},
		},
		Float32Return: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfFloat32)
			},
		},
		ChReturnOfFloat32: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfFloat32, 1)
			},
		},
	}
}

type ApiDecouplerOfInterfaceThenFloat32 struct {
	pool PoolOfInterfaceThenFloat32
}

func NewApiDecouplerOfInterfaceThenFloat32() *ApiDecouplerOfInterfaceThenFloat32 {
	return &ApiDecouplerOfInterfaceThenFloat32{
		pool: NewPoolOfInterfaceThenFloat32Impl(),
	}
}

func (__ *ApiDecouplerOfInterfaceThenFloat32) ReturnError(rtn_ch chan<- *ReturnOfFloat32, err error) {
	rtn := __.pool.GetReturnOfFloat32()
	var other float32
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfInterfaceThenFloat32) HandleOfInterfaceThenFloat32(ctx context.Context, req *WorkOfInterfaceThenFloat32, h func(ctx context.Context, arg interface{}) (float32, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfFloat32()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfInterfaceThenFloat32) DoOfInterfaceThenFloat32(ctx context.Context, worker WorkerOfPushInterfaceThenFloat32, arg interface{}) (float32, error) {
	// ch := make(chan *ReturnOfFloat32, 1)
	ch := __.pool.GetChReturnOfFloat32()
	defer __.pool.PutChReturnOfFloat32(ch)

	req := __.pool.GetWorkOfInterfaceThenFloat32()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfInterfaceThenFloat32(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfFloat32(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfInterfaceThenFloat32 = func(ctx context.Context, arg interface{}) (float32, error)

type WorkerOfInterfaceThenFloat32 struct {
	api_syncer *ApiDecouplerOfInterfaceThenFloat32
	handler    WorkHandlerOfInterfaceThenFloat32

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfInterfaceThenFloat32
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfInterfaceThenFloat32(ctx context.Context, h WorkHandlerOfInterfaceThenFloat32, n int) *WorkerOfInterfaceThenFloat32 {
	__ := &WorkerOfInterfaceThenFloat32{
		api_syncer: NewApiDecouplerOfInterfaceThenFloat32(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfInterfaceThenFloat32, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfInterfaceThenFloat32{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfInterfaceThenFloat32(req.Context, req.WorkOfInterfaceThenFloat32, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfInterfaceThenFloat32) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfInterfaceThenFloat32) Push(ctx context.Context, req *WorkOfInterfaceThenFloat32) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfInterfaceThenFloat32)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfInterfaceThenFloat32 = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfInterfaceThenFloat32) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfInterfaceThenFloat32) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfInterfaceThenFloat32) Call(ctx context.Context, arg interface{}) (float32, error) {
	return __.api_syncer.DoOfInterfaceThenFloat32(ctx, __, arg)
}

type PoolOfInterfaceThenFloat64 interface {
	GetInterfaceArg() *interface{}
	PutInterfaceArg(*interface{})
	GetFloat64Return() *float64
	PutFloat64Return(*float64)

	GetWorkOfInterfaceThenFloat64() *WorkOfInterfaceThenFloat64
	GetReturnOfFloat64() *ReturnOfFloat64
	PutWorkOfInterfaceThenFloat64(*WorkOfInterfaceThenFloat64)
	PutReturnOfFloat64(*ReturnOfFloat64)

	GetChReturnOfFloat64() chan *ReturnOfFloat64
	PutChReturnOfFloat64(chan *ReturnOfFloat64)
}

type PoolOfInterfaceThenFloat64Impl struct {
	InterfaceArg      sync.Pool
	Float64Rtn        sync.Pool
	InterfaceWork     sync.Pool
	Float64Return     sync.Pool
	ChReturnOfFloat64 sync.Pool
}

func (__ *PoolOfInterfaceThenFloat64Impl) GetInterfaceArg() *interface{} {
	return __.InterfaceArg.Get().(*interface{})
}
func (__ *PoolOfInterfaceThenFloat64Impl) PutInterfaceArg(p *interface{}) {
	__.InterfaceArg.Put(p)
}
func (__ *PoolOfInterfaceThenFloat64Impl) GetFloat64Return() *float64 {
	return __.Float64Rtn.Get().(*float64)
}
func (__ *PoolOfInterfaceThenFloat64Impl) PutFloat64Return(p *float64) {
	__.Float64Rtn.Put(p)
}

func (__ *PoolOfInterfaceThenFloat64Impl) GetWorkOfInterfaceThenFloat64() *WorkOfInterfaceThenFloat64 {
	return __.InterfaceWork.Get().(*WorkOfInterfaceThenFloat64)
}
func (__ *PoolOfInterfaceThenFloat64Impl) PutWorkOfInterfaceThenFloat64(p *WorkOfInterfaceThenFloat64) {
	__.InterfaceWork.Put(p)
}
func (__ *PoolOfInterfaceThenFloat64Impl) GetReturnOfFloat64() *ReturnOfFloat64 {
	return __.Float64Return.Get().(*ReturnOfFloat64)
}
func (__ *PoolOfInterfaceThenFloat64Impl) PutReturnOfFloat64(p *ReturnOfFloat64) {
	__.Float64Return.Put(p)
}

func (__ *PoolOfInterfaceThenFloat64Impl) GetChReturnOfFloat64() chan *ReturnOfFloat64 {
	return __.ChReturnOfFloat64.Get().(chan *ReturnOfFloat64)
}
func (__ *PoolOfInterfaceThenFloat64Impl) PutChReturnOfFloat64(p chan *ReturnOfFloat64) {
	__.ChReturnOfFloat64.Put(p)
}

func NewPoolOfInterfaceThenFloat64Impl() *PoolOfInterfaceThenFloat64Impl {
	return &PoolOfInterfaceThenFloat64Impl{
		InterfaceArg: sync.Pool{
			New: func() interface{} {
				return new(interface{})
			},
		},
		InterfaceWork: sync.Pool{
			New: func() interface{} {
				return new(WorkOfInterfaceThenFloat64)
			},
		},
		Float64Rtn: sync.Pool{
			New: func() interface{} {
				return new(float64)
			},
		},
		Float64Return: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfFloat64)
			},
		},
		ChReturnOfFloat64: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfFloat64, 1)
			},
		},
	}
}

type ApiDecouplerOfInterfaceThenFloat64 struct {
	pool PoolOfInterfaceThenFloat64
}

func NewApiDecouplerOfInterfaceThenFloat64() *ApiDecouplerOfInterfaceThenFloat64 {
	return &ApiDecouplerOfInterfaceThenFloat64{
		pool: NewPoolOfInterfaceThenFloat64Impl(),
	}
}

func (__ *ApiDecouplerOfInterfaceThenFloat64) ReturnError(rtn_ch chan<- *ReturnOfFloat64, err error) {
	rtn := __.pool.GetReturnOfFloat64()
	var other float64
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfInterfaceThenFloat64) HandleOfInterfaceThenFloat64(ctx context.Context, req *WorkOfInterfaceThenFloat64, h func(ctx context.Context, arg interface{}) (float64, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfFloat64()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfInterfaceThenFloat64) DoOfInterfaceThenFloat64(ctx context.Context, worker WorkerOfPushInterfaceThenFloat64, arg interface{}) (float64, error) {
	// ch := make(chan *ReturnOfFloat64, 1)
	ch := __.pool.GetChReturnOfFloat64()
	defer __.pool.PutChReturnOfFloat64(ch)

	req := __.pool.GetWorkOfInterfaceThenFloat64()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfInterfaceThenFloat64(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfFloat64(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfInterfaceThenFloat64 = func(ctx context.Context, arg interface{}) (float64, error)

type WorkerOfInterfaceThenFloat64 struct {
	api_syncer *ApiDecouplerOfInterfaceThenFloat64
	handler    WorkHandlerOfInterfaceThenFloat64

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfInterfaceThenFloat64
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfInterfaceThenFloat64(ctx context.Context, h WorkHandlerOfInterfaceThenFloat64, n int) *WorkerOfInterfaceThenFloat64 {
	__ := &WorkerOfInterfaceThenFloat64{
		api_syncer: NewApiDecouplerOfInterfaceThenFloat64(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfInterfaceThenFloat64, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfInterfaceThenFloat64{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfInterfaceThenFloat64(req.Context, req.WorkOfInterfaceThenFloat64, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfInterfaceThenFloat64) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfInterfaceThenFloat64) Push(ctx context.Context, req *WorkOfInterfaceThenFloat64) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfInterfaceThenFloat64)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfInterfaceThenFloat64 = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfInterfaceThenFloat64) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfInterfaceThenFloat64) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfInterfaceThenFloat64) Call(ctx context.Context, arg interface{}) (float64, error) {
	return __.api_syncer.DoOfInterfaceThenFloat64(ctx, __, arg)
}

type PoolOfInterfaceThenInt interface {
	GetInterfaceArg() *interface{}
	PutInterfaceArg(*interface{})
	GetIntReturn() *int
	PutIntReturn(*int)

	GetWorkOfInterfaceThenInt() *WorkOfInterfaceThenInt
	GetReturnOfInt() *ReturnOfInt
	PutWorkOfInterfaceThenInt(*WorkOfInterfaceThenInt)
	PutReturnOfInt(*ReturnOfInt)

	GetChReturnOfInt() chan *ReturnOfInt
	PutChReturnOfInt(chan *ReturnOfInt)
}

type PoolOfInterfaceThenIntImpl struct {
	InterfaceArg  sync.Pool
	IntRtn        sync.Pool
	InterfaceWork sync.Pool
	IntReturn     sync.Pool
	ChReturnOfInt sync.Pool
}

func (__ *PoolOfInterfaceThenIntImpl) GetInterfaceArg() *interface{} {
	return __.InterfaceArg.Get().(*interface{})
}
func (__ *PoolOfInterfaceThenIntImpl) PutInterfaceArg(p *interface{}) {
	__.InterfaceArg.Put(p)
}
func (__ *PoolOfInterfaceThenIntImpl) GetIntReturn() *int {
	return __.IntRtn.Get().(*int)
}
func (__ *PoolOfInterfaceThenIntImpl) PutIntReturn(p *int) {
	__.IntRtn.Put(p)
}

func (__ *PoolOfInterfaceThenIntImpl) GetWorkOfInterfaceThenInt() *WorkOfInterfaceThenInt {
	return __.InterfaceWork.Get().(*WorkOfInterfaceThenInt)
}
func (__ *PoolOfInterfaceThenIntImpl) PutWorkOfInterfaceThenInt(p *WorkOfInterfaceThenInt) {
	__.InterfaceWork.Put(p)
}
func (__ *PoolOfInterfaceThenIntImpl) GetReturnOfInt() *ReturnOfInt {
	return __.IntReturn.Get().(*ReturnOfInt)
}
func (__ *PoolOfInterfaceThenIntImpl) PutReturnOfInt(p *ReturnOfInt) {
	__.IntReturn.Put(p)
}

func (__ *PoolOfInterfaceThenIntImpl) GetChReturnOfInt() chan *ReturnOfInt {
	return __.ChReturnOfInt.Get().(chan *ReturnOfInt)
}
func (__ *PoolOfInterfaceThenIntImpl) PutChReturnOfInt(p chan *ReturnOfInt) {
	__.ChReturnOfInt.Put(p)
}

func NewPoolOfInterfaceThenIntImpl() *PoolOfInterfaceThenIntImpl {
	return &PoolOfInterfaceThenIntImpl{
		InterfaceArg: sync.Pool{
			New: func() interface{} {
				return new(interface{})
			},
		},
		InterfaceWork: sync.Pool{
			New: func() interface{} {
				return new(WorkOfInterfaceThenInt)
			},
		},
		IntRtn: sync.Pool{
			New: func() interface{} {
				return new(int)
			},
		},
		IntReturn: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfInt)
			},
		},
		ChReturnOfInt: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfInt, 1)
			},
		},
	}
}

type ApiDecouplerOfInterfaceThenInt struct {
	pool PoolOfInterfaceThenInt
}

func NewApiDecouplerOfInterfaceThenInt() *ApiDecouplerOfInterfaceThenInt {
	return &ApiDecouplerOfInterfaceThenInt{
		pool: NewPoolOfInterfaceThenIntImpl(),
	}
}

func (__ *ApiDecouplerOfInterfaceThenInt) ReturnError(rtn_ch chan<- *ReturnOfInt, err error) {
	rtn := __.pool.GetReturnOfInt()
	var other int
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfInterfaceThenInt) HandleOfInterfaceThenInt(ctx context.Context, req *WorkOfInterfaceThenInt, h func(ctx context.Context, arg interface{}) (int, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfInt()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfInterfaceThenInt) DoOfInterfaceThenInt(ctx context.Context, worker WorkerOfPushInterfaceThenInt, arg interface{}) (int, error) {
	// ch := make(chan *ReturnOfInt, 1)
	ch := __.pool.GetChReturnOfInt()
	defer __.pool.PutChReturnOfInt(ch)

	req := __.pool.GetWorkOfInterfaceThenInt()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfInterfaceThenInt(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfInt(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfInterfaceThenInt = func(ctx context.Context, arg interface{}) (int, error)

type WorkerOfInterfaceThenInt struct {
	api_syncer *ApiDecouplerOfInterfaceThenInt
	handler    WorkHandlerOfInterfaceThenInt

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfInterfaceThenInt
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfInterfaceThenInt(ctx context.Context, h WorkHandlerOfInterfaceThenInt, n int) *WorkerOfInterfaceThenInt {
	__ := &WorkerOfInterfaceThenInt{
		api_syncer: NewApiDecouplerOfInterfaceThenInt(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfInterfaceThenInt, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfInterfaceThenInt{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfInterfaceThenInt(req.Context, req.WorkOfInterfaceThenInt, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfInterfaceThenInt) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfInterfaceThenInt) Push(ctx context.Context, req *WorkOfInterfaceThenInt) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfInterfaceThenInt)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfInterfaceThenInt = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfInterfaceThenInt) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfInterfaceThenInt) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfInterfaceThenInt) Call(ctx context.Context, arg interface{}) (int, error) {
	return __.api_syncer.DoOfInterfaceThenInt(ctx, __, arg)
}

type PoolOfInterfaceThenInt16 interface {
	GetInterfaceArg() *interface{}
	PutInterfaceArg(*interface{})
	GetInt16Return() *int16
	PutInt16Return(*int16)

	GetWorkOfInterfaceThenInt16() *WorkOfInterfaceThenInt16
	GetReturnOfInt16() *ReturnOfInt16
	PutWorkOfInterfaceThenInt16(*WorkOfInterfaceThenInt16)
	PutReturnOfInt16(*ReturnOfInt16)

	GetChReturnOfInt16() chan *ReturnOfInt16
	PutChReturnOfInt16(chan *ReturnOfInt16)
}

type PoolOfInterfaceThenInt16Impl struct {
	InterfaceArg    sync.Pool
	Int16Rtn        sync.Pool
	InterfaceWork   sync.Pool
	Int16Return     sync.Pool
	ChReturnOfInt16 sync.Pool
}

func (__ *PoolOfInterfaceThenInt16Impl) GetInterfaceArg() *interface{} {
	return __.InterfaceArg.Get().(*interface{})
}
func (__ *PoolOfInterfaceThenInt16Impl) PutInterfaceArg(p *interface{}) {
	__.InterfaceArg.Put(p)
}
func (__ *PoolOfInterfaceThenInt16Impl) GetInt16Return() *int16 {
	return __.Int16Rtn.Get().(*int16)
}
func (__ *PoolOfInterfaceThenInt16Impl) PutInt16Return(p *int16) {
	__.Int16Rtn.Put(p)
}

func (__ *PoolOfInterfaceThenInt16Impl) GetWorkOfInterfaceThenInt16() *WorkOfInterfaceThenInt16 {
	return __.InterfaceWork.Get().(*WorkOfInterfaceThenInt16)
}
func (__ *PoolOfInterfaceThenInt16Impl) PutWorkOfInterfaceThenInt16(p *WorkOfInterfaceThenInt16) {
	__.InterfaceWork.Put(p)
}
func (__ *PoolOfInterfaceThenInt16Impl) GetReturnOfInt16() *ReturnOfInt16 {
	return __.Int16Return.Get().(*ReturnOfInt16)
}
func (__ *PoolOfInterfaceThenInt16Impl) PutReturnOfInt16(p *ReturnOfInt16) {
	__.Int16Return.Put(p)
}

func (__ *PoolOfInterfaceThenInt16Impl) GetChReturnOfInt16() chan *ReturnOfInt16 {
	return __.ChReturnOfInt16.Get().(chan *ReturnOfInt16)
}
func (__ *PoolOfInterfaceThenInt16Impl) PutChReturnOfInt16(p chan *ReturnOfInt16) {
	__.ChReturnOfInt16.Put(p)
}

func NewPoolOfInterfaceThenInt16Impl() *PoolOfInterfaceThenInt16Impl {
	return &PoolOfInterfaceThenInt16Impl{
		InterfaceArg: sync.Pool{
			New: func() interface{} {
				return new(interface{})
			},
		},
		InterfaceWork: sync.Pool{
			New: func() interface{} {
				return new(WorkOfInterfaceThenInt16)
			},
		},
		Int16Rtn: sync.Pool{
			New: func() interface{} {
				return new(int16)
			},
		},
		Int16Return: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfInt16)
			},
		},
		ChReturnOfInt16: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfInt16, 1)
			},
		},
	}
}

type ApiDecouplerOfInterfaceThenInt16 struct {
	pool PoolOfInterfaceThenInt16
}

func NewApiDecouplerOfInterfaceThenInt16() *ApiDecouplerOfInterfaceThenInt16 {
	return &ApiDecouplerOfInterfaceThenInt16{
		pool: NewPoolOfInterfaceThenInt16Impl(),
	}
}

func (__ *ApiDecouplerOfInterfaceThenInt16) ReturnError(rtn_ch chan<- *ReturnOfInt16, err error) {
	rtn := __.pool.GetReturnOfInt16()
	var other int16
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfInterfaceThenInt16) HandleOfInterfaceThenInt16(ctx context.Context, req *WorkOfInterfaceThenInt16, h func(ctx context.Context, arg interface{}) (int16, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfInt16()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfInterfaceThenInt16) DoOfInterfaceThenInt16(ctx context.Context, worker WorkerOfPushInterfaceThenInt16, arg interface{}) (int16, error) {
	// ch := make(chan *ReturnOfInt16, 1)
	ch := __.pool.GetChReturnOfInt16()
	defer __.pool.PutChReturnOfInt16(ch)

	req := __.pool.GetWorkOfInterfaceThenInt16()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfInterfaceThenInt16(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfInt16(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfInterfaceThenInt16 = func(ctx context.Context, arg interface{}) (int16, error)

type WorkerOfInterfaceThenInt16 struct {
	api_syncer *ApiDecouplerOfInterfaceThenInt16
	handler    WorkHandlerOfInterfaceThenInt16

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfInterfaceThenInt16
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfInterfaceThenInt16(ctx context.Context, h WorkHandlerOfInterfaceThenInt16, n int) *WorkerOfInterfaceThenInt16 {
	__ := &WorkerOfInterfaceThenInt16{
		api_syncer: NewApiDecouplerOfInterfaceThenInt16(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfInterfaceThenInt16, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfInterfaceThenInt16{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfInterfaceThenInt16(req.Context, req.WorkOfInterfaceThenInt16, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfInterfaceThenInt16) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfInterfaceThenInt16) Push(ctx context.Context, req *WorkOfInterfaceThenInt16) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfInterfaceThenInt16)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfInterfaceThenInt16 = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfInterfaceThenInt16) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfInterfaceThenInt16) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfInterfaceThenInt16) Call(ctx context.Context, arg interface{}) (int16, error) {
	return __.api_syncer.DoOfInterfaceThenInt16(ctx, __, arg)
}

type PoolOfInterfaceThenInt32 interface {
	GetInterfaceArg() *interface{}
	PutInterfaceArg(*interface{})
	GetInt32Return() *int32
	PutInt32Return(*int32)

	GetWorkOfInterfaceThenInt32() *WorkOfInterfaceThenInt32
	GetReturnOfInt32() *ReturnOfInt32
	PutWorkOfInterfaceThenInt32(*WorkOfInterfaceThenInt32)
	PutReturnOfInt32(*ReturnOfInt32)

	GetChReturnOfInt32() chan *ReturnOfInt32
	PutChReturnOfInt32(chan *ReturnOfInt32)
}

type PoolOfInterfaceThenInt32Impl struct {
	InterfaceArg    sync.Pool
	Int32Rtn        sync.Pool
	InterfaceWork   sync.Pool
	Int32Return     sync.Pool
	ChReturnOfInt32 sync.Pool
}

func (__ *PoolOfInterfaceThenInt32Impl) GetInterfaceArg() *interface{} {
	return __.InterfaceArg.Get().(*interface{})
}
func (__ *PoolOfInterfaceThenInt32Impl) PutInterfaceArg(p *interface{}) {
	__.InterfaceArg.Put(p)
}
func (__ *PoolOfInterfaceThenInt32Impl) GetInt32Return() *int32 {
	return __.Int32Rtn.Get().(*int32)
}
func (__ *PoolOfInterfaceThenInt32Impl) PutInt32Return(p *int32) {
	__.Int32Rtn.Put(p)
}

func (__ *PoolOfInterfaceThenInt32Impl) GetWorkOfInterfaceThenInt32() *WorkOfInterfaceThenInt32 {
	return __.InterfaceWork.Get().(*WorkOfInterfaceThenInt32)
}
func (__ *PoolOfInterfaceThenInt32Impl) PutWorkOfInterfaceThenInt32(p *WorkOfInterfaceThenInt32) {
	__.InterfaceWork.Put(p)
}
func (__ *PoolOfInterfaceThenInt32Impl) GetReturnOfInt32() *ReturnOfInt32 {
	return __.Int32Return.Get().(*ReturnOfInt32)
}
func (__ *PoolOfInterfaceThenInt32Impl) PutReturnOfInt32(p *ReturnOfInt32) {
	__.Int32Return.Put(p)
}

func (__ *PoolOfInterfaceThenInt32Impl) GetChReturnOfInt32() chan *ReturnOfInt32 {
	return __.ChReturnOfInt32.Get().(chan *ReturnOfInt32)
}
func (__ *PoolOfInterfaceThenInt32Impl) PutChReturnOfInt32(p chan *ReturnOfInt32) {
	__.ChReturnOfInt32.Put(p)
}

func NewPoolOfInterfaceThenInt32Impl() *PoolOfInterfaceThenInt32Impl {
	return &PoolOfInterfaceThenInt32Impl{
		InterfaceArg: sync.Pool{
			New: func() interface{} {
				return new(interface{})
			},
		},
		InterfaceWork: sync.Pool{
			New: func() interface{} {
				return new(WorkOfInterfaceThenInt32)
			},
		},
		Int32Rtn: sync.Pool{
			New: func() interface{} {
				return new(int32)
			},
		},
		Int32Return: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfInt32)
			},
		},
		ChReturnOfInt32: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfInt32, 1)
			},
		},
	}
}

type ApiDecouplerOfInterfaceThenInt32 struct {
	pool PoolOfInterfaceThenInt32
}

func NewApiDecouplerOfInterfaceThenInt32() *ApiDecouplerOfInterfaceThenInt32 {
	return &ApiDecouplerOfInterfaceThenInt32{
		pool: NewPoolOfInterfaceThenInt32Impl(),
	}
}

func (__ *ApiDecouplerOfInterfaceThenInt32) ReturnError(rtn_ch chan<- *ReturnOfInt32, err error) {
	rtn := __.pool.GetReturnOfInt32()
	var other int32
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfInterfaceThenInt32) HandleOfInterfaceThenInt32(ctx context.Context, req *WorkOfInterfaceThenInt32, h func(ctx context.Context, arg interface{}) (int32, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfInt32()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfInterfaceThenInt32) DoOfInterfaceThenInt32(ctx context.Context, worker WorkerOfPushInterfaceThenInt32, arg interface{}) (int32, error) {
	// ch := make(chan *ReturnOfInt32, 1)
	ch := __.pool.GetChReturnOfInt32()
	defer __.pool.PutChReturnOfInt32(ch)

	req := __.pool.GetWorkOfInterfaceThenInt32()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfInterfaceThenInt32(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfInt32(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfInterfaceThenInt32 = func(ctx context.Context, arg interface{}) (int32, error)

type WorkerOfInterfaceThenInt32 struct {
	api_syncer *ApiDecouplerOfInterfaceThenInt32
	handler    WorkHandlerOfInterfaceThenInt32

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfInterfaceThenInt32
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfInterfaceThenInt32(ctx context.Context, h WorkHandlerOfInterfaceThenInt32, n int) *WorkerOfInterfaceThenInt32 {
	__ := &WorkerOfInterfaceThenInt32{
		api_syncer: NewApiDecouplerOfInterfaceThenInt32(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfInterfaceThenInt32, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfInterfaceThenInt32{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfInterfaceThenInt32(req.Context, req.WorkOfInterfaceThenInt32, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfInterfaceThenInt32) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfInterfaceThenInt32) Push(ctx context.Context, req *WorkOfInterfaceThenInt32) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfInterfaceThenInt32)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfInterfaceThenInt32 = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfInterfaceThenInt32) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfInterfaceThenInt32) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfInterfaceThenInt32) Call(ctx context.Context, arg interface{}) (int32, error) {
	return __.api_syncer.DoOfInterfaceThenInt32(ctx, __, arg)
}

type PoolOfInterfaceThenInt64 interface {
	GetInterfaceArg() *interface{}
	PutInterfaceArg(*interface{})
	GetInt64Return() *int64
	PutInt64Return(*int64)

	GetWorkOfInterfaceThenInt64() *WorkOfInterfaceThenInt64
	GetReturnOfInt64() *ReturnOfInt64
	PutWorkOfInterfaceThenInt64(*WorkOfInterfaceThenInt64)
	PutReturnOfInt64(*ReturnOfInt64)

	GetChReturnOfInt64() chan *ReturnOfInt64
	PutChReturnOfInt64(chan *ReturnOfInt64)
}

type PoolOfInterfaceThenInt64Impl struct {
	InterfaceArg    sync.Pool
	Int64Rtn        sync.Pool
	InterfaceWork   sync.Pool
	Int64Return     sync.Pool
	ChReturnOfInt64 sync.Pool
}

func (__ *PoolOfInterfaceThenInt64Impl) GetInterfaceArg() *interface{} {
	return __.InterfaceArg.Get().(*interface{})
}
func (__ *PoolOfInterfaceThenInt64Impl) PutInterfaceArg(p *interface{}) {
	__.InterfaceArg.Put(p)
}
func (__ *PoolOfInterfaceThenInt64Impl) GetInt64Return() *int64 {
	return __.Int64Rtn.Get().(*int64)
}
func (__ *PoolOfInterfaceThenInt64Impl) PutInt64Return(p *int64) {
	__.Int64Rtn.Put(p)
}

func (__ *PoolOfInterfaceThenInt64Impl) GetWorkOfInterfaceThenInt64() *WorkOfInterfaceThenInt64 {
	return __.InterfaceWork.Get().(*WorkOfInterfaceThenInt64)
}
func (__ *PoolOfInterfaceThenInt64Impl) PutWorkOfInterfaceThenInt64(p *WorkOfInterfaceThenInt64) {
	__.InterfaceWork.Put(p)
}
func (__ *PoolOfInterfaceThenInt64Impl) GetReturnOfInt64() *ReturnOfInt64 {
	return __.Int64Return.Get().(*ReturnOfInt64)
}
func (__ *PoolOfInterfaceThenInt64Impl) PutReturnOfInt64(p *ReturnOfInt64) {
	__.Int64Return.Put(p)
}

func (__ *PoolOfInterfaceThenInt64Impl) GetChReturnOfInt64() chan *ReturnOfInt64 {
	return __.ChReturnOfInt64.Get().(chan *ReturnOfInt64)
}
func (__ *PoolOfInterfaceThenInt64Impl) PutChReturnOfInt64(p chan *ReturnOfInt64) {
	__.ChReturnOfInt64.Put(p)
}

func NewPoolOfInterfaceThenInt64Impl() *PoolOfInterfaceThenInt64Impl {
	return &PoolOfInterfaceThenInt64Impl{
		InterfaceArg: sync.Pool{
			New: func() interface{} {
				return new(interface{})
			},
		},
		InterfaceWork: sync.Pool{
			New: func() interface{} {
				return new(WorkOfInterfaceThenInt64)
			},
		},
		Int64Rtn: sync.Pool{
			New: func() interface{} {
				return new(int64)
			},
		},
		Int64Return: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfInt64)
			},
		},
		ChReturnOfInt64: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfInt64, 1)
			},
		},
	}
}

type ApiDecouplerOfInterfaceThenInt64 struct {
	pool PoolOfInterfaceThenInt64
}

func NewApiDecouplerOfInterfaceThenInt64() *ApiDecouplerOfInterfaceThenInt64 {
	return &ApiDecouplerOfInterfaceThenInt64{
		pool: NewPoolOfInterfaceThenInt64Impl(),
	}
}

func (__ *ApiDecouplerOfInterfaceThenInt64) ReturnError(rtn_ch chan<- *ReturnOfInt64, err error) {
	rtn := __.pool.GetReturnOfInt64()
	var other int64
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfInterfaceThenInt64) HandleOfInterfaceThenInt64(ctx context.Context, req *WorkOfInterfaceThenInt64, h func(ctx context.Context, arg interface{}) (int64, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfInt64()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfInterfaceThenInt64) DoOfInterfaceThenInt64(ctx context.Context, worker WorkerOfPushInterfaceThenInt64, arg interface{}) (int64, error) {
	// ch := make(chan *ReturnOfInt64, 1)
	ch := __.pool.GetChReturnOfInt64()
	defer __.pool.PutChReturnOfInt64(ch)

	req := __.pool.GetWorkOfInterfaceThenInt64()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfInterfaceThenInt64(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfInt64(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfInterfaceThenInt64 = func(ctx context.Context, arg interface{}) (int64, error)

type WorkerOfInterfaceThenInt64 struct {
	api_syncer *ApiDecouplerOfInterfaceThenInt64
	handler    WorkHandlerOfInterfaceThenInt64

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfInterfaceThenInt64
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfInterfaceThenInt64(ctx context.Context, h WorkHandlerOfInterfaceThenInt64, n int) *WorkerOfInterfaceThenInt64 {
	__ := &WorkerOfInterfaceThenInt64{
		api_syncer: NewApiDecouplerOfInterfaceThenInt64(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfInterfaceThenInt64, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfInterfaceThenInt64{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfInterfaceThenInt64(req.Context, req.WorkOfInterfaceThenInt64, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfInterfaceThenInt64) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfInterfaceThenInt64) Push(ctx context.Context, req *WorkOfInterfaceThenInt64) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfInterfaceThenInt64)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfInterfaceThenInt64 = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfInterfaceThenInt64) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfInterfaceThenInt64) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfInterfaceThenInt64) Call(ctx context.Context, arg interface{}) (int64, error) {
	return __.api_syncer.DoOfInterfaceThenInt64(ctx, __, arg)
}

type PoolOfInterfaceThenInt8 interface {
	GetInterfaceArg() *interface{}
	PutInterfaceArg(*interface{})
	GetInt8Return() *int8
	PutInt8Return(*int8)

	GetWorkOfInterfaceThenInt8() *WorkOfInterfaceThenInt8
	GetReturnOfInt8() *ReturnOfInt8
	PutWorkOfInterfaceThenInt8(*WorkOfInterfaceThenInt8)
	PutReturnOfInt8(*ReturnOfInt8)

	GetChReturnOfInt8() chan *ReturnOfInt8
	PutChReturnOfInt8(chan *ReturnOfInt8)
}

type PoolOfInterfaceThenInt8Impl struct {
	InterfaceArg   sync.Pool
	Int8Rtn        sync.Pool
	InterfaceWork  sync.Pool
	Int8Return     sync.Pool
	ChReturnOfInt8 sync.Pool
}

func (__ *PoolOfInterfaceThenInt8Impl) GetInterfaceArg() *interface{} {
	return __.InterfaceArg.Get().(*interface{})
}
func (__ *PoolOfInterfaceThenInt8Impl) PutInterfaceArg(p *interface{}) {
	__.InterfaceArg.Put(p)
}
func (__ *PoolOfInterfaceThenInt8Impl) GetInt8Return() *int8 {
	return __.Int8Rtn.Get().(*int8)
}
func (__ *PoolOfInterfaceThenInt8Impl) PutInt8Return(p *int8) {
	__.Int8Rtn.Put(p)
}

func (__ *PoolOfInterfaceThenInt8Impl) GetWorkOfInterfaceThenInt8() *WorkOfInterfaceThenInt8 {
	return __.InterfaceWork.Get().(*WorkOfInterfaceThenInt8)
}
func (__ *PoolOfInterfaceThenInt8Impl) PutWorkOfInterfaceThenInt8(p *WorkOfInterfaceThenInt8) {
	__.InterfaceWork.Put(p)
}
func (__ *PoolOfInterfaceThenInt8Impl) GetReturnOfInt8() *ReturnOfInt8 {
	return __.Int8Return.Get().(*ReturnOfInt8)
}
func (__ *PoolOfInterfaceThenInt8Impl) PutReturnOfInt8(p *ReturnOfInt8) {
	__.Int8Return.Put(p)
}

func (__ *PoolOfInterfaceThenInt8Impl) GetChReturnOfInt8() chan *ReturnOfInt8 {
	return __.ChReturnOfInt8.Get().(chan *ReturnOfInt8)
}
func (__ *PoolOfInterfaceThenInt8Impl) PutChReturnOfInt8(p chan *ReturnOfInt8) {
	__.ChReturnOfInt8.Put(p)
}

func NewPoolOfInterfaceThenInt8Impl() *PoolOfInterfaceThenInt8Impl {
	return &PoolOfInterfaceThenInt8Impl{
		InterfaceArg: sync.Pool{
			New: func() interface{} {
				return new(interface{})
			},
		},
		InterfaceWork: sync.Pool{
			New: func() interface{} {
				return new(WorkOfInterfaceThenInt8)
			},
		},
		Int8Rtn: sync.Pool{
			New: func() interface{} {
				return new(int8)
			},
		},
		Int8Return: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfInt8)
			},
		},
		ChReturnOfInt8: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfInt8, 1)
			},
		},
	}
}

type ApiDecouplerOfInterfaceThenInt8 struct {
	pool PoolOfInterfaceThenInt8
}

func NewApiDecouplerOfInterfaceThenInt8() *ApiDecouplerOfInterfaceThenInt8 {
	return &ApiDecouplerOfInterfaceThenInt8{
		pool: NewPoolOfInterfaceThenInt8Impl(),
	}
}

func (__ *ApiDecouplerOfInterfaceThenInt8) ReturnError(rtn_ch chan<- *ReturnOfInt8, err error) {
	rtn := __.pool.GetReturnOfInt8()
	var other int8
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfInterfaceThenInt8) HandleOfInterfaceThenInt8(ctx context.Context, req *WorkOfInterfaceThenInt8, h func(ctx context.Context, arg interface{}) (int8, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfInt8()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfInterfaceThenInt8) DoOfInterfaceThenInt8(ctx context.Context, worker WorkerOfPushInterfaceThenInt8, arg interface{}) (int8, error) {
	// ch := make(chan *ReturnOfInt8, 1)
	ch := __.pool.GetChReturnOfInt8()
	defer __.pool.PutChReturnOfInt8(ch)

	req := __.pool.GetWorkOfInterfaceThenInt8()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfInterfaceThenInt8(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfInt8(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfInterfaceThenInt8 = func(ctx context.Context, arg interface{}) (int8, error)

type WorkerOfInterfaceThenInt8 struct {
	api_syncer *ApiDecouplerOfInterfaceThenInt8
	handler    WorkHandlerOfInterfaceThenInt8

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfInterfaceThenInt8
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfInterfaceThenInt8(ctx context.Context, h WorkHandlerOfInterfaceThenInt8, n int) *WorkerOfInterfaceThenInt8 {
	__ := &WorkerOfInterfaceThenInt8{
		api_syncer: NewApiDecouplerOfInterfaceThenInt8(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfInterfaceThenInt8, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfInterfaceThenInt8{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfInterfaceThenInt8(req.Context, req.WorkOfInterfaceThenInt8, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfInterfaceThenInt8) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfInterfaceThenInt8) Push(ctx context.Context, req *WorkOfInterfaceThenInt8) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfInterfaceThenInt8)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfInterfaceThenInt8 = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfInterfaceThenInt8) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfInterfaceThenInt8) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfInterfaceThenInt8) Call(ctx context.Context, arg interface{}) (int8, error) {
	return __.api_syncer.DoOfInterfaceThenInt8(ctx, __, arg)
}

type PoolOfInterfaceThenRune interface {
	GetInterfaceArg() *interface{}
	PutInterfaceArg(*interface{})
	GetRuneReturn() *rune
	PutRuneReturn(*rune)

	GetWorkOfInterfaceThenRune() *WorkOfInterfaceThenRune
	GetReturnOfRune() *ReturnOfRune
	PutWorkOfInterfaceThenRune(*WorkOfInterfaceThenRune)
	PutReturnOfRune(*ReturnOfRune)

	GetChReturnOfRune() chan *ReturnOfRune
	PutChReturnOfRune(chan *ReturnOfRune)
}

type PoolOfInterfaceThenRuneImpl struct {
	InterfaceArg   sync.Pool
	RuneRtn        sync.Pool
	InterfaceWork  sync.Pool
	RuneReturn     sync.Pool
	ChReturnOfRune sync.Pool
}

func (__ *PoolOfInterfaceThenRuneImpl) GetInterfaceArg() *interface{} {
	return __.InterfaceArg.Get().(*interface{})
}
func (__ *PoolOfInterfaceThenRuneImpl) PutInterfaceArg(p *interface{}) {
	__.InterfaceArg.Put(p)
}
func (__ *PoolOfInterfaceThenRuneImpl) GetRuneReturn() *rune {
	return __.RuneRtn.Get().(*rune)
}
func (__ *PoolOfInterfaceThenRuneImpl) PutRuneReturn(p *rune) {
	__.RuneRtn.Put(p)
}

func (__ *PoolOfInterfaceThenRuneImpl) GetWorkOfInterfaceThenRune() *WorkOfInterfaceThenRune {
	return __.InterfaceWork.Get().(*WorkOfInterfaceThenRune)
}
func (__ *PoolOfInterfaceThenRuneImpl) PutWorkOfInterfaceThenRune(p *WorkOfInterfaceThenRune) {
	__.InterfaceWork.Put(p)
}
func (__ *PoolOfInterfaceThenRuneImpl) GetReturnOfRune() *ReturnOfRune {
	return __.RuneReturn.Get().(*ReturnOfRune)
}
func (__ *PoolOfInterfaceThenRuneImpl) PutReturnOfRune(p *ReturnOfRune) {
	__.RuneReturn.Put(p)
}

func (__ *PoolOfInterfaceThenRuneImpl) GetChReturnOfRune() chan *ReturnOfRune {
	return __.ChReturnOfRune.Get().(chan *ReturnOfRune)
}
func (__ *PoolOfInterfaceThenRuneImpl) PutChReturnOfRune(p chan *ReturnOfRune) {
	__.ChReturnOfRune.Put(p)
}

func NewPoolOfInterfaceThenRuneImpl() *PoolOfInterfaceThenRuneImpl {
	return &PoolOfInterfaceThenRuneImpl{
		InterfaceArg: sync.Pool{
			New: func() interface{} {
				return new(interface{})
			},
		},
		InterfaceWork: sync.Pool{
			New: func() interface{} {
				return new(WorkOfInterfaceThenRune)
			},
		},
		RuneRtn: sync.Pool{
			New: func() interface{} {
				return new(rune)
			},
		},
		RuneReturn: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfRune)
			},
		},
		ChReturnOfRune: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfRune, 1)
			},
		},
	}
}

type ApiDecouplerOfInterfaceThenRune struct {
	pool PoolOfInterfaceThenRune
}

func NewApiDecouplerOfInterfaceThenRune() *ApiDecouplerOfInterfaceThenRune {
	return &ApiDecouplerOfInterfaceThenRune{
		pool: NewPoolOfInterfaceThenRuneImpl(),
	}
}

func (__ *ApiDecouplerOfInterfaceThenRune) ReturnError(rtn_ch chan<- *ReturnOfRune, err error) {
	rtn := __.pool.GetReturnOfRune()
	var other rune
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfInterfaceThenRune) HandleOfInterfaceThenRune(ctx context.Context, req *WorkOfInterfaceThenRune, h func(ctx context.Context, arg interface{}) (rune, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfRune()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfInterfaceThenRune) DoOfInterfaceThenRune(ctx context.Context, worker WorkerOfPushInterfaceThenRune, arg interface{}) (rune, error) {
	// ch := make(chan *ReturnOfRune, 1)
	ch := __.pool.GetChReturnOfRune()
	defer __.pool.PutChReturnOfRune(ch)

	req := __.pool.GetWorkOfInterfaceThenRune()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfInterfaceThenRune(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfRune(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfInterfaceThenRune = func(ctx context.Context, arg interface{}) (rune, error)

type WorkerOfInterfaceThenRune struct {
	api_syncer *ApiDecouplerOfInterfaceThenRune
	handler    WorkHandlerOfInterfaceThenRune

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfInterfaceThenRune
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfInterfaceThenRune(ctx context.Context, h WorkHandlerOfInterfaceThenRune, n int) *WorkerOfInterfaceThenRune {
	__ := &WorkerOfInterfaceThenRune{
		api_syncer: NewApiDecouplerOfInterfaceThenRune(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfInterfaceThenRune, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfInterfaceThenRune{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfInterfaceThenRune(req.Context, req.WorkOfInterfaceThenRune, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfInterfaceThenRune) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfInterfaceThenRune) Push(ctx context.Context, req *WorkOfInterfaceThenRune) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfInterfaceThenRune)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfInterfaceThenRune = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfInterfaceThenRune) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfInterfaceThenRune) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfInterfaceThenRune) Call(ctx context.Context, arg interface{}) (rune, error) {
	return __.api_syncer.DoOfInterfaceThenRune(ctx, __, arg)
}

type PoolOfInterfaceThenString interface {
	GetInterfaceArg() *interface{}
	PutInterfaceArg(*interface{})
	GetStringReturn() *string
	PutStringReturn(*string)

	GetWorkOfInterfaceThenString() *WorkOfInterfaceThenString
	GetReturnOfString() *ReturnOfString
	PutWorkOfInterfaceThenString(*WorkOfInterfaceThenString)
	PutReturnOfString(*ReturnOfString)

	GetChReturnOfString() chan *ReturnOfString
	PutChReturnOfString(chan *ReturnOfString)
}

type PoolOfInterfaceThenStringImpl struct {
	InterfaceArg     sync.Pool
	StringRtn        sync.Pool
	InterfaceWork    sync.Pool
	StringReturn     sync.Pool
	ChReturnOfString sync.Pool
}

func (__ *PoolOfInterfaceThenStringImpl) GetInterfaceArg() *interface{} {
	return __.InterfaceArg.Get().(*interface{})
}
func (__ *PoolOfInterfaceThenStringImpl) PutInterfaceArg(p *interface{}) {
	__.InterfaceArg.Put(p)
}
func (__ *PoolOfInterfaceThenStringImpl) GetStringReturn() *string {
	return __.StringRtn.Get().(*string)
}
func (__ *PoolOfInterfaceThenStringImpl) PutStringReturn(p *string) {
	__.StringRtn.Put(p)
}

func (__ *PoolOfInterfaceThenStringImpl) GetWorkOfInterfaceThenString() *WorkOfInterfaceThenString {
	return __.InterfaceWork.Get().(*WorkOfInterfaceThenString)
}
func (__ *PoolOfInterfaceThenStringImpl) PutWorkOfInterfaceThenString(p *WorkOfInterfaceThenString) {
	__.InterfaceWork.Put(p)
}
func (__ *PoolOfInterfaceThenStringImpl) GetReturnOfString() *ReturnOfString {
	return __.StringReturn.Get().(*ReturnOfString)
}
func (__ *PoolOfInterfaceThenStringImpl) PutReturnOfString(p *ReturnOfString) {
	__.StringReturn.Put(p)
}

func (__ *PoolOfInterfaceThenStringImpl) GetChReturnOfString() chan *ReturnOfString {
	return __.ChReturnOfString.Get().(chan *ReturnOfString)
}
func (__ *PoolOfInterfaceThenStringImpl) PutChReturnOfString(p chan *ReturnOfString) {
	__.ChReturnOfString.Put(p)
}

func NewPoolOfInterfaceThenStringImpl() *PoolOfInterfaceThenStringImpl {
	return &PoolOfInterfaceThenStringImpl{
		InterfaceArg: sync.Pool{
			New: func() interface{} {
				return new(interface{})
			},
		},
		InterfaceWork: sync.Pool{
			New: func() interface{} {
				return new(WorkOfInterfaceThenString)
			},
		},
		StringRtn: sync.Pool{
			New: func() interface{} {
				return new(string)
			},
		},
		StringReturn: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfString)
			},
		},
		ChReturnOfString: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfString, 1)
			},
		},
	}
}

type ApiDecouplerOfInterfaceThenString struct {
	pool PoolOfInterfaceThenString
}

func NewApiDecouplerOfInterfaceThenString() *ApiDecouplerOfInterfaceThenString {
	return &ApiDecouplerOfInterfaceThenString{
		pool: NewPoolOfInterfaceThenStringImpl(),
	}
}

func (__ *ApiDecouplerOfInterfaceThenString) ReturnError(rtn_ch chan<- *ReturnOfString, err error) {
	rtn := __.pool.GetReturnOfString()
	var other string
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfInterfaceThenString) HandleOfInterfaceThenString(ctx context.Context, req *WorkOfInterfaceThenString, h func(ctx context.Context, arg interface{}) (string, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfString()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfInterfaceThenString) DoOfInterfaceThenString(ctx context.Context, worker WorkerOfPushInterfaceThenString, arg interface{}) (string, error) {
	// ch := make(chan *ReturnOfString, 1)
	ch := __.pool.GetChReturnOfString()
	defer __.pool.PutChReturnOfString(ch)

	req := __.pool.GetWorkOfInterfaceThenString()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfInterfaceThenString(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfString(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfInterfaceThenString = func(ctx context.Context, arg interface{}) (string, error)

type WorkerOfInterfaceThenString struct {
	api_syncer *ApiDecouplerOfInterfaceThenString
	handler    WorkHandlerOfInterfaceThenString

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfInterfaceThenString
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfInterfaceThenString(ctx context.Context, h WorkHandlerOfInterfaceThenString, n int) *WorkerOfInterfaceThenString {
	__ := &WorkerOfInterfaceThenString{
		api_syncer: NewApiDecouplerOfInterfaceThenString(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfInterfaceThenString, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfInterfaceThenString{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfInterfaceThenString(req.Context, req.WorkOfInterfaceThenString, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfInterfaceThenString) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfInterfaceThenString) Push(ctx context.Context, req *WorkOfInterfaceThenString) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfInterfaceThenString)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfInterfaceThenString = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfInterfaceThenString) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfInterfaceThenString) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfInterfaceThenString) Call(ctx context.Context, arg interface{}) (string, error) {
	return __.api_syncer.DoOfInterfaceThenString(ctx, __, arg)
}

type PoolOfInterfaceThenUint interface {
	GetInterfaceArg() *interface{}
	PutInterfaceArg(*interface{})
	GetUintReturn() *uint
	PutUintReturn(*uint)

	GetWorkOfInterfaceThenUint() *WorkOfInterfaceThenUint
	GetReturnOfUint() *ReturnOfUint
	PutWorkOfInterfaceThenUint(*WorkOfInterfaceThenUint)
	PutReturnOfUint(*ReturnOfUint)

	GetChReturnOfUint() chan *ReturnOfUint
	PutChReturnOfUint(chan *ReturnOfUint)
}

type PoolOfInterfaceThenUintImpl struct {
	InterfaceArg   sync.Pool
	UintRtn        sync.Pool
	InterfaceWork  sync.Pool
	UintReturn     sync.Pool
	ChReturnOfUint sync.Pool
}

func (__ *PoolOfInterfaceThenUintImpl) GetInterfaceArg() *interface{} {
	return __.InterfaceArg.Get().(*interface{})
}
func (__ *PoolOfInterfaceThenUintImpl) PutInterfaceArg(p *interface{}) {
	__.InterfaceArg.Put(p)
}
func (__ *PoolOfInterfaceThenUintImpl) GetUintReturn() *uint {
	return __.UintRtn.Get().(*uint)
}
func (__ *PoolOfInterfaceThenUintImpl) PutUintReturn(p *uint) {
	__.UintRtn.Put(p)
}

func (__ *PoolOfInterfaceThenUintImpl) GetWorkOfInterfaceThenUint() *WorkOfInterfaceThenUint {
	return __.InterfaceWork.Get().(*WorkOfInterfaceThenUint)
}
func (__ *PoolOfInterfaceThenUintImpl) PutWorkOfInterfaceThenUint(p *WorkOfInterfaceThenUint) {
	__.InterfaceWork.Put(p)
}
func (__ *PoolOfInterfaceThenUintImpl) GetReturnOfUint() *ReturnOfUint {
	return __.UintReturn.Get().(*ReturnOfUint)
}
func (__ *PoolOfInterfaceThenUintImpl) PutReturnOfUint(p *ReturnOfUint) {
	__.UintReturn.Put(p)
}

func (__ *PoolOfInterfaceThenUintImpl) GetChReturnOfUint() chan *ReturnOfUint {
	return __.ChReturnOfUint.Get().(chan *ReturnOfUint)
}
func (__ *PoolOfInterfaceThenUintImpl) PutChReturnOfUint(p chan *ReturnOfUint) {
	__.ChReturnOfUint.Put(p)
}

func NewPoolOfInterfaceThenUintImpl() *PoolOfInterfaceThenUintImpl {
	return &PoolOfInterfaceThenUintImpl{
		InterfaceArg: sync.Pool{
			New: func() interface{} {
				return new(interface{})
			},
		},
		InterfaceWork: sync.Pool{
			New: func() interface{} {
				return new(WorkOfInterfaceThenUint)
			},
		},
		UintRtn: sync.Pool{
			New: func() interface{} {
				return new(uint)
			},
		},
		UintReturn: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfUint)
			},
		},
		ChReturnOfUint: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfUint, 1)
			},
		},
	}
}

type ApiDecouplerOfInterfaceThenUint struct {
	pool PoolOfInterfaceThenUint
}

func NewApiDecouplerOfInterfaceThenUint() *ApiDecouplerOfInterfaceThenUint {
	return &ApiDecouplerOfInterfaceThenUint{
		pool: NewPoolOfInterfaceThenUintImpl(),
	}
}

func (__ *ApiDecouplerOfInterfaceThenUint) ReturnError(rtn_ch chan<- *ReturnOfUint, err error) {
	rtn := __.pool.GetReturnOfUint()
	var other uint
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfInterfaceThenUint) HandleOfInterfaceThenUint(ctx context.Context, req *WorkOfInterfaceThenUint, h func(ctx context.Context, arg interface{}) (uint, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfUint()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfInterfaceThenUint) DoOfInterfaceThenUint(ctx context.Context, worker WorkerOfPushInterfaceThenUint, arg interface{}) (uint, error) {
	// ch := make(chan *ReturnOfUint, 1)
	ch := __.pool.GetChReturnOfUint()
	defer __.pool.PutChReturnOfUint(ch)

	req := __.pool.GetWorkOfInterfaceThenUint()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfInterfaceThenUint(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfUint(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfInterfaceThenUint = func(ctx context.Context, arg interface{}) (uint, error)

type WorkerOfInterfaceThenUint struct {
	api_syncer *ApiDecouplerOfInterfaceThenUint
	handler    WorkHandlerOfInterfaceThenUint

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfInterfaceThenUint
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfInterfaceThenUint(ctx context.Context, h WorkHandlerOfInterfaceThenUint, n int) *WorkerOfInterfaceThenUint {
	__ := &WorkerOfInterfaceThenUint{
		api_syncer: NewApiDecouplerOfInterfaceThenUint(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfInterfaceThenUint, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfInterfaceThenUint{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfInterfaceThenUint(req.Context, req.WorkOfInterfaceThenUint, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfInterfaceThenUint) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfInterfaceThenUint) Push(ctx context.Context, req *WorkOfInterfaceThenUint) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfInterfaceThenUint)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfInterfaceThenUint = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfInterfaceThenUint) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfInterfaceThenUint) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfInterfaceThenUint) Call(ctx context.Context, arg interface{}) (uint, error) {
	return __.api_syncer.DoOfInterfaceThenUint(ctx, __, arg)
}

type PoolOfInterfaceThenUint16 interface {
	GetInterfaceArg() *interface{}
	PutInterfaceArg(*interface{})
	GetUint16Return() *uint16
	PutUint16Return(*uint16)

	GetWorkOfInterfaceThenUint16() *WorkOfInterfaceThenUint16
	GetReturnOfUint16() *ReturnOfUint16
	PutWorkOfInterfaceThenUint16(*WorkOfInterfaceThenUint16)
	PutReturnOfUint16(*ReturnOfUint16)

	GetChReturnOfUint16() chan *ReturnOfUint16
	PutChReturnOfUint16(chan *ReturnOfUint16)
}

type PoolOfInterfaceThenUint16Impl struct {
	InterfaceArg     sync.Pool
	Uint16Rtn        sync.Pool
	InterfaceWork    sync.Pool
	Uint16Return     sync.Pool
	ChReturnOfUint16 sync.Pool
}

func (__ *PoolOfInterfaceThenUint16Impl) GetInterfaceArg() *interface{} {
	return __.InterfaceArg.Get().(*interface{})
}
func (__ *PoolOfInterfaceThenUint16Impl) PutInterfaceArg(p *interface{}) {
	__.InterfaceArg.Put(p)
}
func (__ *PoolOfInterfaceThenUint16Impl) GetUint16Return() *uint16 {
	return __.Uint16Rtn.Get().(*uint16)
}
func (__ *PoolOfInterfaceThenUint16Impl) PutUint16Return(p *uint16) {
	__.Uint16Rtn.Put(p)
}

func (__ *PoolOfInterfaceThenUint16Impl) GetWorkOfInterfaceThenUint16() *WorkOfInterfaceThenUint16 {
	return __.InterfaceWork.Get().(*WorkOfInterfaceThenUint16)
}
func (__ *PoolOfInterfaceThenUint16Impl) PutWorkOfInterfaceThenUint16(p *WorkOfInterfaceThenUint16) {
	__.InterfaceWork.Put(p)
}
func (__ *PoolOfInterfaceThenUint16Impl) GetReturnOfUint16() *ReturnOfUint16 {
	return __.Uint16Return.Get().(*ReturnOfUint16)
}
func (__ *PoolOfInterfaceThenUint16Impl) PutReturnOfUint16(p *ReturnOfUint16) {
	__.Uint16Return.Put(p)
}

func (__ *PoolOfInterfaceThenUint16Impl) GetChReturnOfUint16() chan *ReturnOfUint16 {
	return __.ChReturnOfUint16.Get().(chan *ReturnOfUint16)
}
func (__ *PoolOfInterfaceThenUint16Impl) PutChReturnOfUint16(p chan *ReturnOfUint16) {
	__.ChReturnOfUint16.Put(p)
}

func NewPoolOfInterfaceThenUint16Impl() *PoolOfInterfaceThenUint16Impl {
	return &PoolOfInterfaceThenUint16Impl{
		InterfaceArg: sync.Pool{
			New: func() interface{} {
				return new(interface{})
			},
		},
		InterfaceWork: sync.Pool{
			New: func() interface{} {
				return new(WorkOfInterfaceThenUint16)
			},
		},
		Uint16Rtn: sync.Pool{
			New: func() interface{} {
				return new(uint16)
			},
		},
		Uint16Return: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfUint16)
			},
		},
		ChReturnOfUint16: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfUint16, 1)
			},
		},
	}
}

type ApiDecouplerOfInterfaceThenUint16 struct {
	pool PoolOfInterfaceThenUint16
}

func NewApiDecouplerOfInterfaceThenUint16() *ApiDecouplerOfInterfaceThenUint16 {
	return &ApiDecouplerOfInterfaceThenUint16{
		pool: NewPoolOfInterfaceThenUint16Impl(),
	}
}

func (__ *ApiDecouplerOfInterfaceThenUint16) ReturnError(rtn_ch chan<- *ReturnOfUint16, err error) {
	rtn := __.pool.GetReturnOfUint16()
	var other uint16
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfInterfaceThenUint16) HandleOfInterfaceThenUint16(ctx context.Context, req *WorkOfInterfaceThenUint16, h func(ctx context.Context, arg interface{}) (uint16, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfUint16()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfInterfaceThenUint16) DoOfInterfaceThenUint16(ctx context.Context, worker WorkerOfPushInterfaceThenUint16, arg interface{}) (uint16, error) {
	// ch := make(chan *ReturnOfUint16, 1)
	ch := __.pool.GetChReturnOfUint16()
	defer __.pool.PutChReturnOfUint16(ch)

	req := __.pool.GetWorkOfInterfaceThenUint16()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfInterfaceThenUint16(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfUint16(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfInterfaceThenUint16 = func(ctx context.Context, arg interface{}) (uint16, error)

type WorkerOfInterfaceThenUint16 struct {
	api_syncer *ApiDecouplerOfInterfaceThenUint16
	handler    WorkHandlerOfInterfaceThenUint16

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfInterfaceThenUint16
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfInterfaceThenUint16(ctx context.Context, h WorkHandlerOfInterfaceThenUint16, n int) *WorkerOfInterfaceThenUint16 {
	__ := &WorkerOfInterfaceThenUint16{
		api_syncer: NewApiDecouplerOfInterfaceThenUint16(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfInterfaceThenUint16, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfInterfaceThenUint16{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfInterfaceThenUint16(req.Context, req.WorkOfInterfaceThenUint16, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfInterfaceThenUint16) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfInterfaceThenUint16) Push(ctx context.Context, req *WorkOfInterfaceThenUint16) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfInterfaceThenUint16)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfInterfaceThenUint16 = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfInterfaceThenUint16) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfInterfaceThenUint16) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfInterfaceThenUint16) Call(ctx context.Context, arg interface{}) (uint16, error) {
	return __.api_syncer.DoOfInterfaceThenUint16(ctx, __, arg)
}

type PoolOfInterfaceThenUint32 interface {
	GetInterfaceArg() *interface{}
	PutInterfaceArg(*interface{})
	GetUint32Return() *uint32
	PutUint32Return(*uint32)

	GetWorkOfInterfaceThenUint32() *WorkOfInterfaceThenUint32
	GetReturnOfUint32() *ReturnOfUint32
	PutWorkOfInterfaceThenUint32(*WorkOfInterfaceThenUint32)
	PutReturnOfUint32(*ReturnOfUint32)

	GetChReturnOfUint32() chan *ReturnOfUint32
	PutChReturnOfUint32(chan *ReturnOfUint32)
}

type PoolOfInterfaceThenUint32Impl struct {
	InterfaceArg     sync.Pool
	Uint32Rtn        sync.Pool
	InterfaceWork    sync.Pool
	Uint32Return     sync.Pool
	ChReturnOfUint32 sync.Pool
}

func (__ *PoolOfInterfaceThenUint32Impl) GetInterfaceArg() *interface{} {
	return __.InterfaceArg.Get().(*interface{})
}
func (__ *PoolOfInterfaceThenUint32Impl) PutInterfaceArg(p *interface{}) {
	__.InterfaceArg.Put(p)
}
func (__ *PoolOfInterfaceThenUint32Impl) GetUint32Return() *uint32 {
	return __.Uint32Rtn.Get().(*uint32)
}
func (__ *PoolOfInterfaceThenUint32Impl) PutUint32Return(p *uint32) {
	__.Uint32Rtn.Put(p)
}

func (__ *PoolOfInterfaceThenUint32Impl) GetWorkOfInterfaceThenUint32() *WorkOfInterfaceThenUint32 {
	return __.InterfaceWork.Get().(*WorkOfInterfaceThenUint32)
}
func (__ *PoolOfInterfaceThenUint32Impl) PutWorkOfInterfaceThenUint32(p *WorkOfInterfaceThenUint32) {
	__.InterfaceWork.Put(p)
}
func (__ *PoolOfInterfaceThenUint32Impl) GetReturnOfUint32() *ReturnOfUint32 {
	return __.Uint32Return.Get().(*ReturnOfUint32)
}
func (__ *PoolOfInterfaceThenUint32Impl) PutReturnOfUint32(p *ReturnOfUint32) {
	__.Uint32Return.Put(p)
}

func (__ *PoolOfInterfaceThenUint32Impl) GetChReturnOfUint32() chan *ReturnOfUint32 {
	return __.ChReturnOfUint32.Get().(chan *ReturnOfUint32)
}
func (__ *PoolOfInterfaceThenUint32Impl) PutChReturnOfUint32(p chan *ReturnOfUint32) {
	__.ChReturnOfUint32.Put(p)
}

func NewPoolOfInterfaceThenUint32Impl() *PoolOfInterfaceThenUint32Impl {
	return &PoolOfInterfaceThenUint32Impl{
		InterfaceArg: sync.Pool{
			New: func() interface{} {
				return new(interface{})
			},
		},
		InterfaceWork: sync.Pool{
			New: func() interface{} {
				return new(WorkOfInterfaceThenUint32)
			},
		},
		Uint32Rtn: sync.Pool{
			New: func() interface{} {
				return new(uint32)
			},
		},
		Uint32Return: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfUint32)
			},
		},
		ChReturnOfUint32: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfUint32, 1)
			},
		},
	}
}

type ApiDecouplerOfInterfaceThenUint32 struct {
	pool PoolOfInterfaceThenUint32
}

func NewApiDecouplerOfInterfaceThenUint32() *ApiDecouplerOfInterfaceThenUint32 {
	return &ApiDecouplerOfInterfaceThenUint32{
		pool: NewPoolOfInterfaceThenUint32Impl(),
	}
}

func (__ *ApiDecouplerOfInterfaceThenUint32) ReturnError(rtn_ch chan<- *ReturnOfUint32, err error) {
	rtn := __.pool.GetReturnOfUint32()
	var other uint32
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfInterfaceThenUint32) HandleOfInterfaceThenUint32(ctx context.Context, req *WorkOfInterfaceThenUint32, h func(ctx context.Context, arg interface{}) (uint32, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfUint32()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfInterfaceThenUint32) DoOfInterfaceThenUint32(ctx context.Context, worker WorkerOfPushInterfaceThenUint32, arg interface{}) (uint32, error) {
	// ch := make(chan *ReturnOfUint32, 1)
	ch := __.pool.GetChReturnOfUint32()
	defer __.pool.PutChReturnOfUint32(ch)

	req := __.pool.GetWorkOfInterfaceThenUint32()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfInterfaceThenUint32(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfUint32(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfInterfaceThenUint32 = func(ctx context.Context, arg interface{}) (uint32, error)

type WorkerOfInterfaceThenUint32 struct {
	api_syncer *ApiDecouplerOfInterfaceThenUint32
	handler    WorkHandlerOfInterfaceThenUint32

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfInterfaceThenUint32
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfInterfaceThenUint32(ctx context.Context, h WorkHandlerOfInterfaceThenUint32, n int) *WorkerOfInterfaceThenUint32 {
	__ := &WorkerOfInterfaceThenUint32{
		api_syncer: NewApiDecouplerOfInterfaceThenUint32(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfInterfaceThenUint32, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfInterfaceThenUint32{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfInterfaceThenUint32(req.Context, req.WorkOfInterfaceThenUint32, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfInterfaceThenUint32) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfInterfaceThenUint32) Push(ctx context.Context, req *WorkOfInterfaceThenUint32) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfInterfaceThenUint32)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfInterfaceThenUint32 = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfInterfaceThenUint32) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfInterfaceThenUint32) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfInterfaceThenUint32) Call(ctx context.Context, arg interface{}) (uint32, error) {
	return __.api_syncer.DoOfInterfaceThenUint32(ctx, __, arg)
}

type PoolOfInterfaceThenUint64 interface {
	GetInterfaceArg() *interface{}
	PutInterfaceArg(*interface{})
	GetUint64Return() *uint64
	PutUint64Return(*uint64)

	GetWorkOfInterfaceThenUint64() *WorkOfInterfaceThenUint64
	GetReturnOfUint64() *ReturnOfUint64
	PutWorkOfInterfaceThenUint64(*WorkOfInterfaceThenUint64)
	PutReturnOfUint64(*ReturnOfUint64)

	GetChReturnOfUint64() chan *ReturnOfUint64
	PutChReturnOfUint64(chan *ReturnOfUint64)
}

type PoolOfInterfaceThenUint64Impl struct {
	InterfaceArg     sync.Pool
	Uint64Rtn        sync.Pool
	InterfaceWork    sync.Pool
	Uint64Return     sync.Pool
	ChReturnOfUint64 sync.Pool
}

func (__ *PoolOfInterfaceThenUint64Impl) GetInterfaceArg() *interface{} {
	return __.InterfaceArg.Get().(*interface{})
}
func (__ *PoolOfInterfaceThenUint64Impl) PutInterfaceArg(p *interface{}) {
	__.InterfaceArg.Put(p)
}
func (__ *PoolOfInterfaceThenUint64Impl) GetUint64Return() *uint64 {
	return __.Uint64Rtn.Get().(*uint64)
}
func (__ *PoolOfInterfaceThenUint64Impl) PutUint64Return(p *uint64) {
	__.Uint64Rtn.Put(p)
}

func (__ *PoolOfInterfaceThenUint64Impl) GetWorkOfInterfaceThenUint64() *WorkOfInterfaceThenUint64 {
	return __.InterfaceWork.Get().(*WorkOfInterfaceThenUint64)
}
func (__ *PoolOfInterfaceThenUint64Impl) PutWorkOfInterfaceThenUint64(p *WorkOfInterfaceThenUint64) {
	__.InterfaceWork.Put(p)
}
func (__ *PoolOfInterfaceThenUint64Impl) GetReturnOfUint64() *ReturnOfUint64 {
	return __.Uint64Return.Get().(*ReturnOfUint64)
}
func (__ *PoolOfInterfaceThenUint64Impl) PutReturnOfUint64(p *ReturnOfUint64) {
	__.Uint64Return.Put(p)
}

func (__ *PoolOfInterfaceThenUint64Impl) GetChReturnOfUint64() chan *ReturnOfUint64 {
	return __.ChReturnOfUint64.Get().(chan *ReturnOfUint64)
}
func (__ *PoolOfInterfaceThenUint64Impl) PutChReturnOfUint64(p chan *ReturnOfUint64) {
	__.ChReturnOfUint64.Put(p)
}

func NewPoolOfInterfaceThenUint64Impl() *PoolOfInterfaceThenUint64Impl {
	return &PoolOfInterfaceThenUint64Impl{
		InterfaceArg: sync.Pool{
			New: func() interface{} {
				return new(interface{})
			},
		},
		InterfaceWork: sync.Pool{
			New: func() interface{} {
				return new(WorkOfInterfaceThenUint64)
			},
		},
		Uint64Rtn: sync.Pool{
			New: func() interface{} {
				return new(uint64)
			},
		},
		Uint64Return: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfUint64)
			},
		},
		ChReturnOfUint64: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfUint64, 1)
			},
		},
	}
}

type ApiDecouplerOfInterfaceThenUint64 struct {
	pool PoolOfInterfaceThenUint64
}

func NewApiDecouplerOfInterfaceThenUint64() *ApiDecouplerOfInterfaceThenUint64 {
	return &ApiDecouplerOfInterfaceThenUint64{
		pool: NewPoolOfInterfaceThenUint64Impl(),
	}
}

func (__ *ApiDecouplerOfInterfaceThenUint64) ReturnError(rtn_ch chan<- *ReturnOfUint64, err error) {
	rtn := __.pool.GetReturnOfUint64()
	var other uint64
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfInterfaceThenUint64) HandleOfInterfaceThenUint64(ctx context.Context, req *WorkOfInterfaceThenUint64, h func(ctx context.Context, arg interface{}) (uint64, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfUint64()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfInterfaceThenUint64) DoOfInterfaceThenUint64(ctx context.Context, worker WorkerOfPushInterfaceThenUint64, arg interface{}) (uint64, error) {
	// ch := make(chan *ReturnOfUint64, 1)
	ch := __.pool.GetChReturnOfUint64()
	defer __.pool.PutChReturnOfUint64(ch)

	req := __.pool.GetWorkOfInterfaceThenUint64()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfInterfaceThenUint64(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfUint64(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfInterfaceThenUint64 = func(ctx context.Context, arg interface{}) (uint64, error)

type WorkerOfInterfaceThenUint64 struct {
	api_syncer *ApiDecouplerOfInterfaceThenUint64
	handler    WorkHandlerOfInterfaceThenUint64

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfInterfaceThenUint64
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfInterfaceThenUint64(ctx context.Context, h WorkHandlerOfInterfaceThenUint64, n int) *WorkerOfInterfaceThenUint64 {
	__ := &WorkerOfInterfaceThenUint64{
		api_syncer: NewApiDecouplerOfInterfaceThenUint64(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfInterfaceThenUint64, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfInterfaceThenUint64{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfInterfaceThenUint64(req.Context, req.WorkOfInterfaceThenUint64, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfInterfaceThenUint64) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfInterfaceThenUint64) Push(ctx context.Context, req *WorkOfInterfaceThenUint64) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfInterfaceThenUint64)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfInterfaceThenUint64 = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfInterfaceThenUint64) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfInterfaceThenUint64) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfInterfaceThenUint64) Call(ctx context.Context, arg interface{}) (uint64, error) {
	return __.api_syncer.DoOfInterfaceThenUint64(ctx, __, arg)
}

type PoolOfInterfaceThenUint8 interface {
	GetInterfaceArg() *interface{}
	PutInterfaceArg(*interface{})
	GetUint8Return() *uint8
	PutUint8Return(*uint8)

	GetWorkOfInterfaceThenUint8() *WorkOfInterfaceThenUint8
	GetReturnOfUint8() *ReturnOfUint8
	PutWorkOfInterfaceThenUint8(*WorkOfInterfaceThenUint8)
	PutReturnOfUint8(*ReturnOfUint8)

	GetChReturnOfUint8() chan *ReturnOfUint8
	PutChReturnOfUint8(chan *ReturnOfUint8)
}

type PoolOfInterfaceThenUint8Impl struct {
	InterfaceArg    sync.Pool
	Uint8Rtn        sync.Pool
	InterfaceWork   sync.Pool
	Uint8Return     sync.Pool
	ChReturnOfUint8 sync.Pool
}

func (__ *PoolOfInterfaceThenUint8Impl) GetInterfaceArg() *interface{} {
	return __.InterfaceArg.Get().(*interface{})
}
func (__ *PoolOfInterfaceThenUint8Impl) PutInterfaceArg(p *interface{}) {
	__.InterfaceArg.Put(p)
}
func (__ *PoolOfInterfaceThenUint8Impl) GetUint8Return() *uint8 {
	return __.Uint8Rtn.Get().(*uint8)
}
func (__ *PoolOfInterfaceThenUint8Impl) PutUint8Return(p *uint8) {
	__.Uint8Rtn.Put(p)
}

func (__ *PoolOfInterfaceThenUint8Impl) GetWorkOfInterfaceThenUint8() *WorkOfInterfaceThenUint8 {
	return __.InterfaceWork.Get().(*WorkOfInterfaceThenUint8)
}
func (__ *PoolOfInterfaceThenUint8Impl) PutWorkOfInterfaceThenUint8(p *WorkOfInterfaceThenUint8) {
	__.InterfaceWork.Put(p)
}
func (__ *PoolOfInterfaceThenUint8Impl) GetReturnOfUint8() *ReturnOfUint8 {
	return __.Uint8Return.Get().(*ReturnOfUint8)
}
func (__ *PoolOfInterfaceThenUint8Impl) PutReturnOfUint8(p *ReturnOfUint8) {
	__.Uint8Return.Put(p)
}

func (__ *PoolOfInterfaceThenUint8Impl) GetChReturnOfUint8() chan *ReturnOfUint8 {
	return __.ChReturnOfUint8.Get().(chan *ReturnOfUint8)
}
func (__ *PoolOfInterfaceThenUint8Impl) PutChReturnOfUint8(p chan *ReturnOfUint8) {
	__.ChReturnOfUint8.Put(p)
}

func NewPoolOfInterfaceThenUint8Impl() *PoolOfInterfaceThenUint8Impl {
	return &PoolOfInterfaceThenUint8Impl{
		InterfaceArg: sync.Pool{
			New: func() interface{} {
				return new(interface{})
			},
		},
		InterfaceWork: sync.Pool{
			New: func() interface{} {
				return new(WorkOfInterfaceThenUint8)
			},
		},
		Uint8Rtn: sync.Pool{
			New: func() interface{} {
				return new(uint8)
			},
		},
		Uint8Return: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfUint8)
			},
		},
		ChReturnOfUint8: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfUint8, 1)
			},
		},
	}
}

type ApiDecouplerOfInterfaceThenUint8 struct {
	pool PoolOfInterfaceThenUint8
}

func NewApiDecouplerOfInterfaceThenUint8() *ApiDecouplerOfInterfaceThenUint8 {
	return &ApiDecouplerOfInterfaceThenUint8{
		pool: NewPoolOfInterfaceThenUint8Impl(),
	}
}

func (__ *ApiDecouplerOfInterfaceThenUint8) ReturnError(rtn_ch chan<- *ReturnOfUint8, err error) {
	rtn := __.pool.GetReturnOfUint8()
	var other uint8
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfInterfaceThenUint8) HandleOfInterfaceThenUint8(ctx context.Context, req *WorkOfInterfaceThenUint8, h func(ctx context.Context, arg interface{}) (uint8, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfUint8()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfInterfaceThenUint8) DoOfInterfaceThenUint8(ctx context.Context, worker WorkerOfPushInterfaceThenUint8, arg interface{}) (uint8, error) {
	// ch := make(chan *ReturnOfUint8, 1)
	ch := __.pool.GetChReturnOfUint8()
	defer __.pool.PutChReturnOfUint8(ch)

	req := __.pool.GetWorkOfInterfaceThenUint8()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfInterfaceThenUint8(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfUint8(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfInterfaceThenUint8 = func(ctx context.Context, arg interface{}) (uint8, error)

type WorkerOfInterfaceThenUint8 struct {
	api_syncer *ApiDecouplerOfInterfaceThenUint8
	handler    WorkHandlerOfInterfaceThenUint8

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfInterfaceThenUint8
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfInterfaceThenUint8(ctx context.Context, h WorkHandlerOfInterfaceThenUint8, n int) *WorkerOfInterfaceThenUint8 {
	__ := &WorkerOfInterfaceThenUint8{
		api_syncer: NewApiDecouplerOfInterfaceThenUint8(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfInterfaceThenUint8, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfInterfaceThenUint8{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfInterfaceThenUint8(req.Context, req.WorkOfInterfaceThenUint8, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfInterfaceThenUint8) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfInterfaceThenUint8) Push(ctx context.Context, req *WorkOfInterfaceThenUint8) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfInterfaceThenUint8)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfInterfaceThenUint8 = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfInterfaceThenUint8) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfInterfaceThenUint8) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfInterfaceThenUint8) Call(ctx context.Context, arg interface{}) (uint8, error) {
	return __.api_syncer.DoOfInterfaceThenUint8(ctx, __, arg)
}

type PoolOfInterfaceThenUintptr interface {
	GetInterfaceArg() *interface{}
	PutInterfaceArg(*interface{})
	GetUintptrReturn() *uintptr
	PutUintptrReturn(*uintptr)

	GetWorkOfInterfaceThenUintptr() *WorkOfInterfaceThenUintptr
	GetReturnOfUintptr() *ReturnOfUintptr
	PutWorkOfInterfaceThenUintptr(*WorkOfInterfaceThenUintptr)
	PutReturnOfUintptr(*ReturnOfUintptr)

	GetChReturnOfUintptr() chan *ReturnOfUintptr
	PutChReturnOfUintptr(chan *ReturnOfUintptr)
}

type PoolOfInterfaceThenUintptrImpl struct {
	InterfaceArg      sync.Pool
	UintptrRtn        sync.Pool
	InterfaceWork     sync.Pool
	UintptrReturn     sync.Pool
	ChReturnOfUintptr sync.Pool
}

func (__ *PoolOfInterfaceThenUintptrImpl) GetInterfaceArg() *interface{} {
	return __.InterfaceArg.Get().(*interface{})
}
func (__ *PoolOfInterfaceThenUintptrImpl) PutInterfaceArg(p *interface{}) {
	__.InterfaceArg.Put(p)
}
func (__ *PoolOfInterfaceThenUintptrImpl) GetUintptrReturn() *uintptr {
	return __.UintptrRtn.Get().(*uintptr)
}
func (__ *PoolOfInterfaceThenUintptrImpl) PutUintptrReturn(p *uintptr) {
	__.UintptrRtn.Put(p)
}

func (__ *PoolOfInterfaceThenUintptrImpl) GetWorkOfInterfaceThenUintptr() *WorkOfInterfaceThenUintptr {
	return __.InterfaceWork.Get().(*WorkOfInterfaceThenUintptr)
}
func (__ *PoolOfInterfaceThenUintptrImpl) PutWorkOfInterfaceThenUintptr(p *WorkOfInterfaceThenUintptr) {
	__.InterfaceWork.Put(p)
}
func (__ *PoolOfInterfaceThenUintptrImpl) GetReturnOfUintptr() *ReturnOfUintptr {
	return __.UintptrReturn.Get().(*ReturnOfUintptr)
}
func (__ *PoolOfInterfaceThenUintptrImpl) PutReturnOfUintptr(p *ReturnOfUintptr) {
	__.UintptrReturn.Put(p)
}

func (__ *PoolOfInterfaceThenUintptrImpl) GetChReturnOfUintptr() chan *ReturnOfUintptr {
	return __.ChReturnOfUintptr.Get().(chan *ReturnOfUintptr)
}
func (__ *PoolOfInterfaceThenUintptrImpl) PutChReturnOfUintptr(p chan *ReturnOfUintptr) {
	__.ChReturnOfUintptr.Put(p)
}

func NewPoolOfInterfaceThenUintptrImpl() *PoolOfInterfaceThenUintptrImpl {
	return &PoolOfInterfaceThenUintptrImpl{
		InterfaceArg: sync.Pool{
			New: func() interface{} {
				return new(interface{})
			},
		},
		InterfaceWork: sync.Pool{
			New: func() interface{} {
				return new(WorkOfInterfaceThenUintptr)
			},
		},
		UintptrRtn: sync.Pool{
			New: func() interface{} {
				return new(uintptr)
			},
		},
		UintptrReturn: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfUintptr)
			},
		},
		ChReturnOfUintptr: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfUintptr, 1)
			},
		},
	}
}

type ApiDecouplerOfInterfaceThenUintptr struct {
	pool PoolOfInterfaceThenUintptr
}

func NewApiDecouplerOfInterfaceThenUintptr() *ApiDecouplerOfInterfaceThenUintptr {
	return &ApiDecouplerOfInterfaceThenUintptr{
		pool: NewPoolOfInterfaceThenUintptrImpl(),
	}
}

func (__ *ApiDecouplerOfInterfaceThenUintptr) ReturnError(rtn_ch chan<- *ReturnOfUintptr, err error) {
	rtn := __.pool.GetReturnOfUintptr()
	var other uintptr
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfInterfaceThenUintptr) HandleOfInterfaceThenUintptr(ctx context.Context, req *WorkOfInterfaceThenUintptr, h func(ctx context.Context, arg interface{}) (uintptr, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfUintptr()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfInterfaceThenUintptr) DoOfInterfaceThenUintptr(ctx context.Context, worker WorkerOfPushInterfaceThenUintptr, arg interface{}) (uintptr, error) {
	// ch := make(chan *ReturnOfUintptr, 1)
	ch := __.pool.GetChReturnOfUintptr()
	defer __.pool.PutChReturnOfUintptr(ch)

	req := __.pool.GetWorkOfInterfaceThenUintptr()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfInterfaceThenUintptr(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfUintptr(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfInterfaceThenUintptr = func(ctx context.Context, arg interface{}) (uintptr, error)

type WorkerOfInterfaceThenUintptr struct {
	api_syncer *ApiDecouplerOfInterfaceThenUintptr
	handler    WorkHandlerOfInterfaceThenUintptr

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfInterfaceThenUintptr
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfInterfaceThenUintptr(ctx context.Context, h WorkHandlerOfInterfaceThenUintptr, n int) *WorkerOfInterfaceThenUintptr {
	__ := &WorkerOfInterfaceThenUintptr{
		api_syncer: NewApiDecouplerOfInterfaceThenUintptr(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfInterfaceThenUintptr, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfInterfaceThenUintptr{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfInterfaceThenUintptr(req.Context, req.WorkOfInterfaceThenUintptr, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfInterfaceThenUintptr) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfInterfaceThenUintptr) Push(ctx context.Context, req *WorkOfInterfaceThenUintptr) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfInterfaceThenUintptr)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfInterfaceThenUintptr = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfInterfaceThenUintptr) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfInterfaceThenUintptr) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfInterfaceThenUintptr) Call(ctx context.Context, arg interface{}) (uintptr, error) {
	return __.api_syncer.DoOfInterfaceThenUintptr(ctx, __, arg)
}

type PoolOfInterfaceThenInterface interface {
	GetInterfaceArg() *interface{}
	PutInterfaceArg(*interface{})
	GetInterfaceReturn() *interface{}
	PutInterfaceReturn(*interface{})

	GetWorkOfInterfaceThenInterface() *WorkOfInterfaceThenInterface
	GetReturnOfInterface() *ReturnOfInterface
	PutWorkOfInterfaceThenInterface(*WorkOfInterfaceThenInterface)
	PutReturnOfInterface(*ReturnOfInterface)

	GetChReturnOfInterface() chan *ReturnOfInterface
	PutChReturnOfInterface(chan *ReturnOfInterface)
}

type PoolOfInterfaceThenInterfaceImpl struct {
	InterfaceArg        sync.Pool
	InterfaceRtn        sync.Pool
	InterfaceWork       sync.Pool
	InterfaceReturn     sync.Pool
	ChReturnOfInterface sync.Pool
}

func (__ *PoolOfInterfaceThenInterfaceImpl) GetInterfaceArg() *interface{} {
	return __.InterfaceArg.Get().(*interface{})
}
func (__ *PoolOfInterfaceThenInterfaceImpl) PutInterfaceArg(p *interface{}) {
	__.InterfaceArg.Put(p)
}
func (__ *PoolOfInterfaceThenInterfaceImpl) GetInterfaceReturn() *interface{} {
	return __.InterfaceRtn.Get().(*interface{})
}
func (__ *PoolOfInterfaceThenInterfaceImpl) PutInterfaceReturn(p *interface{}) {
	__.InterfaceRtn.Put(p)
}

func (__ *PoolOfInterfaceThenInterfaceImpl) GetWorkOfInterfaceThenInterface() *WorkOfInterfaceThenInterface {
	return __.InterfaceWork.Get().(*WorkOfInterfaceThenInterface)
}
func (__ *PoolOfInterfaceThenInterfaceImpl) PutWorkOfInterfaceThenInterface(p *WorkOfInterfaceThenInterface) {
	__.InterfaceWork.Put(p)
}
func (__ *PoolOfInterfaceThenInterfaceImpl) GetReturnOfInterface() *ReturnOfInterface {
	return __.InterfaceReturn.Get().(*ReturnOfInterface)
}
func (__ *PoolOfInterfaceThenInterfaceImpl) PutReturnOfInterface(p *ReturnOfInterface) {
	__.InterfaceReturn.Put(p)
}

func (__ *PoolOfInterfaceThenInterfaceImpl) GetChReturnOfInterface() chan *ReturnOfInterface {
	return __.ChReturnOfInterface.Get().(chan *ReturnOfInterface)
}
func (__ *PoolOfInterfaceThenInterfaceImpl) PutChReturnOfInterface(p chan *ReturnOfInterface) {
	__.ChReturnOfInterface.Put(p)
}

func NewPoolOfInterfaceThenInterfaceImpl() *PoolOfInterfaceThenInterfaceImpl {
	return &PoolOfInterfaceThenInterfaceImpl{
		InterfaceArg: sync.Pool{
			New: func() interface{} {
				return new(interface{})
			},
		},
		InterfaceWork: sync.Pool{
			New: func() interface{} {
				return new(WorkOfInterfaceThenInterface)
			},
		},
		InterfaceRtn: sync.Pool{
			New: func() interface{} {
				return new(interface{})
			},
		},
		InterfaceReturn: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfInterface)
			},
		},
		ChReturnOfInterface: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfInterface, 1)
			},
		},
	}
}

type ApiDecouplerOfInterfaceThenInterface struct {
	pool PoolOfInterfaceThenInterface
}

func NewApiDecouplerOfInterfaceThenInterface() *ApiDecouplerOfInterfaceThenInterface {
	return &ApiDecouplerOfInterfaceThenInterface{
		pool: NewPoolOfInterfaceThenInterfaceImpl(),
	}
}

func (__ *ApiDecouplerOfInterfaceThenInterface) ReturnError(rtn_ch chan<- *ReturnOfInterface, err error) {
	rtn := __.pool.GetReturnOfInterface()
	var other interface{}
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfInterfaceThenInterface) HandleOfInterfaceThenInterface(ctx context.Context, req *WorkOfInterfaceThenInterface, h func(ctx context.Context, arg interface{}) (interface{}, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfInterface()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfInterfaceThenInterface) DoOfInterfaceThenInterface(ctx context.Context, worker WorkerOfPushInterfaceThenInterface, arg interface{}) (interface{}, error) {
	// ch := make(chan *ReturnOfInterface, 1)
	ch := __.pool.GetChReturnOfInterface()
	defer __.pool.PutChReturnOfInterface(ch)

	req := __.pool.GetWorkOfInterfaceThenInterface()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfInterfaceThenInterface(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfInterface(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfInterfaceThenInterface = func(ctx context.Context, arg interface{}) (interface{}, error)

type WorkerOfInterfaceThenInterface struct {
	api_syncer *ApiDecouplerOfInterfaceThenInterface
	handler    WorkHandlerOfInterfaceThenInterface

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfInterfaceThenInterface
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfInterfaceThenInterface(ctx context.Context, h WorkHandlerOfInterfaceThenInterface, n int) *WorkerOfInterfaceThenInterface {
	__ := &WorkerOfInterfaceThenInterface{
		api_syncer: NewApiDecouplerOfInterfaceThenInterface(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfInterfaceThenInterface, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfInterfaceThenInterface{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfInterfaceThenInterface(req.Context, req.WorkOfInterfaceThenInterface, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfInterfaceThenInterface) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfInterfaceThenInterface) Push(ctx context.Context, req *WorkOfInterfaceThenInterface) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfInterfaceThenInterface)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfInterfaceThenInterface = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfInterfaceThenInterface) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfInterfaceThenInterface) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfInterfaceThenInterface) Call(ctx context.Context, arg interface{}) (interface{}, error) {
	return __.api_syncer.DoOfInterfaceThenInterface(ctx, __, arg)
}

type PoolOfInterfaceThenStruct interface {
	GetInterfaceArg() *interface{}
	PutInterfaceArg(*interface{})
	GetStructReturn() *struct{}
	PutStructReturn(*struct{})

	GetWorkOfInterfaceThenStruct() *WorkOfInterfaceThenStruct
	GetReturnOfStruct() *ReturnOfStruct
	PutWorkOfInterfaceThenStruct(*WorkOfInterfaceThenStruct)
	PutReturnOfStruct(*ReturnOfStruct)

	GetChReturnOfStruct() chan *ReturnOfStruct
	PutChReturnOfStruct(chan *ReturnOfStruct)
}

type PoolOfInterfaceThenStructImpl struct {
	InterfaceArg     sync.Pool
	StructRtn        sync.Pool
	InterfaceWork    sync.Pool
	StructReturn     sync.Pool
	ChReturnOfStruct sync.Pool
}

func (__ *PoolOfInterfaceThenStructImpl) GetInterfaceArg() *interface{} {
	return __.InterfaceArg.Get().(*interface{})
}
func (__ *PoolOfInterfaceThenStructImpl) PutInterfaceArg(p *interface{}) {
	__.InterfaceArg.Put(p)
}
func (__ *PoolOfInterfaceThenStructImpl) GetStructReturn() *struct{} {
	return __.StructRtn.Get().(*struct{})
}
func (__ *PoolOfInterfaceThenStructImpl) PutStructReturn(p *struct{}) {
	__.StructRtn.Put(p)
}

func (__ *PoolOfInterfaceThenStructImpl) GetWorkOfInterfaceThenStruct() *WorkOfInterfaceThenStruct {
	return __.InterfaceWork.Get().(*WorkOfInterfaceThenStruct)
}
func (__ *PoolOfInterfaceThenStructImpl) PutWorkOfInterfaceThenStruct(p *WorkOfInterfaceThenStruct) {
	__.InterfaceWork.Put(p)
}
func (__ *PoolOfInterfaceThenStructImpl) GetReturnOfStruct() *ReturnOfStruct {
	return __.StructReturn.Get().(*ReturnOfStruct)
}
func (__ *PoolOfInterfaceThenStructImpl) PutReturnOfStruct(p *ReturnOfStruct) {
	__.StructReturn.Put(p)
}

func (__ *PoolOfInterfaceThenStructImpl) GetChReturnOfStruct() chan *ReturnOfStruct {
	return __.ChReturnOfStruct.Get().(chan *ReturnOfStruct)
}
func (__ *PoolOfInterfaceThenStructImpl) PutChReturnOfStruct(p chan *ReturnOfStruct) {
	__.ChReturnOfStruct.Put(p)
}

func NewPoolOfInterfaceThenStructImpl() *PoolOfInterfaceThenStructImpl {
	return &PoolOfInterfaceThenStructImpl{
		InterfaceArg: sync.Pool{
			New: func() interface{} {
				return new(interface{})
			},
		},
		InterfaceWork: sync.Pool{
			New: func() interface{} {
				return new(WorkOfInterfaceThenStruct)
			},
		},
		StructRtn: sync.Pool{
			New: func() interface{} {
				return new(struct{})
			},
		},
		StructReturn: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfStruct)
			},
		},
		ChReturnOfStruct: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfStruct, 1)
			},
		},
	}
}

type ApiDecouplerOfInterfaceThenStruct struct {
	pool PoolOfInterfaceThenStruct
}

func NewApiDecouplerOfInterfaceThenStruct() *ApiDecouplerOfInterfaceThenStruct {
	return &ApiDecouplerOfInterfaceThenStruct{
		pool: NewPoolOfInterfaceThenStructImpl(),
	}
}

func (__ *ApiDecouplerOfInterfaceThenStruct) ReturnError(rtn_ch chan<- *ReturnOfStruct, err error) {
	rtn := __.pool.GetReturnOfStruct()
	var other struct{}
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfInterfaceThenStruct) HandleOfInterfaceThenStruct(ctx context.Context, req *WorkOfInterfaceThenStruct, h func(ctx context.Context, arg interface{}) (struct{}, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfStruct()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfInterfaceThenStruct) DoOfInterfaceThenStruct(ctx context.Context, worker WorkerOfPushInterfaceThenStruct, arg interface{}) (struct{}, error) {
	// ch := make(chan *ReturnOfStruct, 1)
	ch := __.pool.GetChReturnOfStruct()
	defer __.pool.PutChReturnOfStruct(ch)

	req := __.pool.GetWorkOfInterfaceThenStruct()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfInterfaceThenStruct(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfStruct(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfInterfaceThenStruct = func(ctx context.Context, arg interface{}) (struct{}, error)

type WorkerOfInterfaceThenStruct struct {
	api_syncer *ApiDecouplerOfInterfaceThenStruct
	handler    WorkHandlerOfInterfaceThenStruct

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfInterfaceThenStruct
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfInterfaceThenStruct(ctx context.Context, h WorkHandlerOfInterfaceThenStruct, n int) *WorkerOfInterfaceThenStruct {
	__ := &WorkerOfInterfaceThenStruct{
		api_syncer: NewApiDecouplerOfInterfaceThenStruct(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfInterfaceThenStruct, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfInterfaceThenStruct{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfInterfaceThenStruct(req.Context, req.WorkOfInterfaceThenStruct, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfInterfaceThenStruct) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfInterfaceThenStruct) Push(ctx context.Context, req *WorkOfInterfaceThenStruct) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfInterfaceThenStruct)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfInterfaceThenStruct = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfInterfaceThenStruct) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfInterfaceThenStruct) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfInterfaceThenStruct) Call(ctx context.Context, arg interface{}) (struct{}, error) {
	return __.api_syncer.DoOfInterfaceThenStruct(ctx, __, arg)
}

type PoolOfStructThenBool interface {
	GetStructArg() *struct{}
	PutStructArg(*struct{})
	GetBoolReturn() *bool
	PutBoolReturn(*bool)

	GetWorkOfStructThenBool() *WorkOfStructThenBool
	GetReturnOfBool() *ReturnOfBool
	PutWorkOfStructThenBool(*WorkOfStructThenBool)
	PutReturnOfBool(*ReturnOfBool)

	GetChReturnOfBool() chan *ReturnOfBool
	PutChReturnOfBool(chan *ReturnOfBool)
}

type PoolOfStructThenBoolImpl struct {
	StructArg      sync.Pool
	BoolRtn        sync.Pool
	StructWork     sync.Pool
	BoolReturn     sync.Pool
	ChReturnOfBool sync.Pool
}

func (__ *PoolOfStructThenBoolImpl) GetStructArg() *struct{} {
	return __.StructArg.Get().(*struct{})
}
func (__ *PoolOfStructThenBoolImpl) PutStructArg(p *struct{}) {
	__.StructArg.Put(p)
}
func (__ *PoolOfStructThenBoolImpl) GetBoolReturn() *bool {
	return __.BoolRtn.Get().(*bool)
}
func (__ *PoolOfStructThenBoolImpl) PutBoolReturn(p *bool) {
	__.BoolRtn.Put(p)
}

func (__ *PoolOfStructThenBoolImpl) GetWorkOfStructThenBool() *WorkOfStructThenBool {
	return __.StructWork.Get().(*WorkOfStructThenBool)
}
func (__ *PoolOfStructThenBoolImpl) PutWorkOfStructThenBool(p *WorkOfStructThenBool) {
	__.StructWork.Put(p)
}
func (__ *PoolOfStructThenBoolImpl) GetReturnOfBool() *ReturnOfBool {
	return __.BoolReturn.Get().(*ReturnOfBool)
}
func (__ *PoolOfStructThenBoolImpl) PutReturnOfBool(p *ReturnOfBool) {
	__.BoolReturn.Put(p)
}

func (__ *PoolOfStructThenBoolImpl) GetChReturnOfBool() chan *ReturnOfBool {
	return __.ChReturnOfBool.Get().(chan *ReturnOfBool)
}
func (__ *PoolOfStructThenBoolImpl) PutChReturnOfBool(p chan *ReturnOfBool) {
	__.ChReturnOfBool.Put(p)
}

func NewPoolOfStructThenBoolImpl() *PoolOfStructThenBoolImpl {
	return &PoolOfStructThenBoolImpl{
		StructArg: sync.Pool{
			New: func() interface{} {
				return new(struct{})
			},
		},
		StructWork: sync.Pool{
			New: func() interface{} {
				return new(WorkOfStructThenBool)
			},
		},
		BoolRtn: sync.Pool{
			New: func() interface{} {
				return new(bool)
			},
		},
		BoolReturn: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfBool)
			},
		},
		ChReturnOfBool: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfBool, 1)
			},
		},
	}
}

type ApiDecouplerOfStructThenBool struct {
	pool PoolOfStructThenBool
}

func NewApiDecouplerOfStructThenBool() *ApiDecouplerOfStructThenBool {
	return &ApiDecouplerOfStructThenBool{
		pool: NewPoolOfStructThenBoolImpl(),
	}
}

func (__ *ApiDecouplerOfStructThenBool) ReturnError(rtn_ch chan<- *ReturnOfBool, err error) {
	rtn := __.pool.GetReturnOfBool()
	var other bool
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfStructThenBool) HandleOfStructThenBool(ctx context.Context, req *WorkOfStructThenBool, h func(ctx context.Context, arg struct{}) (bool, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfBool()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfStructThenBool) DoOfStructThenBool(ctx context.Context, worker WorkerOfPushStructThenBool, arg struct{}) (bool, error) {
	// ch := make(chan *ReturnOfBool, 1)
	ch := __.pool.GetChReturnOfBool()
	defer __.pool.PutChReturnOfBool(ch)

	req := __.pool.GetWorkOfStructThenBool()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfStructThenBool(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfBool(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfStructThenBool = func(ctx context.Context, arg struct{}) (bool, error)

type WorkerOfStructThenBool struct {
	api_syncer *ApiDecouplerOfStructThenBool
	handler    WorkHandlerOfStructThenBool

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfStructThenBool
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfStructThenBool(ctx context.Context, h WorkHandlerOfStructThenBool, n int) *WorkerOfStructThenBool {
	__ := &WorkerOfStructThenBool{
		api_syncer: NewApiDecouplerOfStructThenBool(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfStructThenBool, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfStructThenBool{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfStructThenBool(req.Context, req.WorkOfStructThenBool, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfStructThenBool) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfStructThenBool) Push(ctx context.Context, req *WorkOfStructThenBool) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfStructThenBool)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfStructThenBool = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfStructThenBool) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfStructThenBool) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfStructThenBool) Call(ctx context.Context, arg struct{}) (bool, error) {
	return __.api_syncer.DoOfStructThenBool(ctx, __, arg)
}

type PoolOfStructThenByte interface {
	GetStructArg() *struct{}
	PutStructArg(*struct{})
	GetByteReturn() *byte
	PutByteReturn(*byte)

	GetWorkOfStructThenByte() *WorkOfStructThenByte
	GetReturnOfByte() *ReturnOfByte
	PutWorkOfStructThenByte(*WorkOfStructThenByte)
	PutReturnOfByte(*ReturnOfByte)

	GetChReturnOfByte() chan *ReturnOfByte
	PutChReturnOfByte(chan *ReturnOfByte)
}

type PoolOfStructThenByteImpl struct {
	StructArg      sync.Pool
	ByteRtn        sync.Pool
	StructWork     sync.Pool
	ByteReturn     sync.Pool
	ChReturnOfByte sync.Pool
}

func (__ *PoolOfStructThenByteImpl) GetStructArg() *struct{} {
	return __.StructArg.Get().(*struct{})
}
func (__ *PoolOfStructThenByteImpl) PutStructArg(p *struct{}) {
	__.StructArg.Put(p)
}
func (__ *PoolOfStructThenByteImpl) GetByteReturn() *byte {
	return __.ByteRtn.Get().(*byte)
}
func (__ *PoolOfStructThenByteImpl) PutByteReturn(p *byte) {
	__.ByteRtn.Put(p)
}

func (__ *PoolOfStructThenByteImpl) GetWorkOfStructThenByte() *WorkOfStructThenByte {
	return __.StructWork.Get().(*WorkOfStructThenByte)
}
func (__ *PoolOfStructThenByteImpl) PutWorkOfStructThenByte(p *WorkOfStructThenByte) {
	__.StructWork.Put(p)
}
func (__ *PoolOfStructThenByteImpl) GetReturnOfByte() *ReturnOfByte {
	return __.ByteReturn.Get().(*ReturnOfByte)
}
func (__ *PoolOfStructThenByteImpl) PutReturnOfByte(p *ReturnOfByte) {
	__.ByteReturn.Put(p)
}

func (__ *PoolOfStructThenByteImpl) GetChReturnOfByte() chan *ReturnOfByte {
	return __.ChReturnOfByte.Get().(chan *ReturnOfByte)
}
func (__ *PoolOfStructThenByteImpl) PutChReturnOfByte(p chan *ReturnOfByte) {
	__.ChReturnOfByte.Put(p)
}

func NewPoolOfStructThenByteImpl() *PoolOfStructThenByteImpl {
	return &PoolOfStructThenByteImpl{
		StructArg: sync.Pool{
			New: func() interface{} {
				return new(struct{})
			},
		},
		StructWork: sync.Pool{
			New: func() interface{} {
				return new(WorkOfStructThenByte)
			},
		},
		ByteRtn: sync.Pool{
			New: func() interface{} {
				return new(byte)
			},
		},
		ByteReturn: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfByte)
			},
		},
		ChReturnOfByte: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfByte, 1)
			},
		},
	}
}

type ApiDecouplerOfStructThenByte struct {
	pool PoolOfStructThenByte
}

func NewApiDecouplerOfStructThenByte() *ApiDecouplerOfStructThenByte {
	return &ApiDecouplerOfStructThenByte{
		pool: NewPoolOfStructThenByteImpl(),
	}
}

func (__ *ApiDecouplerOfStructThenByte) ReturnError(rtn_ch chan<- *ReturnOfByte, err error) {
	rtn := __.pool.GetReturnOfByte()
	var other byte
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfStructThenByte) HandleOfStructThenByte(ctx context.Context, req *WorkOfStructThenByte, h func(ctx context.Context, arg struct{}) (byte, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfByte()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfStructThenByte) DoOfStructThenByte(ctx context.Context, worker WorkerOfPushStructThenByte, arg struct{}) (byte, error) {
	// ch := make(chan *ReturnOfByte, 1)
	ch := __.pool.GetChReturnOfByte()
	defer __.pool.PutChReturnOfByte(ch)

	req := __.pool.GetWorkOfStructThenByte()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfStructThenByte(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfByte(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfStructThenByte = func(ctx context.Context, arg struct{}) (byte, error)

type WorkerOfStructThenByte struct {
	api_syncer *ApiDecouplerOfStructThenByte
	handler    WorkHandlerOfStructThenByte

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfStructThenByte
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfStructThenByte(ctx context.Context, h WorkHandlerOfStructThenByte, n int) *WorkerOfStructThenByte {
	__ := &WorkerOfStructThenByte{
		api_syncer: NewApiDecouplerOfStructThenByte(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfStructThenByte, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfStructThenByte{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfStructThenByte(req.Context, req.WorkOfStructThenByte, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfStructThenByte) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfStructThenByte) Push(ctx context.Context, req *WorkOfStructThenByte) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfStructThenByte)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfStructThenByte = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfStructThenByte) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfStructThenByte) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfStructThenByte) Call(ctx context.Context, arg struct{}) (byte, error) {
	return __.api_syncer.DoOfStructThenByte(ctx, __, arg)
}

type PoolOfStructThenComplex128 interface {
	GetStructArg() *struct{}
	PutStructArg(*struct{})
	GetComplex128Return() *complex128
	PutComplex128Return(*complex128)

	GetWorkOfStructThenComplex128() *WorkOfStructThenComplex128
	GetReturnOfComplex128() *ReturnOfComplex128
	PutWorkOfStructThenComplex128(*WorkOfStructThenComplex128)
	PutReturnOfComplex128(*ReturnOfComplex128)

	GetChReturnOfComplex128() chan *ReturnOfComplex128
	PutChReturnOfComplex128(chan *ReturnOfComplex128)
}

type PoolOfStructThenComplex128Impl struct {
	StructArg            sync.Pool
	Complex128Rtn        sync.Pool
	StructWork           sync.Pool
	Complex128Return     sync.Pool
	ChReturnOfComplex128 sync.Pool
}

func (__ *PoolOfStructThenComplex128Impl) GetStructArg() *struct{} {
	return __.StructArg.Get().(*struct{})
}
func (__ *PoolOfStructThenComplex128Impl) PutStructArg(p *struct{}) {
	__.StructArg.Put(p)
}
func (__ *PoolOfStructThenComplex128Impl) GetComplex128Return() *complex128 {
	return __.Complex128Rtn.Get().(*complex128)
}
func (__ *PoolOfStructThenComplex128Impl) PutComplex128Return(p *complex128) {
	__.Complex128Rtn.Put(p)
}

func (__ *PoolOfStructThenComplex128Impl) GetWorkOfStructThenComplex128() *WorkOfStructThenComplex128 {
	return __.StructWork.Get().(*WorkOfStructThenComplex128)
}
func (__ *PoolOfStructThenComplex128Impl) PutWorkOfStructThenComplex128(p *WorkOfStructThenComplex128) {
	__.StructWork.Put(p)
}
func (__ *PoolOfStructThenComplex128Impl) GetReturnOfComplex128() *ReturnOfComplex128 {
	return __.Complex128Return.Get().(*ReturnOfComplex128)
}
func (__ *PoolOfStructThenComplex128Impl) PutReturnOfComplex128(p *ReturnOfComplex128) {
	__.Complex128Return.Put(p)
}

func (__ *PoolOfStructThenComplex128Impl) GetChReturnOfComplex128() chan *ReturnOfComplex128 {
	return __.ChReturnOfComplex128.Get().(chan *ReturnOfComplex128)
}
func (__ *PoolOfStructThenComplex128Impl) PutChReturnOfComplex128(p chan *ReturnOfComplex128) {
	__.ChReturnOfComplex128.Put(p)
}

func NewPoolOfStructThenComplex128Impl() *PoolOfStructThenComplex128Impl {
	return &PoolOfStructThenComplex128Impl{
		StructArg: sync.Pool{
			New: func() interface{} {
				return new(struct{})
			},
		},
		StructWork: sync.Pool{
			New: func() interface{} {
				return new(WorkOfStructThenComplex128)
			},
		},
		Complex128Rtn: sync.Pool{
			New: func() interface{} {
				return new(complex128)
			},
		},
		Complex128Return: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfComplex128)
			},
		},
		ChReturnOfComplex128: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfComplex128, 1)
			},
		},
	}
}

type ApiDecouplerOfStructThenComplex128 struct {
	pool PoolOfStructThenComplex128
}

func NewApiDecouplerOfStructThenComplex128() *ApiDecouplerOfStructThenComplex128 {
	return &ApiDecouplerOfStructThenComplex128{
		pool: NewPoolOfStructThenComplex128Impl(),
	}
}

func (__ *ApiDecouplerOfStructThenComplex128) ReturnError(rtn_ch chan<- *ReturnOfComplex128, err error) {
	rtn := __.pool.GetReturnOfComplex128()
	var other complex128
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfStructThenComplex128) HandleOfStructThenComplex128(ctx context.Context, req *WorkOfStructThenComplex128, h func(ctx context.Context, arg struct{}) (complex128, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfComplex128()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfStructThenComplex128) DoOfStructThenComplex128(ctx context.Context, worker WorkerOfPushStructThenComplex128, arg struct{}) (complex128, error) {
	// ch := make(chan *ReturnOfComplex128, 1)
	ch := __.pool.GetChReturnOfComplex128()
	defer __.pool.PutChReturnOfComplex128(ch)

	req := __.pool.GetWorkOfStructThenComplex128()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfStructThenComplex128(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfComplex128(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfStructThenComplex128 = func(ctx context.Context, arg struct{}) (complex128, error)

type WorkerOfStructThenComplex128 struct {
	api_syncer *ApiDecouplerOfStructThenComplex128
	handler    WorkHandlerOfStructThenComplex128

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfStructThenComplex128
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfStructThenComplex128(ctx context.Context, h WorkHandlerOfStructThenComplex128, n int) *WorkerOfStructThenComplex128 {
	__ := &WorkerOfStructThenComplex128{
		api_syncer: NewApiDecouplerOfStructThenComplex128(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfStructThenComplex128, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfStructThenComplex128{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfStructThenComplex128(req.Context, req.WorkOfStructThenComplex128, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfStructThenComplex128) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfStructThenComplex128) Push(ctx context.Context, req *WorkOfStructThenComplex128) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfStructThenComplex128)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfStructThenComplex128 = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfStructThenComplex128) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfStructThenComplex128) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfStructThenComplex128) Call(ctx context.Context, arg struct{}) (complex128, error) {
	return __.api_syncer.DoOfStructThenComplex128(ctx, __, arg)
}

type PoolOfStructThenComplex64 interface {
	GetStructArg() *struct{}
	PutStructArg(*struct{})
	GetComplex64Return() *complex64
	PutComplex64Return(*complex64)

	GetWorkOfStructThenComplex64() *WorkOfStructThenComplex64
	GetReturnOfComplex64() *ReturnOfComplex64
	PutWorkOfStructThenComplex64(*WorkOfStructThenComplex64)
	PutReturnOfComplex64(*ReturnOfComplex64)

	GetChReturnOfComplex64() chan *ReturnOfComplex64
	PutChReturnOfComplex64(chan *ReturnOfComplex64)
}

type PoolOfStructThenComplex64Impl struct {
	StructArg           sync.Pool
	Complex64Rtn        sync.Pool
	StructWork          sync.Pool
	Complex64Return     sync.Pool
	ChReturnOfComplex64 sync.Pool
}

func (__ *PoolOfStructThenComplex64Impl) GetStructArg() *struct{} {
	return __.StructArg.Get().(*struct{})
}
func (__ *PoolOfStructThenComplex64Impl) PutStructArg(p *struct{}) {
	__.StructArg.Put(p)
}
func (__ *PoolOfStructThenComplex64Impl) GetComplex64Return() *complex64 {
	return __.Complex64Rtn.Get().(*complex64)
}
func (__ *PoolOfStructThenComplex64Impl) PutComplex64Return(p *complex64) {
	__.Complex64Rtn.Put(p)
}

func (__ *PoolOfStructThenComplex64Impl) GetWorkOfStructThenComplex64() *WorkOfStructThenComplex64 {
	return __.StructWork.Get().(*WorkOfStructThenComplex64)
}
func (__ *PoolOfStructThenComplex64Impl) PutWorkOfStructThenComplex64(p *WorkOfStructThenComplex64) {
	__.StructWork.Put(p)
}
func (__ *PoolOfStructThenComplex64Impl) GetReturnOfComplex64() *ReturnOfComplex64 {
	return __.Complex64Return.Get().(*ReturnOfComplex64)
}
func (__ *PoolOfStructThenComplex64Impl) PutReturnOfComplex64(p *ReturnOfComplex64) {
	__.Complex64Return.Put(p)
}

func (__ *PoolOfStructThenComplex64Impl) GetChReturnOfComplex64() chan *ReturnOfComplex64 {
	return __.ChReturnOfComplex64.Get().(chan *ReturnOfComplex64)
}
func (__ *PoolOfStructThenComplex64Impl) PutChReturnOfComplex64(p chan *ReturnOfComplex64) {
	__.ChReturnOfComplex64.Put(p)
}

func NewPoolOfStructThenComplex64Impl() *PoolOfStructThenComplex64Impl {
	return &PoolOfStructThenComplex64Impl{
		StructArg: sync.Pool{
			New: func() interface{} {
				return new(struct{})
			},
		},
		StructWork: sync.Pool{
			New: func() interface{} {
				return new(WorkOfStructThenComplex64)
			},
		},
		Complex64Rtn: sync.Pool{
			New: func() interface{} {
				return new(complex64)
			},
		},
		Complex64Return: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfComplex64)
			},
		},
		ChReturnOfComplex64: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfComplex64, 1)
			},
		},
	}
}

type ApiDecouplerOfStructThenComplex64 struct {
	pool PoolOfStructThenComplex64
}

func NewApiDecouplerOfStructThenComplex64() *ApiDecouplerOfStructThenComplex64 {
	return &ApiDecouplerOfStructThenComplex64{
		pool: NewPoolOfStructThenComplex64Impl(),
	}
}

func (__ *ApiDecouplerOfStructThenComplex64) ReturnError(rtn_ch chan<- *ReturnOfComplex64, err error) {
	rtn := __.pool.GetReturnOfComplex64()
	var other complex64
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfStructThenComplex64) HandleOfStructThenComplex64(ctx context.Context, req *WorkOfStructThenComplex64, h func(ctx context.Context, arg struct{}) (complex64, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfComplex64()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfStructThenComplex64) DoOfStructThenComplex64(ctx context.Context, worker WorkerOfPushStructThenComplex64, arg struct{}) (complex64, error) {
	// ch := make(chan *ReturnOfComplex64, 1)
	ch := __.pool.GetChReturnOfComplex64()
	defer __.pool.PutChReturnOfComplex64(ch)

	req := __.pool.GetWorkOfStructThenComplex64()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfStructThenComplex64(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfComplex64(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfStructThenComplex64 = func(ctx context.Context, arg struct{}) (complex64, error)

type WorkerOfStructThenComplex64 struct {
	api_syncer *ApiDecouplerOfStructThenComplex64
	handler    WorkHandlerOfStructThenComplex64

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfStructThenComplex64
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfStructThenComplex64(ctx context.Context, h WorkHandlerOfStructThenComplex64, n int) *WorkerOfStructThenComplex64 {
	__ := &WorkerOfStructThenComplex64{
		api_syncer: NewApiDecouplerOfStructThenComplex64(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfStructThenComplex64, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfStructThenComplex64{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfStructThenComplex64(req.Context, req.WorkOfStructThenComplex64, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfStructThenComplex64) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfStructThenComplex64) Push(ctx context.Context, req *WorkOfStructThenComplex64) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfStructThenComplex64)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfStructThenComplex64 = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfStructThenComplex64) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfStructThenComplex64) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfStructThenComplex64) Call(ctx context.Context, arg struct{}) (complex64, error) {
	return __.api_syncer.DoOfStructThenComplex64(ctx, __, arg)
}

type PoolOfStructThenError interface {
	GetStructArg() *struct{}
	PutStructArg(*struct{})
	GetErrorReturn() *error
	PutErrorReturn(*error)

	GetWorkOfStructThenError() *WorkOfStructThenError
	GetReturnOfError() *ReturnOfError
	PutWorkOfStructThenError(*WorkOfStructThenError)
	PutReturnOfError(*ReturnOfError)

	GetChReturnOfError() chan *ReturnOfError
	PutChReturnOfError(chan *ReturnOfError)
}

type PoolOfStructThenErrorImpl struct {
	StructArg       sync.Pool
	ErrorRtn        sync.Pool
	StructWork      sync.Pool
	ErrorReturn     sync.Pool
	ChReturnOfError sync.Pool
}

func (__ *PoolOfStructThenErrorImpl) GetStructArg() *struct{} {
	return __.StructArg.Get().(*struct{})
}
func (__ *PoolOfStructThenErrorImpl) PutStructArg(p *struct{}) {
	__.StructArg.Put(p)
}
func (__ *PoolOfStructThenErrorImpl) GetErrorReturn() *error {
	return __.ErrorRtn.Get().(*error)
}
func (__ *PoolOfStructThenErrorImpl) PutErrorReturn(p *error) {
	__.ErrorRtn.Put(p)
}

func (__ *PoolOfStructThenErrorImpl) GetWorkOfStructThenError() *WorkOfStructThenError {
	return __.StructWork.Get().(*WorkOfStructThenError)
}
func (__ *PoolOfStructThenErrorImpl) PutWorkOfStructThenError(p *WorkOfStructThenError) {
	__.StructWork.Put(p)
}
func (__ *PoolOfStructThenErrorImpl) GetReturnOfError() *ReturnOfError {
	return __.ErrorReturn.Get().(*ReturnOfError)
}
func (__ *PoolOfStructThenErrorImpl) PutReturnOfError(p *ReturnOfError) {
	__.ErrorReturn.Put(p)
}

func (__ *PoolOfStructThenErrorImpl) GetChReturnOfError() chan *ReturnOfError {
	return __.ChReturnOfError.Get().(chan *ReturnOfError)
}
func (__ *PoolOfStructThenErrorImpl) PutChReturnOfError(p chan *ReturnOfError) {
	__.ChReturnOfError.Put(p)
}

func NewPoolOfStructThenErrorImpl() *PoolOfStructThenErrorImpl {
	return &PoolOfStructThenErrorImpl{
		StructArg: sync.Pool{
			New: func() interface{} {
				return new(struct{})
			},
		},
		StructWork: sync.Pool{
			New: func() interface{} {
				return new(WorkOfStructThenError)
			},
		},
		ErrorRtn: sync.Pool{
			New: func() interface{} {
				return new(error)
			},
		},
		ErrorReturn: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfError)
			},
		},
		ChReturnOfError: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfError, 1)
			},
		},
	}
}

type ApiDecouplerOfStructThenError struct {
	pool PoolOfStructThenError
}

func NewApiDecouplerOfStructThenError() *ApiDecouplerOfStructThenError {
	return &ApiDecouplerOfStructThenError{
		pool: NewPoolOfStructThenErrorImpl(),
	}
}

func (__ *ApiDecouplerOfStructThenError) ReturnError(rtn_ch chan<- *ReturnOfError, err error) {
	rtn := __.pool.GetReturnOfError()
	var other error
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfStructThenError) HandleOfStructThenError(ctx context.Context, req *WorkOfStructThenError, h func(ctx context.Context, arg struct{}) (error, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfError()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfStructThenError) DoOfStructThenError(ctx context.Context, worker WorkerOfPushStructThenError, arg struct{}) (error, error) {
	// ch := make(chan *ReturnOfError, 1)
	ch := __.pool.GetChReturnOfError()
	defer __.pool.PutChReturnOfError(ch)

	req := __.pool.GetWorkOfStructThenError()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfStructThenError(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfError(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfStructThenError = func(ctx context.Context, arg struct{}) (error, error)

type WorkerOfStructThenError struct {
	api_syncer *ApiDecouplerOfStructThenError
	handler    WorkHandlerOfStructThenError

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfStructThenError
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfStructThenError(ctx context.Context, h WorkHandlerOfStructThenError, n int) *WorkerOfStructThenError {
	__ := &WorkerOfStructThenError{
		api_syncer: NewApiDecouplerOfStructThenError(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfStructThenError, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfStructThenError{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfStructThenError(req.Context, req.WorkOfStructThenError, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfStructThenError) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfStructThenError) Push(ctx context.Context, req *WorkOfStructThenError) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfStructThenError)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfStructThenError = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfStructThenError) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfStructThenError) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfStructThenError) Call(ctx context.Context, arg struct{}) (error, error) {
	return __.api_syncer.DoOfStructThenError(ctx, __, arg)
}

type PoolOfStructThenFloat32 interface {
	GetStructArg() *struct{}
	PutStructArg(*struct{})
	GetFloat32Return() *float32
	PutFloat32Return(*float32)

	GetWorkOfStructThenFloat32() *WorkOfStructThenFloat32
	GetReturnOfFloat32() *ReturnOfFloat32
	PutWorkOfStructThenFloat32(*WorkOfStructThenFloat32)
	PutReturnOfFloat32(*ReturnOfFloat32)

	GetChReturnOfFloat32() chan *ReturnOfFloat32
	PutChReturnOfFloat32(chan *ReturnOfFloat32)
}

type PoolOfStructThenFloat32Impl struct {
	StructArg         sync.Pool
	Float32Rtn        sync.Pool
	StructWork        sync.Pool
	Float32Return     sync.Pool
	ChReturnOfFloat32 sync.Pool
}

func (__ *PoolOfStructThenFloat32Impl) GetStructArg() *struct{} {
	return __.StructArg.Get().(*struct{})
}
func (__ *PoolOfStructThenFloat32Impl) PutStructArg(p *struct{}) {
	__.StructArg.Put(p)
}
func (__ *PoolOfStructThenFloat32Impl) GetFloat32Return() *float32 {
	return __.Float32Rtn.Get().(*float32)
}
func (__ *PoolOfStructThenFloat32Impl) PutFloat32Return(p *float32) {
	__.Float32Rtn.Put(p)
}

func (__ *PoolOfStructThenFloat32Impl) GetWorkOfStructThenFloat32() *WorkOfStructThenFloat32 {
	return __.StructWork.Get().(*WorkOfStructThenFloat32)
}
func (__ *PoolOfStructThenFloat32Impl) PutWorkOfStructThenFloat32(p *WorkOfStructThenFloat32) {
	__.StructWork.Put(p)
}
func (__ *PoolOfStructThenFloat32Impl) GetReturnOfFloat32() *ReturnOfFloat32 {
	return __.Float32Return.Get().(*ReturnOfFloat32)
}
func (__ *PoolOfStructThenFloat32Impl) PutReturnOfFloat32(p *ReturnOfFloat32) {
	__.Float32Return.Put(p)
}

func (__ *PoolOfStructThenFloat32Impl) GetChReturnOfFloat32() chan *ReturnOfFloat32 {
	return __.ChReturnOfFloat32.Get().(chan *ReturnOfFloat32)
}
func (__ *PoolOfStructThenFloat32Impl) PutChReturnOfFloat32(p chan *ReturnOfFloat32) {
	__.ChReturnOfFloat32.Put(p)
}

func NewPoolOfStructThenFloat32Impl() *PoolOfStructThenFloat32Impl {
	return &PoolOfStructThenFloat32Impl{
		StructArg: sync.Pool{
			New: func() interface{} {
				return new(struct{})
			},
		},
		StructWork: sync.Pool{
			New: func() interface{} {
				return new(WorkOfStructThenFloat32)
			},
		},
		Float32Rtn: sync.Pool{
			New: func() interface{} {
				return new(float32)
			},
		},
		Float32Return: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfFloat32)
			},
		},
		ChReturnOfFloat32: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfFloat32, 1)
			},
		},
	}
}

type ApiDecouplerOfStructThenFloat32 struct {
	pool PoolOfStructThenFloat32
}

func NewApiDecouplerOfStructThenFloat32() *ApiDecouplerOfStructThenFloat32 {
	return &ApiDecouplerOfStructThenFloat32{
		pool: NewPoolOfStructThenFloat32Impl(),
	}
}

func (__ *ApiDecouplerOfStructThenFloat32) ReturnError(rtn_ch chan<- *ReturnOfFloat32, err error) {
	rtn := __.pool.GetReturnOfFloat32()
	var other float32
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfStructThenFloat32) HandleOfStructThenFloat32(ctx context.Context, req *WorkOfStructThenFloat32, h func(ctx context.Context, arg struct{}) (float32, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfFloat32()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfStructThenFloat32) DoOfStructThenFloat32(ctx context.Context, worker WorkerOfPushStructThenFloat32, arg struct{}) (float32, error) {
	// ch := make(chan *ReturnOfFloat32, 1)
	ch := __.pool.GetChReturnOfFloat32()
	defer __.pool.PutChReturnOfFloat32(ch)

	req := __.pool.GetWorkOfStructThenFloat32()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfStructThenFloat32(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfFloat32(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfStructThenFloat32 = func(ctx context.Context, arg struct{}) (float32, error)

type WorkerOfStructThenFloat32 struct {
	api_syncer *ApiDecouplerOfStructThenFloat32
	handler    WorkHandlerOfStructThenFloat32

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfStructThenFloat32
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfStructThenFloat32(ctx context.Context, h WorkHandlerOfStructThenFloat32, n int) *WorkerOfStructThenFloat32 {
	__ := &WorkerOfStructThenFloat32{
		api_syncer: NewApiDecouplerOfStructThenFloat32(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfStructThenFloat32, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfStructThenFloat32{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfStructThenFloat32(req.Context, req.WorkOfStructThenFloat32, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfStructThenFloat32) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfStructThenFloat32) Push(ctx context.Context, req *WorkOfStructThenFloat32) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfStructThenFloat32)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfStructThenFloat32 = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfStructThenFloat32) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfStructThenFloat32) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfStructThenFloat32) Call(ctx context.Context, arg struct{}) (float32, error) {
	return __.api_syncer.DoOfStructThenFloat32(ctx, __, arg)
}

type PoolOfStructThenFloat64 interface {
	GetStructArg() *struct{}
	PutStructArg(*struct{})
	GetFloat64Return() *float64
	PutFloat64Return(*float64)

	GetWorkOfStructThenFloat64() *WorkOfStructThenFloat64
	GetReturnOfFloat64() *ReturnOfFloat64
	PutWorkOfStructThenFloat64(*WorkOfStructThenFloat64)
	PutReturnOfFloat64(*ReturnOfFloat64)

	GetChReturnOfFloat64() chan *ReturnOfFloat64
	PutChReturnOfFloat64(chan *ReturnOfFloat64)
}

type PoolOfStructThenFloat64Impl struct {
	StructArg         sync.Pool
	Float64Rtn        sync.Pool
	StructWork        sync.Pool
	Float64Return     sync.Pool
	ChReturnOfFloat64 sync.Pool
}

func (__ *PoolOfStructThenFloat64Impl) GetStructArg() *struct{} {
	return __.StructArg.Get().(*struct{})
}
func (__ *PoolOfStructThenFloat64Impl) PutStructArg(p *struct{}) {
	__.StructArg.Put(p)
}
func (__ *PoolOfStructThenFloat64Impl) GetFloat64Return() *float64 {
	return __.Float64Rtn.Get().(*float64)
}
func (__ *PoolOfStructThenFloat64Impl) PutFloat64Return(p *float64) {
	__.Float64Rtn.Put(p)
}

func (__ *PoolOfStructThenFloat64Impl) GetWorkOfStructThenFloat64() *WorkOfStructThenFloat64 {
	return __.StructWork.Get().(*WorkOfStructThenFloat64)
}
func (__ *PoolOfStructThenFloat64Impl) PutWorkOfStructThenFloat64(p *WorkOfStructThenFloat64) {
	__.StructWork.Put(p)
}
func (__ *PoolOfStructThenFloat64Impl) GetReturnOfFloat64() *ReturnOfFloat64 {
	return __.Float64Return.Get().(*ReturnOfFloat64)
}
func (__ *PoolOfStructThenFloat64Impl) PutReturnOfFloat64(p *ReturnOfFloat64) {
	__.Float64Return.Put(p)
}

func (__ *PoolOfStructThenFloat64Impl) GetChReturnOfFloat64() chan *ReturnOfFloat64 {
	return __.ChReturnOfFloat64.Get().(chan *ReturnOfFloat64)
}
func (__ *PoolOfStructThenFloat64Impl) PutChReturnOfFloat64(p chan *ReturnOfFloat64) {
	__.ChReturnOfFloat64.Put(p)
}

func NewPoolOfStructThenFloat64Impl() *PoolOfStructThenFloat64Impl {
	return &PoolOfStructThenFloat64Impl{
		StructArg: sync.Pool{
			New: func() interface{} {
				return new(struct{})
			},
		},
		StructWork: sync.Pool{
			New: func() interface{} {
				return new(WorkOfStructThenFloat64)
			},
		},
		Float64Rtn: sync.Pool{
			New: func() interface{} {
				return new(float64)
			},
		},
		Float64Return: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfFloat64)
			},
		},
		ChReturnOfFloat64: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfFloat64, 1)
			},
		},
	}
}

type ApiDecouplerOfStructThenFloat64 struct {
	pool PoolOfStructThenFloat64
}

func NewApiDecouplerOfStructThenFloat64() *ApiDecouplerOfStructThenFloat64 {
	return &ApiDecouplerOfStructThenFloat64{
		pool: NewPoolOfStructThenFloat64Impl(),
	}
}

func (__ *ApiDecouplerOfStructThenFloat64) ReturnError(rtn_ch chan<- *ReturnOfFloat64, err error) {
	rtn := __.pool.GetReturnOfFloat64()
	var other float64
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfStructThenFloat64) HandleOfStructThenFloat64(ctx context.Context, req *WorkOfStructThenFloat64, h func(ctx context.Context, arg struct{}) (float64, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfFloat64()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfStructThenFloat64) DoOfStructThenFloat64(ctx context.Context, worker WorkerOfPushStructThenFloat64, arg struct{}) (float64, error) {
	// ch := make(chan *ReturnOfFloat64, 1)
	ch := __.pool.GetChReturnOfFloat64()
	defer __.pool.PutChReturnOfFloat64(ch)

	req := __.pool.GetWorkOfStructThenFloat64()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfStructThenFloat64(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfFloat64(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfStructThenFloat64 = func(ctx context.Context, arg struct{}) (float64, error)

type WorkerOfStructThenFloat64 struct {
	api_syncer *ApiDecouplerOfStructThenFloat64
	handler    WorkHandlerOfStructThenFloat64

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfStructThenFloat64
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfStructThenFloat64(ctx context.Context, h WorkHandlerOfStructThenFloat64, n int) *WorkerOfStructThenFloat64 {
	__ := &WorkerOfStructThenFloat64{
		api_syncer: NewApiDecouplerOfStructThenFloat64(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfStructThenFloat64, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfStructThenFloat64{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfStructThenFloat64(req.Context, req.WorkOfStructThenFloat64, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfStructThenFloat64) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfStructThenFloat64) Push(ctx context.Context, req *WorkOfStructThenFloat64) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfStructThenFloat64)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfStructThenFloat64 = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfStructThenFloat64) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfStructThenFloat64) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfStructThenFloat64) Call(ctx context.Context, arg struct{}) (float64, error) {
	return __.api_syncer.DoOfStructThenFloat64(ctx, __, arg)
}

type PoolOfStructThenInt interface {
	GetStructArg() *struct{}
	PutStructArg(*struct{})
	GetIntReturn() *int
	PutIntReturn(*int)

	GetWorkOfStructThenInt() *WorkOfStructThenInt
	GetReturnOfInt() *ReturnOfInt
	PutWorkOfStructThenInt(*WorkOfStructThenInt)
	PutReturnOfInt(*ReturnOfInt)

	GetChReturnOfInt() chan *ReturnOfInt
	PutChReturnOfInt(chan *ReturnOfInt)
}

type PoolOfStructThenIntImpl struct {
	StructArg     sync.Pool
	IntRtn        sync.Pool
	StructWork    sync.Pool
	IntReturn     sync.Pool
	ChReturnOfInt sync.Pool
}

func (__ *PoolOfStructThenIntImpl) GetStructArg() *struct{} {
	return __.StructArg.Get().(*struct{})
}
func (__ *PoolOfStructThenIntImpl) PutStructArg(p *struct{}) {
	__.StructArg.Put(p)
}
func (__ *PoolOfStructThenIntImpl) GetIntReturn() *int {
	return __.IntRtn.Get().(*int)
}
func (__ *PoolOfStructThenIntImpl) PutIntReturn(p *int) {
	__.IntRtn.Put(p)
}

func (__ *PoolOfStructThenIntImpl) GetWorkOfStructThenInt() *WorkOfStructThenInt {
	return __.StructWork.Get().(*WorkOfStructThenInt)
}
func (__ *PoolOfStructThenIntImpl) PutWorkOfStructThenInt(p *WorkOfStructThenInt) {
	__.StructWork.Put(p)
}
func (__ *PoolOfStructThenIntImpl) GetReturnOfInt() *ReturnOfInt {
	return __.IntReturn.Get().(*ReturnOfInt)
}
func (__ *PoolOfStructThenIntImpl) PutReturnOfInt(p *ReturnOfInt) {
	__.IntReturn.Put(p)
}

func (__ *PoolOfStructThenIntImpl) GetChReturnOfInt() chan *ReturnOfInt {
	return __.ChReturnOfInt.Get().(chan *ReturnOfInt)
}
func (__ *PoolOfStructThenIntImpl) PutChReturnOfInt(p chan *ReturnOfInt) {
	__.ChReturnOfInt.Put(p)
}

func NewPoolOfStructThenIntImpl() *PoolOfStructThenIntImpl {
	return &PoolOfStructThenIntImpl{
		StructArg: sync.Pool{
			New: func() interface{} {
				return new(struct{})
			},
		},
		StructWork: sync.Pool{
			New: func() interface{} {
				return new(WorkOfStructThenInt)
			},
		},
		IntRtn: sync.Pool{
			New: func() interface{} {
				return new(int)
			},
		},
		IntReturn: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfInt)
			},
		},
		ChReturnOfInt: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfInt, 1)
			},
		},
	}
}

type ApiDecouplerOfStructThenInt struct {
	pool PoolOfStructThenInt
}

func NewApiDecouplerOfStructThenInt() *ApiDecouplerOfStructThenInt {
	return &ApiDecouplerOfStructThenInt{
		pool: NewPoolOfStructThenIntImpl(),
	}
}

func (__ *ApiDecouplerOfStructThenInt) ReturnError(rtn_ch chan<- *ReturnOfInt, err error) {
	rtn := __.pool.GetReturnOfInt()
	var other int
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfStructThenInt) HandleOfStructThenInt(ctx context.Context, req *WorkOfStructThenInt, h func(ctx context.Context, arg struct{}) (int, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfInt()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfStructThenInt) DoOfStructThenInt(ctx context.Context, worker WorkerOfPushStructThenInt, arg struct{}) (int, error) {
	// ch := make(chan *ReturnOfInt, 1)
	ch := __.pool.GetChReturnOfInt()
	defer __.pool.PutChReturnOfInt(ch)

	req := __.pool.GetWorkOfStructThenInt()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfStructThenInt(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfInt(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfStructThenInt = func(ctx context.Context, arg struct{}) (int, error)

type WorkerOfStructThenInt struct {
	api_syncer *ApiDecouplerOfStructThenInt
	handler    WorkHandlerOfStructThenInt

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfStructThenInt
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfStructThenInt(ctx context.Context, h WorkHandlerOfStructThenInt, n int) *WorkerOfStructThenInt {
	__ := &WorkerOfStructThenInt{
		api_syncer: NewApiDecouplerOfStructThenInt(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfStructThenInt, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfStructThenInt{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfStructThenInt(req.Context, req.WorkOfStructThenInt, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfStructThenInt) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfStructThenInt) Push(ctx context.Context, req *WorkOfStructThenInt) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfStructThenInt)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfStructThenInt = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfStructThenInt) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfStructThenInt) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfStructThenInt) Call(ctx context.Context, arg struct{}) (int, error) {
	return __.api_syncer.DoOfStructThenInt(ctx, __, arg)
}

type PoolOfStructThenInt16 interface {
	GetStructArg() *struct{}
	PutStructArg(*struct{})
	GetInt16Return() *int16
	PutInt16Return(*int16)

	GetWorkOfStructThenInt16() *WorkOfStructThenInt16
	GetReturnOfInt16() *ReturnOfInt16
	PutWorkOfStructThenInt16(*WorkOfStructThenInt16)
	PutReturnOfInt16(*ReturnOfInt16)

	GetChReturnOfInt16() chan *ReturnOfInt16
	PutChReturnOfInt16(chan *ReturnOfInt16)
}

type PoolOfStructThenInt16Impl struct {
	StructArg       sync.Pool
	Int16Rtn        sync.Pool
	StructWork      sync.Pool
	Int16Return     sync.Pool
	ChReturnOfInt16 sync.Pool
}

func (__ *PoolOfStructThenInt16Impl) GetStructArg() *struct{} {
	return __.StructArg.Get().(*struct{})
}
func (__ *PoolOfStructThenInt16Impl) PutStructArg(p *struct{}) {
	__.StructArg.Put(p)
}
func (__ *PoolOfStructThenInt16Impl) GetInt16Return() *int16 {
	return __.Int16Rtn.Get().(*int16)
}
func (__ *PoolOfStructThenInt16Impl) PutInt16Return(p *int16) {
	__.Int16Rtn.Put(p)
}

func (__ *PoolOfStructThenInt16Impl) GetWorkOfStructThenInt16() *WorkOfStructThenInt16 {
	return __.StructWork.Get().(*WorkOfStructThenInt16)
}
func (__ *PoolOfStructThenInt16Impl) PutWorkOfStructThenInt16(p *WorkOfStructThenInt16) {
	__.StructWork.Put(p)
}
func (__ *PoolOfStructThenInt16Impl) GetReturnOfInt16() *ReturnOfInt16 {
	return __.Int16Return.Get().(*ReturnOfInt16)
}
func (__ *PoolOfStructThenInt16Impl) PutReturnOfInt16(p *ReturnOfInt16) {
	__.Int16Return.Put(p)
}

func (__ *PoolOfStructThenInt16Impl) GetChReturnOfInt16() chan *ReturnOfInt16 {
	return __.ChReturnOfInt16.Get().(chan *ReturnOfInt16)
}
func (__ *PoolOfStructThenInt16Impl) PutChReturnOfInt16(p chan *ReturnOfInt16) {
	__.ChReturnOfInt16.Put(p)
}

func NewPoolOfStructThenInt16Impl() *PoolOfStructThenInt16Impl {
	return &PoolOfStructThenInt16Impl{
		StructArg: sync.Pool{
			New: func() interface{} {
				return new(struct{})
			},
		},
		StructWork: sync.Pool{
			New: func() interface{} {
				return new(WorkOfStructThenInt16)
			},
		},
		Int16Rtn: sync.Pool{
			New: func() interface{} {
				return new(int16)
			},
		},
		Int16Return: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfInt16)
			},
		},
		ChReturnOfInt16: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfInt16, 1)
			},
		},
	}
}

type ApiDecouplerOfStructThenInt16 struct {
	pool PoolOfStructThenInt16
}

func NewApiDecouplerOfStructThenInt16() *ApiDecouplerOfStructThenInt16 {
	return &ApiDecouplerOfStructThenInt16{
		pool: NewPoolOfStructThenInt16Impl(),
	}
}

func (__ *ApiDecouplerOfStructThenInt16) ReturnError(rtn_ch chan<- *ReturnOfInt16, err error) {
	rtn := __.pool.GetReturnOfInt16()
	var other int16
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfStructThenInt16) HandleOfStructThenInt16(ctx context.Context, req *WorkOfStructThenInt16, h func(ctx context.Context, arg struct{}) (int16, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfInt16()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfStructThenInt16) DoOfStructThenInt16(ctx context.Context, worker WorkerOfPushStructThenInt16, arg struct{}) (int16, error) {
	// ch := make(chan *ReturnOfInt16, 1)
	ch := __.pool.GetChReturnOfInt16()
	defer __.pool.PutChReturnOfInt16(ch)

	req := __.pool.GetWorkOfStructThenInt16()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfStructThenInt16(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfInt16(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfStructThenInt16 = func(ctx context.Context, arg struct{}) (int16, error)

type WorkerOfStructThenInt16 struct {
	api_syncer *ApiDecouplerOfStructThenInt16
	handler    WorkHandlerOfStructThenInt16

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfStructThenInt16
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfStructThenInt16(ctx context.Context, h WorkHandlerOfStructThenInt16, n int) *WorkerOfStructThenInt16 {
	__ := &WorkerOfStructThenInt16{
		api_syncer: NewApiDecouplerOfStructThenInt16(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfStructThenInt16, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfStructThenInt16{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfStructThenInt16(req.Context, req.WorkOfStructThenInt16, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfStructThenInt16) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfStructThenInt16) Push(ctx context.Context, req *WorkOfStructThenInt16) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfStructThenInt16)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfStructThenInt16 = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfStructThenInt16) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfStructThenInt16) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfStructThenInt16) Call(ctx context.Context, arg struct{}) (int16, error) {
	return __.api_syncer.DoOfStructThenInt16(ctx, __, arg)
}

type PoolOfStructThenInt32 interface {
	GetStructArg() *struct{}
	PutStructArg(*struct{})
	GetInt32Return() *int32
	PutInt32Return(*int32)

	GetWorkOfStructThenInt32() *WorkOfStructThenInt32
	GetReturnOfInt32() *ReturnOfInt32
	PutWorkOfStructThenInt32(*WorkOfStructThenInt32)
	PutReturnOfInt32(*ReturnOfInt32)

	GetChReturnOfInt32() chan *ReturnOfInt32
	PutChReturnOfInt32(chan *ReturnOfInt32)
}

type PoolOfStructThenInt32Impl struct {
	StructArg       sync.Pool
	Int32Rtn        sync.Pool
	StructWork      sync.Pool
	Int32Return     sync.Pool
	ChReturnOfInt32 sync.Pool
}

func (__ *PoolOfStructThenInt32Impl) GetStructArg() *struct{} {
	return __.StructArg.Get().(*struct{})
}
func (__ *PoolOfStructThenInt32Impl) PutStructArg(p *struct{}) {
	__.StructArg.Put(p)
}
func (__ *PoolOfStructThenInt32Impl) GetInt32Return() *int32 {
	return __.Int32Rtn.Get().(*int32)
}
func (__ *PoolOfStructThenInt32Impl) PutInt32Return(p *int32) {
	__.Int32Rtn.Put(p)
}

func (__ *PoolOfStructThenInt32Impl) GetWorkOfStructThenInt32() *WorkOfStructThenInt32 {
	return __.StructWork.Get().(*WorkOfStructThenInt32)
}
func (__ *PoolOfStructThenInt32Impl) PutWorkOfStructThenInt32(p *WorkOfStructThenInt32) {
	__.StructWork.Put(p)
}
func (__ *PoolOfStructThenInt32Impl) GetReturnOfInt32() *ReturnOfInt32 {
	return __.Int32Return.Get().(*ReturnOfInt32)
}
func (__ *PoolOfStructThenInt32Impl) PutReturnOfInt32(p *ReturnOfInt32) {
	__.Int32Return.Put(p)
}

func (__ *PoolOfStructThenInt32Impl) GetChReturnOfInt32() chan *ReturnOfInt32 {
	return __.ChReturnOfInt32.Get().(chan *ReturnOfInt32)
}
func (__ *PoolOfStructThenInt32Impl) PutChReturnOfInt32(p chan *ReturnOfInt32) {
	__.ChReturnOfInt32.Put(p)
}

func NewPoolOfStructThenInt32Impl() *PoolOfStructThenInt32Impl {
	return &PoolOfStructThenInt32Impl{
		StructArg: sync.Pool{
			New: func() interface{} {
				return new(struct{})
			},
		},
		StructWork: sync.Pool{
			New: func() interface{} {
				return new(WorkOfStructThenInt32)
			},
		},
		Int32Rtn: sync.Pool{
			New: func() interface{} {
				return new(int32)
			},
		},
		Int32Return: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfInt32)
			},
		},
		ChReturnOfInt32: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfInt32, 1)
			},
		},
	}
}

type ApiDecouplerOfStructThenInt32 struct {
	pool PoolOfStructThenInt32
}

func NewApiDecouplerOfStructThenInt32() *ApiDecouplerOfStructThenInt32 {
	return &ApiDecouplerOfStructThenInt32{
		pool: NewPoolOfStructThenInt32Impl(),
	}
}

func (__ *ApiDecouplerOfStructThenInt32) ReturnError(rtn_ch chan<- *ReturnOfInt32, err error) {
	rtn := __.pool.GetReturnOfInt32()
	var other int32
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfStructThenInt32) HandleOfStructThenInt32(ctx context.Context, req *WorkOfStructThenInt32, h func(ctx context.Context, arg struct{}) (int32, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfInt32()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfStructThenInt32) DoOfStructThenInt32(ctx context.Context, worker WorkerOfPushStructThenInt32, arg struct{}) (int32, error) {
	// ch := make(chan *ReturnOfInt32, 1)
	ch := __.pool.GetChReturnOfInt32()
	defer __.pool.PutChReturnOfInt32(ch)

	req := __.pool.GetWorkOfStructThenInt32()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfStructThenInt32(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfInt32(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfStructThenInt32 = func(ctx context.Context, arg struct{}) (int32, error)

type WorkerOfStructThenInt32 struct {
	api_syncer *ApiDecouplerOfStructThenInt32
	handler    WorkHandlerOfStructThenInt32

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfStructThenInt32
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfStructThenInt32(ctx context.Context, h WorkHandlerOfStructThenInt32, n int) *WorkerOfStructThenInt32 {
	__ := &WorkerOfStructThenInt32{
		api_syncer: NewApiDecouplerOfStructThenInt32(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfStructThenInt32, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfStructThenInt32{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfStructThenInt32(req.Context, req.WorkOfStructThenInt32, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfStructThenInt32) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfStructThenInt32) Push(ctx context.Context, req *WorkOfStructThenInt32) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfStructThenInt32)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfStructThenInt32 = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfStructThenInt32) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfStructThenInt32) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfStructThenInt32) Call(ctx context.Context, arg struct{}) (int32, error) {
	return __.api_syncer.DoOfStructThenInt32(ctx, __, arg)
}

type PoolOfStructThenInt64 interface {
	GetStructArg() *struct{}
	PutStructArg(*struct{})
	GetInt64Return() *int64
	PutInt64Return(*int64)

	GetWorkOfStructThenInt64() *WorkOfStructThenInt64
	GetReturnOfInt64() *ReturnOfInt64
	PutWorkOfStructThenInt64(*WorkOfStructThenInt64)
	PutReturnOfInt64(*ReturnOfInt64)

	GetChReturnOfInt64() chan *ReturnOfInt64
	PutChReturnOfInt64(chan *ReturnOfInt64)
}

type PoolOfStructThenInt64Impl struct {
	StructArg       sync.Pool
	Int64Rtn        sync.Pool
	StructWork      sync.Pool
	Int64Return     sync.Pool
	ChReturnOfInt64 sync.Pool
}

func (__ *PoolOfStructThenInt64Impl) GetStructArg() *struct{} {
	return __.StructArg.Get().(*struct{})
}
func (__ *PoolOfStructThenInt64Impl) PutStructArg(p *struct{}) {
	__.StructArg.Put(p)
}
func (__ *PoolOfStructThenInt64Impl) GetInt64Return() *int64 {
	return __.Int64Rtn.Get().(*int64)
}
func (__ *PoolOfStructThenInt64Impl) PutInt64Return(p *int64) {
	__.Int64Rtn.Put(p)
}

func (__ *PoolOfStructThenInt64Impl) GetWorkOfStructThenInt64() *WorkOfStructThenInt64 {
	return __.StructWork.Get().(*WorkOfStructThenInt64)
}
func (__ *PoolOfStructThenInt64Impl) PutWorkOfStructThenInt64(p *WorkOfStructThenInt64) {
	__.StructWork.Put(p)
}
func (__ *PoolOfStructThenInt64Impl) GetReturnOfInt64() *ReturnOfInt64 {
	return __.Int64Return.Get().(*ReturnOfInt64)
}
func (__ *PoolOfStructThenInt64Impl) PutReturnOfInt64(p *ReturnOfInt64) {
	__.Int64Return.Put(p)
}

func (__ *PoolOfStructThenInt64Impl) GetChReturnOfInt64() chan *ReturnOfInt64 {
	return __.ChReturnOfInt64.Get().(chan *ReturnOfInt64)
}
func (__ *PoolOfStructThenInt64Impl) PutChReturnOfInt64(p chan *ReturnOfInt64) {
	__.ChReturnOfInt64.Put(p)
}

func NewPoolOfStructThenInt64Impl() *PoolOfStructThenInt64Impl {
	return &PoolOfStructThenInt64Impl{
		StructArg: sync.Pool{
			New: func() interface{} {
				return new(struct{})
			},
		},
		StructWork: sync.Pool{
			New: func() interface{} {
				return new(WorkOfStructThenInt64)
			},
		},
		Int64Rtn: sync.Pool{
			New: func() interface{} {
				return new(int64)
			},
		},
		Int64Return: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfInt64)
			},
		},
		ChReturnOfInt64: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfInt64, 1)
			},
		},
	}
}

type ApiDecouplerOfStructThenInt64 struct {
	pool PoolOfStructThenInt64
}

func NewApiDecouplerOfStructThenInt64() *ApiDecouplerOfStructThenInt64 {
	return &ApiDecouplerOfStructThenInt64{
		pool: NewPoolOfStructThenInt64Impl(),
	}
}

func (__ *ApiDecouplerOfStructThenInt64) ReturnError(rtn_ch chan<- *ReturnOfInt64, err error) {
	rtn := __.pool.GetReturnOfInt64()
	var other int64
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfStructThenInt64) HandleOfStructThenInt64(ctx context.Context, req *WorkOfStructThenInt64, h func(ctx context.Context, arg struct{}) (int64, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfInt64()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfStructThenInt64) DoOfStructThenInt64(ctx context.Context, worker WorkerOfPushStructThenInt64, arg struct{}) (int64, error) {
	// ch := make(chan *ReturnOfInt64, 1)
	ch := __.pool.GetChReturnOfInt64()
	defer __.pool.PutChReturnOfInt64(ch)

	req := __.pool.GetWorkOfStructThenInt64()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfStructThenInt64(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfInt64(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfStructThenInt64 = func(ctx context.Context, arg struct{}) (int64, error)

type WorkerOfStructThenInt64 struct {
	api_syncer *ApiDecouplerOfStructThenInt64
	handler    WorkHandlerOfStructThenInt64

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfStructThenInt64
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfStructThenInt64(ctx context.Context, h WorkHandlerOfStructThenInt64, n int) *WorkerOfStructThenInt64 {
	__ := &WorkerOfStructThenInt64{
		api_syncer: NewApiDecouplerOfStructThenInt64(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfStructThenInt64, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfStructThenInt64{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfStructThenInt64(req.Context, req.WorkOfStructThenInt64, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfStructThenInt64) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfStructThenInt64) Push(ctx context.Context, req *WorkOfStructThenInt64) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfStructThenInt64)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfStructThenInt64 = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfStructThenInt64) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfStructThenInt64) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfStructThenInt64) Call(ctx context.Context, arg struct{}) (int64, error) {
	return __.api_syncer.DoOfStructThenInt64(ctx, __, arg)
}

type PoolOfStructThenInt8 interface {
	GetStructArg() *struct{}
	PutStructArg(*struct{})
	GetInt8Return() *int8
	PutInt8Return(*int8)

	GetWorkOfStructThenInt8() *WorkOfStructThenInt8
	GetReturnOfInt8() *ReturnOfInt8
	PutWorkOfStructThenInt8(*WorkOfStructThenInt8)
	PutReturnOfInt8(*ReturnOfInt8)

	GetChReturnOfInt8() chan *ReturnOfInt8
	PutChReturnOfInt8(chan *ReturnOfInt8)
}

type PoolOfStructThenInt8Impl struct {
	StructArg      sync.Pool
	Int8Rtn        sync.Pool
	StructWork     sync.Pool
	Int8Return     sync.Pool
	ChReturnOfInt8 sync.Pool
}

func (__ *PoolOfStructThenInt8Impl) GetStructArg() *struct{} {
	return __.StructArg.Get().(*struct{})
}
func (__ *PoolOfStructThenInt8Impl) PutStructArg(p *struct{}) {
	__.StructArg.Put(p)
}
func (__ *PoolOfStructThenInt8Impl) GetInt8Return() *int8 {
	return __.Int8Rtn.Get().(*int8)
}
func (__ *PoolOfStructThenInt8Impl) PutInt8Return(p *int8) {
	__.Int8Rtn.Put(p)
}

func (__ *PoolOfStructThenInt8Impl) GetWorkOfStructThenInt8() *WorkOfStructThenInt8 {
	return __.StructWork.Get().(*WorkOfStructThenInt8)
}
func (__ *PoolOfStructThenInt8Impl) PutWorkOfStructThenInt8(p *WorkOfStructThenInt8) {
	__.StructWork.Put(p)
}
func (__ *PoolOfStructThenInt8Impl) GetReturnOfInt8() *ReturnOfInt8 {
	return __.Int8Return.Get().(*ReturnOfInt8)
}
func (__ *PoolOfStructThenInt8Impl) PutReturnOfInt8(p *ReturnOfInt8) {
	__.Int8Return.Put(p)
}

func (__ *PoolOfStructThenInt8Impl) GetChReturnOfInt8() chan *ReturnOfInt8 {
	return __.ChReturnOfInt8.Get().(chan *ReturnOfInt8)
}
func (__ *PoolOfStructThenInt8Impl) PutChReturnOfInt8(p chan *ReturnOfInt8) {
	__.ChReturnOfInt8.Put(p)
}

func NewPoolOfStructThenInt8Impl() *PoolOfStructThenInt8Impl {
	return &PoolOfStructThenInt8Impl{
		StructArg: sync.Pool{
			New: func() interface{} {
				return new(struct{})
			},
		},
		StructWork: sync.Pool{
			New: func() interface{} {
				return new(WorkOfStructThenInt8)
			},
		},
		Int8Rtn: sync.Pool{
			New: func() interface{} {
				return new(int8)
			},
		},
		Int8Return: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfInt8)
			},
		},
		ChReturnOfInt8: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfInt8, 1)
			},
		},
	}
}

type ApiDecouplerOfStructThenInt8 struct {
	pool PoolOfStructThenInt8
}

func NewApiDecouplerOfStructThenInt8() *ApiDecouplerOfStructThenInt8 {
	return &ApiDecouplerOfStructThenInt8{
		pool: NewPoolOfStructThenInt8Impl(),
	}
}

func (__ *ApiDecouplerOfStructThenInt8) ReturnError(rtn_ch chan<- *ReturnOfInt8, err error) {
	rtn := __.pool.GetReturnOfInt8()
	var other int8
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfStructThenInt8) HandleOfStructThenInt8(ctx context.Context, req *WorkOfStructThenInt8, h func(ctx context.Context, arg struct{}) (int8, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfInt8()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfStructThenInt8) DoOfStructThenInt8(ctx context.Context, worker WorkerOfPushStructThenInt8, arg struct{}) (int8, error) {
	// ch := make(chan *ReturnOfInt8, 1)
	ch := __.pool.GetChReturnOfInt8()
	defer __.pool.PutChReturnOfInt8(ch)

	req := __.pool.GetWorkOfStructThenInt8()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfStructThenInt8(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfInt8(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfStructThenInt8 = func(ctx context.Context, arg struct{}) (int8, error)

type WorkerOfStructThenInt8 struct {
	api_syncer *ApiDecouplerOfStructThenInt8
	handler    WorkHandlerOfStructThenInt8

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfStructThenInt8
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfStructThenInt8(ctx context.Context, h WorkHandlerOfStructThenInt8, n int) *WorkerOfStructThenInt8 {
	__ := &WorkerOfStructThenInt8{
		api_syncer: NewApiDecouplerOfStructThenInt8(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfStructThenInt8, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfStructThenInt8{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfStructThenInt8(req.Context, req.WorkOfStructThenInt8, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfStructThenInt8) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfStructThenInt8) Push(ctx context.Context, req *WorkOfStructThenInt8) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfStructThenInt8)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfStructThenInt8 = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfStructThenInt8) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfStructThenInt8) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfStructThenInt8) Call(ctx context.Context, arg struct{}) (int8, error) {
	return __.api_syncer.DoOfStructThenInt8(ctx, __, arg)
}

type PoolOfStructThenRune interface {
	GetStructArg() *struct{}
	PutStructArg(*struct{})
	GetRuneReturn() *rune
	PutRuneReturn(*rune)

	GetWorkOfStructThenRune() *WorkOfStructThenRune
	GetReturnOfRune() *ReturnOfRune
	PutWorkOfStructThenRune(*WorkOfStructThenRune)
	PutReturnOfRune(*ReturnOfRune)

	GetChReturnOfRune() chan *ReturnOfRune
	PutChReturnOfRune(chan *ReturnOfRune)
}

type PoolOfStructThenRuneImpl struct {
	StructArg      sync.Pool
	RuneRtn        sync.Pool
	StructWork     sync.Pool
	RuneReturn     sync.Pool
	ChReturnOfRune sync.Pool
}

func (__ *PoolOfStructThenRuneImpl) GetStructArg() *struct{} {
	return __.StructArg.Get().(*struct{})
}
func (__ *PoolOfStructThenRuneImpl) PutStructArg(p *struct{}) {
	__.StructArg.Put(p)
}
func (__ *PoolOfStructThenRuneImpl) GetRuneReturn() *rune {
	return __.RuneRtn.Get().(*rune)
}
func (__ *PoolOfStructThenRuneImpl) PutRuneReturn(p *rune) {
	__.RuneRtn.Put(p)
}

func (__ *PoolOfStructThenRuneImpl) GetWorkOfStructThenRune() *WorkOfStructThenRune {
	return __.StructWork.Get().(*WorkOfStructThenRune)
}
func (__ *PoolOfStructThenRuneImpl) PutWorkOfStructThenRune(p *WorkOfStructThenRune) {
	__.StructWork.Put(p)
}
func (__ *PoolOfStructThenRuneImpl) GetReturnOfRune() *ReturnOfRune {
	return __.RuneReturn.Get().(*ReturnOfRune)
}
func (__ *PoolOfStructThenRuneImpl) PutReturnOfRune(p *ReturnOfRune) {
	__.RuneReturn.Put(p)
}

func (__ *PoolOfStructThenRuneImpl) GetChReturnOfRune() chan *ReturnOfRune {
	return __.ChReturnOfRune.Get().(chan *ReturnOfRune)
}
func (__ *PoolOfStructThenRuneImpl) PutChReturnOfRune(p chan *ReturnOfRune) {
	__.ChReturnOfRune.Put(p)
}

func NewPoolOfStructThenRuneImpl() *PoolOfStructThenRuneImpl {
	return &PoolOfStructThenRuneImpl{
		StructArg: sync.Pool{
			New: func() interface{} {
				return new(struct{})
			},
		},
		StructWork: sync.Pool{
			New: func() interface{} {
				return new(WorkOfStructThenRune)
			},
		},
		RuneRtn: sync.Pool{
			New: func() interface{} {
				return new(rune)
			},
		},
		RuneReturn: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfRune)
			},
		},
		ChReturnOfRune: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfRune, 1)
			},
		},
	}
}

type ApiDecouplerOfStructThenRune struct {
	pool PoolOfStructThenRune
}

func NewApiDecouplerOfStructThenRune() *ApiDecouplerOfStructThenRune {
	return &ApiDecouplerOfStructThenRune{
		pool: NewPoolOfStructThenRuneImpl(),
	}
}

func (__ *ApiDecouplerOfStructThenRune) ReturnError(rtn_ch chan<- *ReturnOfRune, err error) {
	rtn := __.pool.GetReturnOfRune()
	var other rune
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfStructThenRune) HandleOfStructThenRune(ctx context.Context, req *WorkOfStructThenRune, h func(ctx context.Context, arg struct{}) (rune, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfRune()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfStructThenRune) DoOfStructThenRune(ctx context.Context, worker WorkerOfPushStructThenRune, arg struct{}) (rune, error) {
	// ch := make(chan *ReturnOfRune, 1)
	ch := __.pool.GetChReturnOfRune()
	defer __.pool.PutChReturnOfRune(ch)

	req := __.pool.GetWorkOfStructThenRune()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfStructThenRune(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfRune(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfStructThenRune = func(ctx context.Context, arg struct{}) (rune, error)

type WorkerOfStructThenRune struct {
	api_syncer *ApiDecouplerOfStructThenRune
	handler    WorkHandlerOfStructThenRune

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfStructThenRune
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfStructThenRune(ctx context.Context, h WorkHandlerOfStructThenRune, n int) *WorkerOfStructThenRune {
	__ := &WorkerOfStructThenRune{
		api_syncer: NewApiDecouplerOfStructThenRune(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfStructThenRune, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfStructThenRune{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfStructThenRune(req.Context, req.WorkOfStructThenRune, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfStructThenRune) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfStructThenRune) Push(ctx context.Context, req *WorkOfStructThenRune) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfStructThenRune)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfStructThenRune = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfStructThenRune) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfStructThenRune) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfStructThenRune) Call(ctx context.Context, arg struct{}) (rune, error) {
	return __.api_syncer.DoOfStructThenRune(ctx, __, arg)
}

type PoolOfStructThenString interface {
	GetStructArg() *struct{}
	PutStructArg(*struct{})
	GetStringReturn() *string
	PutStringReturn(*string)

	GetWorkOfStructThenString() *WorkOfStructThenString
	GetReturnOfString() *ReturnOfString
	PutWorkOfStructThenString(*WorkOfStructThenString)
	PutReturnOfString(*ReturnOfString)

	GetChReturnOfString() chan *ReturnOfString
	PutChReturnOfString(chan *ReturnOfString)
}

type PoolOfStructThenStringImpl struct {
	StructArg        sync.Pool
	StringRtn        sync.Pool
	StructWork       sync.Pool
	StringReturn     sync.Pool
	ChReturnOfString sync.Pool
}

func (__ *PoolOfStructThenStringImpl) GetStructArg() *struct{} {
	return __.StructArg.Get().(*struct{})
}
func (__ *PoolOfStructThenStringImpl) PutStructArg(p *struct{}) {
	__.StructArg.Put(p)
}
func (__ *PoolOfStructThenStringImpl) GetStringReturn() *string {
	return __.StringRtn.Get().(*string)
}
func (__ *PoolOfStructThenStringImpl) PutStringReturn(p *string) {
	__.StringRtn.Put(p)
}

func (__ *PoolOfStructThenStringImpl) GetWorkOfStructThenString() *WorkOfStructThenString {
	return __.StructWork.Get().(*WorkOfStructThenString)
}
func (__ *PoolOfStructThenStringImpl) PutWorkOfStructThenString(p *WorkOfStructThenString) {
	__.StructWork.Put(p)
}
func (__ *PoolOfStructThenStringImpl) GetReturnOfString() *ReturnOfString {
	return __.StringReturn.Get().(*ReturnOfString)
}
func (__ *PoolOfStructThenStringImpl) PutReturnOfString(p *ReturnOfString) {
	__.StringReturn.Put(p)
}

func (__ *PoolOfStructThenStringImpl) GetChReturnOfString() chan *ReturnOfString {
	return __.ChReturnOfString.Get().(chan *ReturnOfString)
}
func (__ *PoolOfStructThenStringImpl) PutChReturnOfString(p chan *ReturnOfString) {
	__.ChReturnOfString.Put(p)
}

func NewPoolOfStructThenStringImpl() *PoolOfStructThenStringImpl {
	return &PoolOfStructThenStringImpl{
		StructArg: sync.Pool{
			New: func() interface{} {
				return new(struct{})
			},
		},
		StructWork: sync.Pool{
			New: func() interface{} {
				return new(WorkOfStructThenString)
			},
		},
		StringRtn: sync.Pool{
			New: func() interface{} {
				return new(string)
			},
		},
		StringReturn: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfString)
			},
		},
		ChReturnOfString: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfString, 1)
			},
		},
	}
}

type ApiDecouplerOfStructThenString struct {
	pool PoolOfStructThenString
}

func NewApiDecouplerOfStructThenString() *ApiDecouplerOfStructThenString {
	return &ApiDecouplerOfStructThenString{
		pool: NewPoolOfStructThenStringImpl(),
	}
}

func (__ *ApiDecouplerOfStructThenString) ReturnError(rtn_ch chan<- *ReturnOfString, err error) {
	rtn := __.pool.GetReturnOfString()
	var other string
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfStructThenString) HandleOfStructThenString(ctx context.Context, req *WorkOfStructThenString, h func(ctx context.Context, arg struct{}) (string, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfString()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfStructThenString) DoOfStructThenString(ctx context.Context, worker WorkerOfPushStructThenString, arg struct{}) (string, error) {
	// ch := make(chan *ReturnOfString, 1)
	ch := __.pool.GetChReturnOfString()
	defer __.pool.PutChReturnOfString(ch)

	req := __.pool.GetWorkOfStructThenString()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfStructThenString(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfString(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfStructThenString = func(ctx context.Context, arg struct{}) (string, error)

type WorkerOfStructThenString struct {
	api_syncer *ApiDecouplerOfStructThenString
	handler    WorkHandlerOfStructThenString

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfStructThenString
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfStructThenString(ctx context.Context, h WorkHandlerOfStructThenString, n int) *WorkerOfStructThenString {
	__ := &WorkerOfStructThenString{
		api_syncer: NewApiDecouplerOfStructThenString(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfStructThenString, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfStructThenString{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfStructThenString(req.Context, req.WorkOfStructThenString, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfStructThenString) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfStructThenString) Push(ctx context.Context, req *WorkOfStructThenString) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfStructThenString)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfStructThenString = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfStructThenString) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfStructThenString) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfStructThenString) Call(ctx context.Context, arg struct{}) (string, error) {
	return __.api_syncer.DoOfStructThenString(ctx, __, arg)
}

type PoolOfStructThenUint interface {
	GetStructArg() *struct{}
	PutStructArg(*struct{})
	GetUintReturn() *uint
	PutUintReturn(*uint)

	GetWorkOfStructThenUint() *WorkOfStructThenUint
	GetReturnOfUint() *ReturnOfUint
	PutWorkOfStructThenUint(*WorkOfStructThenUint)
	PutReturnOfUint(*ReturnOfUint)

	GetChReturnOfUint() chan *ReturnOfUint
	PutChReturnOfUint(chan *ReturnOfUint)
}

type PoolOfStructThenUintImpl struct {
	StructArg      sync.Pool
	UintRtn        sync.Pool
	StructWork     sync.Pool
	UintReturn     sync.Pool
	ChReturnOfUint sync.Pool
}

func (__ *PoolOfStructThenUintImpl) GetStructArg() *struct{} {
	return __.StructArg.Get().(*struct{})
}
func (__ *PoolOfStructThenUintImpl) PutStructArg(p *struct{}) {
	__.StructArg.Put(p)
}
func (__ *PoolOfStructThenUintImpl) GetUintReturn() *uint {
	return __.UintRtn.Get().(*uint)
}
func (__ *PoolOfStructThenUintImpl) PutUintReturn(p *uint) {
	__.UintRtn.Put(p)
}

func (__ *PoolOfStructThenUintImpl) GetWorkOfStructThenUint() *WorkOfStructThenUint {
	return __.StructWork.Get().(*WorkOfStructThenUint)
}
func (__ *PoolOfStructThenUintImpl) PutWorkOfStructThenUint(p *WorkOfStructThenUint) {
	__.StructWork.Put(p)
}
func (__ *PoolOfStructThenUintImpl) GetReturnOfUint() *ReturnOfUint {
	return __.UintReturn.Get().(*ReturnOfUint)
}
func (__ *PoolOfStructThenUintImpl) PutReturnOfUint(p *ReturnOfUint) {
	__.UintReturn.Put(p)
}

func (__ *PoolOfStructThenUintImpl) GetChReturnOfUint() chan *ReturnOfUint {
	return __.ChReturnOfUint.Get().(chan *ReturnOfUint)
}
func (__ *PoolOfStructThenUintImpl) PutChReturnOfUint(p chan *ReturnOfUint) {
	__.ChReturnOfUint.Put(p)
}

func NewPoolOfStructThenUintImpl() *PoolOfStructThenUintImpl {
	return &PoolOfStructThenUintImpl{
		StructArg: sync.Pool{
			New: func() interface{} {
				return new(struct{})
			},
		},
		StructWork: sync.Pool{
			New: func() interface{} {
				return new(WorkOfStructThenUint)
			},
		},
		UintRtn: sync.Pool{
			New: func() interface{} {
				return new(uint)
			},
		},
		UintReturn: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfUint)
			},
		},
		ChReturnOfUint: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfUint, 1)
			},
		},
	}
}

type ApiDecouplerOfStructThenUint struct {
	pool PoolOfStructThenUint
}

func NewApiDecouplerOfStructThenUint() *ApiDecouplerOfStructThenUint {
	return &ApiDecouplerOfStructThenUint{
		pool: NewPoolOfStructThenUintImpl(),
	}
}

func (__ *ApiDecouplerOfStructThenUint) ReturnError(rtn_ch chan<- *ReturnOfUint, err error) {
	rtn := __.pool.GetReturnOfUint()
	var other uint
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfStructThenUint) HandleOfStructThenUint(ctx context.Context, req *WorkOfStructThenUint, h func(ctx context.Context, arg struct{}) (uint, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfUint()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfStructThenUint) DoOfStructThenUint(ctx context.Context, worker WorkerOfPushStructThenUint, arg struct{}) (uint, error) {
	// ch := make(chan *ReturnOfUint, 1)
	ch := __.pool.GetChReturnOfUint()
	defer __.pool.PutChReturnOfUint(ch)

	req := __.pool.GetWorkOfStructThenUint()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfStructThenUint(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfUint(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfStructThenUint = func(ctx context.Context, arg struct{}) (uint, error)

type WorkerOfStructThenUint struct {
	api_syncer *ApiDecouplerOfStructThenUint
	handler    WorkHandlerOfStructThenUint

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfStructThenUint
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfStructThenUint(ctx context.Context, h WorkHandlerOfStructThenUint, n int) *WorkerOfStructThenUint {
	__ := &WorkerOfStructThenUint{
		api_syncer: NewApiDecouplerOfStructThenUint(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfStructThenUint, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfStructThenUint{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfStructThenUint(req.Context, req.WorkOfStructThenUint, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfStructThenUint) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfStructThenUint) Push(ctx context.Context, req *WorkOfStructThenUint) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfStructThenUint)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfStructThenUint = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfStructThenUint) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfStructThenUint) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfStructThenUint) Call(ctx context.Context, arg struct{}) (uint, error) {
	return __.api_syncer.DoOfStructThenUint(ctx, __, arg)
}

type PoolOfStructThenUint16 interface {
	GetStructArg() *struct{}
	PutStructArg(*struct{})
	GetUint16Return() *uint16
	PutUint16Return(*uint16)

	GetWorkOfStructThenUint16() *WorkOfStructThenUint16
	GetReturnOfUint16() *ReturnOfUint16
	PutWorkOfStructThenUint16(*WorkOfStructThenUint16)
	PutReturnOfUint16(*ReturnOfUint16)

	GetChReturnOfUint16() chan *ReturnOfUint16
	PutChReturnOfUint16(chan *ReturnOfUint16)
}

type PoolOfStructThenUint16Impl struct {
	StructArg        sync.Pool
	Uint16Rtn        sync.Pool
	StructWork       sync.Pool
	Uint16Return     sync.Pool
	ChReturnOfUint16 sync.Pool
}

func (__ *PoolOfStructThenUint16Impl) GetStructArg() *struct{} {
	return __.StructArg.Get().(*struct{})
}
func (__ *PoolOfStructThenUint16Impl) PutStructArg(p *struct{}) {
	__.StructArg.Put(p)
}
func (__ *PoolOfStructThenUint16Impl) GetUint16Return() *uint16 {
	return __.Uint16Rtn.Get().(*uint16)
}
func (__ *PoolOfStructThenUint16Impl) PutUint16Return(p *uint16) {
	__.Uint16Rtn.Put(p)
}

func (__ *PoolOfStructThenUint16Impl) GetWorkOfStructThenUint16() *WorkOfStructThenUint16 {
	return __.StructWork.Get().(*WorkOfStructThenUint16)
}
func (__ *PoolOfStructThenUint16Impl) PutWorkOfStructThenUint16(p *WorkOfStructThenUint16) {
	__.StructWork.Put(p)
}
func (__ *PoolOfStructThenUint16Impl) GetReturnOfUint16() *ReturnOfUint16 {
	return __.Uint16Return.Get().(*ReturnOfUint16)
}
func (__ *PoolOfStructThenUint16Impl) PutReturnOfUint16(p *ReturnOfUint16) {
	__.Uint16Return.Put(p)
}

func (__ *PoolOfStructThenUint16Impl) GetChReturnOfUint16() chan *ReturnOfUint16 {
	return __.ChReturnOfUint16.Get().(chan *ReturnOfUint16)
}
func (__ *PoolOfStructThenUint16Impl) PutChReturnOfUint16(p chan *ReturnOfUint16) {
	__.ChReturnOfUint16.Put(p)
}

func NewPoolOfStructThenUint16Impl() *PoolOfStructThenUint16Impl {
	return &PoolOfStructThenUint16Impl{
		StructArg: sync.Pool{
			New: func() interface{} {
				return new(struct{})
			},
		},
		StructWork: sync.Pool{
			New: func() interface{} {
				return new(WorkOfStructThenUint16)
			},
		},
		Uint16Rtn: sync.Pool{
			New: func() interface{} {
				return new(uint16)
			},
		},
		Uint16Return: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfUint16)
			},
		},
		ChReturnOfUint16: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfUint16, 1)
			},
		},
	}
}

type ApiDecouplerOfStructThenUint16 struct {
	pool PoolOfStructThenUint16
}

func NewApiDecouplerOfStructThenUint16() *ApiDecouplerOfStructThenUint16 {
	return &ApiDecouplerOfStructThenUint16{
		pool: NewPoolOfStructThenUint16Impl(),
	}
}

func (__ *ApiDecouplerOfStructThenUint16) ReturnError(rtn_ch chan<- *ReturnOfUint16, err error) {
	rtn := __.pool.GetReturnOfUint16()
	var other uint16
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfStructThenUint16) HandleOfStructThenUint16(ctx context.Context, req *WorkOfStructThenUint16, h func(ctx context.Context, arg struct{}) (uint16, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfUint16()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfStructThenUint16) DoOfStructThenUint16(ctx context.Context, worker WorkerOfPushStructThenUint16, arg struct{}) (uint16, error) {
	// ch := make(chan *ReturnOfUint16, 1)
	ch := __.pool.GetChReturnOfUint16()
	defer __.pool.PutChReturnOfUint16(ch)

	req := __.pool.GetWorkOfStructThenUint16()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfStructThenUint16(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfUint16(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfStructThenUint16 = func(ctx context.Context, arg struct{}) (uint16, error)

type WorkerOfStructThenUint16 struct {
	api_syncer *ApiDecouplerOfStructThenUint16
	handler    WorkHandlerOfStructThenUint16

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfStructThenUint16
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfStructThenUint16(ctx context.Context, h WorkHandlerOfStructThenUint16, n int) *WorkerOfStructThenUint16 {
	__ := &WorkerOfStructThenUint16{
		api_syncer: NewApiDecouplerOfStructThenUint16(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfStructThenUint16, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfStructThenUint16{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfStructThenUint16(req.Context, req.WorkOfStructThenUint16, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfStructThenUint16) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfStructThenUint16) Push(ctx context.Context, req *WorkOfStructThenUint16) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfStructThenUint16)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfStructThenUint16 = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfStructThenUint16) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfStructThenUint16) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfStructThenUint16) Call(ctx context.Context, arg struct{}) (uint16, error) {
	return __.api_syncer.DoOfStructThenUint16(ctx, __, arg)
}

type PoolOfStructThenUint32 interface {
	GetStructArg() *struct{}
	PutStructArg(*struct{})
	GetUint32Return() *uint32
	PutUint32Return(*uint32)

	GetWorkOfStructThenUint32() *WorkOfStructThenUint32
	GetReturnOfUint32() *ReturnOfUint32
	PutWorkOfStructThenUint32(*WorkOfStructThenUint32)
	PutReturnOfUint32(*ReturnOfUint32)

	GetChReturnOfUint32() chan *ReturnOfUint32
	PutChReturnOfUint32(chan *ReturnOfUint32)
}

type PoolOfStructThenUint32Impl struct {
	StructArg        sync.Pool
	Uint32Rtn        sync.Pool
	StructWork       sync.Pool
	Uint32Return     sync.Pool
	ChReturnOfUint32 sync.Pool
}

func (__ *PoolOfStructThenUint32Impl) GetStructArg() *struct{} {
	return __.StructArg.Get().(*struct{})
}
func (__ *PoolOfStructThenUint32Impl) PutStructArg(p *struct{}) {
	__.StructArg.Put(p)
}
func (__ *PoolOfStructThenUint32Impl) GetUint32Return() *uint32 {
	return __.Uint32Rtn.Get().(*uint32)
}
func (__ *PoolOfStructThenUint32Impl) PutUint32Return(p *uint32) {
	__.Uint32Rtn.Put(p)
}

func (__ *PoolOfStructThenUint32Impl) GetWorkOfStructThenUint32() *WorkOfStructThenUint32 {
	return __.StructWork.Get().(*WorkOfStructThenUint32)
}
func (__ *PoolOfStructThenUint32Impl) PutWorkOfStructThenUint32(p *WorkOfStructThenUint32) {
	__.StructWork.Put(p)
}
func (__ *PoolOfStructThenUint32Impl) GetReturnOfUint32() *ReturnOfUint32 {
	return __.Uint32Return.Get().(*ReturnOfUint32)
}
func (__ *PoolOfStructThenUint32Impl) PutReturnOfUint32(p *ReturnOfUint32) {
	__.Uint32Return.Put(p)
}

func (__ *PoolOfStructThenUint32Impl) GetChReturnOfUint32() chan *ReturnOfUint32 {
	return __.ChReturnOfUint32.Get().(chan *ReturnOfUint32)
}
func (__ *PoolOfStructThenUint32Impl) PutChReturnOfUint32(p chan *ReturnOfUint32) {
	__.ChReturnOfUint32.Put(p)
}

func NewPoolOfStructThenUint32Impl() *PoolOfStructThenUint32Impl {
	return &PoolOfStructThenUint32Impl{
		StructArg: sync.Pool{
			New: func() interface{} {
				return new(struct{})
			},
		},
		StructWork: sync.Pool{
			New: func() interface{} {
				return new(WorkOfStructThenUint32)
			},
		},
		Uint32Rtn: sync.Pool{
			New: func() interface{} {
				return new(uint32)
			},
		},
		Uint32Return: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfUint32)
			},
		},
		ChReturnOfUint32: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfUint32, 1)
			},
		},
	}
}

type ApiDecouplerOfStructThenUint32 struct {
	pool PoolOfStructThenUint32
}

func NewApiDecouplerOfStructThenUint32() *ApiDecouplerOfStructThenUint32 {
	return &ApiDecouplerOfStructThenUint32{
		pool: NewPoolOfStructThenUint32Impl(),
	}
}

func (__ *ApiDecouplerOfStructThenUint32) ReturnError(rtn_ch chan<- *ReturnOfUint32, err error) {
	rtn := __.pool.GetReturnOfUint32()
	var other uint32
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfStructThenUint32) HandleOfStructThenUint32(ctx context.Context, req *WorkOfStructThenUint32, h func(ctx context.Context, arg struct{}) (uint32, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfUint32()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfStructThenUint32) DoOfStructThenUint32(ctx context.Context, worker WorkerOfPushStructThenUint32, arg struct{}) (uint32, error) {
	// ch := make(chan *ReturnOfUint32, 1)
	ch := __.pool.GetChReturnOfUint32()
	defer __.pool.PutChReturnOfUint32(ch)

	req := __.pool.GetWorkOfStructThenUint32()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfStructThenUint32(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfUint32(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfStructThenUint32 = func(ctx context.Context, arg struct{}) (uint32, error)

type WorkerOfStructThenUint32 struct {
	api_syncer *ApiDecouplerOfStructThenUint32
	handler    WorkHandlerOfStructThenUint32

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfStructThenUint32
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfStructThenUint32(ctx context.Context, h WorkHandlerOfStructThenUint32, n int) *WorkerOfStructThenUint32 {
	__ := &WorkerOfStructThenUint32{
		api_syncer: NewApiDecouplerOfStructThenUint32(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfStructThenUint32, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfStructThenUint32{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfStructThenUint32(req.Context, req.WorkOfStructThenUint32, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfStructThenUint32) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfStructThenUint32) Push(ctx context.Context, req *WorkOfStructThenUint32) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfStructThenUint32)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfStructThenUint32 = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfStructThenUint32) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfStructThenUint32) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfStructThenUint32) Call(ctx context.Context, arg struct{}) (uint32, error) {
	return __.api_syncer.DoOfStructThenUint32(ctx, __, arg)
}

type PoolOfStructThenUint64 interface {
	GetStructArg() *struct{}
	PutStructArg(*struct{})
	GetUint64Return() *uint64
	PutUint64Return(*uint64)

	GetWorkOfStructThenUint64() *WorkOfStructThenUint64
	GetReturnOfUint64() *ReturnOfUint64
	PutWorkOfStructThenUint64(*WorkOfStructThenUint64)
	PutReturnOfUint64(*ReturnOfUint64)

	GetChReturnOfUint64() chan *ReturnOfUint64
	PutChReturnOfUint64(chan *ReturnOfUint64)
}

type PoolOfStructThenUint64Impl struct {
	StructArg        sync.Pool
	Uint64Rtn        sync.Pool
	StructWork       sync.Pool
	Uint64Return     sync.Pool
	ChReturnOfUint64 sync.Pool
}

func (__ *PoolOfStructThenUint64Impl) GetStructArg() *struct{} {
	return __.StructArg.Get().(*struct{})
}
func (__ *PoolOfStructThenUint64Impl) PutStructArg(p *struct{}) {
	__.StructArg.Put(p)
}
func (__ *PoolOfStructThenUint64Impl) GetUint64Return() *uint64 {
	return __.Uint64Rtn.Get().(*uint64)
}
func (__ *PoolOfStructThenUint64Impl) PutUint64Return(p *uint64) {
	__.Uint64Rtn.Put(p)
}

func (__ *PoolOfStructThenUint64Impl) GetWorkOfStructThenUint64() *WorkOfStructThenUint64 {
	return __.StructWork.Get().(*WorkOfStructThenUint64)
}
func (__ *PoolOfStructThenUint64Impl) PutWorkOfStructThenUint64(p *WorkOfStructThenUint64) {
	__.StructWork.Put(p)
}
func (__ *PoolOfStructThenUint64Impl) GetReturnOfUint64() *ReturnOfUint64 {
	return __.Uint64Return.Get().(*ReturnOfUint64)
}
func (__ *PoolOfStructThenUint64Impl) PutReturnOfUint64(p *ReturnOfUint64) {
	__.Uint64Return.Put(p)
}

func (__ *PoolOfStructThenUint64Impl) GetChReturnOfUint64() chan *ReturnOfUint64 {
	return __.ChReturnOfUint64.Get().(chan *ReturnOfUint64)
}
func (__ *PoolOfStructThenUint64Impl) PutChReturnOfUint64(p chan *ReturnOfUint64) {
	__.ChReturnOfUint64.Put(p)
}

func NewPoolOfStructThenUint64Impl() *PoolOfStructThenUint64Impl {
	return &PoolOfStructThenUint64Impl{
		StructArg: sync.Pool{
			New: func() interface{} {
				return new(struct{})
			},
		},
		StructWork: sync.Pool{
			New: func() interface{} {
				return new(WorkOfStructThenUint64)
			},
		},
		Uint64Rtn: sync.Pool{
			New: func() interface{} {
				return new(uint64)
			},
		},
		Uint64Return: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfUint64)
			},
		},
		ChReturnOfUint64: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfUint64, 1)
			},
		},
	}
}

type ApiDecouplerOfStructThenUint64 struct {
	pool PoolOfStructThenUint64
}

func NewApiDecouplerOfStructThenUint64() *ApiDecouplerOfStructThenUint64 {
	return &ApiDecouplerOfStructThenUint64{
		pool: NewPoolOfStructThenUint64Impl(),
	}
}

func (__ *ApiDecouplerOfStructThenUint64) ReturnError(rtn_ch chan<- *ReturnOfUint64, err error) {
	rtn := __.pool.GetReturnOfUint64()
	var other uint64
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfStructThenUint64) HandleOfStructThenUint64(ctx context.Context, req *WorkOfStructThenUint64, h func(ctx context.Context, arg struct{}) (uint64, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfUint64()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfStructThenUint64) DoOfStructThenUint64(ctx context.Context, worker WorkerOfPushStructThenUint64, arg struct{}) (uint64, error) {
	// ch := make(chan *ReturnOfUint64, 1)
	ch := __.pool.GetChReturnOfUint64()
	defer __.pool.PutChReturnOfUint64(ch)

	req := __.pool.GetWorkOfStructThenUint64()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfStructThenUint64(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfUint64(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfStructThenUint64 = func(ctx context.Context, arg struct{}) (uint64, error)

type WorkerOfStructThenUint64 struct {
	api_syncer *ApiDecouplerOfStructThenUint64
	handler    WorkHandlerOfStructThenUint64

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfStructThenUint64
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfStructThenUint64(ctx context.Context, h WorkHandlerOfStructThenUint64, n int) *WorkerOfStructThenUint64 {
	__ := &WorkerOfStructThenUint64{
		api_syncer: NewApiDecouplerOfStructThenUint64(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfStructThenUint64, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfStructThenUint64{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfStructThenUint64(req.Context, req.WorkOfStructThenUint64, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfStructThenUint64) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfStructThenUint64) Push(ctx context.Context, req *WorkOfStructThenUint64) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfStructThenUint64)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfStructThenUint64 = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfStructThenUint64) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfStructThenUint64) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfStructThenUint64) Call(ctx context.Context, arg struct{}) (uint64, error) {
	return __.api_syncer.DoOfStructThenUint64(ctx, __, arg)
}

type PoolOfStructThenUint8 interface {
	GetStructArg() *struct{}
	PutStructArg(*struct{})
	GetUint8Return() *uint8
	PutUint8Return(*uint8)

	GetWorkOfStructThenUint8() *WorkOfStructThenUint8
	GetReturnOfUint8() *ReturnOfUint8
	PutWorkOfStructThenUint8(*WorkOfStructThenUint8)
	PutReturnOfUint8(*ReturnOfUint8)

	GetChReturnOfUint8() chan *ReturnOfUint8
	PutChReturnOfUint8(chan *ReturnOfUint8)
}

type PoolOfStructThenUint8Impl struct {
	StructArg       sync.Pool
	Uint8Rtn        sync.Pool
	StructWork      sync.Pool
	Uint8Return     sync.Pool
	ChReturnOfUint8 sync.Pool
}

func (__ *PoolOfStructThenUint8Impl) GetStructArg() *struct{} {
	return __.StructArg.Get().(*struct{})
}
func (__ *PoolOfStructThenUint8Impl) PutStructArg(p *struct{}) {
	__.StructArg.Put(p)
}
func (__ *PoolOfStructThenUint8Impl) GetUint8Return() *uint8 {
	return __.Uint8Rtn.Get().(*uint8)
}
func (__ *PoolOfStructThenUint8Impl) PutUint8Return(p *uint8) {
	__.Uint8Rtn.Put(p)
}

func (__ *PoolOfStructThenUint8Impl) GetWorkOfStructThenUint8() *WorkOfStructThenUint8 {
	return __.StructWork.Get().(*WorkOfStructThenUint8)
}
func (__ *PoolOfStructThenUint8Impl) PutWorkOfStructThenUint8(p *WorkOfStructThenUint8) {
	__.StructWork.Put(p)
}
func (__ *PoolOfStructThenUint8Impl) GetReturnOfUint8() *ReturnOfUint8 {
	return __.Uint8Return.Get().(*ReturnOfUint8)
}
func (__ *PoolOfStructThenUint8Impl) PutReturnOfUint8(p *ReturnOfUint8) {
	__.Uint8Return.Put(p)
}

func (__ *PoolOfStructThenUint8Impl) GetChReturnOfUint8() chan *ReturnOfUint8 {
	return __.ChReturnOfUint8.Get().(chan *ReturnOfUint8)
}
func (__ *PoolOfStructThenUint8Impl) PutChReturnOfUint8(p chan *ReturnOfUint8) {
	__.ChReturnOfUint8.Put(p)
}

func NewPoolOfStructThenUint8Impl() *PoolOfStructThenUint8Impl {
	return &PoolOfStructThenUint8Impl{
		StructArg: sync.Pool{
			New: func() interface{} {
				return new(struct{})
			},
		},
		StructWork: sync.Pool{
			New: func() interface{} {
				return new(WorkOfStructThenUint8)
			},
		},
		Uint8Rtn: sync.Pool{
			New: func() interface{} {
				return new(uint8)
			},
		},
		Uint8Return: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfUint8)
			},
		},
		ChReturnOfUint8: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfUint8, 1)
			},
		},
	}
}

type ApiDecouplerOfStructThenUint8 struct {
	pool PoolOfStructThenUint8
}

func NewApiDecouplerOfStructThenUint8() *ApiDecouplerOfStructThenUint8 {
	return &ApiDecouplerOfStructThenUint8{
		pool: NewPoolOfStructThenUint8Impl(),
	}
}

func (__ *ApiDecouplerOfStructThenUint8) ReturnError(rtn_ch chan<- *ReturnOfUint8, err error) {
	rtn := __.pool.GetReturnOfUint8()
	var other uint8
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfStructThenUint8) HandleOfStructThenUint8(ctx context.Context, req *WorkOfStructThenUint8, h func(ctx context.Context, arg struct{}) (uint8, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfUint8()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfStructThenUint8) DoOfStructThenUint8(ctx context.Context, worker WorkerOfPushStructThenUint8, arg struct{}) (uint8, error) {
	// ch := make(chan *ReturnOfUint8, 1)
	ch := __.pool.GetChReturnOfUint8()
	defer __.pool.PutChReturnOfUint8(ch)

	req := __.pool.GetWorkOfStructThenUint8()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfStructThenUint8(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfUint8(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfStructThenUint8 = func(ctx context.Context, arg struct{}) (uint8, error)

type WorkerOfStructThenUint8 struct {
	api_syncer *ApiDecouplerOfStructThenUint8
	handler    WorkHandlerOfStructThenUint8

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfStructThenUint8
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfStructThenUint8(ctx context.Context, h WorkHandlerOfStructThenUint8, n int) *WorkerOfStructThenUint8 {
	__ := &WorkerOfStructThenUint8{
		api_syncer: NewApiDecouplerOfStructThenUint8(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfStructThenUint8, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfStructThenUint8{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfStructThenUint8(req.Context, req.WorkOfStructThenUint8, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfStructThenUint8) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfStructThenUint8) Push(ctx context.Context, req *WorkOfStructThenUint8) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfStructThenUint8)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfStructThenUint8 = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfStructThenUint8) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfStructThenUint8) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfStructThenUint8) Call(ctx context.Context, arg struct{}) (uint8, error) {
	return __.api_syncer.DoOfStructThenUint8(ctx, __, arg)
}

type PoolOfStructThenUintptr interface {
	GetStructArg() *struct{}
	PutStructArg(*struct{})
	GetUintptrReturn() *uintptr
	PutUintptrReturn(*uintptr)

	GetWorkOfStructThenUintptr() *WorkOfStructThenUintptr
	GetReturnOfUintptr() *ReturnOfUintptr
	PutWorkOfStructThenUintptr(*WorkOfStructThenUintptr)
	PutReturnOfUintptr(*ReturnOfUintptr)

	GetChReturnOfUintptr() chan *ReturnOfUintptr
	PutChReturnOfUintptr(chan *ReturnOfUintptr)
}

type PoolOfStructThenUintptrImpl struct {
	StructArg         sync.Pool
	UintptrRtn        sync.Pool
	StructWork        sync.Pool
	UintptrReturn     sync.Pool
	ChReturnOfUintptr sync.Pool
}

func (__ *PoolOfStructThenUintptrImpl) GetStructArg() *struct{} {
	return __.StructArg.Get().(*struct{})
}
func (__ *PoolOfStructThenUintptrImpl) PutStructArg(p *struct{}) {
	__.StructArg.Put(p)
}
func (__ *PoolOfStructThenUintptrImpl) GetUintptrReturn() *uintptr {
	return __.UintptrRtn.Get().(*uintptr)
}
func (__ *PoolOfStructThenUintptrImpl) PutUintptrReturn(p *uintptr) {
	__.UintptrRtn.Put(p)
}

func (__ *PoolOfStructThenUintptrImpl) GetWorkOfStructThenUintptr() *WorkOfStructThenUintptr {
	return __.StructWork.Get().(*WorkOfStructThenUintptr)
}
func (__ *PoolOfStructThenUintptrImpl) PutWorkOfStructThenUintptr(p *WorkOfStructThenUintptr) {
	__.StructWork.Put(p)
}
func (__ *PoolOfStructThenUintptrImpl) GetReturnOfUintptr() *ReturnOfUintptr {
	return __.UintptrReturn.Get().(*ReturnOfUintptr)
}
func (__ *PoolOfStructThenUintptrImpl) PutReturnOfUintptr(p *ReturnOfUintptr) {
	__.UintptrReturn.Put(p)
}

func (__ *PoolOfStructThenUintptrImpl) GetChReturnOfUintptr() chan *ReturnOfUintptr {
	return __.ChReturnOfUintptr.Get().(chan *ReturnOfUintptr)
}
func (__ *PoolOfStructThenUintptrImpl) PutChReturnOfUintptr(p chan *ReturnOfUintptr) {
	__.ChReturnOfUintptr.Put(p)
}

func NewPoolOfStructThenUintptrImpl() *PoolOfStructThenUintptrImpl {
	return &PoolOfStructThenUintptrImpl{
		StructArg: sync.Pool{
			New: func() interface{} {
				return new(struct{})
			},
		},
		StructWork: sync.Pool{
			New: func() interface{} {
				return new(WorkOfStructThenUintptr)
			},
		},
		UintptrRtn: sync.Pool{
			New: func() interface{} {
				return new(uintptr)
			},
		},
		UintptrReturn: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfUintptr)
			},
		},
		ChReturnOfUintptr: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfUintptr, 1)
			},
		},
	}
}

type ApiDecouplerOfStructThenUintptr struct {
	pool PoolOfStructThenUintptr
}

func NewApiDecouplerOfStructThenUintptr() *ApiDecouplerOfStructThenUintptr {
	return &ApiDecouplerOfStructThenUintptr{
		pool: NewPoolOfStructThenUintptrImpl(),
	}
}

func (__ *ApiDecouplerOfStructThenUintptr) ReturnError(rtn_ch chan<- *ReturnOfUintptr, err error) {
	rtn := __.pool.GetReturnOfUintptr()
	var other uintptr
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfStructThenUintptr) HandleOfStructThenUintptr(ctx context.Context, req *WorkOfStructThenUintptr, h func(ctx context.Context, arg struct{}) (uintptr, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfUintptr()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfStructThenUintptr) DoOfStructThenUintptr(ctx context.Context, worker WorkerOfPushStructThenUintptr, arg struct{}) (uintptr, error) {
	// ch := make(chan *ReturnOfUintptr, 1)
	ch := __.pool.GetChReturnOfUintptr()
	defer __.pool.PutChReturnOfUintptr(ch)

	req := __.pool.GetWorkOfStructThenUintptr()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfStructThenUintptr(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfUintptr(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfStructThenUintptr = func(ctx context.Context, arg struct{}) (uintptr, error)

type WorkerOfStructThenUintptr struct {
	api_syncer *ApiDecouplerOfStructThenUintptr
	handler    WorkHandlerOfStructThenUintptr

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfStructThenUintptr
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfStructThenUintptr(ctx context.Context, h WorkHandlerOfStructThenUintptr, n int) *WorkerOfStructThenUintptr {
	__ := &WorkerOfStructThenUintptr{
		api_syncer: NewApiDecouplerOfStructThenUintptr(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfStructThenUintptr, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfStructThenUintptr{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfStructThenUintptr(req.Context, req.WorkOfStructThenUintptr, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfStructThenUintptr) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfStructThenUintptr) Push(ctx context.Context, req *WorkOfStructThenUintptr) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfStructThenUintptr)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfStructThenUintptr = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfStructThenUintptr) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfStructThenUintptr) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfStructThenUintptr) Call(ctx context.Context, arg struct{}) (uintptr, error) {
	return __.api_syncer.DoOfStructThenUintptr(ctx, __, arg)
}

type PoolOfStructThenInterface interface {
	GetStructArg() *struct{}
	PutStructArg(*struct{})
	GetInterfaceReturn() *interface{}
	PutInterfaceReturn(*interface{})

	GetWorkOfStructThenInterface() *WorkOfStructThenInterface
	GetReturnOfInterface() *ReturnOfInterface
	PutWorkOfStructThenInterface(*WorkOfStructThenInterface)
	PutReturnOfInterface(*ReturnOfInterface)

	GetChReturnOfInterface() chan *ReturnOfInterface
	PutChReturnOfInterface(chan *ReturnOfInterface)
}

type PoolOfStructThenInterfaceImpl struct {
	StructArg           sync.Pool
	InterfaceRtn        sync.Pool
	StructWork          sync.Pool
	InterfaceReturn     sync.Pool
	ChReturnOfInterface sync.Pool
}

func (__ *PoolOfStructThenInterfaceImpl) GetStructArg() *struct{} {
	return __.StructArg.Get().(*struct{})
}
func (__ *PoolOfStructThenInterfaceImpl) PutStructArg(p *struct{}) {
	__.StructArg.Put(p)
}
func (__ *PoolOfStructThenInterfaceImpl) GetInterfaceReturn() *interface{} {
	return __.InterfaceRtn.Get().(*interface{})
}
func (__ *PoolOfStructThenInterfaceImpl) PutInterfaceReturn(p *interface{}) {
	__.InterfaceRtn.Put(p)
}

func (__ *PoolOfStructThenInterfaceImpl) GetWorkOfStructThenInterface() *WorkOfStructThenInterface {
	return __.StructWork.Get().(*WorkOfStructThenInterface)
}
func (__ *PoolOfStructThenInterfaceImpl) PutWorkOfStructThenInterface(p *WorkOfStructThenInterface) {
	__.StructWork.Put(p)
}
func (__ *PoolOfStructThenInterfaceImpl) GetReturnOfInterface() *ReturnOfInterface {
	return __.InterfaceReturn.Get().(*ReturnOfInterface)
}
func (__ *PoolOfStructThenInterfaceImpl) PutReturnOfInterface(p *ReturnOfInterface) {
	__.InterfaceReturn.Put(p)
}

func (__ *PoolOfStructThenInterfaceImpl) GetChReturnOfInterface() chan *ReturnOfInterface {
	return __.ChReturnOfInterface.Get().(chan *ReturnOfInterface)
}
func (__ *PoolOfStructThenInterfaceImpl) PutChReturnOfInterface(p chan *ReturnOfInterface) {
	__.ChReturnOfInterface.Put(p)
}

func NewPoolOfStructThenInterfaceImpl() *PoolOfStructThenInterfaceImpl {
	return &PoolOfStructThenInterfaceImpl{
		StructArg: sync.Pool{
			New: func() interface{} {
				return new(struct{})
			},
		},
		StructWork: sync.Pool{
			New: func() interface{} {
				return new(WorkOfStructThenInterface)
			},
		},
		InterfaceRtn: sync.Pool{
			New: func() interface{} {
				return new(interface{})
			},
		},
		InterfaceReturn: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfInterface)
			},
		},
		ChReturnOfInterface: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfInterface, 1)
			},
		},
	}
}

type ApiDecouplerOfStructThenInterface struct {
	pool PoolOfStructThenInterface
}

func NewApiDecouplerOfStructThenInterface() *ApiDecouplerOfStructThenInterface {
	return &ApiDecouplerOfStructThenInterface{
		pool: NewPoolOfStructThenInterfaceImpl(),
	}
}

func (__ *ApiDecouplerOfStructThenInterface) ReturnError(rtn_ch chan<- *ReturnOfInterface, err error) {
	rtn := __.pool.GetReturnOfInterface()
	var other interface{}
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfStructThenInterface) HandleOfStructThenInterface(ctx context.Context, req *WorkOfStructThenInterface, h func(ctx context.Context, arg struct{}) (interface{}, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfInterface()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfStructThenInterface) DoOfStructThenInterface(ctx context.Context, worker WorkerOfPushStructThenInterface, arg struct{}) (interface{}, error) {
	// ch := make(chan *ReturnOfInterface, 1)
	ch := __.pool.GetChReturnOfInterface()
	defer __.pool.PutChReturnOfInterface(ch)

	req := __.pool.GetWorkOfStructThenInterface()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfStructThenInterface(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfInterface(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfStructThenInterface = func(ctx context.Context, arg struct{}) (interface{}, error)

type WorkerOfStructThenInterface struct {
	api_syncer *ApiDecouplerOfStructThenInterface
	handler    WorkHandlerOfStructThenInterface

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfStructThenInterface
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfStructThenInterface(ctx context.Context, h WorkHandlerOfStructThenInterface, n int) *WorkerOfStructThenInterface {
	__ := &WorkerOfStructThenInterface{
		api_syncer: NewApiDecouplerOfStructThenInterface(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfStructThenInterface, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfStructThenInterface{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfStructThenInterface(req.Context, req.WorkOfStructThenInterface, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfStructThenInterface) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfStructThenInterface) Push(ctx context.Context, req *WorkOfStructThenInterface) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfStructThenInterface)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfStructThenInterface = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfStructThenInterface) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfStructThenInterface) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfStructThenInterface) Call(ctx context.Context, arg struct{}) (interface{}, error) {
	return __.api_syncer.DoOfStructThenInterface(ctx, __, arg)
}

type PoolOfStructThenStruct interface {
	GetStructArg() *struct{}
	PutStructArg(*struct{})
	GetStructReturn() *struct{}
	PutStructReturn(*struct{})

	GetWorkOfStructThenStruct() *WorkOfStructThenStruct
	GetReturnOfStruct() *ReturnOfStruct
	PutWorkOfStructThenStruct(*WorkOfStructThenStruct)
	PutReturnOfStruct(*ReturnOfStruct)

	GetChReturnOfStruct() chan *ReturnOfStruct
	PutChReturnOfStruct(chan *ReturnOfStruct)
}

type PoolOfStructThenStructImpl struct {
	StructArg        sync.Pool
	StructRtn        sync.Pool
	StructWork       sync.Pool
	StructReturn     sync.Pool
	ChReturnOfStruct sync.Pool
}

func (__ *PoolOfStructThenStructImpl) GetStructArg() *struct{} {
	return __.StructArg.Get().(*struct{})
}
func (__ *PoolOfStructThenStructImpl) PutStructArg(p *struct{}) {
	__.StructArg.Put(p)
}
func (__ *PoolOfStructThenStructImpl) GetStructReturn() *struct{} {
	return __.StructRtn.Get().(*struct{})
}
func (__ *PoolOfStructThenStructImpl) PutStructReturn(p *struct{}) {
	__.StructRtn.Put(p)
}

func (__ *PoolOfStructThenStructImpl) GetWorkOfStructThenStruct() *WorkOfStructThenStruct {
	return __.StructWork.Get().(*WorkOfStructThenStruct)
}
func (__ *PoolOfStructThenStructImpl) PutWorkOfStructThenStruct(p *WorkOfStructThenStruct) {
	__.StructWork.Put(p)
}
func (__ *PoolOfStructThenStructImpl) GetReturnOfStruct() *ReturnOfStruct {
	return __.StructReturn.Get().(*ReturnOfStruct)
}
func (__ *PoolOfStructThenStructImpl) PutReturnOfStruct(p *ReturnOfStruct) {
	__.StructReturn.Put(p)
}

func (__ *PoolOfStructThenStructImpl) GetChReturnOfStruct() chan *ReturnOfStruct {
	return __.ChReturnOfStruct.Get().(chan *ReturnOfStruct)
}
func (__ *PoolOfStructThenStructImpl) PutChReturnOfStruct(p chan *ReturnOfStruct) {
	__.ChReturnOfStruct.Put(p)
}

func NewPoolOfStructThenStructImpl() *PoolOfStructThenStructImpl {
	return &PoolOfStructThenStructImpl{
		StructArg: sync.Pool{
			New: func() interface{} {
				return new(struct{})
			},
		},
		StructWork: sync.Pool{
			New: func() interface{} {
				return new(WorkOfStructThenStruct)
			},
		},
		StructRtn: sync.Pool{
			New: func() interface{} {
				return new(struct{})
			},
		},
		StructReturn: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfStruct)
			},
		},
		ChReturnOfStruct: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfStruct, 1)
			},
		},
	}
}

type ApiDecouplerOfStructThenStruct struct {
	pool PoolOfStructThenStruct
}

func NewApiDecouplerOfStructThenStruct() *ApiDecouplerOfStructThenStruct {
	return &ApiDecouplerOfStructThenStruct{
		pool: NewPoolOfStructThenStructImpl(),
	}
}

func (__ *ApiDecouplerOfStructThenStruct) ReturnError(rtn_ch chan<- *ReturnOfStruct, err error) {
	rtn := __.pool.GetReturnOfStruct()
	var other struct{}
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfStructThenStruct) HandleOfStructThenStruct(ctx context.Context, req *WorkOfStructThenStruct, h func(ctx context.Context, arg struct{}) (struct{}, error), defered func()) {
	defer defered()

	rtn := __.pool.GetReturnOfStruct()

	res, err := h(ctx, req.Argument)
	if err != nil {
		rtn.Error = err
		req.ReturnCh <- rtn
		return
	}

	rtn.Value = res
	rtn.Error = nil
	req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfStructThenStruct) DoOfStructThenStruct(ctx context.Context, worker WorkerOfPushStructThenStruct, arg struct{}) (struct{}, error) {
	// ch := make(chan *ReturnOfStruct, 1)
	ch := __.pool.GetChReturnOfStruct()
	defer __.pool.PutChReturnOfStruct(ch)

	req := __.pool.GetWorkOfStructThenStruct()
	req.Argument = arg
	req.ReturnCh = ch

	worker.Push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfStructThenStruct(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfStruct(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfStructThenStruct = func(ctx context.Context, arg struct{}) (struct{}, error)

type WorkerOfStructThenStruct struct {
	api_syncer *ApiDecouplerOfStructThenStruct
	handler    WorkHandlerOfStructThenStruct

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfStructThenStruct
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfStructThenStruct(ctx context.Context, h WorkHandlerOfStructThenStruct, n int) *WorkerOfStructThenStruct {
	__ := &WorkerOfStructThenStruct{
		api_syncer: NewApiDecouplerOfStructThenStruct(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfStructThenStruct, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfStructThenStruct{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for rst_req := range __.reset_ch {
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.HandleOfStructThenStruct(req.Context, req.WorkOfStructThenStruct, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfStructThenStruct) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfStructThenStruct) Push(ctx context.Context, req *WorkOfStructThenStruct) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfStructThenStruct)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfStructThenStruct = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfStructThenStruct) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfStructThenStruct) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfStructThenStruct) Call(ctx context.Context, arg struct{}) (struct{}, error) {
	return __.api_syncer.DoOfStructThenStruct(ctx, __, arg)
}

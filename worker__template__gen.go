// This file was automatically generated by genny.
// Any changes will be lost if this file is regenerated.
// see https://github.com/cheekybits/genny

package async

import (
	"context"
	"fmt"
	"sync"
)

type PoolOfBytesThenBytes interface {
	// GetBytesArg() Bytes
	// PutBytesArg(Bytes)
	// GetBytesReturn() Bytes
	// PutBytesReturn(Bytes)

	GetWorkOfBytesThenBytes() *WorkOfBytesThenBytes
	GetReturnOfBytes() *ReturnOfBytes
	PutWorkOfBytesThenBytes(*WorkOfBytesThenBytes)
	PutReturnOfBytes(*ReturnOfBytes)

	GetChReturnOfBytes() chan *ReturnOfBytes
	PutChReturnOfBytes(chan *ReturnOfBytes)
}

type PoolOfBytesThenBytesImpl struct {
	BytesArg        sync.Pool
	BytesRtn        sync.Pool
	BytesWork       sync.Pool
	BytesReturn     sync.Pool
	ChReturnOfBytes sync.Pool
}

func (__ *PoolOfBytesThenBytesImpl) GetBytesArg() *Bytes {
	return __.BytesArg.Get().(*Bytes)
}
func (__ *PoolOfBytesThenBytesImpl) PutBytesArg(p *Bytes) {
	__.BytesArg.Put(p)
}
func (__ *PoolOfBytesThenBytesImpl) GetBytesReturn() *Bytes {
	return __.BytesRtn.Get().(*Bytes)
}
func (__ *PoolOfBytesThenBytesImpl) PutBytesReturn(p *Bytes) {
	__.BytesRtn.Put(p)
}

func (__ *PoolOfBytesThenBytesImpl) GetWorkOfBytesThenBytes() *WorkOfBytesThenBytes {
	return __.BytesWork.Get().(*WorkOfBytesThenBytes)
}
func (__ *PoolOfBytesThenBytesImpl) PutWorkOfBytesThenBytes(p *WorkOfBytesThenBytes) {
	__.BytesWork.Put(p)
}
func (__ *PoolOfBytesThenBytesImpl) GetReturnOfBytes() *ReturnOfBytes {
	return __.BytesReturn.Get().(*ReturnOfBytes)
}
func (__ *PoolOfBytesThenBytesImpl) PutReturnOfBytes(p *ReturnOfBytes) {
	__.BytesReturn.Put(p)
}

func (__ *PoolOfBytesThenBytesImpl) GetChReturnOfBytes() chan *ReturnOfBytes {
	return __.ChReturnOfBytes.Get().(chan *ReturnOfBytes)
}
func (__ *PoolOfBytesThenBytesImpl) PutChReturnOfBytes(p chan *ReturnOfBytes) {
	__.ChReturnOfBytes.Put(p)
}

func NewPoolOfBytesThenBytesImpl() *PoolOfBytesThenBytesImpl {
	return &PoolOfBytesThenBytesImpl{
		BytesArg: sync.Pool{
			New: func() interface{} {
				return new(Bytes)
			},
		},
		BytesWork: sync.Pool{
			New: func() interface{} {
				return new(WorkOfBytesThenBytes)
			},
		},
		BytesRtn: sync.Pool{
			New: func() interface{} {
				return new(Bytes)
			},
		},
		BytesReturn: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfBytes)
			},
		},
		ChReturnOfBytes: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfBytes, 1)
			},
		},
	}
}

type ApiDecouplerOfBytesThenBytes struct {
	pool PoolOfBytesThenBytes
}

func NewApiDecouplerOfBytesThenBytes() *ApiDecouplerOfBytesThenBytes {
	return &ApiDecouplerOfBytesThenBytes{
		pool: NewPoolOfBytesThenBytesImpl(),
	}
}

func (__ *ApiDecouplerOfBytesThenBytes) ReturnError(rtn_ch chan<- *ReturnOfBytes, err error) {
	rtn := __.pool.GetReturnOfBytes()
	var other Bytes
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfBytesThenBytes) ReturnValue(rtn_ch chan<- *ReturnOfBytes, value Bytes) {
	rtn := __.pool.GetReturnOfBytes()
	rtn.Value = value
	rtn.Error = nil
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfBytesThenBytes) Handle(ctx context.Context, req *WorkOfBytesThenBytes, h func(ctx context.Context, arg Bytes) (Bytes, error), defered func()) {
	defer defered()

	// rtn := __.pool.GetReturnOfBytes()

	res, err := h(ctx, req.Argument)
	if err != nil {
		// 	rtn.Error = err
		// 	req.ReturnCh <- rtn
		__.ReturnError(req.ReturnCh, err)
		return
	}
	__.ReturnValue(req.ReturnCh, res)
	// rtn.Value = res
	// rtn.Error = nil
	// req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfBytesThenBytes) Call(ctx context.Context, push func(context.Context, *WorkOfBytesThenBytes), arg Bytes) (Bytes, error) {
	ch := __.pool.GetChReturnOfBytes()
	defer __.pool.PutChReturnOfBytes(ch)

	req := __.pool.GetWorkOfBytesThenBytes()
	req.Argument = arg
	req.ReturnCh = ch

	// worker.Push(ctx, req)
	push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfBytesThenBytes(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfBytes(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfBytesThenBytes = func(ctx context.Context, arg Bytes) (Bytes, error)

// type CallerOfBytesThenBytes interface {
// Call(ctx context.Context, arg Bytes) (Bytes, error)
// }

type WorkerOfBytesThenBytes struct {
	api_syncer *ApiDecouplerOfBytesThenBytes
	handler    WorkHandlerOfBytesThenBytes

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfBytesThenBytes
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfBytesThenBytes(ctx context.Context, h WorkHandlerOfBytesThenBytes, n int) *WorkerOfBytesThenBytes {
	__ := &WorkerOfBytesThenBytes{
		api_syncer: NewApiDecouplerOfBytesThenBytes(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfBytesThenBytes, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfBytesThenBytes{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.Handle(req.Context, req.WorkOfBytesThenBytes, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfBytesThenBytes) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfBytesThenBytes) Push(ctx context.Context, req *WorkOfBytesThenBytes) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfBytesThenBytes)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfBytesThenBytes = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfBytesThenBytes) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfBytesThenBytes) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfBytesThenBytes) Call(ctx context.Context, arg Bytes) (Bytes, error) {
	return __.api_syncer.Call(ctx, __.Push, arg)
}

type PoolOfBytesThenString interface {
	// GetBytesArg() Bytes
	// PutBytesArg(Bytes)
	// GetStringReturn() string
	// PutStringReturn(String)

	GetWorkOfBytesThenString() *WorkOfBytesThenString
	GetReturnOfString() *ReturnOfString
	PutWorkOfBytesThenString(*WorkOfBytesThenString)
	PutReturnOfString(*ReturnOfString)

	GetChReturnOfString() chan *ReturnOfString
	PutChReturnOfString(chan *ReturnOfString)
}

type PoolOfBytesThenStringImpl struct {
	BytesArg         sync.Pool
	StringRtn        sync.Pool
	BytesWork        sync.Pool
	StringReturn     sync.Pool
	ChReturnOfString sync.Pool
}

func (__ *PoolOfBytesThenStringImpl) GetBytesArg() *Bytes {
	return __.BytesArg.Get().(*Bytes)
}
func (__ *PoolOfBytesThenStringImpl) PutBytesArg(p *Bytes) {
	__.BytesArg.Put(p)
}
func (__ *PoolOfBytesThenStringImpl) GetStringReturn() *string {
	return __.StringRtn.Get().(*string)
}
func (__ *PoolOfBytesThenStringImpl) PutStringReturn(p *string) {
	__.StringRtn.Put(p)
}

func (__ *PoolOfBytesThenStringImpl) GetWorkOfBytesThenString() *WorkOfBytesThenString {
	return __.BytesWork.Get().(*WorkOfBytesThenString)
}
func (__ *PoolOfBytesThenStringImpl) PutWorkOfBytesThenString(p *WorkOfBytesThenString) {
	__.BytesWork.Put(p)
}
func (__ *PoolOfBytesThenStringImpl) GetReturnOfString() *ReturnOfString {
	return __.StringReturn.Get().(*ReturnOfString)
}
func (__ *PoolOfBytesThenStringImpl) PutReturnOfString(p *ReturnOfString) {
	__.StringReturn.Put(p)
}

func (__ *PoolOfBytesThenStringImpl) GetChReturnOfString() chan *ReturnOfString {
	return __.ChReturnOfString.Get().(chan *ReturnOfString)
}
func (__ *PoolOfBytesThenStringImpl) PutChReturnOfString(p chan *ReturnOfString) {
	__.ChReturnOfString.Put(p)
}

func NewPoolOfBytesThenStringImpl() *PoolOfBytesThenStringImpl {
	return &PoolOfBytesThenStringImpl{
		BytesArg: sync.Pool{
			New: func() interface{} {
				return new(Bytes)
			},
		},
		BytesWork: sync.Pool{
			New: func() interface{} {
				return new(WorkOfBytesThenString)
			},
		},
		StringRtn: sync.Pool{
			New: func() interface{} {
				return new(string)
			},
		},
		StringReturn: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfString)
			},
		},
		ChReturnOfString: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfString, 1)
			},
		},
	}
}

type ApiDecouplerOfBytesThenString struct {
	pool PoolOfBytesThenString
}

func NewApiDecouplerOfBytesThenString() *ApiDecouplerOfBytesThenString {
	return &ApiDecouplerOfBytesThenString{
		pool: NewPoolOfBytesThenStringImpl(),
	}
}

func (__ *ApiDecouplerOfBytesThenString) ReturnError(rtn_ch chan<- *ReturnOfString, err error) {
	rtn := __.pool.GetReturnOfString()
	var other string
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfBytesThenString) ReturnValue(rtn_ch chan<- *ReturnOfString, value string) {
	rtn := __.pool.GetReturnOfString()
	rtn.Value = value
	rtn.Error = nil
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfBytesThenString) Handle(ctx context.Context, req *WorkOfBytesThenString, h func(ctx context.Context, arg Bytes) (string, error), defered func()) {
	defer defered()

	// rtn := __.pool.GetReturnOfString()

	res, err := h(ctx, req.Argument)
	if err != nil {
		// 	rtn.Error = err
		// 	req.ReturnCh <- rtn
		__.ReturnError(req.ReturnCh, err)
		return
	}
	__.ReturnValue(req.ReturnCh, res)
	// rtn.Value = res
	// rtn.Error = nil
	// req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfBytesThenString) Call(ctx context.Context, push func(context.Context, *WorkOfBytesThenString), arg Bytes) (string, error) {
	ch := __.pool.GetChReturnOfString()
	defer __.pool.PutChReturnOfString(ch)

	req := __.pool.GetWorkOfBytesThenString()
	req.Argument = arg
	req.ReturnCh = ch

	// worker.Push(ctx, req)
	push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfBytesThenString(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfString(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfBytesThenString = func(ctx context.Context, arg Bytes) (string, error)

// type CallerOfBytesThenString interface {
// Call(ctx context.Context, arg Bytes) (String, error)
// }

type WorkerOfBytesThenString struct {
	api_syncer *ApiDecouplerOfBytesThenString
	handler    WorkHandlerOfBytesThenString

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfBytesThenString
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfBytesThenString(ctx context.Context, h WorkHandlerOfBytesThenString, n int) *WorkerOfBytesThenString {
	__ := &WorkerOfBytesThenString{
		api_syncer: NewApiDecouplerOfBytesThenString(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfBytesThenString, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfBytesThenString{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.Handle(req.Context, req.WorkOfBytesThenString, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfBytesThenString) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfBytesThenString) Push(ctx context.Context, req *WorkOfBytesThenString) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfBytesThenString)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfBytesThenString = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfBytesThenString) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfBytesThenString) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfBytesThenString) Call(ctx context.Context, arg Bytes) (string, error) {
	return __.api_syncer.Call(ctx, __.Push, arg)
}

type PoolOfBytesThenInterface interface {
	// GetBytesArg() Bytes
	// PutBytesArg(Bytes)
	// GetInterfaceReturn() interface{}
	// PutInterfaceReturn(Interface)

	GetWorkOfBytesThenInterface() *WorkOfBytesThenInterface
	GetReturnOfInterface() *ReturnOfInterface
	PutWorkOfBytesThenInterface(*WorkOfBytesThenInterface)
	PutReturnOfInterface(*ReturnOfInterface)

	GetChReturnOfInterface() chan *ReturnOfInterface
	PutChReturnOfInterface(chan *ReturnOfInterface)
}

type PoolOfBytesThenInterfaceImpl struct {
	BytesArg            sync.Pool
	InterfaceRtn        sync.Pool
	BytesWork           sync.Pool
	InterfaceReturn     sync.Pool
	ChReturnOfInterface sync.Pool
}

func (__ *PoolOfBytesThenInterfaceImpl) GetBytesArg() *Bytes {
	return __.BytesArg.Get().(*Bytes)
}
func (__ *PoolOfBytesThenInterfaceImpl) PutBytesArg(p *Bytes) {
	__.BytesArg.Put(p)
}
func (__ *PoolOfBytesThenInterfaceImpl) GetInterfaceReturn() *interface{} {
	return __.InterfaceRtn.Get().(*interface{})
}
func (__ *PoolOfBytesThenInterfaceImpl) PutInterfaceReturn(p *interface{}) {
	__.InterfaceRtn.Put(p)
}

func (__ *PoolOfBytesThenInterfaceImpl) GetWorkOfBytesThenInterface() *WorkOfBytesThenInterface {
	return __.BytesWork.Get().(*WorkOfBytesThenInterface)
}
func (__ *PoolOfBytesThenInterfaceImpl) PutWorkOfBytesThenInterface(p *WorkOfBytesThenInterface) {
	__.BytesWork.Put(p)
}
func (__ *PoolOfBytesThenInterfaceImpl) GetReturnOfInterface() *ReturnOfInterface {
	return __.InterfaceReturn.Get().(*ReturnOfInterface)
}
func (__ *PoolOfBytesThenInterfaceImpl) PutReturnOfInterface(p *ReturnOfInterface) {
	__.InterfaceReturn.Put(p)
}

func (__ *PoolOfBytesThenInterfaceImpl) GetChReturnOfInterface() chan *ReturnOfInterface {
	return __.ChReturnOfInterface.Get().(chan *ReturnOfInterface)
}
func (__ *PoolOfBytesThenInterfaceImpl) PutChReturnOfInterface(p chan *ReturnOfInterface) {
	__.ChReturnOfInterface.Put(p)
}

func NewPoolOfBytesThenInterfaceImpl() *PoolOfBytesThenInterfaceImpl {
	return &PoolOfBytesThenInterfaceImpl{
		BytesArg: sync.Pool{
			New: func() interface{} {
				return new(Bytes)
			},
		},
		BytesWork: sync.Pool{
			New: func() interface{} {
				return new(WorkOfBytesThenInterface)
			},
		},
		InterfaceRtn: sync.Pool{
			New: func() interface{} {
				return new(interface{})
			},
		},
		InterfaceReturn: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfInterface)
			},
		},
		ChReturnOfInterface: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfInterface, 1)
			},
		},
	}
}

type ApiDecouplerOfBytesThenInterface struct {
	pool PoolOfBytesThenInterface
}

func NewApiDecouplerOfBytesThenInterface() *ApiDecouplerOfBytesThenInterface {
	return &ApiDecouplerOfBytesThenInterface{
		pool: NewPoolOfBytesThenInterfaceImpl(),
	}
}

func (__ *ApiDecouplerOfBytesThenInterface) ReturnError(rtn_ch chan<- *ReturnOfInterface, err error) {
	rtn := __.pool.GetReturnOfInterface()
	var other interface{}
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfBytesThenInterface) ReturnValue(rtn_ch chan<- *ReturnOfInterface, value interface{}) {
	rtn := __.pool.GetReturnOfInterface()
	rtn.Value = value
	rtn.Error = nil
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfBytesThenInterface) Handle(ctx context.Context, req *WorkOfBytesThenInterface, h func(ctx context.Context, arg Bytes) (interface{}, error), defered func()) {
	defer defered()

	// rtn := __.pool.GetReturnOfInterface()

	res, err := h(ctx, req.Argument)
	if err != nil {
		// 	rtn.Error = err
		// 	req.ReturnCh <- rtn
		__.ReturnError(req.ReturnCh, err)
		return
	}
	__.ReturnValue(req.ReturnCh, res)
	// rtn.Value = res
	// rtn.Error = nil
	// req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfBytesThenInterface) Call(ctx context.Context, push func(context.Context, *WorkOfBytesThenInterface), arg Bytes) (interface{}, error) {
	ch := __.pool.GetChReturnOfInterface()
	defer __.pool.PutChReturnOfInterface(ch)

	req := __.pool.GetWorkOfBytesThenInterface()
	req.Argument = arg
	req.ReturnCh = ch

	// worker.Push(ctx, req)
	push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfBytesThenInterface(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfInterface(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfBytesThenInterface = func(ctx context.Context, arg Bytes) (interface{}, error)

// type CallerOfBytesThenInterface interface {
// Call(ctx context.Context, arg Bytes) (Interface, error)
// }

type WorkerOfBytesThenInterface struct {
	api_syncer *ApiDecouplerOfBytesThenInterface
	handler    WorkHandlerOfBytesThenInterface

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfBytesThenInterface
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfBytesThenInterface(ctx context.Context, h WorkHandlerOfBytesThenInterface, n int) *WorkerOfBytesThenInterface {
	__ := &WorkerOfBytesThenInterface{
		api_syncer: NewApiDecouplerOfBytesThenInterface(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfBytesThenInterface, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfBytesThenInterface{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.Handle(req.Context, req.WorkOfBytesThenInterface, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfBytesThenInterface) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfBytesThenInterface) Push(ctx context.Context, req *WorkOfBytesThenInterface) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfBytesThenInterface)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfBytesThenInterface = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfBytesThenInterface) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfBytesThenInterface) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfBytesThenInterface) Call(ctx context.Context, arg Bytes) (interface{}, error) {
	return __.api_syncer.Call(ctx, __.Push, arg)
}

type PoolOfStringThenBytes interface {
	// GetStringArg() string
	// PutStringArg(String)
	// GetBytesReturn() Bytes
	// PutBytesReturn(Bytes)

	GetWorkOfStringThenBytes() *WorkOfStringThenBytes
	GetReturnOfBytes() *ReturnOfBytes
	PutWorkOfStringThenBytes(*WorkOfStringThenBytes)
	PutReturnOfBytes(*ReturnOfBytes)

	GetChReturnOfBytes() chan *ReturnOfBytes
	PutChReturnOfBytes(chan *ReturnOfBytes)
}

type PoolOfStringThenBytesImpl struct {
	StringArg       sync.Pool
	BytesRtn        sync.Pool
	StringWork      sync.Pool
	BytesReturn     sync.Pool
	ChReturnOfBytes sync.Pool
}

func (__ *PoolOfStringThenBytesImpl) GetStringArg() *string {
	return __.StringArg.Get().(*string)
}
func (__ *PoolOfStringThenBytesImpl) PutStringArg(p *string) {
	__.StringArg.Put(p)
}
func (__ *PoolOfStringThenBytesImpl) GetBytesReturn() *Bytes {
	return __.BytesRtn.Get().(*Bytes)
}
func (__ *PoolOfStringThenBytesImpl) PutBytesReturn(p *Bytes) {
	__.BytesRtn.Put(p)
}

func (__ *PoolOfStringThenBytesImpl) GetWorkOfStringThenBytes() *WorkOfStringThenBytes {
	return __.StringWork.Get().(*WorkOfStringThenBytes)
}
func (__ *PoolOfStringThenBytesImpl) PutWorkOfStringThenBytes(p *WorkOfStringThenBytes) {
	__.StringWork.Put(p)
}
func (__ *PoolOfStringThenBytesImpl) GetReturnOfBytes() *ReturnOfBytes {
	return __.BytesReturn.Get().(*ReturnOfBytes)
}
func (__ *PoolOfStringThenBytesImpl) PutReturnOfBytes(p *ReturnOfBytes) {
	__.BytesReturn.Put(p)
}

func (__ *PoolOfStringThenBytesImpl) GetChReturnOfBytes() chan *ReturnOfBytes {
	return __.ChReturnOfBytes.Get().(chan *ReturnOfBytes)
}
func (__ *PoolOfStringThenBytesImpl) PutChReturnOfBytes(p chan *ReturnOfBytes) {
	__.ChReturnOfBytes.Put(p)
}

func NewPoolOfStringThenBytesImpl() *PoolOfStringThenBytesImpl {
	return &PoolOfStringThenBytesImpl{
		StringArg: sync.Pool{
			New: func() interface{} {
				return new(string)
			},
		},
		StringWork: sync.Pool{
			New: func() interface{} {
				return new(WorkOfStringThenBytes)
			},
		},
		BytesRtn: sync.Pool{
			New: func() interface{} {
				return new(Bytes)
			},
		},
		BytesReturn: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfBytes)
			},
		},
		ChReturnOfBytes: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfBytes, 1)
			},
		},
	}
}

type ApiDecouplerOfStringThenBytes struct {
	pool PoolOfStringThenBytes
}

func NewApiDecouplerOfStringThenBytes() *ApiDecouplerOfStringThenBytes {
	return &ApiDecouplerOfStringThenBytes{
		pool: NewPoolOfStringThenBytesImpl(),
	}
}

func (__ *ApiDecouplerOfStringThenBytes) ReturnError(rtn_ch chan<- *ReturnOfBytes, err error) {
	rtn := __.pool.GetReturnOfBytes()
	var other Bytes
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfStringThenBytes) ReturnValue(rtn_ch chan<- *ReturnOfBytes, value Bytes) {
	rtn := __.pool.GetReturnOfBytes()
	rtn.Value = value
	rtn.Error = nil
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfStringThenBytes) Handle(ctx context.Context, req *WorkOfStringThenBytes, h func(ctx context.Context, arg string) (Bytes, error), defered func()) {
	defer defered()

	// rtn := __.pool.GetReturnOfBytes()

	res, err := h(ctx, req.Argument)
	if err != nil {
		// 	rtn.Error = err
		// 	req.ReturnCh <- rtn
		__.ReturnError(req.ReturnCh, err)
		return
	}
	__.ReturnValue(req.ReturnCh, res)
	// rtn.Value = res
	// rtn.Error = nil
	// req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfStringThenBytes) Call(ctx context.Context, push func(context.Context, *WorkOfStringThenBytes), arg string) (Bytes, error) {
	ch := __.pool.GetChReturnOfBytes()
	defer __.pool.PutChReturnOfBytes(ch)

	req := __.pool.GetWorkOfStringThenBytes()
	req.Argument = arg
	req.ReturnCh = ch

	// worker.Push(ctx, req)
	push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfStringThenBytes(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfBytes(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfStringThenBytes = func(ctx context.Context, arg string) (Bytes, error)

// type CallerOfStringThenBytes interface {
// Call(ctx context.Context, arg String) (Bytes, error)
// }

type WorkerOfStringThenBytes struct {
	api_syncer *ApiDecouplerOfStringThenBytes
	handler    WorkHandlerOfStringThenBytes

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfStringThenBytes
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfStringThenBytes(ctx context.Context, h WorkHandlerOfStringThenBytes, n int) *WorkerOfStringThenBytes {
	__ := &WorkerOfStringThenBytes{
		api_syncer: NewApiDecouplerOfStringThenBytes(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfStringThenBytes, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfStringThenBytes{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.Handle(req.Context, req.WorkOfStringThenBytes, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfStringThenBytes) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfStringThenBytes) Push(ctx context.Context, req *WorkOfStringThenBytes) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfStringThenBytes)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfStringThenBytes = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfStringThenBytes) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfStringThenBytes) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfStringThenBytes) Call(ctx context.Context, arg string) (Bytes, error) {
	return __.api_syncer.Call(ctx, __.Push, arg)
}

type PoolOfStringThenString interface {
	// GetStringArg() string
	// PutStringArg(String)
	// GetStringReturn() string
	// PutStringReturn(String)

	GetWorkOfStringThenString() *WorkOfStringThenString
	GetReturnOfString() *ReturnOfString
	PutWorkOfStringThenString(*WorkOfStringThenString)
	PutReturnOfString(*ReturnOfString)

	GetChReturnOfString() chan *ReturnOfString
	PutChReturnOfString(chan *ReturnOfString)
}

type PoolOfStringThenStringImpl struct {
	StringArg        sync.Pool
	StringRtn        sync.Pool
	StringWork       sync.Pool
	StringReturn     sync.Pool
	ChReturnOfString sync.Pool
}

func (__ *PoolOfStringThenStringImpl) GetStringArg() *string {
	return __.StringArg.Get().(*string)
}
func (__ *PoolOfStringThenStringImpl) PutStringArg(p *string) {
	__.StringArg.Put(p)
}
func (__ *PoolOfStringThenStringImpl) GetStringReturn() *string {
	return __.StringRtn.Get().(*string)
}
func (__ *PoolOfStringThenStringImpl) PutStringReturn(p *string) {
	__.StringRtn.Put(p)
}

func (__ *PoolOfStringThenStringImpl) GetWorkOfStringThenString() *WorkOfStringThenString {
	return __.StringWork.Get().(*WorkOfStringThenString)
}
func (__ *PoolOfStringThenStringImpl) PutWorkOfStringThenString(p *WorkOfStringThenString) {
	__.StringWork.Put(p)
}
func (__ *PoolOfStringThenStringImpl) GetReturnOfString() *ReturnOfString {
	return __.StringReturn.Get().(*ReturnOfString)
}
func (__ *PoolOfStringThenStringImpl) PutReturnOfString(p *ReturnOfString) {
	__.StringReturn.Put(p)
}

func (__ *PoolOfStringThenStringImpl) GetChReturnOfString() chan *ReturnOfString {
	return __.ChReturnOfString.Get().(chan *ReturnOfString)
}
func (__ *PoolOfStringThenStringImpl) PutChReturnOfString(p chan *ReturnOfString) {
	__.ChReturnOfString.Put(p)
}

func NewPoolOfStringThenStringImpl() *PoolOfStringThenStringImpl {
	return &PoolOfStringThenStringImpl{
		StringArg: sync.Pool{
			New: func() interface{} {
				return new(string)
			},
		},
		StringWork: sync.Pool{
			New: func() interface{} {
				return new(WorkOfStringThenString)
			},
		},
		StringRtn: sync.Pool{
			New: func() interface{} {
				return new(string)
			},
		},
		StringReturn: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfString)
			},
		},
		ChReturnOfString: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfString, 1)
			},
		},
	}
}

type ApiDecouplerOfStringThenString struct {
	pool PoolOfStringThenString
}

func NewApiDecouplerOfStringThenString() *ApiDecouplerOfStringThenString {
	return &ApiDecouplerOfStringThenString{
		pool: NewPoolOfStringThenStringImpl(),
	}
}

func (__ *ApiDecouplerOfStringThenString) ReturnError(rtn_ch chan<- *ReturnOfString, err error) {
	rtn := __.pool.GetReturnOfString()
	var other string
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfStringThenString) ReturnValue(rtn_ch chan<- *ReturnOfString, value string) {
	rtn := __.pool.GetReturnOfString()
	rtn.Value = value
	rtn.Error = nil
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfStringThenString) Handle(ctx context.Context, req *WorkOfStringThenString, h func(ctx context.Context, arg string) (string, error), defered func()) {
	defer defered()

	// rtn := __.pool.GetReturnOfString()

	res, err := h(ctx, req.Argument)
	if err != nil {
		// 	rtn.Error = err
		// 	req.ReturnCh <- rtn
		__.ReturnError(req.ReturnCh, err)
		return
	}
	__.ReturnValue(req.ReturnCh, res)
	// rtn.Value = res
	// rtn.Error = nil
	// req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfStringThenString) Call(ctx context.Context, push func(context.Context, *WorkOfStringThenString), arg string) (string, error) {
	ch := __.pool.GetChReturnOfString()
	defer __.pool.PutChReturnOfString(ch)

	req := __.pool.GetWorkOfStringThenString()
	req.Argument = arg
	req.ReturnCh = ch

	// worker.Push(ctx, req)
	push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfStringThenString(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfString(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfStringThenString = func(ctx context.Context, arg string) (string, error)

// type CallerOfStringThenString interface {
// Call(ctx context.Context, arg String) (String, error)
// }

type WorkerOfStringThenString struct {
	api_syncer *ApiDecouplerOfStringThenString
	handler    WorkHandlerOfStringThenString

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfStringThenString
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfStringThenString(ctx context.Context, h WorkHandlerOfStringThenString, n int) *WorkerOfStringThenString {
	__ := &WorkerOfStringThenString{
		api_syncer: NewApiDecouplerOfStringThenString(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfStringThenString, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfStringThenString{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.Handle(req.Context, req.WorkOfStringThenString, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfStringThenString) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfStringThenString) Push(ctx context.Context, req *WorkOfStringThenString) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfStringThenString)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfStringThenString = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfStringThenString) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfStringThenString) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfStringThenString) Call(ctx context.Context, arg string) (string, error) {
	return __.api_syncer.Call(ctx, __.Push, arg)
}

type PoolOfStringThenInterface interface {
	// GetStringArg() string
	// PutStringArg(String)
	// GetInterfaceReturn() interface{}
	// PutInterfaceReturn(Interface)

	GetWorkOfStringThenInterface() *WorkOfStringThenInterface
	GetReturnOfInterface() *ReturnOfInterface
	PutWorkOfStringThenInterface(*WorkOfStringThenInterface)
	PutReturnOfInterface(*ReturnOfInterface)

	GetChReturnOfInterface() chan *ReturnOfInterface
	PutChReturnOfInterface(chan *ReturnOfInterface)
}

type PoolOfStringThenInterfaceImpl struct {
	StringArg           sync.Pool
	InterfaceRtn        sync.Pool
	StringWork          sync.Pool
	InterfaceReturn     sync.Pool
	ChReturnOfInterface sync.Pool
}

func (__ *PoolOfStringThenInterfaceImpl) GetStringArg() *string {
	return __.StringArg.Get().(*string)
}
func (__ *PoolOfStringThenInterfaceImpl) PutStringArg(p *string) {
	__.StringArg.Put(p)
}
func (__ *PoolOfStringThenInterfaceImpl) GetInterfaceReturn() *interface{} {
	return __.InterfaceRtn.Get().(*interface{})
}
func (__ *PoolOfStringThenInterfaceImpl) PutInterfaceReturn(p *interface{}) {
	__.InterfaceRtn.Put(p)
}

func (__ *PoolOfStringThenInterfaceImpl) GetWorkOfStringThenInterface() *WorkOfStringThenInterface {
	return __.StringWork.Get().(*WorkOfStringThenInterface)
}
func (__ *PoolOfStringThenInterfaceImpl) PutWorkOfStringThenInterface(p *WorkOfStringThenInterface) {
	__.StringWork.Put(p)
}
func (__ *PoolOfStringThenInterfaceImpl) GetReturnOfInterface() *ReturnOfInterface {
	return __.InterfaceReturn.Get().(*ReturnOfInterface)
}
func (__ *PoolOfStringThenInterfaceImpl) PutReturnOfInterface(p *ReturnOfInterface) {
	__.InterfaceReturn.Put(p)
}

func (__ *PoolOfStringThenInterfaceImpl) GetChReturnOfInterface() chan *ReturnOfInterface {
	return __.ChReturnOfInterface.Get().(chan *ReturnOfInterface)
}
func (__ *PoolOfStringThenInterfaceImpl) PutChReturnOfInterface(p chan *ReturnOfInterface) {
	__.ChReturnOfInterface.Put(p)
}

func NewPoolOfStringThenInterfaceImpl() *PoolOfStringThenInterfaceImpl {
	return &PoolOfStringThenInterfaceImpl{
		StringArg: sync.Pool{
			New: func() interface{} {
				return new(string)
			},
		},
		StringWork: sync.Pool{
			New: func() interface{} {
				return new(WorkOfStringThenInterface)
			},
		},
		InterfaceRtn: sync.Pool{
			New: func() interface{} {
				return new(interface{})
			},
		},
		InterfaceReturn: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfInterface)
			},
		},
		ChReturnOfInterface: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfInterface, 1)
			},
		},
	}
}

type ApiDecouplerOfStringThenInterface struct {
	pool PoolOfStringThenInterface
}

func NewApiDecouplerOfStringThenInterface() *ApiDecouplerOfStringThenInterface {
	return &ApiDecouplerOfStringThenInterface{
		pool: NewPoolOfStringThenInterfaceImpl(),
	}
}

func (__ *ApiDecouplerOfStringThenInterface) ReturnError(rtn_ch chan<- *ReturnOfInterface, err error) {
	rtn := __.pool.GetReturnOfInterface()
	var other interface{}
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfStringThenInterface) ReturnValue(rtn_ch chan<- *ReturnOfInterface, value interface{}) {
	rtn := __.pool.GetReturnOfInterface()
	rtn.Value = value
	rtn.Error = nil
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfStringThenInterface) Handle(ctx context.Context, req *WorkOfStringThenInterface, h func(ctx context.Context, arg string) (interface{}, error), defered func()) {
	defer defered()

	// rtn := __.pool.GetReturnOfInterface()

	res, err := h(ctx, req.Argument)
	if err != nil {
		// 	rtn.Error = err
		// 	req.ReturnCh <- rtn
		__.ReturnError(req.ReturnCh, err)
		return
	}
	__.ReturnValue(req.ReturnCh, res)
	// rtn.Value = res
	// rtn.Error = nil
	// req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfStringThenInterface) Call(ctx context.Context, push func(context.Context, *WorkOfStringThenInterface), arg string) (interface{}, error) {
	ch := __.pool.GetChReturnOfInterface()
	defer __.pool.PutChReturnOfInterface(ch)

	req := __.pool.GetWorkOfStringThenInterface()
	req.Argument = arg
	req.ReturnCh = ch

	// worker.Push(ctx, req)
	push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfStringThenInterface(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfInterface(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfStringThenInterface = func(ctx context.Context, arg string) (interface{}, error)

// type CallerOfStringThenInterface interface {
// Call(ctx context.Context, arg String) (Interface, error)
// }

type WorkerOfStringThenInterface struct {
	api_syncer *ApiDecouplerOfStringThenInterface
	handler    WorkHandlerOfStringThenInterface

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfStringThenInterface
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfStringThenInterface(ctx context.Context, h WorkHandlerOfStringThenInterface, n int) *WorkerOfStringThenInterface {
	__ := &WorkerOfStringThenInterface{
		api_syncer: NewApiDecouplerOfStringThenInterface(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfStringThenInterface, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfStringThenInterface{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.Handle(req.Context, req.WorkOfStringThenInterface, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfStringThenInterface) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfStringThenInterface) Push(ctx context.Context, req *WorkOfStringThenInterface) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfStringThenInterface)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfStringThenInterface = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfStringThenInterface) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfStringThenInterface) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfStringThenInterface) Call(ctx context.Context, arg string) (interface{}, error) {
	return __.api_syncer.Call(ctx, __.Push, arg)
}

type PoolOfInterfaceThenBytes interface {
	// GetInterfaceArg() interface{}
	// PutInterfaceArg(Interface)
	// GetBytesReturn() Bytes
	// PutBytesReturn(Bytes)

	GetWorkOfInterfaceThenBytes() *WorkOfInterfaceThenBytes
	GetReturnOfBytes() *ReturnOfBytes
	PutWorkOfInterfaceThenBytes(*WorkOfInterfaceThenBytes)
	PutReturnOfBytes(*ReturnOfBytes)

	GetChReturnOfBytes() chan *ReturnOfBytes
	PutChReturnOfBytes(chan *ReturnOfBytes)
}

type PoolOfInterfaceThenBytesImpl struct {
	InterfaceArg    sync.Pool
	BytesRtn        sync.Pool
	InterfaceWork   sync.Pool
	BytesReturn     sync.Pool
	ChReturnOfBytes sync.Pool
}

func (__ *PoolOfInterfaceThenBytesImpl) GetInterfaceArg() *interface{} {
	return __.InterfaceArg.Get().(*interface{})
}
func (__ *PoolOfInterfaceThenBytesImpl) PutInterfaceArg(p *interface{}) {
	__.InterfaceArg.Put(p)
}
func (__ *PoolOfInterfaceThenBytesImpl) GetBytesReturn() *Bytes {
	return __.BytesRtn.Get().(*Bytes)
}
func (__ *PoolOfInterfaceThenBytesImpl) PutBytesReturn(p *Bytes) {
	__.BytesRtn.Put(p)
}

func (__ *PoolOfInterfaceThenBytesImpl) GetWorkOfInterfaceThenBytes() *WorkOfInterfaceThenBytes {
	return __.InterfaceWork.Get().(*WorkOfInterfaceThenBytes)
}
func (__ *PoolOfInterfaceThenBytesImpl) PutWorkOfInterfaceThenBytes(p *WorkOfInterfaceThenBytes) {
	__.InterfaceWork.Put(p)
}
func (__ *PoolOfInterfaceThenBytesImpl) GetReturnOfBytes() *ReturnOfBytes {
	return __.BytesReturn.Get().(*ReturnOfBytes)
}
func (__ *PoolOfInterfaceThenBytesImpl) PutReturnOfBytes(p *ReturnOfBytes) {
	__.BytesReturn.Put(p)
}

func (__ *PoolOfInterfaceThenBytesImpl) GetChReturnOfBytes() chan *ReturnOfBytes {
	return __.ChReturnOfBytes.Get().(chan *ReturnOfBytes)
}
func (__ *PoolOfInterfaceThenBytesImpl) PutChReturnOfBytes(p chan *ReturnOfBytes) {
	__.ChReturnOfBytes.Put(p)
}

func NewPoolOfInterfaceThenBytesImpl() *PoolOfInterfaceThenBytesImpl {
	return &PoolOfInterfaceThenBytesImpl{
		InterfaceArg: sync.Pool{
			New: func() interface{} {
				return new(interface{})
			},
		},
		InterfaceWork: sync.Pool{
			New: func() interface{} {
				return new(WorkOfInterfaceThenBytes)
			},
		},
		BytesRtn: sync.Pool{
			New: func() interface{} {
				return new(Bytes)
			},
		},
		BytesReturn: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfBytes)
			},
		},
		ChReturnOfBytes: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfBytes, 1)
			},
		},
	}
}

type ApiDecouplerOfInterfaceThenBytes struct {
	pool PoolOfInterfaceThenBytes
}

func NewApiDecouplerOfInterfaceThenBytes() *ApiDecouplerOfInterfaceThenBytes {
	return &ApiDecouplerOfInterfaceThenBytes{
		pool: NewPoolOfInterfaceThenBytesImpl(),
	}
}

func (__ *ApiDecouplerOfInterfaceThenBytes) ReturnError(rtn_ch chan<- *ReturnOfBytes, err error) {
	rtn := __.pool.GetReturnOfBytes()
	var other Bytes
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfInterfaceThenBytes) ReturnValue(rtn_ch chan<- *ReturnOfBytes, value Bytes) {
	rtn := __.pool.GetReturnOfBytes()
	rtn.Value = value
	rtn.Error = nil
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfInterfaceThenBytes) Handle(ctx context.Context, req *WorkOfInterfaceThenBytes, h func(ctx context.Context, arg interface{}) (Bytes, error), defered func()) {
	defer defered()

	// rtn := __.pool.GetReturnOfBytes()

	res, err := h(ctx, req.Argument)
	if err != nil {
		// 	rtn.Error = err
		// 	req.ReturnCh <- rtn
		__.ReturnError(req.ReturnCh, err)
		return
	}
	__.ReturnValue(req.ReturnCh, res)
	// rtn.Value = res
	// rtn.Error = nil
	// req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfInterfaceThenBytes) Call(ctx context.Context, push func(context.Context, *WorkOfInterfaceThenBytes), arg interface{}) (Bytes, error) {
	ch := __.pool.GetChReturnOfBytes()
	defer __.pool.PutChReturnOfBytes(ch)

	req := __.pool.GetWorkOfInterfaceThenBytes()
	req.Argument = arg
	req.ReturnCh = ch

	// worker.Push(ctx, req)
	push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfInterfaceThenBytes(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfBytes(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfInterfaceThenBytes = func(ctx context.Context, arg interface{}) (Bytes, error)

// type CallerOfInterfaceThenBytes interface {
// Call(ctx context.Context, arg Interface) (Bytes, error)
// }

type WorkerOfInterfaceThenBytes struct {
	api_syncer *ApiDecouplerOfInterfaceThenBytes
	handler    WorkHandlerOfInterfaceThenBytes

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfInterfaceThenBytes
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfInterfaceThenBytes(ctx context.Context, h WorkHandlerOfInterfaceThenBytes, n int) *WorkerOfInterfaceThenBytes {
	__ := &WorkerOfInterfaceThenBytes{
		api_syncer: NewApiDecouplerOfInterfaceThenBytes(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfInterfaceThenBytes, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfInterfaceThenBytes{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.Handle(req.Context, req.WorkOfInterfaceThenBytes, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfInterfaceThenBytes) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfInterfaceThenBytes) Push(ctx context.Context, req *WorkOfInterfaceThenBytes) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfInterfaceThenBytes)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfInterfaceThenBytes = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfInterfaceThenBytes) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfInterfaceThenBytes) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfInterfaceThenBytes) Call(ctx context.Context, arg interface{}) (Bytes, error) {
	return __.api_syncer.Call(ctx, __.Push, arg)
}

type PoolOfInterfaceThenString interface {
	// GetInterfaceArg() interface{}
	// PutInterfaceArg(Interface)
	// GetStringReturn() string
	// PutStringReturn(String)

	GetWorkOfInterfaceThenString() *WorkOfInterfaceThenString
	GetReturnOfString() *ReturnOfString
	PutWorkOfInterfaceThenString(*WorkOfInterfaceThenString)
	PutReturnOfString(*ReturnOfString)

	GetChReturnOfString() chan *ReturnOfString
	PutChReturnOfString(chan *ReturnOfString)
}

type PoolOfInterfaceThenStringImpl struct {
	InterfaceArg     sync.Pool
	StringRtn        sync.Pool
	InterfaceWork    sync.Pool
	StringReturn     sync.Pool
	ChReturnOfString sync.Pool
}

func (__ *PoolOfInterfaceThenStringImpl) GetInterfaceArg() *interface{} {
	return __.InterfaceArg.Get().(*interface{})
}
func (__ *PoolOfInterfaceThenStringImpl) PutInterfaceArg(p *interface{}) {
	__.InterfaceArg.Put(p)
}
func (__ *PoolOfInterfaceThenStringImpl) GetStringReturn() *string {
	return __.StringRtn.Get().(*string)
}
func (__ *PoolOfInterfaceThenStringImpl) PutStringReturn(p *string) {
	__.StringRtn.Put(p)
}

func (__ *PoolOfInterfaceThenStringImpl) GetWorkOfInterfaceThenString() *WorkOfInterfaceThenString {
	return __.InterfaceWork.Get().(*WorkOfInterfaceThenString)
}
func (__ *PoolOfInterfaceThenStringImpl) PutWorkOfInterfaceThenString(p *WorkOfInterfaceThenString) {
	__.InterfaceWork.Put(p)
}
func (__ *PoolOfInterfaceThenStringImpl) GetReturnOfString() *ReturnOfString {
	return __.StringReturn.Get().(*ReturnOfString)
}
func (__ *PoolOfInterfaceThenStringImpl) PutReturnOfString(p *ReturnOfString) {
	__.StringReturn.Put(p)
}

func (__ *PoolOfInterfaceThenStringImpl) GetChReturnOfString() chan *ReturnOfString {
	return __.ChReturnOfString.Get().(chan *ReturnOfString)
}
func (__ *PoolOfInterfaceThenStringImpl) PutChReturnOfString(p chan *ReturnOfString) {
	__.ChReturnOfString.Put(p)
}

func NewPoolOfInterfaceThenStringImpl() *PoolOfInterfaceThenStringImpl {
	return &PoolOfInterfaceThenStringImpl{
		InterfaceArg: sync.Pool{
			New: func() interface{} {
				return new(interface{})
			},
		},
		InterfaceWork: sync.Pool{
			New: func() interface{} {
				return new(WorkOfInterfaceThenString)
			},
		},
		StringRtn: sync.Pool{
			New: func() interface{} {
				return new(string)
			},
		},
		StringReturn: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfString)
			},
		},
		ChReturnOfString: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfString, 1)
			},
		},
	}
}

type ApiDecouplerOfInterfaceThenString struct {
	pool PoolOfInterfaceThenString
}

func NewApiDecouplerOfInterfaceThenString() *ApiDecouplerOfInterfaceThenString {
	return &ApiDecouplerOfInterfaceThenString{
		pool: NewPoolOfInterfaceThenStringImpl(),
	}
}

func (__ *ApiDecouplerOfInterfaceThenString) ReturnError(rtn_ch chan<- *ReturnOfString, err error) {
	rtn := __.pool.GetReturnOfString()
	var other string
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfInterfaceThenString) ReturnValue(rtn_ch chan<- *ReturnOfString, value string) {
	rtn := __.pool.GetReturnOfString()
	rtn.Value = value
	rtn.Error = nil
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfInterfaceThenString) Handle(ctx context.Context, req *WorkOfInterfaceThenString, h func(ctx context.Context, arg interface{}) (string, error), defered func()) {
	defer defered()

	// rtn := __.pool.GetReturnOfString()

	res, err := h(ctx, req.Argument)
	if err != nil {
		// 	rtn.Error = err
		// 	req.ReturnCh <- rtn
		__.ReturnError(req.ReturnCh, err)
		return
	}
	__.ReturnValue(req.ReturnCh, res)
	// rtn.Value = res
	// rtn.Error = nil
	// req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfInterfaceThenString) Call(ctx context.Context, push func(context.Context, *WorkOfInterfaceThenString), arg interface{}) (string, error) {
	ch := __.pool.GetChReturnOfString()
	defer __.pool.PutChReturnOfString(ch)

	req := __.pool.GetWorkOfInterfaceThenString()
	req.Argument = arg
	req.ReturnCh = ch

	// worker.Push(ctx, req)
	push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfInterfaceThenString(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfString(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfInterfaceThenString = func(ctx context.Context, arg interface{}) (string, error)

// type CallerOfInterfaceThenString interface {
// Call(ctx context.Context, arg Interface) (String, error)
// }

type WorkerOfInterfaceThenString struct {
	api_syncer *ApiDecouplerOfInterfaceThenString
	handler    WorkHandlerOfInterfaceThenString

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfInterfaceThenString
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfInterfaceThenString(ctx context.Context, h WorkHandlerOfInterfaceThenString, n int) *WorkerOfInterfaceThenString {
	__ := &WorkerOfInterfaceThenString{
		api_syncer: NewApiDecouplerOfInterfaceThenString(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfInterfaceThenString, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfInterfaceThenString{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.Handle(req.Context, req.WorkOfInterfaceThenString, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfInterfaceThenString) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfInterfaceThenString) Push(ctx context.Context, req *WorkOfInterfaceThenString) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfInterfaceThenString)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfInterfaceThenString = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfInterfaceThenString) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfInterfaceThenString) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfInterfaceThenString) Call(ctx context.Context, arg interface{}) (string, error) {
	return __.api_syncer.Call(ctx, __.Push, arg)
}

type PoolOfInterfaceThenInterface interface {
	// GetInterfaceArg() interface{}
	// PutInterfaceArg(Interface)
	// GetInterfaceReturn() interface{}
	// PutInterfaceReturn(Interface)

	GetWorkOfInterfaceThenInterface() *WorkOfInterfaceThenInterface
	GetReturnOfInterface() *ReturnOfInterface
	PutWorkOfInterfaceThenInterface(*WorkOfInterfaceThenInterface)
	PutReturnOfInterface(*ReturnOfInterface)

	GetChReturnOfInterface() chan *ReturnOfInterface
	PutChReturnOfInterface(chan *ReturnOfInterface)
}

type PoolOfInterfaceThenInterfaceImpl struct {
	InterfaceArg        sync.Pool
	InterfaceRtn        sync.Pool
	InterfaceWork       sync.Pool
	InterfaceReturn     sync.Pool
	ChReturnOfInterface sync.Pool
}

func (__ *PoolOfInterfaceThenInterfaceImpl) GetInterfaceArg() *interface{} {
	return __.InterfaceArg.Get().(*interface{})
}
func (__ *PoolOfInterfaceThenInterfaceImpl) PutInterfaceArg(p *interface{}) {
	__.InterfaceArg.Put(p)
}
func (__ *PoolOfInterfaceThenInterfaceImpl) GetInterfaceReturn() *interface{} {
	return __.InterfaceRtn.Get().(*interface{})
}
func (__ *PoolOfInterfaceThenInterfaceImpl) PutInterfaceReturn(p *interface{}) {
	__.InterfaceRtn.Put(p)
}

func (__ *PoolOfInterfaceThenInterfaceImpl) GetWorkOfInterfaceThenInterface() *WorkOfInterfaceThenInterface {
	return __.InterfaceWork.Get().(*WorkOfInterfaceThenInterface)
}
func (__ *PoolOfInterfaceThenInterfaceImpl) PutWorkOfInterfaceThenInterface(p *WorkOfInterfaceThenInterface) {
	__.InterfaceWork.Put(p)
}
func (__ *PoolOfInterfaceThenInterfaceImpl) GetReturnOfInterface() *ReturnOfInterface {
	return __.InterfaceReturn.Get().(*ReturnOfInterface)
}
func (__ *PoolOfInterfaceThenInterfaceImpl) PutReturnOfInterface(p *ReturnOfInterface) {
	__.InterfaceReturn.Put(p)
}

func (__ *PoolOfInterfaceThenInterfaceImpl) GetChReturnOfInterface() chan *ReturnOfInterface {
	return __.ChReturnOfInterface.Get().(chan *ReturnOfInterface)
}
func (__ *PoolOfInterfaceThenInterfaceImpl) PutChReturnOfInterface(p chan *ReturnOfInterface) {
	__.ChReturnOfInterface.Put(p)
}

func NewPoolOfInterfaceThenInterfaceImpl() *PoolOfInterfaceThenInterfaceImpl {
	return &PoolOfInterfaceThenInterfaceImpl{
		InterfaceArg: sync.Pool{
			New: func() interface{} {
				return new(interface{})
			},
		},
		InterfaceWork: sync.Pool{
			New: func() interface{} {
				return new(WorkOfInterfaceThenInterface)
			},
		},
		InterfaceRtn: sync.Pool{
			New: func() interface{} {
				return new(interface{})
			},
		},
		InterfaceReturn: sync.Pool{
			New: func() interface{} {
				return new(ReturnOfInterface)
			},
		},
		ChReturnOfInterface: sync.Pool{
			New: func() interface{} {
				return make(chan *ReturnOfInterface, 1)
			},
		},
	}
}

type ApiDecouplerOfInterfaceThenInterface struct {
	pool PoolOfInterfaceThenInterface
}

func NewApiDecouplerOfInterfaceThenInterface() *ApiDecouplerOfInterfaceThenInterface {
	return &ApiDecouplerOfInterfaceThenInterface{
		pool: NewPoolOfInterfaceThenInterfaceImpl(),
	}
}

func (__ *ApiDecouplerOfInterfaceThenInterface) ReturnError(rtn_ch chan<- *ReturnOfInterface, err error) {
	rtn := __.pool.GetReturnOfInterface()
	var other interface{}
	rtn.Value = other
	rtn.Error = err
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfInterfaceThenInterface) ReturnValue(rtn_ch chan<- *ReturnOfInterface, value interface{}) {
	rtn := __.pool.GetReturnOfInterface()
	rtn.Value = value
	rtn.Error = nil
	rtn_ch <- rtn
}

func (__ *ApiDecouplerOfInterfaceThenInterface) Handle(ctx context.Context, req *WorkOfInterfaceThenInterface, h func(ctx context.Context, arg interface{}) (interface{}, error), defered func()) {
	defer defered()

	// rtn := __.pool.GetReturnOfInterface()

	res, err := h(ctx, req.Argument)
	if err != nil {
		// 	rtn.Error = err
		// 	req.ReturnCh <- rtn
		__.ReturnError(req.ReturnCh, err)
		return
	}
	__.ReturnValue(req.ReturnCh, res)
	// rtn.Value = res
	// rtn.Error = nil
	// req.ReturnCh <- rtn
}

func (__ *ApiDecouplerOfInterfaceThenInterface) Call(ctx context.Context, push func(context.Context, *WorkOfInterfaceThenInterface), arg interface{}) (interface{}, error) {
	ch := __.pool.GetChReturnOfInterface()
	defer __.pool.PutChReturnOfInterface(ch)

	req := __.pool.GetWorkOfInterfaceThenInterface()
	req.Argument = arg
	req.ReturnCh = ch

	// worker.Push(ctx, req)
	push(ctx, req)
	defer func() {
		req.ReturnCh = nil
		__.pool.PutWorkOfInterfaceThenInterface(req)
	}()

	res := <-ch
	defer func() {
		res.Error = nil
		__.pool.PutReturnOfInterface(res)
	}()
	return res.Value, res.Error
}

type WorkHandlerOfInterfaceThenInterface = func(ctx context.Context, arg interface{}) (interface{}, error)

// type CallerOfInterfaceThenInterface interface {
// Call(ctx context.Context, arg Interface) (Interface, error)
// }

type WorkerOfInterfaceThenInterface struct {
	api_syncer *ApiDecouplerOfInterfaceThenInterface
	handler    WorkHandlerOfInterfaceThenInterface

	ctx context.Context

	threads  sync.WaitGroup
	req_ch   chan *WorkWithContextOfInterfaceThenInterface
	done_ch  chan struct{}
	reset_ch chan chan error

	pool sync.Pool
}

func NewWorkerOfInterfaceThenInterface(ctx context.Context, h WorkHandlerOfInterfaceThenInterface, n int) *WorkerOfInterfaceThenInterface {
	__ := &WorkerOfInterfaceThenInterface{
		api_syncer: NewApiDecouplerOfInterfaceThenInterface(),
		handler:    h,

		ctx: ctx,

		req_ch:   make(chan *WorkWithContextOfInterfaceThenInterface, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),

		pool: sync.Pool{
			New: func() interface{} {
				return &WorkWithContextOfInterfaceThenInterface{}
			},
		},
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case req := <-__.req_ch:
				__.threads.Add(1)
				go __.api_syncer.Handle(req.Context, req.WorkOfInterfaceThenInterface, __.handler, func() {
					__.pool.Put(req)
					__.threads.Done()
				})
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *WorkerOfInterfaceThenInterface) reset_queue() {
	for i := 0; i < len(__.req_ch); i += 1 {
		req := <-__.req_ch
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("canceled by reset"))
	}
}

func (__ *WorkerOfInterfaceThenInterface) Push(ctx context.Context, req *WorkOfInterfaceThenInterface) {
	__.threads.Add(1)
	defer __.threads.Done()

	select {
	case <-__.ctx.Done():
		__.api_syncer.ReturnError(req.ReturnCh, fmt.Errorf("terminated worker"))
		return
	default:
	}

	req_n_ctx := __.pool.Get().(*WorkWithContextOfInterfaceThenInterface)
	req_n_ctx.Context = ctx
	req_n_ctx.WorkOfInterfaceThenInterface = req
	__.req_ch <- req_n_ctx
}

func (__ *WorkerOfInterfaceThenInterface) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *WorkerOfInterfaceThenInterface) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

func (__ *WorkerOfInterfaceThenInterface) Call(ctx context.Context, arg interface{}) (interface{}, error) {
	return __.api_syncer.Call(ctx, __.Push, arg)
}

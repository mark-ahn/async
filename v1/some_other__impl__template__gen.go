// This file was automatically generated by genny.
// Any changes will be lost if this file is regenerated.
// see https://github.com/cheekybits/genny

package async

import (
	"context"
	"fmt"
	"sync"
)

type FuncWorkerOfBytesToBytes struct {
	handler func(context.Context, Bytes) (Bytes, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfBytesToBytes
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfBytesToBytes(ctx context.Context, h func(context.Context, Bytes) (Bytes, error), n int) *FuncWorkerOfBytesToBytes {
	__ := &FuncWorkerOfBytesToBytes{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfBytesToBytes, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go BytesToBytes.CallAsAsync(work.Context, work.WorkOfBytesToBytes.Value, work.WorkOfBytesToBytes.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				BytesToBytes.Pool.Work.Put(work.WorkOfBytesToBytes)
				BytesToBytes.Pool.WorkContext.Put(work)
				// BytesToBytes.PutWork(work.WorkOfBytesToBytes)
				// BytesToBytes.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfBytesToBytes) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		// rtn := BytesToBytes.GetReturn()
		rtn := Bytess.Pool.Return.Get()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfBytesToBytes) Push(ctx context.Context, value Bytes, returnCh chan<- *ReturnOfBytes) {
	__.threads.Add(1)
	defer __.threads.Done()

	// work_ctx := BytesToBytes.GetWorkContextWith(ctx, BytesToBytes.GetWorkWith(value, returnCh))
	work_ctx := BytesToBytes.Pool.WorkContext.GetWith(ctx, BytesToBytes.Pool.Work.GetWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfBytesToBytes) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfBytesToBytes) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfBytesToString struct {
	handler func(context.Context, Bytes) (string, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfBytesToString
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfBytesToString(ctx context.Context, h func(context.Context, Bytes) (string, error), n int) *FuncWorkerOfBytesToString {
	__ := &FuncWorkerOfBytesToString{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfBytesToString, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go BytesToString.CallAsAsync(work.Context, work.WorkOfBytesToString.Value, work.WorkOfBytesToString.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				BytesToString.Pool.Work.Put(work.WorkOfBytesToString)
				BytesToString.Pool.WorkContext.Put(work)
				// BytesToString.PutWork(work.WorkOfBytesToString)
				// BytesToString.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfBytesToString) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		// rtn := BytesToString.GetReturn()
		rtn := Strings.Pool.Return.Get()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfBytesToString) Push(ctx context.Context, value Bytes, returnCh chan<- *ReturnOfString) {
	__.threads.Add(1)
	defer __.threads.Done()

	// work_ctx := BytesToString.GetWorkContextWith(ctx, BytesToString.GetWorkWith(value, returnCh))
	work_ctx := BytesToString.Pool.WorkContext.GetWith(ctx, BytesToString.Pool.Work.GetWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfBytesToString) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfBytesToString) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfBytesToInterface struct {
	handler func(context.Context, Bytes) (interface{}, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfBytesToInterface
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfBytesToInterface(ctx context.Context, h func(context.Context, Bytes) (interface{}, error), n int) *FuncWorkerOfBytesToInterface {
	__ := &FuncWorkerOfBytesToInterface{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfBytesToInterface, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go BytesToInterface.CallAsAsync(work.Context, work.WorkOfBytesToInterface.Value, work.WorkOfBytesToInterface.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				BytesToInterface.Pool.Work.Put(work.WorkOfBytesToInterface)
				BytesToInterface.Pool.WorkContext.Put(work)
				// BytesToInterface.PutWork(work.WorkOfBytesToInterface)
				// BytesToInterface.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfBytesToInterface) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		// rtn := BytesToInterface.GetReturn()
		rtn := Interfaces.Pool.Return.Get()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfBytesToInterface) Push(ctx context.Context, value Bytes, returnCh chan<- *ReturnOfInterface) {
	__.threads.Add(1)
	defer __.threads.Done()

	// work_ctx := BytesToInterface.GetWorkContextWith(ctx, BytesToInterface.GetWorkWith(value, returnCh))
	work_ctx := BytesToInterface.Pool.WorkContext.GetWith(ctx, BytesToInterface.Pool.Work.GetWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfBytesToInterface) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfBytesToInterface) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfStringToBytes struct {
	handler func(context.Context, string) (Bytes, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfStringToBytes
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfStringToBytes(ctx context.Context, h func(context.Context, string) (Bytes, error), n int) *FuncWorkerOfStringToBytes {
	__ := &FuncWorkerOfStringToBytes{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfStringToBytes, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go StringToBytes.CallAsAsync(work.Context, work.WorkOfStringToBytes.Value, work.WorkOfStringToBytes.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				StringToBytes.Pool.Work.Put(work.WorkOfStringToBytes)
				StringToBytes.Pool.WorkContext.Put(work)
				// StringToBytes.PutWork(work.WorkOfStringToBytes)
				// StringToBytes.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfStringToBytes) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		// rtn := StringToBytes.GetReturn()
		rtn := Bytess.Pool.Return.Get()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfStringToBytes) Push(ctx context.Context, value string, returnCh chan<- *ReturnOfBytes) {
	__.threads.Add(1)
	defer __.threads.Done()

	// work_ctx := StringToBytes.GetWorkContextWith(ctx, StringToBytes.GetWorkWith(value, returnCh))
	work_ctx := StringToBytes.Pool.WorkContext.GetWith(ctx, StringToBytes.Pool.Work.GetWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfStringToBytes) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfStringToBytes) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfStringToString struct {
	handler func(context.Context, string) (string, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfStringToString
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfStringToString(ctx context.Context, h func(context.Context, string) (string, error), n int) *FuncWorkerOfStringToString {
	__ := &FuncWorkerOfStringToString{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfStringToString, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go StringToString.CallAsAsync(work.Context, work.WorkOfStringToString.Value, work.WorkOfStringToString.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				StringToString.Pool.Work.Put(work.WorkOfStringToString)
				StringToString.Pool.WorkContext.Put(work)
				// StringToString.PutWork(work.WorkOfStringToString)
				// StringToString.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfStringToString) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		// rtn := StringToString.GetReturn()
		rtn := Strings.Pool.Return.Get()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfStringToString) Push(ctx context.Context, value string, returnCh chan<- *ReturnOfString) {
	__.threads.Add(1)
	defer __.threads.Done()

	// work_ctx := StringToString.GetWorkContextWith(ctx, StringToString.GetWorkWith(value, returnCh))
	work_ctx := StringToString.Pool.WorkContext.GetWith(ctx, StringToString.Pool.Work.GetWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfStringToString) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfStringToString) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfStringToInterface struct {
	handler func(context.Context, string) (interface{}, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfStringToInterface
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfStringToInterface(ctx context.Context, h func(context.Context, string) (interface{}, error), n int) *FuncWorkerOfStringToInterface {
	__ := &FuncWorkerOfStringToInterface{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfStringToInterface, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go StringToInterface.CallAsAsync(work.Context, work.WorkOfStringToInterface.Value, work.WorkOfStringToInterface.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				StringToInterface.Pool.Work.Put(work.WorkOfStringToInterface)
				StringToInterface.Pool.WorkContext.Put(work)
				// StringToInterface.PutWork(work.WorkOfStringToInterface)
				// StringToInterface.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfStringToInterface) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		// rtn := StringToInterface.GetReturn()
		rtn := Interfaces.Pool.Return.Get()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfStringToInterface) Push(ctx context.Context, value string, returnCh chan<- *ReturnOfInterface) {
	__.threads.Add(1)
	defer __.threads.Done()

	// work_ctx := StringToInterface.GetWorkContextWith(ctx, StringToInterface.GetWorkWith(value, returnCh))
	work_ctx := StringToInterface.Pool.WorkContext.GetWith(ctx, StringToInterface.Pool.Work.GetWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfStringToInterface) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfStringToInterface) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfInterfaceToBytes struct {
	handler func(context.Context, interface{}) (Bytes, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfInterfaceToBytes
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfInterfaceToBytes(ctx context.Context, h func(context.Context, interface{}) (Bytes, error), n int) *FuncWorkerOfInterfaceToBytes {
	__ := &FuncWorkerOfInterfaceToBytes{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfInterfaceToBytes, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go InterfaceToBytes.CallAsAsync(work.Context, work.WorkOfInterfaceToBytes.Value, work.WorkOfInterfaceToBytes.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				InterfaceToBytes.Pool.Work.Put(work.WorkOfInterfaceToBytes)
				InterfaceToBytes.Pool.WorkContext.Put(work)
				// InterfaceToBytes.PutWork(work.WorkOfInterfaceToBytes)
				// InterfaceToBytes.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfInterfaceToBytes) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		// rtn := InterfaceToBytes.GetReturn()
		rtn := Bytess.Pool.Return.Get()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfInterfaceToBytes) Push(ctx context.Context, value interface{}, returnCh chan<- *ReturnOfBytes) {
	__.threads.Add(1)
	defer __.threads.Done()

	// work_ctx := InterfaceToBytes.GetWorkContextWith(ctx, InterfaceToBytes.GetWorkWith(value, returnCh))
	work_ctx := InterfaceToBytes.Pool.WorkContext.GetWith(ctx, InterfaceToBytes.Pool.Work.GetWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfInterfaceToBytes) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfInterfaceToBytes) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfInterfaceToString struct {
	handler func(context.Context, interface{}) (string, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfInterfaceToString
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfInterfaceToString(ctx context.Context, h func(context.Context, interface{}) (string, error), n int) *FuncWorkerOfInterfaceToString {
	__ := &FuncWorkerOfInterfaceToString{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfInterfaceToString, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go InterfaceToString.CallAsAsync(work.Context, work.WorkOfInterfaceToString.Value, work.WorkOfInterfaceToString.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				InterfaceToString.Pool.Work.Put(work.WorkOfInterfaceToString)
				InterfaceToString.Pool.WorkContext.Put(work)
				// InterfaceToString.PutWork(work.WorkOfInterfaceToString)
				// InterfaceToString.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfInterfaceToString) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		// rtn := InterfaceToString.GetReturn()
		rtn := Strings.Pool.Return.Get()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfInterfaceToString) Push(ctx context.Context, value interface{}, returnCh chan<- *ReturnOfString) {
	__.threads.Add(1)
	defer __.threads.Done()

	// work_ctx := InterfaceToString.GetWorkContextWith(ctx, InterfaceToString.GetWorkWith(value, returnCh))
	work_ctx := InterfaceToString.Pool.WorkContext.GetWith(ctx, InterfaceToString.Pool.Work.GetWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfInterfaceToString) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfInterfaceToString) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfInterfaceToInterface struct {
	handler func(context.Context, interface{}) (interface{}, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfInterfaceToInterface
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfInterfaceToInterface(ctx context.Context, h func(context.Context, interface{}) (interface{}, error), n int) *FuncWorkerOfInterfaceToInterface {
	__ := &FuncWorkerOfInterfaceToInterface{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfInterfaceToInterface, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go InterfaceToInterface.CallAsAsync(work.Context, work.WorkOfInterfaceToInterface.Value, work.WorkOfInterfaceToInterface.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				InterfaceToInterface.Pool.Work.Put(work.WorkOfInterfaceToInterface)
				InterfaceToInterface.Pool.WorkContext.Put(work)
				// InterfaceToInterface.PutWork(work.WorkOfInterfaceToInterface)
				// InterfaceToInterface.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfInterfaceToInterface) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		// rtn := InterfaceToInterface.GetReturn()
		rtn := Interfaces.Pool.Return.Get()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfInterfaceToInterface) Push(ctx context.Context, value interface{}, returnCh chan<- *ReturnOfInterface) {
	__.threads.Add(1)
	defer __.threads.Done()

	// work_ctx := InterfaceToInterface.GetWorkContextWith(ctx, InterfaceToInterface.GetWorkWith(value, returnCh))
	work_ctx := InterfaceToInterface.Pool.WorkContext.GetWith(ctx, InterfaceToInterface.Pool.Work.GetWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfInterfaceToInterface) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfInterfaceToInterface) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

// This file was automatically generated by genny.
// Any changes will be lost if this file is regenerated.
// see https://github.com/cheekybits/genny

package async

import (
	"context"
	"fmt"
	"sync"
)

type FuncWorkerOfBoolToBool struct {
	handler func(context.Context, bool) (bool, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfBoolToBool
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfBoolToBool(ctx context.Context, h func(context.Context, bool) (bool, error), n int) *FuncWorkerOfBoolToBool {
	__ := &FuncWorkerOfBoolToBool{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfBoolToBool, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go BoolToBool.CallAsAsync(work.Context, work.WorkOfBoolToBool.Value, work.WorkOfBoolToBool.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				BoolToBool.PutWork(work.WorkOfBoolToBool)
				BoolToBool.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfBoolToBool) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := BoolToBool.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfBoolToBool) Push(ctx context.Context, value bool, returnCh chan<- *ReturnOfBool) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := BoolToBool.GetWorkContextWith(ctx, BoolToBool.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfBoolToBool) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfBoolToBool) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfBoolToByte struct {
	handler func(context.Context, bool) (byte, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfBoolToByte
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfBoolToByte(ctx context.Context, h func(context.Context, bool) (byte, error), n int) *FuncWorkerOfBoolToByte {
	__ := &FuncWorkerOfBoolToByte{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfBoolToByte, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go BoolToByte.CallAsAsync(work.Context, work.WorkOfBoolToByte.Value, work.WorkOfBoolToByte.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				BoolToByte.PutWork(work.WorkOfBoolToByte)
				BoolToByte.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfBoolToByte) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := BoolToByte.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfBoolToByte) Push(ctx context.Context, value bool, returnCh chan<- *ReturnOfByte) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := BoolToByte.GetWorkContextWith(ctx, BoolToByte.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfBoolToByte) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfBoolToByte) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfBoolToComplex128 struct {
	handler func(context.Context, bool) (complex128, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfBoolToComplex128
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfBoolToComplex128(ctx context.Context, h func(context.Context, bool) (complex128, error), n int) *FuncWorkerOfBoolToComplex128 {
	__ := &FuncWorkerOfBoolToComplex128{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfBoolToComplex128, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go BoolToComplex128.CallAsAsync(work.Context, work.WorkOfBoolToComplex128.Value, work.WorkOfBoolToComplex128.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				BoolToComplex128.PutWork(work.WorkOfBoolToComplex128)
				BoolToComplex128.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfBoolToComplex128) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := BoolToComplex128.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfBoolToComplex128) Push(ctx context.Context, value bool, returnCh chan<- *ReturnOfComplex128) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := BoolToComplex128.GetWorkContextWith(ctx, BoolToComplex128.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfBoolToComplex128) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfBoolToComplex128) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfBoolToComplex64 struct {
	handler func(context.Context, bool) (complex64, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfBoolToComplex64
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfBoolToComplex64(ctx context.Context, h func(context.Context, bool) (complex64, error), n int) *FuncWorkerOfBoolToComplex64 {
	__ := &FuncWorkerOfBoolToComplex64{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfBoolToComplex64, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go BoolToComplex64.CallAsAsync(work.Context, work.WorkOfBoolToComplex64.Value, work.WorkOfBoolToComplex64.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				BoolToComplex64.PutWork(work.WorkOfBoolToComplex64)
				BoolToComplex64.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfBoolToComplex64) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := BoolToComplex64.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfBoolToComplex64) Push(ctx context.Context, value bool, returnCh chan<- *ReturnOfComplex64) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := BoolToComplex64.GetWorkContextWith(ctx, BoolToComplex64.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfBoolToComplex64) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfBoolToComplex64) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfBoolToError struct {
	handler func(context.Context, bool) (error, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfBoolToError
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfBoolToError(ctx context.Context, h func(context.Context, bool) (error, error), n int) *FuncWorkerOfBoolToError {
	__ := &FuncWorkerOfBoolToError{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfBoolToError, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go BoolToError.CallAsAsync(work.Context, work.WorkOfBoolToError.Value, work.WorkOfBoolToError.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				BoolToError.PutWork(work.WorkOfBoolToError)
				BoolToError.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfBoolToError) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := BoolToError.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfBoolToError) Push(ctx context.Context, value bool, returnCh chan<- *ReturnOfError) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := BoolToError.GetWorkContextWith(ctx, BoolToError.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfBoolToError) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfBoolToError) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfBoolToFloat32 struct {
	handler func(context.Context, bool) (float32, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfBoolToFloat32
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfBoolToFloat32(ctx context.Context, h func(context.Context, bool) (float32, error), n int) *FuncWorkerOfBoolToFloat32 {
	__ := &FuncWorkerOfBoolToFloat32{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfBoolToFloat32, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go BoolToFloat32.CallAsAsync(work.Context, work.WorkOfBoolToFloat32.Value, work.WorkOfBoolToFloat32.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				BoolToFloat32.PutWork(work.WorkOfBoolToFloat32)
				BoolToFloat32.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfBoolToFloat32) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := BoolToFloat32.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfBoolToFloat32) Push(ctx context.Context, value bool, returnCh chan<- *ReturnOfFloat32) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := BoolToFloat32.GetWorkContextWith(ctx, BoolToFloat32.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfBoolToFloat32) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfBoolToFloat32) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfBoolToFloat64 struct {
	handler func(context.Context, bool) (float64, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfBoolToFloat64
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfBoolToFloat64(ctx context.Context, h func(context.Context, bool) (float64, error), n int) *FuncWorkerOfBoolToFloat64 {
	__ := &FuncWorkerOfBoolToFloat64{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfBoolToFloat64, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go BoolToFloat64.CallAsAsync(work.Context, work.WorkOfBoolToFloat64.Value, work.WorkOfBoolToFloat64.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				BoolToFloat64.PutWork(work.WorkOfBoolToFloat64)
				BoolToFloat64.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfBoolToFloat64) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := BoolToFloat64.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfBoolToFloat64) Push(ctx context.Context, value bool, returnCh chan<- *ReturnOfFloat64) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := BoolToFloat64.GetWorkContextWith(ctx, BoolToFloat64.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfBoolToFloat64) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfBoolToFloat64) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfBoolToInt struct {
	handler func(context.Context, bool) (int, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfBoolToInt
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfBoolToInt(ctx context.Context, h func(context.Context, bool) (int, error), n int) *FuncWorkerOfBoolToInt {
	__ := &FuncWorkerOfBoolToInt{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfBoolToInt, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go BoolToInt.CallAsAsync(work.Context, work.WorkOfBoolToInt.Value, work.WorkOfBoolToInt.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				BoolToInt.PutWork(work.WorkOfBoolToInt)
				BoolToInt.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfBoolToInt) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := BoolToInt.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfBoolToInt) Push(ctx context.Context, value bool, returnCh chan<- *ReturnOfInt) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := BoolToInt.GetWorkContextWith(ctx, BoolToInt.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfBoolToInt) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfBoolToInt) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfBoolToInt16 struct {
	handler func(context.Context, bool) (int16, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfBoolToInt16
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfBoolToInt16(ctx context.Context, h func(context.Context, bool) (int16, error), n int) *FuncWorkerOfBoolToInt16 {
	__ := &FuncWorkerOfBoolToInt16{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfBoolToInt16, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go BoolToInt16.CallAsAsync(work.Context, work.WorkOfBoolToInt16.Value, work.WorkOfBoolToInt16.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				BoolToInt16.PutWork(work.WorkOfBoolToInt16)
				BoolToInt16.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfBoolToInt16) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := BoolToInt16.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfBoolToInt16) Push(ctx context.Context, value bool, returnCh chan<- *ReturnOfInt16) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := BoolToInt16.GetWorkContextWith(ctx, BoolToInt16.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfBoolToInt16) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfBoolToInt16) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfBoolToInt32 struct {
	handler func(context.Context, bool) (int32, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfBoolToInt32
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfBoolToInt32(ctx context.Context, h func(context.Context, bool) (int32, error), n int) *FuncWorkerOfBoolToInt32 {
	__ := &FuncWorkerOfBoolToInt32{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfBoolToInt32, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go BoolToInt32.CallAsAsync(work.Context, work.WorkOfBoolToInt32.Value, work.WorkOfBoolToInt32.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				BoolToInt32.PutWork(work.WorkOfBoolToInt32)
				BoolToInt32.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfBoolToInt32) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := BoolToInt32.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfBoolToInt32) Push(ctx context.Context, value bool, returnCh chan<- *ReturnOfInt32) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := BoolToInt32.GetWorkContextWith(ctx, BoolToInt32.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfBoolToInt32) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfBoolToInt32) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfBoolToInt64 struct {
	handler func(context.Context, bool) (int64, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfBoolToInt64
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfBoolToInt64(ctx context.Context, h func(context.Context, bool) (int64, error), n int) *FuncWorkerOfBoolToInt64 {
	__ := &FuncWorkerOfBoolToInt64{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfBoolToInt64, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go BoolToInt64.CallAsAsync(work.Context, work.WorkOfBoolToInt64.Value, work.WorkOfBoolToInt64.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				BoolToInt64.PutWork(work.WorkOfBoolToInt64)
				BoolToInt64.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfBoolToInt64) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := BoolToInt64.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfBoolToInt64) Push(ctx context.Context, value bool, returnCh chan<- *ReturnOfInt64) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := BoolToInt64.GetWorkContextWith(ctx, BoolToInt64.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfBoolToInt64) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfBoolToInt64) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfBoolToInt8 struct {
	handler func(context.Context, bool) (int8, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfBoolToInt8
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfBoolToInt8(ctx context.Context, h func(context.Context, bool) (int8, error), n int) *FuncWorkerOfBoolToInt8 {
	__ := &FuncWorkerOfBoolToInt8{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfBoolToInt8, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go BoolToInt8.CallAsAsync(work.Context, work.WorkOfBoolToInt8.Value, work.WorkOfBoolToInt8.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				BoolToInt8.PutWork(work.WorkOfBoolToInt8)
				BoolToInt8.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfBoolToInt8) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := BoolToInt8.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfBoolToInt8) Push(ctx context.Context, value bool, returnCh chan<- *ReturnOfInt8) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := BoolToInt8.GetWorkContextWith(ctx, BoolToInt8.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfBoolToInt8) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfBoolToInt8) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfBoolToRune struct {
	handler func(context.Context, bool) (rune, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfBoolToRune
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfBoolToRune(ctx context.Context, h func(context.Context, bool) (rune, error), n int) *FuncWorkerOfBoolToRune {
	__ := &FuncWorkerOfBoolToRune{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfBoolToRune, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go BoolToRune.CallAsAsync(work.Context, work.WorkOfBoolToRune.Value, work.WorkOfBoolToRune.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				BoolToRune.PutWork(work.WorkOfBoolToRune)
				BoolToRune.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfBoolToRune) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := BoolToRune.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfBoolToRune) Push(ctx context.Context, value bool, returnCh chan<- *ReturnOfRune) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := BoolToRune.GetWorkContextWith(ctx, BoolToRune.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfBoolToRune) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfBoolToRune) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfBoolToString struct {
	handler func(context.Context, bool) (string, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfBoolToString
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfBoolToString(ctx context.Context, h func(context.Context, bool) (string, error), n int) *FuncWorkerOfBoolToString {
	__ := &FuncWorkerOfBoolToString{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfBoolToString, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go BoolToString.CallAsAsync(work.Context, work.WorkOfBoolToString.Value, work.WorkOfBoolToString.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				BoolToString.PutWork(work.WorkOfBoolToString)
				BoolToString.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfBoolToString) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := BoolToString.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfBoolToString) Push(ctx context.Context, value bool, returnCh chan<- *ReturnOfString) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := BoolToString.GetWorkContextWith(ctx, BoolToString.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfBoolToString) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfBoolToString) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfBoolToUint struct {
	handler func(context.Context, bool) (uint, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfBoolToUint
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfBoolToUint(ctx context.Context, h func(context.Context, bool) (uint, error), n int) *FuncWorkerOfBoolToUint {
	__ := &FuncWorkerOfBoolToUint{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfBoolToUint, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go BoolToUint.CallAsAsync(work.Context, work.WorkOfBoolToUint.Value, work.WorkOfBoolToUint.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				BoolToUint.PutWork(work.WorkOfBoolToUint)
				BoolToUint.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfBoolToUint) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := BoolToUint.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfBoolToUint) Push(ctx context.Context, value bool, returnCh chan<- *ReturnOfUint) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := BoolToUint.GetWorkContextWith(ctx, BoolToUint.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfBoolToUint) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfBoolToUint) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfBoolToUint16 struct {
	handler func(context.Context, bool) (uint16, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfBoolToUint16
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfBoolToUint16(ctx context.Context, h func(context.Context, bool) (uint16, error), n int) *FuncWorkerOfBoolToUint16 {
	__ := &FuncWorkerOfBoolToUint16{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfBoolToUint16, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go BoolToUint16.CallAsAsync(work.Context, work.WorkOfBoolToUint16.Value, work.WorkOfBoolToUint16.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				BoolToUint16.PutWork(work.WorkOfBoolToUint16)
				BoolToUint16.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfBoolToUint16) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := BoolToUint16.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfBoolToUint16) Push(ctx context.Context, value bool, returnCh chan<- *ReturnOfUint16) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := BoolToUint16.GetWorkContextWith(ctx, BoolToUint16.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfBoolToUint16) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfBoolToUint16) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfBoolToUint32 struct {
	handler func(context.Context, bool) (uint32, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfBoolToUint32
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfBoolToUint32(ctx context.Context, h func(context.Context, bool) (uint32, error), n int) *FuncWorkerOfBoolToUint32 {
	__ := &FuncWorkerOfBoolToUint32{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfBoolToUint32, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go BoolToUint32.CallAsAsync(work.Context, work.WorkOfBoolToUint32.Value, work.WorkOfBoolToUint32.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				BoolToUint32.PutWork(work.WorkOfBoolToUint32)
				BoolToUint32.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfBoolToUint32) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := BoolToUint32.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfBoolToUint32) Push(ctx context.Context, value bool, returnCh chan<- *ReturnOfUint32) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := BoolToUint32.GetWorkContextWith(ctx, BoolToUint32.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfBoolToUint32) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfBoolToUint32) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfBoolToUint64 struct {
	handler func(context.Context, bool) (uint64, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfBoolToUint64
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfBoolToUint64(ctx context.Context, h func(context.Context, bool) (uint64, error), n int) *FuncWorkerOfBoolToUint64 {
	__ := &FuncWorkerOfBoolToUint64{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfBoolToUint64, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go BoolToUint64.CallAsAsync(work.Context, work.WorkOfBoolToUint64.Value, work.WorkOfBoolToUint64.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				BoolToUint64.PutWork(work.WorkOfBoolToUint64)
				BoolToUint64.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfBoolToUint64) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := BoolToUint64.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfBoolToUint64) Push(ctx context.Context, value bool, returnCh chan<- *ReturnOfUint64) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := BoolToUint64.GetWorkContextWith(ctx, BoolToUint64.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfBoolToUint64) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfBoolToUint64) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfBoolToUint8 struct {
	handler func(context.Context, bool) (uint8, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfBoolToUint8
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfBoolToUint8(ctx context.Context, h func(context.Context, bool) (uint8, error), n int) *FuncWorkerOfBoolToUint8 {
	__ := &FuncWorkerOfBoolToUint8{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfBoolToUint8, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go BoolToUint8.CallAsAsync(work.Context, work.WorkOfBoolToUint8.Value, work.WorkOfBoolToUint8.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				BoolToUint8.PutWork(work.WorkOfBoolToUint8)
				BoolToUint8.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfBoolToUint8) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := BoolToUint8.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfBoolToUint8) Push(ctx context.Context, value bool, returnCh chan<- *ReturnOfUint8) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := BoolToUint8.GetWorkContextWith(ctx, BoolToUint8.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfBoolToUint8) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfBoolToUint8) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfBoolToUintptr struct {
	handler func(context.Context, bool) (uintptr, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfBoolToUintptr
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfBoolToUintptr(ctx context.Context, h func(context.Context, bool) (uintptr, error), n int) *FuncWorkerOfBoolToUintptr {
	__ := &FuncWorkerOfBoolToUintptr{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfBoolToUintptr, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go BoolToUintptr.CallAsAsync(work.Context, work.WorkOfBoolToUintptr.Value, work.WorkOfBoolToUintptr.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				BoolToUintptr.PutWork(work.WorkOfBoolToUintptr)
				BoolToUintptr.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfBoolToUintptr) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := BoolToUintptr.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfBoolToUintptr) Push(ctx context.Context, value bool, returnCh chan<- *ReturnOfUintptr) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := BoolToUintptr.GetWorkContextWith(ctx, BoolToUintptr.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfBoolToUintptr) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfBoolToUintptr) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfBoolToBytes struct {
	handler func(context.Context, bool) (Bytes, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfBoolToBytes
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfBoolToBytes(ctx context.Context, h func(context.Context, bool) (Bytes, error), n int) *FuncWorkerOfBoolToBytes {
	__ := &FuncWorkerOfBoolToBytes{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfBoolToBytes, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go BoolToBytes.CallAsAsync(work.Context, work.WorkOfBoolToBytes.Value, work.WorkOfBoolToBytes.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				BoolToBytes.PutWork(work.WorkOfBoolToBytes)
				BoolToBytes.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfBoolToBytes) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := BoolToBytes.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfBoolToBytes) Push(ctx context.Context, value bool, returnCh chan<- *ReturnOfBytes) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := BoolToBytes.GetWorkContextWith(ctx, BoolToBytes.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfBoolToBytes) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfBoolToBytes) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfBoolToInterface struct {
	handler func(context.Context, bool) (interface{}, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfBoolToInterface
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfBoolToInterface(ctx context.Context, h func(context.Context, bool) (interface{}, error), n int) *FuncWorkerOfBoolToInterface {
	__ := &FuncWorkerOfBoolToInterface{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfBoolToInterface, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go BoolToInterface.CallAsAsync(work.Context, work.WorkOfBoolToInterface.Value, work.WorkOfBoolToInterface.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				BoolToInterface.PutWork(work.WorkOfBoolToInterface)
				BoolToInterface.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfBoolToInterface) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := BoolToInterface.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfBoolToInterface) Push(ctx context.Context, value bool, returnCh chan<- *ReturnOfInterface) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := BoolToInterface.GetWorkContextWith(ctx, BoolToInterface.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfBoolToInterface) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfBoolToInterface) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfByteToBool struct {
	handler func(context.Context, byte) (bool, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfByteToBool
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfByteToBool(ctx context.Context, h func(context.Context, byte) (bool, error), n int) *FuncWorkerOfByteToBool {
	__ := &FuncWorkerOfByteToBool{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfByteToBool, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go ByteToBool.CallAsAsync(work.Context, work.WorkOfByteToBool.Value, work.WorkOfByteToBool.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				ByteToBool.PutWork(work.WorkOfByteToBool)
				ByteToBool.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfByteToBool) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := ByteToBool.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfByteToBool) Push(ctx context.Context, value byte, returnCh chan<- *ReturnOfBool) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := ByteToBool.GetWorkContextWith(ctx, ByteToBool.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfByteToBool) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfByteToBool) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfByteToByte struct {
	handler func(context.Context, byte) (byte, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfByteToByte
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfByteToByte(ctx context.Context, h func(context.Context, byte) (byte, error), n int) *FuncWorkerOfByteToByte {
	__ := &FuncWorkerOfByteToByte{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfByteToByte, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go ByteToByte.CallAsAsync(work.Context, work.WorkOfByteToByte.Value, work.WorkOfByteToByte.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				ByteToByte.PutWork(work.WorkOfByteToByte)
				ByteToByte.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfByteToByte) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := ByteToByte.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfByteToByte) Push(ctx context.Context, value byte, returnCh chan<- *ReturnOfByte) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := ByteToByte.GetWorkContextWith(ctx, ByteToByte.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfByteToByte) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfByteToByte) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfByteToComplex128 struct {
	handler func(context.Context, byte) (complex128, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfByteToComplex128
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfByteToComplex128(ctx context.Context, h func(context.Context, byte) (complex128, error), n int) *FuncWorkerOfByteToComplex128 {
	__ := &FuncWorkerOfByteToComplex128{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfByteToComplex128, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go ByteToComplex128.CallAsAsync(work.Context, work.WorkOfByteToComplex128.Value, work.WorkOfByteToComplex128.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				ByteToComplex128.PutWork(work.WorkOfByteToComplex128)
				ByteToComplex128.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfByteToComplex128) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := ByteToComplex128.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfByteToComplex128) Push(ctx context.Context, value byte, returnCh chan<- *ReturnOfComplex128) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := ByteToComplex128.GetWorkContextWith(ctx, ByteToComplex128.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfByteToComplex128) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfByteToComplex128) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfByteToComplex64 struct {
	handler func(context.Context, byte) (complex64, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfByteToComplex64
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfByteToComplex64(ctx context.Context, h func(context.Context, byte) (complex64, error), n int) *FuncWorkerOfByteToComplex64 {
	__ := &FuncWorkerOfByteToComplex64{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfByteToComplex64, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go ByteToComplex64.CallAsAsync(work.Context, work.WorkOfByteToComplex64.Value, work.WorkOfByteToComplex64.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				ByteToComplex64.PutWork(work.WorkOfByteToComplex64)
				ByteToComplex64.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfByteToComplex64) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := ByteToComplex64.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfByteToComplex64) Push(ctx context.Context, value byte, returnCh chan<- *ReturnOfComplex64) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := ByteToComplex64.GetWorkContextWith(ctx, ByteToComplex64.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfByteToComplex64) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfByteToComplex64) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfByteToError struct {
	handler func(context.Context, byte) (error, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfByteToError
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfByteToError(ctx context.Context, h func(context.Context, byte) (error, error), n int) *FuncWorkerOfByteToError {
	__ := &FuncWorkerOfByteToError{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfByteToError, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go ByteToError.CallAsAsync(work.Context, work.WorkOfByteToError.Value, work.WorkOfByteToError.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				ByteToError.PutWork(work.WorkOfByteToError)
				ByteToError.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfByteToError) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := ByteToError.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfByteToError) Push(ctx context.Context, value byte, returnCh chan<- *ReturnOfError) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := ByteToError.GetWorkContextWith(ctx, ByteToError.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfByteToError) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfByteToError) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfByteToFloat32 struct {
	handler func(context.Context, byte) (float32, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfByteToFloat32
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfByteToFloat32(ctx context.Context, h func(context.Context, byte) (float32, error), n int) *FuncWorkerOfByteToFloat32 {
	__ := &FuncWorkerOfByteToFloat32{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfByteToFloat32, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go ByteToFloat32.CallAsAsync(work.Context, work.WorkOfByteToFloat32.Value, work.WorkOfByteToFloat32.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				ByteToFloat32.PutWork(work.WorkOfByteToFloat32)
				ByteToFloat32.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfByteToFloat32) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := ByteToFloat32.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfByteToFloat32) Push(ctx context.Context, value byte, returnCh chan<- *ReturnOfFloat32) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := ByteToFloat32.GetWorkContextWith(ctx, ByteToFloat32.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfByteToFloat32) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfByteToFloat32) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfByteToFloat64 struct {
	handler func(context.Context, byte) (float64, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfByteToFloat64
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfByteToFloat64(ctx context.Context, h func(context.Context, byte) (float64, error), n int) *FuncWorkerOfByteToFloat64 {
	__ := &FuncWorkerOfByteToFloat64{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfByteToFloat64, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go ByteToFloat64.CallAsAsync(work.Context, work.WorkOfByteToFloat64.Value, work.WorkOfByteToFloat64.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				ByteToFloat64.PutWork(work.WorkOfByteToFloat64)
				ByteToFloat64.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfByteToFloat64) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := ByteToFloat64.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfByteToFloat64) Push(ctx context.Context, value byte, returnCh chan<- *ReturnOfFloat64) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := ByteToFloat64.GetWorkContextWith(ctx, ByteToFloat64.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfByteToFloat64) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfByteToFloat64) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfByteToInt struct {
	handler func(context.Context, byte) (int, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfByteToInt
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfByteToInt(ctx context.Context, h func(context.Context, byte) (int, error), n int) *FuncWorkerOfByteToInt {
	__ := &FuncWorkerOfByteToInt{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfByteToInt, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go ByteToInt.CallAsAsync(work.Context, work.WorkOfByteToInt.Value, work.WorkOfByteToInt.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				ByteToInt.PutWork(work.WorkOfByteToInt)
				ByteToInt.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfByteToInt) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := ByteToInt.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfByteToInt) Push(ctx context.Context, value byte, returnCh chan<- *ReturnOfInt) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := ByteToInt.GetWorkContextWith(ctx, ByteToInt.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfByteToInt) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfByteToInt) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfByteToInt16 struct {
	handler func(context.Context, byte) (int16, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfByteToInt16
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfByteToInt16(ctx context.Context, h func(context.Context, byte) (int16, error), n int) *FuncWorkerOfByteToInt16 {
	__ := &FuncWorkerOfByteToInt16{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfByteToInt16, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go ByteToInt16.CallAsAsync(work.Context, work.WorkOfByteToInt16.Value, work.WorkOfByteToInt16.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				ByteToInt16.PutWork(work.WorkOfByteToInt16)
				ByteToInt16.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfByteToInt16) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := ByteToInt16.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfByteToInt16) Push(ctx context.Context, value byte, returnCh chan<- *ReturnOfInt16) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := ByteToInt16.GetWorkContextWith(ctx, ByteToInt16.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfByteToInt16) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfByteToInt16) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfByteToInt32 struct {
	handler func(context.Context, byte) (int32, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfByteToInt32
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfByteToInt32(ctx context.Context, h func(context.Context, byte) (int32, error), n int) *FuncWorkerOfByteToInt32 {
	__ := &FuncWorkerOfByteToInt32{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfByteToInt32, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go ByteToInt32.CallAsAsync(work.Context, work.WorkOfByteToInt32.Value, work.WorkOfByteToInt32.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				ByteToInt32.PutWork(work.WorkOfByteToInt32)
				ByteToInt32.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfByteToInt32) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := ByteToInt32.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfByteToInt32) Push(ctx context.Context, value byte, returnCh chan<- *ReturnOfInt32) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := ByteToInt32.GetWorkContextWith(ctx, ByteToInt32.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfByteToInt32) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfByteToInt32) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfByteToInt64 struct {
	handler func(context.Context, byte) (int64, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfByteToInt64
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfByteToInt64(ctx context.Context, h func(context.Context, byte) (int64, error), n int) *FuncWorkerOfByteToInt64 {
	__ := &FuncWorkerOfByteToInt64{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfByteToInt64, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go ByteToInt64.CallAsAsync(work.Context, work.WorkOfByteToInt64.Value, work.WorkOfByteToInt64.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				ByteToInt64.PutWork(work.WorkOfByteToInt64)
				ByteToInt64.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfByteToInt64) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := ByteToInt64.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfByteToInt64) Push(ctx context.Context, value byte, returnCh chan<- *ReturnOfInt64) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := ByteToInt64.GetWorkContextWith(ctx, ByteToInt64.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfByteToInt64) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfByteToInt64) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfByteToInt8 struct {
	handler func(context.Context, byte) (int8, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfByteToInt8
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfByteToInt8(ctx context.Context, h func(context.Context, byte) (int8, error), n int) *FuncWorkerOfByteToInt8 {
	__ := &FuncWorkerOfByteToInt8{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfByteToInt8, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go ByteToInt8.CallAsAsync(work.Context, work.WorkOfByteToInt8.Value, work.WorkOfByteToInt8.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				ByteToInt8.PutWork(work.WorkOfByteToInt8)
				ByteToInt8.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfByteToInt8) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := ByteToInt8.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfByteToInt8) Push(ctx context.Context, value byte, returnCh chan<- *ReturnOfInt8) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := ByteToInt8.GetWorkContextWith(ctx, ByteToInt8.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfByteToInt8) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfByteToInt8) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfByteToRune struct {
	handler func(context.Context, byte) (rune, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfByteToRune
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfByteToRune(ctx context.Context, h func(context.Context, byte) (rune, error), n int) *FuncWorkerOfByteToRune {
	__ := &FuncWorkerOfByteToRune{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfByteToRune, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go ByteToRune.CallAsAsync(work.Context, work.WorkOfByteToRune.Value, work.WorkOfByteToRune.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				ByteToRune.PutWork(work.WorkOfByteToRune)
				ByteToRune.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfByteToRune) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := ByteToRune.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfByteToRune) Push(ctx context.Context, value byte, returnCh chan<- *ReturnOfRune) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := ByteToRune.GetWorkContextWith(ctx, ByteToRune.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfByteToRune) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfByteToRune) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfByteToString struct {
	handler func(context.Context, byte) (string, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfByteToString
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfByteToString(ctx context.Context, h func(context.Context, byte) (string, error), n int) *FuncWorkerOfByteToString {
	__ := &FuncWorkerOfByteToString{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfByteToString, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go ByteToString.CallAsAsync(work.Context, work.WorkOfByteToString.Value, work.WorkOfByteToString.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				ByteToString.PutWork(work.WorkOfByteToString)
				ByteToString.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfByteToString) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := ByteToString.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfByteToString) Push(ctx context.Context, value byte, returnCh chan<- *ReturnOfString) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := ByteToString.GetWorkContextWith(ctx, ByteToString.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfByteToString) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfByteToString) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfByteToUint struct {
	handler func(context.Context, byte) (uint, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfByteToUint
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfByteToUint(ctx context.Context, h func(context.Context, byte) (uint, error), n int) *FuncWorkerOfByteToUint {
	__ := &FuncWorkerOfByteToUint{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfByteToUint, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go ByteToUint.CallAsAsync(work.Context, work.WorkOfByteToUint.Value, work.WorkOfByteToUint.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				ByteToUint.PutWork(work.WorkOfByteToUint)
				ByteToUint.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfByteToUint) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := ByteToUint.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfByteToUint) Push(ctx context.Context, value byte, returnCh chan<- *ReturnOfUint) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := ByteToUint.GetWorkContextWith(ctx, ByteToUint.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfByteToUint) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfByteToUint) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfByteToUint16 struct {
	handler func(context.Context, byte) (uint16, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfByteToUint16
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfByteToUint16(ctx context.Context, h func(context.Context, byte) (uint16, error), n int) *FuncWorkerOfByteToUint16 {
	__ := &FuncWorkerOfByteToUint16{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfByteToUint16, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go ByteToUint16.CallAsAsync(work.Context, work.WorkOfByteToUint16.Value, work.WorkOfByteToUint16.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				ByteToUint16.PutWork(work.WorkOfByteToUint16)
				ByteToUint16.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfByteToUint16) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := ByteToUint16.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfByteToUint16) Push(ctx context.Context, value byte, returnCh chan<- *ReturnOfUint16) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := ByteToUint16.GetWorkContextWith(ctx, ByteToUint16.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfByteToUint16) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfByteToUint16) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfByteToUint32 struct {
	handler func(context.Context, byte) (uint32, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfByteToUint32
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfByteToUint32(ctx context.Context, h func(context.Context, byte) (uint32, error), n int) *FuncWorkerOfByteToUint32 {
	__ := &FuncWorkerOfByteToUint32{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfByteToUint32, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go ByteToUint32.CallAsAsync(work.Context, work.WorkOfByteToUint32.Value, work.WorkOfByteToUint32.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				ByteToUint32.PutWork(work.WorkOfByteToUint32)
				ByteToUint32.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfByteToUint32) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := ByteToUint32.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfByteToUint32) Push(ctx context.Context, value byte, returnCh chan<- *ReturnOfUint32) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := ByteToUint32.GetWorkContextWith(ctx, ByteToUint32.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfByteToUint32) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfByteToUint32) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfByteToUint64 struct {
	handler func(context.Context, byte) (uint64, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfByteToUint64
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfByteToUint64(ctx context.Context, h func(context.Context, byte) (uint64, error), n int) *FuncWorkerOfByteToUint64 {
	__ := &FuncWorkerOfByteToUint64{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfByteToUint64, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go ByteToUint64.CallAsAsync(work.Context, work.WorkOfByteToUint64.Value, work.WorkOfByteToUint64.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				ByteToUint64.PutWork(work.WorkOfByteToUint64)
				ByteToUint64.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfByteToUint64) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := ByteToUint64.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfByteToUint64) Push(ctx context.Context, value byte, returnCh chan<- *ReturnOfUint64) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := ByteToUint64.GetWorkContextWith(ctx, ByteToUint64.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfByteToUint64) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfByteToUint64) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfByteToUint8 struct {
	handler func(context.Context, byte) (uint8, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfByteToUint8
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfByteToUint8(ctx context.Context, h func(context.Context, byte) (uint8, error), n int) *FuncWorkerOfByteToUint8 {
	__ := &FuncWorkerOfByteToUint8{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfByteToUint8, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go ByteToUint8.CallAsAsync(work.Context, work.WorkOfByteToUint8.Value, work.WorkOfByteToUint8.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				ByteToUint8.PutWork(work.WorkOfByteToUint8)
				ByteToUint8.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfByteToUint8) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := ByteToUint8.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfByteToUint8) Push(ctx context.Context, value byte, returnCh chan<- *ReturnOfUint8) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := ByteToUint8.GetWorkContextWith(ctx, ByteToUint8.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfByteToUint8) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfByteToUint8) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfByteToUintptr struct {
	handler func(context.Context, byte) (uintptr, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfByteToUintptr
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfByteToUintptr(ctx context.Context, h func(context.Context, byte) (uintptr, error), n int) *FuncWorkerOfByteToUintptr {
	__ := &FuncWorkerOfByteToUintptr{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfByteToUintptr, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go ByteToUintptr.CallAsAsync(work.Context, work.WorkOfByteToUintptr.Value, work.WorkOfByteToUintptr.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				ByteToUintptr.PutWork(work.WorkOfByteToUintptr)
				ByteToUintptr.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfByteToUintptr) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := ByteToUintptr.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfByteToUintptr) Push(ctx context.Context, value byte, returnCh chan<- *ReturnOfUintptr) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := ByteToUintptr.GetWorkContextWith(ctx, ByteToUintptr.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfByteToUintptr) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfByteToUintptr) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfByteToBytes struct {
	handler func(context.Context, byte) (Bytes, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfByteToBytes
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfByteToBytes(ctx context.Context, h func(context.Context, byte) (Bytes, error), n int) *FuncWorkerOfByteToBytes {
	__ := &FuncWorkerOfByteToBytes{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfByteToBytes, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go ByteToBytes.CallAsAsync(work.Context, work.WorkOfByteToBytes.Value, work.WorkOfByteToBytes.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				ByteToBytes.PutWork(work.WorkOfByteToBytes)
				ByteToBytes.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfByteToBytes) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := ByteToBytes.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfByteToBytes) Push(ctx context.Context, value byte, returnCh chan<- *ReturnOfBytes) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := ByteToBytes.GetWorkContextWith(ctx, ByteToBytes.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfByteToBytes) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfByteToBytes) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfByteToInterface struct {
	handler func(context.Context, byte) (interface{}, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfByteToInterface
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfByteToInterface(ctx context.Context, h func(context.Context, byte) (interface{}, error), n int) *FuncWorkerOfByteToInterface {
	__ := &FuncWorkerOfByteToInterface{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfByteToInterface, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go ByteToInterface.CallAsAsync(work.Context, work.WorkOfByteToInterface.Value, work.WorkOfByteToInterface.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				ByteToInterface.PutWork(work.WorkOfByteToInterface)
				ByteToInterface.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfByteToInterface) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := ByteToInterface.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfByteToInterface) Push(ctx context.Context, value byte, returnCh chan<- *ReturnOfInterface) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := ByteToInterface.GetWorkContextWith(ctx, ByteToInterface.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfByteToInterface) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfByteToInterface) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfComplex128ToBool struct {
	handler func(context.Context, complex128) (bool, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfComplex128ToBool
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfComplex128ToBool(ctx context.Context, h func(context.Context, complex128) (bool, error), n int) *FuncWorkerOfComplex128ToBool {
	__ := &FuncWorkerOfComplex128ToBool{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfComplex128ToBool, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go Complex128ToBool.CallAsAsync(work.Context, work.WorkOfComplex128ToBool.Value, work.WorkOfComplex128ToBool.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				Complex128ToBool.PutWork(work.WorkOfComplex128ToBool)
				Complex128ToBool.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfComplex128ToBool) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := Complex128ToBool.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfComplex128ToBool) Push(ctx context.Context, value complex128, returnCh chan<- *ReturnOfBool) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := Complex128ToBool.GetWorkContextWith(ctx, Complex128ToBool.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfComplex128ToBool) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfComplex128ToBool) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfComplex128ToByte struct {
	handler func(context.Context, complex128) (byte, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfComplex128ToByte
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfComplex128ToByte(ctx context.Context, h func(context.Context, complex128) (byte, error), n int) *FuncWorkerOfComplex128ToByte {
	__ := &FuncWorkerOfComplex128ToByte{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfComplex128ToByte, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go Complex128ToByte.CallAsAsync(work.Context, work.WorkOfComplex128ToByte.Value, work.WorkOfComplex128ToByte.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				Complex128ToByte.PutWork(work.WorkOfComplex128ToByte)
				Complex128ToByte.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfComplex128ToByte) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := Complex128ToByte.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfComplex128ToByte) Push(ctx context.Context, value complex128, returnCh chan<- *ReturnOfByte) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := Complex128ToByte.GetWorkContextWith(ctx, Complex128ToByte.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfComplex128ToByte) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfComplex128ToByte) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfComplex128ToComplex128 struct {
	handler func(context.Context, complex128) (complex128, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfComplex128ToComplex128
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfComplex128ToComplex128(ctx context.Context, h func(context.Context, complex128) (complex128, error), n int) *FuncWorkerOfComplex128ToComplex128 {
	__ := &FuncWorkerOfComplex128ToComplex128{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfComplex128ToComplex128, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go Complex128ToComplex128.CallAsAsync(work.Context, work.WorkOfComplex128ToComplex128.Value, work.WorkOfComplex128ToComplex128.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				Complex128ToComplex128.PutWork(work.WorkOfComplex128ToComplex128)
				Complex128ToComplex128.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfComplex128ToComplex128) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := Complex128ToComplex128.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfComplex128ToComplex128) Push(ctx context.Context, value complex128, returnCh chan<- *ReturnOfComplex128) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := Complex128ToComplex128.GetWorkContextWith(ctx, Complex128ToComplex128.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfComplex128ToComplex128) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfComplex128ToComplex128) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfComplex128ToComplex64 struct {
	handler func(context.Context, complex128) (complex64, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfComplex128ToComplex64
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfComplex128ToComplex64(ctx context.Context, h func(context.Context, complex128) (complex64, error), n int) *FuncWorkerOfComplex128ToComplex64 {
	__ := &FuncWorkerOfComplex128ToComplex64{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfComplex128ToComplex64, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go Complex128ToComplex64.CallAsAsync(work.Context, work.WorkOfComplex128ToComplex64.Value, work.WorkOfComplex128ToComplex64.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				Complex128ToComplex64.PutWork(work.WorkOfComplex128ToComplex64)
				Complex128ToComplex64.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfComplex128ToComplex64) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := Complex128ToComplex64.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfComplex128ToComplex64) Push(ctx context.Context, value complex128, returnCh chan<- *ReturnOfComplex64) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := Complex128ToComplex64.GetWorkContextWith(ctx, Complex128ToComplex64.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfComplex128ToComplex64) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfComplex128ToComplex64) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfComplex128ToError struct {
	handler func(context.Context, complex128) (error, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfComplex128ToError
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfComplex128ToError(ctx context.Context, h func(context.Context, complex128) (error, error), n int) *FuncWorkerOfComplex128ToError {
	__ := &FuncWorkerOfComplex128ToError{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfComplex128ToError, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go Complex128ToError.CallAsAsync(work.Context, work.WorkOfComplex128ToError.Value, work.WorkOfComplex128ToError.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				Complex128ToError.PutWork(work.WorkOfComplex128ToError)
				Complex128ToError.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfComplex128ToError) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := Complex128ToError.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfComplex128ToError) Push(ctx context.Context, value complex128, returnCh chan<- *ReturnOfError) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := Complex128ToError.GetWorkContextWith(ctx, Complex128ToError.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfComplex128ToError) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfComplex128ToError) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfComplex128ToFloat32 struct {
	handler func(context.Context, complex128) (float32, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfComplex128ToFloat32
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfComplex128ToFloat32(ctx context.Context, h func(context.Context, complex128) (float32, error), n int) *FuncWorkerOfComplex128ToFloat32 {
	__ := &FuncWorkerOfComplex128ToFloat32{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfComplex128ToFloat32, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go Complex128ToFloat32.CallAsAsync(work.Context, work.WorkOfComplex128ToFloat32.Value, work.WorkOfComplex128ToFloat32.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				Complex128ToFloat32.PutWork(work.WorkOfComplex128ToFloat32)
				Complex128ToFloat32.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfComplex128ToFloat32) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := Complex128ToFloat32.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfComplex128ToFloat32) Push(ctx context.Context, value complex128, returnCh chan<- *ReturnOfFloat32) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := Complex128ToFloat32.GetWorkContextWith(ctx, Complex128ToFloat32.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfComplex128ToFloat32) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfComplex128ToFloat32) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfComplex128ToFloat64 struct {
	handler func(context.Context, complex128) (float64, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfComplex128ToFloat64
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfComplex128ToFloat64(ctx context.Context, h func(context.Context, complex128) (float64, error), n int) *FuncWorkerOfComplex128ToFloat64 {
	__ := &FuncWorkerOfComplex128ToFloat64{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfComplex128ToFloat64, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go Complex128ToFloat64.CallAsAsync(work.Context, work.WorkOfComplex128ToFloat64.Value, work.WorkOfComplex128ToFloat64.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				Complex128ToFloat64.PutWork(work.WorkOfComplex128ToFloat64)
				Complex128ToFloat64.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfComplex128ToFloat64) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := Complex128ToFloat64.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfComplex128ToFloat64) Push(ctx context.Context, value complex128, returnCh chan<- *ReturnOfFloat64) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := Complex128ToFloat64.GetWorkContextWith(ctx, Complex128ToFloat64.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfComplex128ToFloat64) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfComplex128ToFloat64) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfComplex128ToInt struct {
	handler func(context.Context, complex128) (int, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfComplex128ToInt
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfComplex128ToInt(ctx context.Context, h func(context.Context, complex128) (int, error), n int) *FuncWorkerOfComplex128ToInt {
	__ := &FuncWorkerOfComplex128ToInt{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfComplex128ToInt, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go Complex128ToInt.CallAsAsync(work.Context, work.WorkOfComplex128ToInt.Value, work.WorkOfComplex128ToInt.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				Complex128ToInt.PutWork(work.WorkOfComplex128ToInt)
				Complex128ToInt.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfComplex128ToInt) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := Complex128ToInt.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfComplex128ToInt) Push(ctx context.Context, value complex128, returnCh chan<- *ReturnOfInt) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := Complex128ToInt.GetWorkContextWith(ctx, Complex128ToInt.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfComplex128ToInt) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfComplex128ToInt) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfComplex128ToInt16 struct {
	handler func(context.Context, complex128) (int16, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfComplex128ToInt16
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfComplex128ToInt16(ctx context.Context, h func(context.Context, complex128) (int16, error), n int) *FuncWorkerOfComplex128ToInt16 {
	__ := &FuncWorkerOfComplex128ToInt16{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfComplex128ToInt16, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go Complex128ToInt16.CallAsAsync(work.Context, work.WorkOfComplex128ToInt16.Value, work.WorkOfComplex128ToInt16.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				Complex128ToInt16.PutWork(work.WorkOfComplex128ToInt16)
				Complex128ToInt16.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfComplex128ToInt16) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := Complex128ToInt16.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfComplex128ToInt16) Push(ctx context.Context, value complex128, returnCh chan<- *ReturnOfInt16) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := Complex128ToInt16.GetWorkContextWith(ctx, Complex128ToInt16.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfComplex128ToInt16) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfComplex128ToInt16) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfComplex128ToInt32 struct {
	handler func(context.Context, complex128) (int32, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfComplex128ToInt32
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfComplex128ToInt32(ctx context.Context, h func(context.Context, complex128) (int32, error), n int) *FuncWorkerOfComplex128ToInt32 {
	__ := &FuncWorkerOfComplex128ToInt32{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfComplex128ToInt32, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go Complex128ToInt32.CallAsAsync(work.Context, work.WorkOfComplex128ToInt32.Value, work.WorkOfComplex128ToInt32.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				Complex128ToInt32.PutWork(work.WorkOfComplex128ToInt32)
				Complex128ToInt32.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfComplex128ToInt32) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := Complex128ToInt32.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfComplex128ToInt32) Push(ctx context.Context, value complex128, returnCh chan<- *ReturnOfInt32) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := Complex128ToInt32.GetWorkContextWith(ctx, Complex128ToInt32.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfComplex128ToInt32) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfComplex128ToInt32) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfComplex128ToInt64 struct {
	handler func(context.Context, complex128) (int64, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfComplex128ToInt64
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfComplex128ToInt64(ctx context.Context, h func(context.Context, complex128) (int64, error), n int) *FuncWorkerOfComplex128ToInt64 {
	__ := &FuncWorkerOfComplex128ToInt64{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfComplex128ToInt64, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go Complex128ToInt64.CallAsAsync(work.Context, work.WorkOfComplex128ToInt64.Value, work.WorkOfComplex128ToInt64.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				Complex128ToInt64.PutWork(work.WorkOfComplex128ToInt64)
				Complex128ToInt64.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfComplex128ToInt64) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := Complex128ToInt64.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfComplex128ToInt64) Push(ctx context.Context, value complex128, returnCh chan<- *ReturnOfInt64) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := Complex128ToInt64.GetWorkContextWith(ctx, Complex128ToInt64.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfComplex128ToInt64) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfComplex128ToInt64) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfComplex128ToInt8 struct {
	handler func(context.Context, complex128) (int8, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfComplex128ToInt8
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfComplex128ToInt8(ctx context.Context, h func(context.Context, complex128) (int8, error), n int) *FuncWorkerOfComplex128ToInt8 {
	__ := &FuncWorkerOfComplex128ToInt8{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfComplex128ToInt8, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go Complex128ToInt8.CallAsAsync(work.Context, work.WorkOfComplex128ToInt8.Value, work.WorkOfComplex128ToInt8.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				Complex128ToInt8.PutWork(work.WorkOfComplex128ToInt8)
				Complex128ToInt8.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfComplex128ToInt8) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := Complex128ToInt8.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfComplex128ToInt8) Push(ctx context.Context, value complex128, returnCh chan<- *ReturnOfInt8) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := Complex128ToInt8.GetWorkContextWith(ctx, Complex128ToInt8.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfComplex128ToInt8) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfComplex128ToInt8) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfComplex128ToRune struct {
	handler func(context.Context, complex128) (rune, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfComplex128ToRune
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfComplex128ToRune(ctx context.Context, h func(context.Context, complex128) (rune, error), n int) *FuncWorkerOfComplex128ToRune {
	__ := &FuncWorkerOfComplex128ToRune{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfComplex128ToRune, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go Complex128ToRune.CallAsAsync(work.Context, work.WorkOfComplex128ToRune.Value, work.WorkOfComplex128ToRune.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				Complex128ToRune.PutWork(work.WorkOfComplex128ToRune)
				Complex128ToRune.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfComplex128ToRune) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := Complex128ToRune.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfComplex128ToRune) Push(ctx context.Context, value complex128, returnCh chan<- *ReturnOfRune) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := Complex128ToRune.GetWorkContextWith(ctx, Complex128ToRune.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfComplex128ToRune) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfComplex128ToRune) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfComplex128ToString struct {
	handler func(context.Context, complex128) (string, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfComplex128ToString
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfComplex128ToString(ctx context.Context, h func(context.Context, complex128) (string, error), n int) *FuncWorkerOfComplex128ToString {
	__ := &FuncWorkerOfComplex128ToString{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfComplex128ToString, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go Complex128ToString.CallAsAsync(work.Context, work.WorkOfComplex128ToString.Value, work.WorkOfComplex128ToString.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				Complex128ToString.PutWork(work.WorkOfComplex128ToString)
				Complex128ToString.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfComplex128ToString) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := Complex128ToString.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfComplex128ToString) Push(ctx context.Context, value complex128, returnCh chan<- *ReturnOfString) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := Complex128ToString.GetWorkContextWith(ctx, Complex128ToString.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfComplex128ToString) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfComplex128ToString) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfComplex128ToUint struct {
	handler func(context.Context, complex128) (uint, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfComplex128ToUint
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfComplex128ToUint(ctx context.Context, h func(context.Context, complex128) (uint, error), n int) *FuncWorkerOfComplex128ToUint {
	__ := &FuncWorkerOfComplex128ToUint{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfComplex128ToUint, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go Complex128ToUint.CallAsAsync(work.Context, work.WorkOfComplex128ToUint.Value, work.WorkOfComplex128ToUint.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				Complex128ToUint.PutWork(work.WorkOfComplex128ToUint)
				Complex128ToUint.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfComplex128ToUint) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := Complex128ToUint.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfComplex128ToUint) Push(ctx context.Context, value complex128, returnCh chan<- *ReturnOfUint) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := Complex128ToUint.GetWorkContextWith(ctx, Complex128ToUint.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfComplex128ToUint) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfComplex128ToUint) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfComplex128ToUint16 struct {
	handler func(context.Context, complex128) (uint16, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfComplex128ToUint16
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfComplex128ToUint16(ctx context.Context, h func(context.Context, complex128) (uint16, error), n int) *FuncWorkerOfComplex128ToUint16 {
	__ := &FuncWorkerOfComplex128ToUint16{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfComplex128ToUint16, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go Complex128ToUint16.CallAsAsync(work.Context, work.WorkOfComplex128ToUint16.Value, work.WorkOfComplex128ToUint16.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				Complex128ToUint16.PutWork(work.WorkOfComplex128ToUint16)
				Complex128ToUint16.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfComplex128ToUint16) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := Complex128ToUint16.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfComplex128ToUint16) Push(ctx context.Context, value complex128, returnCh chan<- *ReturnOfUint16) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := Complex128ToUint16.GetWorkContextWith(ctx, Complex128ToUint16.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfComplex128ToUint16) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfComplex128ToUint16) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfComplex128ToUint32 struct {
	handler func(context.Context, complex128) (uint32, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfComplex128ToUint32
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfComplex128ToUint32(ctx context.Context, h func(context.Context, complex128) (uint32, error), n int) *FuncWorkerOfComplex128ToUint32 {
	__ := &FuncWorkerOfComplex128ToUint32{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfComplex128ToUint32, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go Complex128ToUint32.CallAsAsync(work.Context, work.WorkOfComplex128ToUint32.Value, work.WorkOfComplex128ToUint32.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				Complex128ToUint32.PutWork(work.WorkOfComplex128ToUint32)
				Complex128ToUint32.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfComplex128ToUint32) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := Complex128ToUint32.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfComplex128ToUint32) Push(ctx context.Context, value complex128, returnCh chan<- *ReturnOfUint32) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := Complex128ToUint32.GetWorkContextWith(ctx, Complex128ToUint32.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfComplex128ToUint32) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfComplex128ToUint32) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfComplex128ToUint64 struct {
	handler func(context.Context, complex128) (uint64, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfComplex128ToUint64
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfComplex128ToUint64(ctx context.Context, h func(context.Context, complex128) (uint64, error), n int) *FuncWorkerOfComplex128ToUint64 {
	__ := &FuncWorkerOfComplex128ToUint64{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfComplex128ToUint64, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go Complex128ToUint64.CallAsAsync(work.Context, work.WorkOfComplex128ToUint64.Value, work.WorkOfComplex128ToUint64.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				Complex128ToUint64.PutWork(work.WorkOfComplex128ToUint64)
				Complex128ToUint64.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfComplex128ToUint64) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := Complex128ToUint64.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfComplex128ToUint64) Push(ctx context.Context, value complex128, returnCh chan<- *ReturnOfUint64) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := Complex128ToUint64.GetWorkContextWith(ctx, Complex128ToUint64.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfComplex128ToUint64) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfComplex128ToUint64) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfComplex128ToUint8 struct {
	handler func(context.Context, complex128) (uint8, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfComplex128ToUint8
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfComplex128ToUint8(ctx context.Context, h func(context.Context, complex128) (uint8, error), n int) *FuncWorkerOfComplex128ToUint8 {
	__ := &FuncWorkerOfComplex128ToUint8{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfComplex128ToUint8, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go Complex128ToUint8.CallAsAsync(work.Context, work.WorkOfComplex128ToUint8.Value, work.WorkOfComplex128ToUint8.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				Complex128ToUint8.PutWork(work.WorkOfComplex128ToUint8)
				Complex128ToUint8.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfComplex128ToUint8) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := Complex128ToUint8.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfComplex128ToUint8) Push(ctx context.Context, value complex128, returnCh chan<- *ReturnOfUint8) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := Complex128ToUint8.GetWorkContextWith(ctx, Complex128ToUint8.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfComplex128ToUint8) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfComplex128ToUint8) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfComplex128ToUintptr struct {
	handler func(context.Context, complex128) (uintptr, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfComplex128ToUintptr
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfComplex128ToUintptr(ctx context.Context, h func(context.Context, complex128) (uintptr, error), n int) *FuncWorkerOfComplex128ToUintptr {
	__ := &FuncWorkerOfComplex128ToUintptr{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfComplex128ToUintptr, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go Complex128ToUintptr.CallAsAsync(work.Context, work.WorkOfComplex128ToUintptr.Value, work.WorkOfComplex128ToUintptr.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				Complex128ToUintptr.PutWork(work.WorkOfComplex128ToUintptr)
				Complex128ToUintptr.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfComplex128ToUintptr) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := Complex128ToUintptr.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfComplex128ToUintptr) Push(ctx context.Context, value complex128, returnCh chan<- *ReturnOfUintptr) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := Complex128ToUintptr.GetWorkContextWith(ctx, Complex128ToUintptr.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfComplex128ToUintptr) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfComplex128ToUintptr) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfComplex128ToBytes struct {
	handler func(context.Context, complex128) (Bytes, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfComplex128ToBytes
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfComplex128ToBytes(ctx context.Context, h func(context.Context, complex128) (Bytes, error), n int) *FuncWorkerOfComplex128ToBytes {
	__ := &FuncWorkerOfComplex128ToBytes{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfComplex128ToBytes, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go Complex128ToBytes.CallAsAsync(work.Context, work.WorkOfComplex128ToBytes.Value, work.WorkOfComplex128ToBytes.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				Complex128ToBytes.PutWork(work.WorkOfComplex128ToBytes)
				Complex128ToBytes.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfComplex128ToBytes) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := Complex128ToBytes.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfComplex128ToBytes) Push(ctx context.Context, value complex128, returnCh chan<- *ReturnOfBytes) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := Complex128ToBytes.GetWorkContextWith(ctx, Complex128ToBytes.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfComplex128ToBytes) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfComplex128ToBytes) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfComplex128ToInterface struct {
	handler func(context.Context, complex128) (interface{}, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfComplex128ToInterface
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfComplex128ToInterface(ctx context.Context, h func(context.Context, complex128) (interface{}, error), n int) *FuncWorkerOfComplex128ToInterface {
	__ := &FuncWorkerOfComplex128ToInterface{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfComplex128ToInterface, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go Complex128ToInterface.CallAsAsync(work.Context, work.WorkOfComplex128ToInterface.Value, work.WorkOfComplex128ToInterface.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				Complex128ToInterface.PutWork(work.WorkOfComplex128ToInterface)
				Complex128ToInterface.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfComplex128ToInterface) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := Complex128ToInterface.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfComplex128ToInterface) Push(ctx context.Context, value complex128, returnCh chan<- *ReturnOfInterface) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := Complex128ToInterface.GetWorkContextWith(ctx, Complex128ToInterface.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfComplex128ToInterface) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfComplex128ToInterface) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfComplex64ToBool struct {
	handler func(context.Context, complex64) (bool, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfComplex64ToBool
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfComplex64ToBool(ctx context.Context, h func(context.Context, complex64) (bool, error), n int) *FuncWorkerOfComplex64ToBool {
	__ := &FuncWorkerOfComplex64ToBool{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfComplex64ToBool, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go Complex64ToBool.CallAsAsync(work.Context, work.WorkOfComplex64ToBool.Value, work.WorkOfComplex64ToBool.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				Complex64ToBool.PutWork(work.WorkOfComplex64ToBool)
				Complex64ToBool.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfComplex64ToBool) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := Complex64ToBool.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfComplex64ToBool) Push(ctx context.Context, value complex64, returnCh chan<- *ReturnOfBool) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := Complex64ToBool.GetWorkContextWith(ctx, Complex64ToBool.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfComplex64ToBool) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfComplex64ToBool) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfComplex64ToByte struct {
	handler func(context.Context, complex64) (byte, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfComplex64ToByte
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfComplex64ToByte(ctx context.Context, h func(context.Context, complex64) (byte, error), n int) *FuncWorkerOfComplex64ToByte {
	__ := &FuncWorkerOfComplex64ToByte{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfComplex64ToByte, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go Complex64ToByte.CallAsAsync(work.Context, work.WorkOfComplex64ToByte.Value, work.WorkOfComplex64ToByte.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				Complex64ToByte.PutWork(work.WorkOfComplex64ToByte)
				Complex64ToByte.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfComplex64ToByte) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := Complex64ToByte.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfComplex64ToByte) Push(ctx context.Context, value complex64, returnCh chan<- *ReturnOfByte) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := Complex64ToByte.GetWorkContextWith(ctx, Complex64ToByte.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfComplex64ToByte) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfComplex64ToByte) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfComplex64ToComplex128 struct {
	handler func(context.Context, complex64) (complex128, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfComplex64ToComplex128
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfComplex64ToComplex128(ctx context.Context, h func(context.Context, complex64) (complex128, error), n int) *FuncWorkerOfComplex64ToComplex128 {
	__ := &FuncWorkerOfComplex64ToComplex128{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfComplex64ToComplex128, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go Complex64ToComplex128.CallAsAsync(work.Context, work.WorkOfComplex64ToComplex128.Value, work.WorkOfComplex64ToComplex128.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				Complex64ToComplex128.PutWork(work.WorkOfComplex64ToComplex128)
				Complex64ToComplex128.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfComplex64ToComplex128) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := Complex64ToComplex128.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfComplex64ToComplex128) Push(ctx context.Context, value complex64, returnCh chan<- *ReturnOfComplex128) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := Complex64ToComplex128.GetWorkContextWith(ctx, Complex64ToComplex128.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfComplex64ToComplex128) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfComplex64ToComplex128) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfComplex64ToComplex64 struct {
	handler func(context.Context, complex64) (complex64, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfComplex64ToComplex64
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfComplex64ToComplex64(ctx context.Context, h func(context.Context, complex64) (complex64, error), n int) *FuncWorkerOfComplex64ToComplex64 {
	__ := &FuncWorkerOfComplex64ToComplex64{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfComplex64ToComplex64, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go Complex64ToComplex64.CallAsAsync(work.Context, work.WorkOfComplex64ToComplex64.Value, work.WorkOfComplex64ToComplex64.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				Complex64ToComplex64.PutWork(work.WorkOfComplex64ToComplex64)
				Complex64ToComplex64.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfComplex64ToComplex64) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := Complex64ToComplex64.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfComplex64ToComplex64) Push(ctx context.Context, value complex64, returnCh chan<- *ReturnOfComplex64) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := Complex64ToComplex64.GetWorkContextWith(ctx, Complex64ToComplex64.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfComplex64ToComplex64) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfComplex64ToComplex64) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfComplex64ToError struct {
	handler func(context.Context, complex64) (error, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfComplex64ToError
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfComplex64ToError(ctx context.Context, h func(context.Context, complex64) (error, error), n int) *FuncWorkerOfComplex64ToError {
	__ := &FuncWorkerOfComplex64ToError{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfComplex64ToError, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go Complex64ToError.CallAsAsync(work.Context, work.WorkOfComplex64ToError.Value, work.WorkOfComplex64ToError.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				Complex64ToError.PutWork(work.WorkOfComplex64ToError)
				Complex64ToError.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfComplex64ToError) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := Complex64ToError.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfComplex64ToError) Push(ctx context.Context, value complex64, returnCh chan<- *ReturnOfError) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := Complex64ToError.GetWorkContextWith(ctx, Complex64ToError.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfComplex64ToError) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfComplex64ToError) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfComplex64ToFloat32 struct {
	handler func(context.Context, complex64) (float32, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfComplex64ToFloat32
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfComplex64ToFloat32(ctx context.Context, h func(context.Context, complex64) (float32, error), n int) *FuncWorkerOfComplex64ToFloat32 {
	__ := &FuncWorkerOfComplex64ToFloat32{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfComplex64ToFloat32, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go Complex64ToFloat32.CallAsAsync(work.Context, work.WorkOfComplex64ToFloat32.Value, work.WorkOfComplex64ToFloat32.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				Complex64ToFloat32.PutWork(work.WorkOfComplex64ToFloat32)
				Complex64ToFloat32.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfComplex64ToFloat32) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := Complex64ToFloat32.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfComplex64ToFloat32) Push(ctx context.Context, value complex64, returnCh chan<- *ReturnOfFloat32) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := Complex64ToFloat32.GetWorkContextWith(ctx, Complex64ToFloat32.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfComplex64ToFloat32) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfComplex64ToFloat32) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfComplex64ToFloat64 struct {
	handler func(context.Context, complex64) (float64, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfComplex64ToFloat64
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfComplex64ToFloat64(ctx context.Context, h func(context.Context, complex64) (float64, error), n int) *FuncWorkerOfComplex64ToFloat64 {
	__ := &FuncWorkerOfComplex64ToFloat64{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfComplex64ToFloat64, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go Complex64ToFloat64.CallAsAsync(work.Context, work.WorkOfComplex64ToFloat64.Value, work.WorkOfComplex64ToFloat64.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				Complex64ToFloat64.PutWork(work.WorkOfComplex64ToFloat64)
				Complex64ToFloat64.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfComplex64ToFloat64) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := Complex64ToFloat64.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfComplex64ToFloat64) Push(ctx context.Context, value complex64, returnCh chan<- *ReturnOfFloat64) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := Complex64ToFloat64.GetWorkContextWith(ctx, Complex64ToFloat64.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfComplex64ToFloat64) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfComplex64ToFloat64) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfComplex64ToInt struct {
	handler func(context.Context, complex64) (int, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfComplex64ToInt
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfComplex64ToInt(ctx context.Context, h func(context.Context, complex64) (int, error), n int) *FuncWorkerOfComplex64ToInt {
	__ := &FuncWorkerOfComplex64ToInt{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfComplex64ToInt, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go Complex64ToInt.CallAsAsync(work.Context, work.WorkOfComplex64ToInt.Value, work.WorkOfComplex64ToInt.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				Complex64ToInt.PutWork(work.WorkOfComplex64ToInt)
				Complex64ToInt.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfComplex64ToInt) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := Complex64ToInt.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfComplex64ToInt) Push(ctx context.Context, value complex64, returnCh chan<- *ReturnOfInt) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := Complex64ToInt.GetWorkContextWith(ctx, Complex64ToInt.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfComplex64ToInt) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfComplex64ToInt) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfComplex64ToInt16 struct {
	handler func(context.Context, complex64) (int16, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfComplex64ToInt16
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfComplex64ToInt16(ctx context.Context, h func(context.Context, complex64) (int16, error), n int) *FuncWorkerOfComplex64ToInt16 {
	__ := &FuncWorkerOfComplex64ToInt16{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfComplex64ToInt16, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go Complex64ToInt16.CallAsAsync(work.Context, work.WorkOfComplex64ToInt16.Value, work.WorkOfComplex64ToInt16.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				Complex64ToInt16.PutWork(work.WorkOfComplex64ToInt16)
				Complex64ToInt16.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfComplex64ToInt16) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := Complex64ToInt16.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfComplex64ToInt16) Push(ctx context.Context, value complex64, returnCh chan<- *ReturnOfInt16) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := Complex64ToInt16.GetWorkContextWith(ctx, Complex64ToInt16.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfComplex64ToInt16) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfComplex64ToInt16) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfComplex64ToInt32 struct {
	handler func(context.Context, complex64) (int32, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfComplex64ToInt32
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfComplex64ToInt32(ctx context.Context, h func(context.Context, complex64) (int32, error), n int) *FuncWorkerOfComplex64ToInt32 {
	__ := &FuncWorkerOfComplex64ToInt32{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfComplex64ToInt32, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go Complex64ToInt32.CallAsAsync(work.Context, work.WorkOfComplex64ToInt32.Value, work.WorkOfComplex64ToInt32.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				Complex64ToInt32.PutWork(work.WorkOfComplex64ToInt32)
				Complex64ToInt32.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfComplex64ToInt32) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := Complex64ToInt32.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfComplex64ToInt32) Push(ctx context.Context, value complex64, returnCh chan<- *ReturnOfInt32) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := Complex64ToInt32.GetWorkContextWith(ctx, Complex64ToInt32.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfComplex64ToInt32) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfComplex64ToInt32) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfComplex64ToInt64 struct {
	handler func(context.Context, complex64) (int64, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfComplex64ToInt64
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfComplex64ToInt64(ctx context.Context, h func(context.Context, complex64) (int64, error), n int) *FuncWorkerOfComplex64ToInt64 {
	__ := &FuncWorkerOfComplex64ToInt64{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfComplex64ToInt64, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go Complex64ToInt64.CallAsAsync(work.Context, work.WorkOfComplex64ToInt64.Value, work.WorkOfComplex64ToInt64.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				Complex64ToInt64.PutWork(work.WorkOfComplex64ToInt64)
				Complex64ToInt64.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfComplex64ToInt64) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := Complex64ToInt64.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfComplex64ToInt64) Push(ctx context.Context, value complex64, returnCh chan<- *ReturnOfInt64) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := Complex64ToInt64.GetWorkContextWith(ctx, Complex64ToInt64.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfComplex64ToInt64) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfComplex64ToInt64) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfComplex64ToInt8 struct {
	handler func(context.Context, complex64) (int8, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfComplex64ToInt8
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfComplex64ToInt8(ctx context.Context, h func(context.Context, complex64) (int8, error), n int) *FuncWorkerOfComplex64ToInt8 {
	__ := &FuncWorkerOfComplex64ToInt8{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfComplex64ToInt8, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go Complex64ToInt8.CallAsAsync(work.Context, work.WorkOfComplex64ToInt8.Value, work.WorkOfComplex64ToInt8.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				Complex64ToInt8.PutWork(work.WorkOfComplex64ToInt8)
				Complex64ToInt8.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfComplex64ToInt8) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := Complex64ToInt8.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfComplex64ToInt8) Push(ctx context.Context, value complex64, returnCh chan<- *ReturnOfInt8) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := Complex64ToInt8.GetWorkContextWith(ctx, Complex64ToInt8.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfComplex64ToInt8) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfComplex64ToInt8) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfComplex64ToRune struct {
	handler func(context.Context, complex64) (rune, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfComplex64ToRune
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfComplex64ToRune(ctx context.Context, h func(context.Context, complex64) (rune, error), n int) *FuncWorkerOfComplex64ToRune {
	__ := &FuncWorkerOfComplex64ToRune{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfComplex64ToRune, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go Complex64ToRune.CallAsAsync(work.Context, work.WorkOfComplex64ToRune.Value, work.WorkOfComplex64ToRune.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				Complex64ToRune.PutWork(work.WorkOfComplex64ToRune)
				Complex64ToRune.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfComplex64ToRune) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := Complex64ToRune.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfComplex64ToRune) Push(ctx context.Context, value complex64, returnCh chan<- *ReturnOfRune) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := Complex64ToRune.GetWorkContextWith(ctx, Complex64ToRune.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfComplex64ToRune) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfComplex64ToRune) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfComplex64ToString struct {
	handler func(context.Context, complex64) (string, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfComplex64ToString
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfComplex64ToString(ctx context.Context, h func(context.Context, complex64) (string, error), n int) *FuncWorkerOfComplex64ToString {
	__ := &FuncWorkerOfComplex64ToString{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfComplex64ToString, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go Complex64ToString.CallAsAsync(work.Context, work.WorkOfComplex64ToString.Value, work.WorkOfComplex64ToString.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				Complex64ToString.PutWork(work.WorkOfComplex64ToString)
				Complex64ToString.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfComplex64ToString) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := Complex64ToString.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfComplex64ToString) Push(ctx context.Context, value complex64, returnCh chan<- *ReturnOfString) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := Complex64ToString.GetWorkContextWith(ctx, Complex64ToString.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfComplex64ToString) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfComplex64ToString) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfComplex64ToUint struct {
	handler func(context.Context, complex64) (uint, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfComplex64ToUint
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfComplex64ToUint(ctx context.Context, h func(context.Context, complex64) (uint, error), n int) *FuncWorkerOfComplex64ToUint {
	__ := &FuncWorkerOfComplex64ToUint{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfComplex64ToUint, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go Complex64ToUint.CallAsAsync(work.Context, work.WorkOfComplex64ToUint.Value, work.WorkOfComplex64ToUint.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				Complex64ToUint.PutWork(work.WorkOfComplex64ToUint)
				Complex64ToUint.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfComplex64ToUint) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := Complex64ToUint.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfComplex64ToUint) Push(ctx context.Context, value complex64, returnCh chan<- *ReturnOfUint) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := Complex64ToUint.GetWorkContextWith(ctx, Complex64ToUint.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfComplex64ToUint) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfComplex64ToUint) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfComplex64ToUint16 struct {
	handler func(context.Context, complex64) (uint16, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfComplex64ToUint16
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfComplex64ToUint16(ctx context.Context, h func(context.Context, complex64) (uint16, error), n int) *FuncWorkerOfComplex64ToUint16 {
	__ := &FuncWorkerOfComplex64ToUint16{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfComplex64ToUint16, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go Complex64ToUint16.CallAsAsync(work.Context, work.WorkOfComplex64ToUint16.Value, work.WorkOfComplex64ToUint16.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				Complex64ToUint16.PutWork(work.WorkOfComplex64ToUint16)
				Complex64ToUint16.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfComplex64ToUint16) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := Complex64ToUint16.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfComplex64ToUint16) Push(ctx context.Context, value complex64, returnCh chan<- *ReturnOfUint16) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := Complex64ToUint16.GetWorkContextWith(ctx, Complex64ToUint16.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfComplex64ToUint16) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfComplex64ToUint16) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfComplex64ToUint32 struct {
	handler func(context.Context, complex64) (uint32, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfComplex64ToUint32
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfComplex64ToUint32(ctx context.Context, h func(context.Context, complex64) (uint32, error), n int) *FuncWorkerOfComplex64ToUint32 {
	__ := &FuncWorkerOfComplex64ToUint32{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfComplex64ToUint32, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go Complex64ToUint32.CallAsAsync(work.Context, work.WorkOfComplex64ToUint32.Value, work.WorkOfComplex64ToUint32.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				Complex64ToUint32.PutWork(work.WorkOfComplex64ToUint32)
				Complex64ToUint32.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfComplex64ToUint32) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := Complex64ToUint32.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfComplex64ToUint32) Push(ctx context.Context, value complex64, returnCh chan<- *ReturnOfUint32) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := Complex64ToUint32.GetWorkContextWith(ctx, Complex64ToUint32.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfComplex64ToUint32) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfComplex64ToUint32) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfComplex64ToUint64 struct {
	handler func(context.Context, complex64) (uint64, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfComplex64ToUint64
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfComplex64ToUint64(ctx context.Context, h func(context.Context, complex64) (uint64, error), n int) *FuncWorkerOfComplex64ToUint64 {
	__ := &FuncWorkerOfComplex64ToUint64{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfComplex64ToUint64, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go Complex64ToUint64.CallAsAsync(work.Context, work.WorkOfComplex64ToUint64.Value, work.WorkOfComplex64ToUint64.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				Complex64ToUint64.PutWork(work.WorkOfComplex64ToUint64)
				Complex64ToUint64.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfComplex64ToUint64) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := Complex64ToUint64.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfComplex64ToUint64) Push(ctx context.Context, value complex64, returnCh chan<- *ReturnOfUint64) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := Complex64ToUint64.GetWorkContextWith(ctx, Complex64ToUint64.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfComplex64ToUint64) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfComplex64ToUint64) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfComplex64ToUint8 struct {
	handler func(context.Context, complex64) (uint8, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfComplex64ToUint8
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfComplex64ToUint8(ctx context.Context, h func(context.Context, complex64) (uint8, error), n int) *FuncWorkerOfComplex64ToUint8 {
	__ := &FuncWorkerOfComplex64ToUint8{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfComplex64ToUint8, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go Complex64ToUint8.CallAsAsync(work.Context, work.WorkOfComplex64ToUint8.Value, work.WorkOfComplex64ToUint8.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				Complex64ToUint8.PutWork(work.WorkOfComplex64ToUint8)
				Complex64ToUint8.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfComplex64ToUint8) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := Complex64ToUint8.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfComplex64ToUint8) Push(ctx context.Context, value complex64, returnCh chan<- *ReturnOfUint8) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := Complex64ToUint8.GetWorkContextWith(ctx, Complex64ToUint8.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfComplex64ToUint8) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfComplex64ToUint8) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfComplex64ToUintptr struct {
	handler func(context.Context, complex64) (uintptr, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfComplex64ToUintptr
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfComplex64ToUintptr(ctx context.Context, h func(context.Context, complex64) (uintptr, error), n int) *FuncWorkerOfComplex64ToUintptr {
	__ := &FuncWorkerOfComplex64ToUintptr{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfComplex64ToUintptr, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go Complex64ToUintptr.CallAsAsync(work.Context, work.WorkOfComplex64ToUintptr.Value, work.WorkOfComplex64ToUintptr.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				Complex64ToUintptr.PutWork(work.WorkOfComplex64ToUintptr)
				Complex64ToUintptr.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfComplex64ToUintptr) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := Complex64ToUintptr.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfComplex64ToUintptr) Push(ctx context.Context, value complex64, returnCh chan<- *ReturnOfUintptr) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := Complex64ToUintptr.GetWorkContextWith(ctx, Complex64ToUintptr.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfComplex64ToUintptr) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfComplex64ToUintptr) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfComplex64ToBytes struct {
	handler func(context.Context, complex64) (Bytes, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfComplex64ToBytes
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfComplex64ToBytes(ctx context.Context, h func(context.Context, complex64) (Bytes, error), n int) *FuncWorkerOfComplex64ToBytes {
	__ := &FuncWorkerOfComplex64ToBytes{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfComplex64ToBytes, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go Complex64ToBytes.CallAsAsync(work.Context, work.WorkOfComplex64ToBytes.Value, work.WorkOfComplex64ToBytes.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				Complex64ToBytes.PutWork(work.WorkOfComplex64ToBytes)
				Complex64ToBytes.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfComplex64ToBytes) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := Complex64ToBytes.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfComplex64ToBytes) Push(ctx context.Context, value complex64, returnCh chan<- *ReturnOfBytes) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := Complex64ToBytes.GetWorkContextWith(ctx, Complex64ToBytes.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfComplex64ToBytes) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfComplex64ToBytes) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfComplex64ToInterface struct {
	handler func(context.Context, complex64) (interface{}, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfComplex64ToInterface
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfComplex64ToInterface(ctx context.Context, h func(context.Context, complex64) (interface{}, error), n int) *FuncWorkerOfComplex64ToInterface {
	__ := &FuncWorkerOfComplex64ToInterface{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfComplex64ToInterface, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go Complex64ToInterface.CallAsAsync(work.Context, work.WorkOfComplex64ToInterface.Value, work.WorkOfComplex64ToInterface.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				Complex64ToInterface.PutWork(work.WorkOfComplex64ToInterface)
				Complex64ToInterface.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfComplex64ToInterface) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := Complex64ToInterface.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfComplex64ToInterface) Push(ctx context.Context, value complex64, returnCh chan<- *ReturnOfInterface) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := Complex64ToInterface.GetWorkContextWith(ctx, Complex64ToInterface.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfComplex64ToInterface) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfComplex64ToInterface) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfErrorToBool struct {
	handler func(context.Context, error) (bool, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfErrorToBool
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfErrorToBool(ctx context.Context, h func(context.Context, error) (bool, error), n int) *FuncWorkerOfErrorToBool {
	__ := &FuncWorkerOfErrorToBool{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfErrorToBool, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go ErrorToBool.CallAsAsync(work.Context, work.WorkOfErrorToBool.Value, work.WorkOfErrorToBool.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				ErrorToBool.PutWork(work.WorkOfErrorToBool)
				ErrorToBool.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfErrorToBool) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := ErrorToBool.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfErrorToBool) Push(ctx context.Context, value error, returnCh chan<- *ReturnOfBool) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := ErrorToBool.GetWorkContextWith(ctx, ErrorToBool.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfErrorToBool) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfErrorToBool) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfErrorToByte struct {
	handler func(context.Context, error) (byte, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfErrorToByte
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfErrorToByte(ctx context.Context, h func(context.Context, error) (byte, error), n int) *FuncWorkerOfErrorToByte {
	__ := &FuncWorkerOfErrorToByte{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfErrorToByte, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go ErrorToByte.CallAsAsync(work.Context, work.WorkOfErrorToByte.Value, work.WorkOfErrorToByte.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				ErrorToByte.PutWork(work.WorkOfErrorToByte)
				ErrorToByte.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfErrorToByte) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := ErrorToByte.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfErrorToByte) Push(ctx context.Context, value error, returnCh chan<- *ReturnOfByte) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := ErrorToByte.GetWorkContextWith(ctx, ErrorToByte.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfErrorToByte) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfErrorToByte) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfErrorToComplex128 struct {
	handler func(context.Context, error) (complex128, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfErrorToComplex128
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfErrorToComplex128(ctx context.Context, h func(context.Context, error) (complex128, error), n int) *FuncWorkerOfErrorToComplex128 {
	__ := &FuncWorkerOfErrorToComplex128{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfErrorToComplex128, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go ErrorToComplex128.CallAsAsync(work.Context, work.WorkOfErrorToComplex128.Value, work.WorkOfErrorToComplex128.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				ErrorToComplex128.PutWork(work.WorkOfErrorToComplex128)
				ErrorToComplex128.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfErrorToComplex128) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := ErrorToComplex128.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfErrorToComplex128) Push(ctx context.Context, value error, returnCh chan<- *ReturnOfComplex128) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := ErrorToComplex128.GetWorkContextWith(ctx, ErrorToComplex128.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfErrorToComplex128) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfErrorToComplex128) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfErrorToComplex64 struct {
	handler func(context.Context, error) (complex64, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfErrorToComplex64
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfErrorToComplex64(ctx context.Context, h func(context.Context, error) (complex64, error), n int) *FuncWorkerOfErrorToComplex64 {
	__ := &FuncWorkerOfErrorToComplex64{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfErrorToComplex64, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go ErrorToComplex64.CallAsAsync(work.Context, work.WorkOfErrorToComplex64.Value, work.WorkOfErrorToComplex64.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				ErrorToComplex64.PutWork(work.WorkOfErrorToComplex64)
				ErrorToComplex64.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfErrorToComplex64) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := ErrorToComplex64.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfErrorToComplex64) Push(ctx context.Context, value error, returnCh chan<- *ReturnOfComplex64) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := ErrorToComplex64.GetWorkContextWith(ctx, ErrorToComplex64.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfErrorToComplex64) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfErrorToComplex64) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfErrorToError struct {
	handler func(context.Context, error) (error, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfErrorToError
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfErrorToError(ctx context.Context, h func(context.Context, error) (error, error), n int) *FuncWorkerOfErrorToError {
	__ := &FuncWorkerOfErrorToError{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfErrorToError, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go ErrorToError.CallAsAsync(work.Context, work.WorkOfErrorToError.Value, work.WorkOfErrorToError.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				ErrorToError.PutWork(work.WorkOfErrorToError)
				ErrorToError.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfErrorToError) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := ErrorToError.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfErrorToError) Push(ctx context.Context, value error, returnCh chan<- *ReturnOfError) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := ErrorToError.GetWorkContextWith(ctx, ErrorToError.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfErrorToError) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfErrorToError) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfErrorToFloat32 struct {
	handler func(context.Context, error) (float32, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfErrorToFloat32
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfErrorToFloat32(ctx context.Context, h func(context.Context, error) (float32, error), n int) *FuncWorkerOfErrorToFloat32 {
	__ := &FuncWorkerOfErrorToFloat32{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfErrorToFloat32, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go ErrorToFloat32.CallAsAsync(work.Context, work.WorkOfErrorToFloat32.Value, work.WorkOfErrorToFloat32.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				ErrorToFloat32.PutWork(work.WorkOfErrorToFloat32)
				ErrorToFloat32.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfErrorToFloat32) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := ErrorToFloat32.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfErrorToFloat32) Push(ctx context.Context, value error, returnCh chan<- *ReturnOfFloat32) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := ErrorToFloat32.GetWorkContextWith(ctx, ErrorToFloat32.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfErrorToFloat32) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfErrorToFloat32) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfErrorToFloat64 struct {
	handler func(context.Context, error) (float64, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfErrorToFloat64
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfErrorToFloat64(ctx context.Context, h func(context.Context, error) (float64, error), n int) *FuncWorkerOfErrorToFloat64 {
	__ := &FuncWorkerOfErrorToFloat64{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfErrorToFloat64, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go ErrorToFloat64.CallAsAsync(work.Context, work.WorkOfErrorToFloat64.Value, work.WorkOfErrorToFloat64.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				ErrorToFloat64.PutWork(work.WorkOfErrorToFloat64)
				ErrorToFloat64.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfErrorToFloat64) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := ErrorToFloat64.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfErrorToFloat64) Push(ctx context.Context, value error, returnCh chan<- *ReturnOfFloat64) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := ErrorToFloat64.GetWorkContextWith(ctx, ErrorToFloat64.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfErrorToFloat64) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfErrorToFloat64) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfErrorToInt struct {
	handler func(context.Context, error) (int, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfErrorToInt
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfErrorToInt(ctx context.Context, h func(context.Context, error) (int, error), n int) *FuncWorkerOfErrorToInt {
	__ := &FuncWorkerOfErrorToInt{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfErrorToInt, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go ErrorToInt.CallAsAsync(work.Context, work.WorkOfErrorToInt.Value, work.WorkOfErrorToInt.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				ErrorToInt.PutWork(work.WorkOfErrorToInt)
				ErrorToInt.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfErrorToInt) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := ErrorToInt.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfErrorToInt) Push(ctx context.Context, value error, returnCh chan<- *ReturnOfInt) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := ErrorToInt.GetWorkContextWith(ctx, ErrorToInt.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfErrorToInt) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfErrorToInt) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfErrorToInt16 struct {
	handler func(context.Context, error) (int16, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfErrorToInt16
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfErrorToInt16(ctx context.Context, h func(context.Context, error) (int16, error), n int) *FuncWorkerOfErrorToInt16 {
	__ := &FuncWorkerOfErrorToInt16{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfErrorToInt16, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go ErrorToInt16.CallAsAsync(work.Context, work.WorkOfErrorToInt16.Value, work.WorkOfErrorToInt16.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				ErrorToInt16.PutWork(work.WorkOfErrorToInt16)
				ErrorToInt16.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfErrorToInt16) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := ErrorToInt16.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfErrorToInt16) Push(ctx context.Context, value error, returnCh chan<- *ReturnOfInt16) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := ErrorToInt16.GetWorkContextWith(ctx, ErrorToInt16.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfErrorToInt16) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfErrorToInt16) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfErrorToInt32 struct {
	handler func(context.Context, error) (int32, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfErrorToInt32
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfErrorToInt32(ctx context.Context, h func(context.Context, error) (int32, error), n int) *FuncWorkerOfErrorToInt32 {
	__ := &FuncWorkerOfErrorToInt32{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfErrorToInt32, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go ErrorToInt32.CallAsAsync(work.Context, work.WorkOfErrorToInt32.Value, work.WorkOfErrorToInt32.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				ErrorToInt32.PutWork(work.WorkOfErrorToInt32)
				ErrorToInt32.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfErrorToInt32) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := ErrorToInt32.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfErrorToInt32) Push(ctx context.Context, value error, returnCh chan<- *ReturnOfInt32) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := ErrorToInt32.GetWorkContextWith(ctx, ErrorToInt32.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfErrorToInt32) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfErrorToInt32) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfErrorToInt64 struct {
	handler func(context.Context, error) (int64, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfErrorToInt64
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfErrorToInt64(ctx context.Context, h func(context.Context, error) (int64, error), n int) *FuncWorkerOfErrorToInt64 {
	__ := &FuncWorkerOfErrorToInt64{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfErrorToInt64, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go ErrorToInt64.CallAsAsync(work.Context, work.WorkOfErrorToInt64.Value, work.WorkOfErrorToInt64.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				ErrorToInt64.PutWork(work.WorkOfErrorToInt64)
				ErrorToInt64.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfErrorToInt64) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := ErrorToInt64.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfErrorToInt64) Push(ctx context.Context, value error, returnCh chan<- *ReturnOfInt64) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := ErrorToInt64.GetWorkContextWith(ctx, ErrorToInt64.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfErrorToInt64) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfErrorToInt64) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfErrorToInt8 struct {
	handler func(context.Context, error) (int8, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfErrorToInt8
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfErrorToInt8(ctx context.Context, h func(context.Context, error) (int8, error), n int) *FuncWorkerOfErrorToInt8 {
	__ := &FuncWorkerOfErrorToInt8{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfErrorToInt8, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go ErrorToInt8.CallAsAsync(work.Context, work.WorkOfErrorToInt8.Value, work.WorkOfErrorToInt8.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				ErrorToInt8.PutWork(work.WorkOfErrorToInt8)
				ErrorToInt8.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfErrorToInt8) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := ErrorToInt8.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfErrorToInt8) Push(ctx context.Context, value error, returnCh chan<- *ReturnOfInt8) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := ErrorToInt8.GetWorkContextWith(ctx, ErrorToInt8.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfErrorToInt8) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfErrorToInt8) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfErrorToRune struct {
	handler func(context.Context, error) (rune, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfErrorToRune
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfErrorToRune(ctx context.Context, h func(context.Context, error) (rune, error), n int) *FuncWorkerOfErrorToRune {
	__ := &FuncWorkerOfErrorToRune{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfErrorToRune, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go ErrorToRune.CallAsAsync(work.Context, work.WorkOfErrorToRune.Value, work.WorkOfErrorToRune.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				ErrorToRune.PutWork(work.WorkOfErrorToRune)
				ErrorToRune.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfErrorToRune) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := ErrorToRune.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfErrorToRune) Push(ctx context.Context, value error, returnCh chan<- *ReturnOfRune) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := ErrorToRune.GetWorkContextWith(ctx, ErrorToRune.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfErrorToRune) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfErrorToRune) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfErrorToString struct {
	handler func(context.Context, error) (string, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfErrorToString
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfErrorToString(ctx context.Context, h func(context.Context, error) (string, error), n int) *FuncWorkerOfErrorToString {
	__ := &FuncWorkerOfErrorToString{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfErrorToString, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go ErrorToString.CallAsAsync(work.Context, work.WorkOfErrorToString.Value, work.WorkOfErrorToString.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				ErrorToString.PutWork(work.WorkOfErrorToString)
				ErrorToString.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfErrorToString) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := ErrorToString.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfErrorToString) Push(ctx context.Context, value error, returnCh chan<- *ReturnOfString) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := ErrorToString.GetWorkContextWith(ctx, ErrorToString.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfErrorToString) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfErrorToString) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfErrorToUint struct {
	handler func(context.Context, error) (uint, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfErrorToUint
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfErrorToUint(ctx context.Context, h func(context.Context, error) (uint, error), n int) *FuncWorkerOfErrorToUint {
	__ := &FuncWorkerOfErrorToUint{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfErrorToUint, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go ErrorToUint.CallAsAsync(work.Context, work.WorkOfErrorToUint.Value, work.WorkOfErrorToUint.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				ErrorToUint.PutWork(work.WorkOfErrorToUint)
				ErrorToUint.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfErrorToUint) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := ErrorToUint.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfErrorToUint) Push(ctx context.Context, value error, returnCh chan<- *ReturnOfUint) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := ErrorToUint.GetWorkContextWith(ctx, ErrorToUint.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfErrorToUint) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfErrorToUint) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfErrorToUint16 struct {
	handler func(context.Context, error) (uint16, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfErrorToUint16
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfErrorToUint16(ctx context.Context, h func(context.Context, error) (uint16, error), n int) *FuncWorkerOfErrorToUint16 {
	__ := &FuncWorkerOfErrorToUint16{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfErrorToUint16, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go ErrorToUint16.CallAsAsync(work.Context, work.WorkOfErrorToUint16.Value, work.WorkOfErrorToUint16.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				ErrorToUint16.PutWork(work.WorkOfErrorToUint16)
				ErrorToUint16.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfErrorToUint16) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := ErrorToUint16.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfErrorToUint16) Push(ctx context.Context, value error, returnCh chan<- *ReturnOfUint16) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := ErrorToUint16.GetWorkContextWith(ctx, ErrorToUint16.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfErrorToUint16) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfErrorToUint16) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfErrorToUint32 struct {
	handler func(context.Context, error) (uint32, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfErrorToUint32
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfErrorToUint32(ctx context.Context, h func(context.Context, error) (uint32, error), n int) *FuncWorkerOfErrorToUint32 {
	__ := &FuncWorkerOfErrorToUint32{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfErrorToUint32, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go ErrorToUint32.CallAsAsync(work.Context, work.WorkOfErrorToUint32.Value, work.WorkOfErrorToUint32.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				ErrorToUint32.PutWork(work.WorkOfErrorToUint32)
				ErrorToUint32.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfErrorToUint32) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := ErrorToUint32.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfErrorToUint32) Push(ctx context.Context, value error, returnCh chan<- *ReturnOfUint32) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := ErrorToUint32.GetWorkContextWith(ctx, ErrorToUint32.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfErrorToUint32) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfErrorToUint32) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfErrorToUint64 struct {
	handler func(context.Context, error) (uint64, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfErrorToUint64
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfErrorToUint64(ctx context.Context, h func(context.Context, error) (uint64, error), n int) *FuncWorkerOfErrorToUint64 {
	__ := &FuncWorkerOfErrorToUint64{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfErrorToUint64, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go ErrorToUint64.CallAsAsync(work.Context, work.WorkOfErrorToUint64.Value, work.WorkOfErrorToUint64.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				ErrorToUint64.PutWork(work.WorkOfErrorToUint64)
				ErrorToUint64.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfErrorToUint64) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := ErrorToUint64.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfErrorToUint64) Push(ctx context.Context, value error, returnCh chan<- *ReturnOfUint64) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := ErrorToUint64.GetWorkContextWith(ctx, ErrorToUint64.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfErrorToUint64) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfErrorToUint64) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfErrorToUint8 struct {
	handler func(context.Context, error) (uint8, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfErrorToUint8
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfErrorToUint8(ctx context.Context, h func(context.Context, error) (uint8, error), n int) *FuncWorkerOfErrorToUint8 {
	__ := &FuncWorkerOfErrorToUint8{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfErrorToUint8, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go ErrorToUint8.CallAsAsync(work.Context, work.WorkOfErrorToUint8.Value, work.WorkOfErrorToUint8.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				ErrorToUint8.PutWork(work.WorkOfErrorToUint8)
				ErrorToUint8.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfErrorToUint8) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := ErrorToUint8.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfErrorToUint8) Push(ctx context.Context, value error, returnCh chan<- *ReturnOfUint8) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := ErrorToUint8.GetWorkContextWith(ctx, ErrorToUint8.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfErrorToUint8) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfErrorToUint8) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfErrorToUintptr struct {
	handler func(context.Context, error) (uintptr, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfErrorToUintptr
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfErrorToUintptr(ctx context.Context, h func(context.Context, error) (uintptr, error), n int) *FuncWorkerOfErrorToUintptr {
	__ := &FuncWorkerOfErrorToUintptr{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfErrorToUintptr, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go ErrorToUintptr.CallAsAsync(work.Context, work.WorkOfErrorToUintptr.Value, work.WorkOfErrorToUintptr.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				ErrorToUintptr.PutWork(work.WorkOfErrorToUintptr)
				ErrorToUintptr.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfErrorToUintptr) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := ErrorToUintptr.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfErrorToUintptr) Push(ctx context.Context, value error, returnCh chan<- *ReturnOfUintptr) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := ErrorToUintptr.GetWorkContextWith(ctx, ErrorToUintptr.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfErrorToUintptr) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfErrorToUintptr) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfErrorToBytes struct {
	handler func(context.Context, error) (Bytes, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfErrorToBytes
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfErrorToBytes(ctx context.Context, h func(context.Context, error) (Bytes, error), n int) *FuncWorkerOfErrorToBytes {
	__ := &FuncWorkerOfErrorToBytes{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfErrorToBytes, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go ErrorToBytes.CallAsAsync(work.Context, work.WorkOfErrorToBytes.Value, work.WorkOfErrorToBytes.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				ErrorToBytes.PutWork(work.WorkOfErrorToBytes)
				ErrorToBytes.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfErrorToBytes) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := ErrorToBytes.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfErrorToBytes) Push(ctx context.Context, value error, returnCh chan<- *ReturnOfBytes) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := ErrorToBytes.GetWorkContextWith(ctx, ErrorToBytes.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfErrorToBytes) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfErrorToBytes) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfErrorToInterface struct {
	handler func(context.Context, error) (interface{}, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfErrorToInterface
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfErrorToInterface(ctx context.Context, h func(context.Context, error) (interface{}, error), n int) *FuncWorkerOfErrorToInterface {
	__ := &FuncWorkerOfErrorToInterface{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfErrorToInterface, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go ErrorToInterface.CallAsAsync(work.Context, work.WorkOfErrorToInterface.Value, work.WorkOfErrorToInterface.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				ErrorToInterface.PutWork(work.WorkOfErrorToInterface)
				ErrorToInterface.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfErrorToInterface) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := ErrorToInterface.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfErrorToInterface) Push(ctx context.Context, value error, returnCh chan<- *ReturnOfInterface) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := ErrorToInterface.GetWorkContextWith(ctx, ErrorToInterface.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfErrorToInterface) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfErrorToInterface) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfFloat32ToBool struct {
	handler func(context.Context, float32) (bool, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfFloat32ToBool
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfFloat32ToBool(ctx context.Context, h func(context.Context, float32) (bool, error), n int) *FuncWorkerOfFloat32ToBool {
	__ := &FuncWorkerOfFloat32ToBool{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfFloat32ToBool, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go Float32ToBool.CallAsAsync(work.Context, work.WorkOfFloat32ToBool.Value, work.WorkOfFloat32ToBool.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				Float32ToBool.PutWork(work.WorkOfFloat32ToBool)
				Float32ToBool.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfFloat32ToBool) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := Float32ToBool.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfFloat32ToBool) Push(ctx context.Context, value float32, returnCh chan<- *ReturnOfBool) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := Float32ToBool.GetWorkContextWith(ctx, Float32ToBool.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfFloat32ToBool) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfFloat32ToBool) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfFloat32ToByte struct {
	handler func(context.Context, float32) (byte, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfFloat32ToByte
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfFloat32ToByte(ctx context.Context, h func(context.Context, float32) (byte, error), n int) *FuncWorkerOfFloat32ToByte {
	__ := &FuncWorkerOfFloat32ToByte{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfFloat32ToByte, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go Float32ToByte.CallAsAsync(work.Context, work.WorkOfFloat32ToByte.Value, work.WorkOfFloat32ToByte.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				Float32ToByte.PutWork(work.WorkOfFloat32ToByte)
				Float32ToByte.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfFloat32ToByte) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := Float32ToByte.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfFloat32ToByte) Push(ctx context.Context, value float32, returnCh chan<- *ReturnOfByte) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := Float32ToByte.GetWorkContextWith(ctx, Float32ToByte.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfFloat32ToByte) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfFloat32ToByte) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfFloat32ToComplex128 struct {
	handler func(context.Context, float32) (complex128, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfFloat32ToComplex128
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfFloat32ToComplex128(ctx context.Context, h func(context.Context, float32) (complex128, error), n int) *FuncWorkerOfFloat32ToComplex128 {
	__ := &FuncWorkerOfFloat32ToComplex128{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfFloat32ToComplex128, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go Float32ToComplex128.CallAsAsync(work.Context, work.WorkOfFloat32ToComplex128.Value, work.WorkOfFloat32ToComplex128.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				Float32ToComplex128.PutWork(work.WorkOfFloat32ToComplex128)
				Float32ToComplex128.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfFloat32ToComplex128) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := Float32ToComplex128.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfFloat32ToComplex128) Push(ctx context.Context, value float32, returnCh chan<- *ReturnOfComplex128) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := Float32ToComplex128.GetWorkContextWith(ctx, Float32ToComplex128.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfFloat32ToComplex128) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfFloat32ToComplex128) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfFloat32ToComplex64 struct {
	handler func(context.Context, float32) (complex64, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfFloat32ToComplex64
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfFloat32ToComplex64(ctx context.Context, h func(context.Context, float32) (complex64, error), n int) *FuncWorkerOfFloat32ToComplex64 {
	__ := &FuncWorkerOfFloat32ToComplex64{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfFloat32ToComplex64, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go Float32ToComplex64.CallAsAsync(work.Context, work.WorkOfFloat32ToComplex64.Value, work.WorkOfFloat32ToComplex64.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				Float32ToComplex64.PutWork(work.WorkOfFloat32ToComplex64)
				Float32ToComplex64.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfFloat32ToComplex64) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := Float32ToComplex64.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfFloat32ToComplex64) Push(ctx context.Context, value float32, returnCh chan<- *ReturnOfComplex64) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := Float32ToComplex64.GetWorkContextWith(ctx, Float32ToComplex64.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfFloat32ToComplex64) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfFloat32ToComplex64) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfFloat32ToError struct {
	handler func(context.Context, float32) (error, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfFloat32ToError
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfFloat32ToError(ctx context.Context, h func(context.Context, float32) (error, error), n int) *FuncWorkerOfFloat32ToError {
	__ := &FuncWorkerOfFloat32ToError{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfFloat32ToError, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go Float32ToError.CallAsAsync(work.Context, work.WorkOfFloat32ToError.Value, work.WorkOfFloat32ToError.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				Float32ToError.PutWork(work.WorkOfFloat32ToError)
				Float32ToError.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfFloat32ToError) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := Float32ToError.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfFloat32ToError) Push(ctx context.Context, value float32, returnCh chan<- *ReturnOfError) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := Float32ToError.GetWorkContextWith(ctx, Float32ToError.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfFloat32ToError) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfFloat32ToError) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfFloat32ToFloat32 struct {
	handler func(context.Context, float32) (float32, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfFloat32ToFloat32
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfFloat32ToFloat32(ctx context.Context, h func(context.Context, float32) (float32, error), n int) *FuncWorkerOfFloat32ToFloat32 {
	__ := &FuncWorkerOfFloat32ToFloat32{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfFloat32ToFloat32, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go Float32ToFloat32.CallAsAsync(work.Context, work.WorkOfFloat32ToFloat32.Value, work.WorkOfFloat32ToFloat32.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				Float32ToFloat32.PutWork(work.WorkOfFloat32ToFloat32)
				Float32ToFloat32.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfFloat32ToFloat32) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := Float32ToFloat32.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfFloat32ToFloat32) Push(ctx context.Context, value float32, returnCh chan<- *ReturnOfFloat32) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := Float32ToFloat32.GetWorkContextWith(ctx, Float32ToFloat32.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfFloat32ToFloat32) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfFloat32ToFloat32) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfFloat32ToFloat64 struct {
	handler func(context.Context, float32) (float64, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfFloat32ToFloat64
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfFloat32ToFloat64(ctx context.Context, h func(context.Context, float32) (float64, error), n int) *FuncWorkerOfFloat32ToFloat64 {
	__ := &FuncWorkerOfFloat32ToFloat64{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfFloat32ToFloat64, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go Float32ToFloat64.CallAsAsync(work.Context, work.WorkOfFloat32ToFloat64.Value, work.WorkOfFloat32ToFloat64.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				Float32ToFloat64.PutWork(work.WorkOfFloat32ToFloat64)
				Float32ToFloat64.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfFloat32ToFloat64) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := Float32ToFloat64.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfFloat32ToFloat64) Push(ctx context.Context, value float32, returnCh chan<- *ReturnOfFloat64) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := Float32ToFloat64.GetWorkContextWith(ctx, Float32ToFloat64.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfFloat32ToFloat64) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfFloat32ToFloat64) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfFloat32ToInt struct {
	handler func(context.Context, float32) (int, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfFloat32ToInt
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfFloat32ToInt(ctx context.Context, h func(context.Context, float32) (int, error), n int) *FuncWorkerOfFloat32ToInt {
	__ := &FuncWorkerOfFloat32ToInt{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfFloat32ToInt, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go Float32ToInt.CallAsAsync(work.Context, work.WorkOfFloat32ToInt.Value, work.WorkOfFloat32ToInt.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				Float32ToInt.PutWork(work.WorkOfFloat32ToInt)
				Float32ToInt.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfFloat32ToInt) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := Float32ToInt.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfFloat32ToInt) Push(ctx context.Context, value float32, returnCh chan<- *ReturnOfInt) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := Float32ToInt.GetWorkContextWith(ctx, Float32ToInt.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfFloat32ToInt) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfFloat32ToInt) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfFloat32ToInt16 struct {
	handler func(context.Context, float32) (int16, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfFloat32ToInt16
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfFloat32ToInt16(ctx context.Context, h func(context.Context, float32) (int16, error), n int) *FuncWorkerOfFloat32ToInt16 {
	__ := &FuncWorkerOfFloat32ToInt16{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfFloat32ToInt16, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go Float32ToInt16.CallAsAsync(work.Context, work.WorkOfFloat32ToInt16.Value, work.WorkOfFloat32ToInt16.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				Float32ToInt16.PutWork(work.WorkOfFloat32ToInt16)
				Float32ToInt16.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfFloat32ToInt16) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := Float32ToInt16.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfFloat32ToInt16) Push(ctx context.Context, value float32, returnCh chan<- *ReturnOfInt16) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := Float32ToInt16.GetWorkContextWith(ctx, Float32ToInt16.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfFloat32ToInt16) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfFloat32ToInt16) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfFloat32ToInt32 struct {
	handler func(context.Context, float32) (int32, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfFloat32ToInt32
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfFloat32ToInt32(ctx context.Context, h func(context.Context, float32) (int32, error), n int) *FuncWorkerOfFloat32ToInt32 {
	__ := &FuncWorkerOfFloat32ToInt32{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfFloat32ToInt32, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go Float32ToInt32.CallAsAsync(work.Context, work.WorkOfFloat32ToInt32.Value, work.WorkOfFloat32ToInt32.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				Float32ToInt32.PutWork(work.WorkOfFloat32ToInt32)
				Float32ToInt32.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfFloat32ToInt32) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := Float32ToInt32.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfFloat32ToInt32) Push(ctx context.Context, value float32, returnCh chan<- *ReturnOfInt32) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := Float32ToInt32.GetWorkContextWith(ctx, Float32ToInt32.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfFloat32ToInt32) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfFloat32ToInt32) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfFloat32ToInt64 struct {
	handler func(context.Context, float32) (int64, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfFloat32ToInt64
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfFloat32ToInt64(ctx context.Context, h func(context.Context, float32) (int64, error), n int) *FuncWorkerOfFloat32ToInt64 {
	__ := &FuncWorkerOfFloat32ToInt64{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfFloat32ToInt64, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go Float32ToInt64.CallAsAsync(work.Context, work.WorkOfFloat32ToInt64.Value, work.WorkOfFloat32ToInt64.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				Float32ToInt64.PutWork(work.WorkOfFloat32ToInt64)
				Float32ToInt64.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfFloat32ToInt64) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := Float32ToInt64.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfFloat32ToInt64) Push(ctx context.Context, value float32, returnCh chan<- *ReturnOfInt64) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := Float32ToInt64.GetWorkContextWith(ctx, Float32ToInt64.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfFloat32ToInt64) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfFloat32ToInt64) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfFloat32ToInt8 struct {
	handler func(context.Context, float32) (int8, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfFloat32ToInt8
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfFloat32ToInt8(ctx context.Context, h func(context.Context, float32) (int8, error), n int) *FuncWorkerOfFloat32ToInt8 {
	__ := &FuncWorkerOfFloat32ToInt8{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfFloat32ToInt8, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go Float32ToInt8.CallAsAsync(work.Context, work.WorkOfFloat32ToInt8.Value, work.WorkOfFloat32ToInt8.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				Float32ToInt8.PutWork(work.WorkOfFloat32ToInt8)
				Float32ToInt8.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfFloat32ToInt8) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := Float32ToInt8.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfFloat32ToInt8) Push(ctx context.Context, value float32, returnCh chan<- *ReturnOfInt8) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := Float32ToInt8.GetWorkContextWith(ctx, Float32ToInt8.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfFloat32ToInt8) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfFloat32ToInt8) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfFloat32ToRune struct {
	handler func(context.Context, float32) (rune, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfFloat32ToRune
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfFloat32ToRune(ctx context.Context, h func(context.Context, float32) (rune, error), n int) *FuncWorkerOfFloat32ToRune {
	__ := &FuncWorkerOfFloat32ToRune{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfFloat32ToRune, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go Float32ToRune.CallAsAsync(work.Context, work.WorkOfFloat32ToRune.Value, work.WorkOfFloat32ToRune.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				Float32ToRune.PutWork(work.WorkOfFloat32ToRune)
				Float32ToRune.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfFloat32ToRune) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := Float32ToRune.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfFloat32ToRune) Push(ctx context.Context, value float32, returnCh chan<- *ReturnOfRune) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := Float32ToRune.GetWorkContextWith(ctx, Float32ToRune.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfFloat32ToRune) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfFloat32ToRune) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfFloat32ToString struct {
	handler func(context.Context, float32) (string, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfFloat32ToString
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfFloat32ToString(ctx context.Context, h func(context.Context, float32) (string, error), n int) *FuncWorkerOfFloat32ToString {
	__ := &FuncWorkerOfFloat32ToString{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfFloat32ToString, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go Float32ToString.CallAsAsync(work.Context, work.WorkOfFloat32ToString.Value, work.WorkOfFloat32ToString.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				Float32ToString.PutWork(work.WorkOfFloat32ToString)
				Float32ToString.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfFloat32ToString) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := Float32ToString.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfFloat32ToString) Push(ctx context.Context, value float32, returnCh chan<- *ReturnOfString) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := Float32ToString.GetWorkContextWith(ctx, Float32ToString.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfFloat32ToString) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfFloat32ToString) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfFloat32ToUint struct {
	handler func(context.Context, float32) (uint, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfFloat32ToUint
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfFloat32ToUint(ctx context.Context, h func(context.Context, float32) (uint, error), n int) *FuncWorkerOfFloat32ToUint {
	__ := &FuncWorkerOfFloat32ToUint{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfFloat32ToUint, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go Float32ToUint.CallAsAsync(work.Context, work.WorkOfFloat32ToUint.Value, work.WorkOfFloat32ToUint.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				Float32ToUint.PutWork(work.WorkOfFloat32ToUint)
				Float32ToUint.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfFloat32ToUint) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := Float32ToUint.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfFloat32ToUint) Push(ctx context.Context, value float32, returnCh chan<- *ReturnOfUint) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := Float32ToUint.GetWorkContextWith(ctx, Float32ToUint.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfFloat32ToUint) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfFloat32ToUint) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfFloat32ToUint16 struct {
	handler func(context.Context, float32) (uint16, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfFloat32ToUint16
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfFloat32ToUint16(ctx context.Context, h func(context.Context, float32) (uint16, error), n int) *FuncWorkerOfFloat32ToUint16 {
	__ := &FuncWorkerOfFloat32ToUint16{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfFloat32ToUint16, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go Float32ToUint16.CallAsAsync(work.Context, work.WorkOfFloat32ToUint16.Value, work.WorkOfFloat32ToUint16.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				Float32ToUint16.PutWork(work.WorkOfFloat32ToUint16)
				Float32ToUint16.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfFloat32ToUint16) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := Float32ToUint16.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfFloat32ToUint16) Push(ctx context.Context, value float32, returnCh chan<- *ReturnOfUint16) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := Float32ToUint16.GetWorkContextWith(ctx, Float32ToUint16.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfFloat32ToUint16) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfFloat32ToUint16) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfFloat32ToUint32 struct {
	handler func(context.Context, float32) (uint32, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfFloat32ToUint32
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfFloat32ToUint32(ctx context.Context, h func(context.Context, float32) (uint32, error), n int) *FuncWorkerOfFloat32ToUint32 {
	__ := &FuncWorkerOfFloat32ToUint32{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfFloat32ToUint32, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go Float32ToUint32.CallAsAsync(work.Context, work.WorkOfFloat32ToUint32.Value, work.WorkOfFloat32ToUint32.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				Float32ToUint32.PutWork(work.WorkOfFloat32ToUint32)
				Float32ToUint32.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfFloat32ToUint32) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := Float32ToUint32.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfFloat32ToUint32) Push(ctx context.Context, value float32, returnCh chan<- *ReturnOfUint32) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := Float32ToUint32.GetWorkContextWith(ctx, Float32ToUint32.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfFloat32ToUint32) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfFloat32ToUint32) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfFloat32ToUint64 struct {
	handler func(context.Context, float32) (uint64, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfFloat32ToUint64
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfFloat32ToUint64(ctx context.Context, h func(context.Context, float32) (uint64, error), n int) *FuncWorkerOfFloat32ToUint64 {
	__ := &FuncWorkerOfFloat32ToUint64{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfFloat32ToUint64, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go Float32ToUint64.CallAsAsync(work.Context, work.WorkOfFloat32ToUint64.Value, work.WorkOfFloat32ToUint64.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				Float32ToUint64.PutWork(work.WorkOfFloat32ToUint64)
				Float32ToUint64.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfFloat32ToUint64) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := Float32ToUint64.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfFloat32ToUint64) Push(ctx context.Context, value float32, returnCh chan<- *ReturnOfUint64) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := Float32ToUint64.GetWorkContextWith(ctx, Float32ToUint64.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfFloat32ToUint64) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfFloat32ToUint64) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfFloat32ToUint8 struct {
	handler func(context.Context, float32) (uint8, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfFloat32ToUint8
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfFloat32ToUint8(ctx context.Context, h func(context.Context, float32) (uint8, error), n int) *FuncWorkerOfFloat32ToUint8 {
	__ := &FuncWorkerOfFloat32ToUint8{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfFloat32ToUint8, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go Float32ToUint8.CallAsAsync(work.Context, work.WorkOfFloat32ToUint8.Value, work.WorkOfFloat32ToUint8.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				Float32ToUint8.PutWork(work.WorkOfFloat32ToUint8)
				Float32ToUint8.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfFloat32ToUint8) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := Float32ToUint8.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfFloat32ToUint8) Push(ctx context.Context, value float32, returnCh chan<- *ReturnOfUint8) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := Float32ToUint8.GetWorkContextWith(ctx, Float32ToUint8.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfFloat32ToUint8) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfFloat32ToUint8) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfFloat32ToUintptr struct {
	handler func(context.Context, float32) (uintptr, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfFloat32ToUintptr
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfFloat32ToUintptr(ctx context.Context, h func(context.Context, float32) (uintptr, error), n int) *FuncWorkerOfFloat32ToUintptr {
	__ := &FuncWorkerOfFloat32ToUintptr{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfFloat32ToUintptr, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go Float32ToUintptr.CallAsAsync(work.Context, work.WorkOfFloat32ToUintptr.Value, work.WorkOfFloat32ToUintptr.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				Float32ToUintptr.PutWork(work.WorkOfFloat32ToUintptr)
				Float32ToUintptr.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfFloat32ToUintptr) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := Float32ToUintptr.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfFloat32ToUintptr) Push(ctx context.Context, value float32, returnCh chan<- *ReturnOfUintptr) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := Float32ToUintptr.GetWorkContextWith(ctx, Float32ToUintptr.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfFloat32ToUintptr) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfFloat32ToUintptr) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfFloat32ToBytes struct {
	handler func(context.Context, float32) (Bytes, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfFloat32ToBytes
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfFloat32ToBytes(ctx context.Context, h func(context.Context, float32) (Bytes, error), n int) *FuncWorkerOfFloat32ToBytes {
	__ := &FuncWorkerOfFloat32ToBytes{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfFloat32ToBytes, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go Float32ToBytes.CallAsAsync(work.Context, work.WorkOfFloat32ToBytes.Value, work.WorkOfFloat32ToBytes.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				Float32ToBytes.PutWork(work.WorkOfFloat32ToBytes)
				Float32ToBytes.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfFloat32ToBytes) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := Float32ToBytes.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfFloat32ToBytes) Push(ctx context.Context, value float32, returnCh chan<- *ReturnOfBytes) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := Float32ToBytes.GetWorkContextWith(ctx, Float32ToBytes.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfFloat32ToBytes) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfFloat32ToBytes) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfFloat32ToInterface struct {
	handler func(context.Context, float32) (interface{}, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfFloat32ToInterface
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfFloat32ToInterface(ctx context.Context, h func(context.Context, float32) (interface{}, error), n int) *FuncWorkerOfFloat32ToInterface {
	__ := &FuncWorkerOfFloat32ToInterface{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfFloat32ToInterface, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go Float32ToInterface.CallAsAsync(work.Context, work.WorkOfFloat32ToInterface.Value, work.WorkOfFloat32ToInterface.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				Float32ToInterface.PutWork(work.WorkOfFloat32ToInterface)
				Float32ToInterface.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfFloat32ToInterface) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := Float32ToInterface.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfFloat32ToInterface) Push(ctx context.Context, value float32, returnCh chan<- *ReturnOfInterface) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := Float32ToInterface.GetWorkContextWith(ctx, Float32ToInterface.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfFloat32ToInterface) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfFloat32ToInterface) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfFloat64ToBool struct {
	handler func(context.Context, float64) (bool, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfFloat64ToBool
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfFloat64ToBool(ctx context.Context, h func(context.Context, float64) (bool, error), n int) *FuncWorkerOfFloat64ToBool {
	__ := &FuncWorkerOfFloat64ToBool{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfFloat64ToBool, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go Float64ToBool.CallAsAsync(work.Context, work.WorkOfFloat64ToBool.Value, work.WorkOfFloat64ToBool.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				Float64ToBool.PutWork(work.WorkOfFloat64ToBool)
				Float64ToBool.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfFloat64ToBool) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := Float64ToBool.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfFloat64ToBool) Push(ctx context.Context, value float64, returnCh chan<- *ReturnOfBool) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := Float64ToBool.GetWorkContextWith(ctx, Float64ToBool.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfFloat64ToBool) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfFloat64ToBool) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfFloat64ToByte struct {
	handler func(context.Context, float64) (byte, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfFloat64ToByte
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfFloat64ToByte(ctx context.Context, h func(context.Context, float64) (byte, error), n int) *FuncWorkerOfFloat64ToByte {
	__ := &FuncWorkerOfFloat64ToByte{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfFloat64ToByte, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go Float64ToByte.CallAsAsync(work.Context, work.WorkOfFloat64ToByte.Value, work.WorkOfFloat64ToByte.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				Float64ToByte.PutWork(work.WorkOfFloat64ToByte)
				Float64ToByte.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfFloat64ToByte) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := Float64ToByte.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfFloat64ToByte) Push(ctx context.Context, value float64, returnCh chan<- *ReturnOfByte) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := Float64ToByte.GetWorkContextWith(ctx, Float64ToByte.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfFloat64ToByte) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfFloat64ToByte) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfFloat64ToComplex128 struct {
	handler func(context.Context, float64) (complex128, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfFloat64ToComplex128
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfFloat64ToComplex128(ctx context.Context, h func(context.Context, float64) (complex128, error), n int) *FuncWorkerOfFloat64ToComplex128 {
	__ := &FuncWorkerOfFloat64ToComplex128{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfFloat64ToComplex128, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go Float64ToComplex128.CallAsAsync(work.Context, work.WorkOfFloat64ToComplex128.Value, work.WorkOfFloat64ToComplex128.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				Float64ToComplex128.PutWork(work.WorkOfFloat64ToComplex128)
				Float64ToComplex128.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfFloat64ToComplex128) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := Float64ToComplex128.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfFloat64ToComplex128) Push(ctx context.Context, value float64, returnCh chan<- *ReturnOfComplex128) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := Float64ToComplex128.GetWorkContextWith(ctx, Float64ToComplex128.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfFloat64ToComplex128) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfFloat64ToComplex128) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfFloat64ToComplex64 struct {
	handler func(context.Context, float64) (complex64, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfFloat64ToComplex64
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfFloat64ToComplex64(ctx context.Context, h func(context.Context, float64) (complex64, error), n int) *FuncWorkerOfFloat64ToComplex64 {
	__ := &FuncWorkerOfFloat64ToComplex64{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfFloat64ToComplex64, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go Float64ToComplex64.CallAsAsync(work.Context, work.WorkOfFloat64ToComplex64.Value, work.WorkOfFloat64ToComplex64.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				Float64ToComplex64.PutWork(work.WorkOfFloat64ToComplex64)
				Float64ToComplex64.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfFloat64ToComplex64) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := Float64ToComplex64.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfFloat64ToComplex64) Push(ctx context.Context, value float64, returnCh chan<- *ReturnOfComplex64) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := Float64ToComplex64.GetWorkContextWith(ctx, Float64ToComplex64.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfFloat64ToComplex64) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfFloat64ToComplex64) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfFloat64ToError struct {
	handler func(context.Context, float64) (error, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfFloat64ToError
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfFloat64ToError(ctx context.Context, h func(context.Context, float64) (error, error), n int) *FuncWorkerOfFloat64ToError {
	__ := &FuncWorkerOfFloat64ToError{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfFloat64ToError, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go Float64ToError.CallAsAsync(work.Context, work.WorkOfFloat64ToError.Value, work.WorkOfFloat64ToError.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				Float64ToError.PutWork(work.WorkOfFloat64ToError)
				Float64ToError.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfFloat64ToError) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := Float64ToError.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfFloat64ToError) Push(ctx context.Context, value float64, returnCh chan<- *ReturnOfError) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := Float64ToError.GetWorkContextWith(ctx, Float64ToError.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfFloat64ToError) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfFloat64ToError) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfFloat64ToFloat32 struct {
	handler func(context.Context, float64) (float32, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfFloat64ToFloat32
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfFloat64ToFloat32(ctx context.Context, h func(context.Context, float64) (float32, error), n int) *FuncWorkerOfFloat64ToFloat32 {
	__ := &FuncWorkerOfFloat64ToFloat32{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfFloat64ToFloat32, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go Float64ToFloat32.CallAsAsync(work.Context, work.WorkOfFloat64ToFloat32.Value, work.WorkOfFloat64ToFloat32.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				Float64ToFloat32.PutWork(work.WorkOfFloat64ToFloat32)
				Float64ToFloat32.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfFloat64ToFloat32) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := Float64ToFloat32.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfFloat64ToFloat32) Push(ctx context.Context, value float64, returnCh chan<- *ReturnOfFloat32) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := Float64ToFloat32.GetWorkContextWith(ctx, Float64ToFloat32.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfFloat64ToFloat32) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfFloat64ToFloat32) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfFloat64ToFloat64 struct {
	handler func(context.Context, float64) (float64, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfFloat64ToFloat64
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfFloat64ToFloat64(ctx context.Context, h func(context.Context, float64) (float64, error), n int) *FuncWorkerOfFloat64ToFloat64 {
	__ := &FuncWorkerOfFloat64ToFloat64{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfFloat64ToFloat64, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go Float64ToFloat64.CallAsAsync(work.Context, work.WorkOfFloat64ToFloat64.Value, work.WorkOfFloat64ToFloat64.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				Float64ToFloat64.PutWork(work.WorkOfFloat64ToFloat64)
				Float64ToFloat64.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfFloat64ToFloat64) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := Float64ToFloat64.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfFloat64ToFloat64) Push(ctx context.Context, value float64, returnCh chan<- *ReturnOfFloat64) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := Float64ToFloat64.GetWorkContextWith(ctx, Float64ToFloat64.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfFloat64ToFloat64) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfFloat64ToFloat64) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfFloat64ToInt struct {
	handler func(context.Context, float64) (int, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfFloat64ToInt
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfFloat64ToInt(ctx context.Context, h func(context.Context, float64) (int, error), n int) *FuncWorkerOfFloat64ToInt {
	__ := &FuncWorkerOfFloat64ToInt{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfFloat64ToInt, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go Float64ToInt.CallAsAsync(work.Context, work.WorkOfFloat64ToInt.Value, work.WorkOfFloat64ToInt.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				Float64ToInt.PutWork(work.WorkOfFloat64ToInt)
				Float64ToInt.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfFloat64ToInt) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := Float64ToInt.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfFloat64ToInt) Push(ctx context.Context, value float64, returnCh chan<- *ReturnOfInt) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := Float64ToInt.GetWorkContextWith(ctx, Float64ToInt.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfFloat64ToInt) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfFloat64ToInt) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfFloat64ToInt16 struct {
	handler func(context.Context, float64) (int16, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfFloat64ToInt16
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfFloat64ToInt16(ctx context.Context, h func(context.Context, float64) (int16, error), n int) *FuncWorkerOfFloat64ToInt16 {
	__ := &FuncWorkerOfFloat64ToInt16{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfFloat64ToInt16, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go Float64ToInt16.CallAsAsync(work.Context, work.WorkOfFloat64ToInt16.Value, work.WorkOfFloat64ToInt16.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				Float64ToInt16.PutWork(work.WorkOfFloat64ToInt16)
				Float64ToInt16.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfFloat64ToInt16) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := Float64ToInt16.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfFloat64ToInt16) Push(ctx context.Context, value float64, returnCh chan<- *ReturnOfInt16) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := Float64ToInt16.GetWorkContextWith(ctx, Float64ToInt16.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfFloat64ToInt16) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfFloat64ToInt16) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfFloat64ToInt32 struct {
	handler func(context.Context, float64) (int32, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfFloat64ToInt32
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfFloat64ToInt32(ctx context.Context, h func(context.Context, float64) (int32, error), n int) *FuncWorkerOfFloat64ToInt32 {
	__ := &FuncWorkerOfFloat64ToInt32{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfFloat64ToInt32, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go Float64ToInt32.CallAsAsync(work.Context, work.WorkOfFloat64ToInt32.Value, work.WorkOfFloat64ToInt32.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				Float64ToInt32.PutWork(work.WorkOfFloat64ToInt32)
				Float64ToInt32.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfFloat64ToInt32) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := Float64ToInt32.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfFloat64ToInt32) Push(ctx context.Context, value float64, returnCh chan<- *ReturnOfInt32) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := Float64ToInt32.GetWorkContextWith(ctx, Float64ToInt32.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfFloat64ToInt32) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfFloat64ToInt32) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfFloat64ToInt64 struct {
	handler func(context.Context, float64) (int64, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfFloat64ToInt64
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfFloat64ToInt64(ctx context.Context, h func(context.Context, float64) (int64, error), n int) *FuncWorkerOfFloat64ToInt64 {
	__ := &FuncWorkerOfFloat64ToInt64{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfFloat64ToInt64, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go Float64ToInt64.CallAsAsync(work.Context, work.WorkOfFloat64ToInt64.Value, work.WorkOfFloat64ToInt64.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				Float64ToInt64.PutWork(work.WorkOfFloat64ToInt64)
				Float64ToInt64.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfFloat64ToInt64) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := Float64ToInt64.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfFloat64ToInt64) Push(ctx context.Context, value float64, returnCh chan<- *ReturnOfInt64) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := Float64ToInt64.GetWorkContextWith(ctx, Float64ToInt64.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfFloat64ToInt64) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfFloat64ToInt64) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfFloat64ToInt8 struct {
	handler func(context.Context, float64) (int8, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfFloat64ToInt8
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfFloat64ToInt8(ctx context.Context, h func(context.Context, float64) (int8, error), n int) *FuncWorkerOfFloat64ToInt8 {
	__ := &FuncWorkerOfFloat64ToInt8{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfFloat64ToInt8, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go Float64ToInt8.CallAsAsync(work.Context, work.WorkOfFloat64ToInt8.Value, work.WorkOfFloat64ToInt8.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				Float64ToInt8.PutWork(work.WorkOfFloat64ToInt8)
				Float64ToInt8.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfFloat64ToInt8) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := Float64ToInt8.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfFloat64ToInt8) Push(ctx context.Context, value float64, returnCh chan<- *ReturnOfInt8) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := Float64ToInt8.GetWorkContextWith(ctx, Float64ToInt8.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfFloat64ToInt8) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfFloat64ToInt8) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfFloat64ToRune struct {
	handler func(context.Context, float64) (rune, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfFloat64ToRune
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfFloat64ToRune(ctx context.Context, h func(context.Context, float64) (rune, error), n int) *FuncWorkerOfFloat64ToRune {
	__ := &FuncWorkerOfFloat64ToRune{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfFloat64ToRune, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go Float64ToRune.CallAsAsync(work.Context, work.WorkOfFloat64ToRune.Value, work.WorkOfFloat64ToRune.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				Float64ToRune.PutWork(work.WorkOfFloat64ToRune)
				Float64ToRune.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfFloat64ToRune) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := Float64ToRune.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfFloat64ToRune) Push(ctx context.Context, value float64, returnCh chan<- *ReturnOfRune) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := Float64ToRune.GetWorkContextWith(ctx, Float64ToRune.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfFloat64ToRune) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfFloat64ToRune) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfFloat64ToString struct {
	handler func(context.Context, float64) (string, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfFloat64ToString
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfFloat64ToString(ctx context.Context, h func(context.Context, float64) (string, error), n int) *FuncWorkerOfFloat64ToString {
	__ := &FuncWorkerOfFloat64ToString{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfFloat64ToString, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go Float64ToString.CallAsAsync(work.Context, work.WorkOfFloat64ToString.Value, work.WorkOfFloat64ToString.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				Float64ToString.PutWork(work.WorkOfFloat64ToString)
				Float64ToString.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfFloat64ToString) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := Float64ToString.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfFloat64ToString) Push(ctx context.Context, value float64, returnCh chan<- *ReturnOfString) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := Float64ToString.GetWorkContextWith(ctx, Float64ToString.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfFloat64ToString) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfFloat64ToString) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfFloat64ToUint struct {
	handler func(context.Context, float64) (uint, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfFloat64ToUint
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfFloat64ToUint(ctx context.Context, h func(context.Context, float64) (uint, error), n int) *FuncWorkerOfFloat64ToUint {
	__ := &FuncWorkerOfFloat64ToUint{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfFloat64ToUint, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go Float64ToUint.CallAsAsync(work.Context, work.WorkOfFloat64ToUint.Value, work.WorkOfFloat64ToUint.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				Float64ToUint.PutWork(work.WorkOfFloat64ToUint)
				Float64ToUint.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfFloat64ToUint) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := Float64ToUint.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfFloat64ToUint) Push(ctx context.Context, value float64, returnCh chan<- *ReturnOfUint) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := Float64ToUint.GetWorkContextWith(ctx, Float64ToUint.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfFloat64ToUint) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfFloat64ToUint) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfFloat64ToUint16 struct {
	handler func(context.Context, float64) (uint16, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfFloat64ToUint16
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfFloat64ToUint16(ctx context.Context, h func(context.Context, float64) (uint16, error), n int) *FuncWorkerOfFloat64ToUint16 {
	__ := &FuncWorkerOfFloat64ToUint16{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfFloat64ToUint16, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go Float64ToUint16.CallAsAsync(work.Context, work.WorkOfFloat64ToUint16.Value, work.WorkOfFloat64ToUint16.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				Float64ToUint16.PutWork(work.WorkOfFloat64ToUint16)
				Float64ToUint16.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfFloat64ToUint16) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := Float64ToUint16.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfFloat64ToUint16) Push(ctx context.Context, value float64, returnCh chan<- *ReturnOfUint16) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := Float64ToUint16.GetWorkContextWith(ctx, Float64ToUint16.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfFloat64ToUint16) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfFloat64ToUint16) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfFloat64ToUint32 struct {
	handler func(context.Context, float64) (uint32, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfFloat64ToUint32
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfFloat64ToUint32(ctx context.Context, h func(context.Context, float64) (uint32, error), n int) *FuncWorkerOfFloat64ToUint32 {
	__ := &FuncWorkerOfFloat64ToUint32{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfFloat64ToUint32, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go Float64ToUint32.CallAsAsync(work.Context, work.WorkOfFloat64ToUint32.Value, work.WorkOfFloat64ToUint32.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				Float64ToUint32.PutWork(work.WorkOfFloat64ToUint32)
				Float64ToUint32.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfFloat64ToUint32) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := Float64ToUint32.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfFloat64ToUint32) Push(ctx context.Context, value float64, returnCh chan<- *ReturnOfUint32) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := Float64ToUint32.GetWorkContextWith(ctx, Float64ToUint32.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfFloat64ToUint32) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfFloat64ToUint32) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfFloat64ToUint64 struct {
	handler func(context.Context, float64) (uint64, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfFloat64ToUint64
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfFloat64ToUint64(ctx context.Context, h func(context.Context, float64) (uint64, error), n int) *FuncWorkerOfFloat64ToUint64 {
	__ := &FuncWorkerOfFloat64ToUint64{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfFloat64ToUint64, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go Float64ToUint64.CallAsAsync(work.Context, work.WorkOfFloat64ToUint64.Value, work.WorkOfFloat64ToUint64.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				Float64ToUint64.PutWork(work.WorkOfFloat64ToUint64)
				Float64ToUint64.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfFloat64ToUint64) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := Float64ToUint64.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfFloat64ToUint64) Push(ctx context.Context, value float64, returnCh chan<- *ReturnOfUint64) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := Float64ToUint64.GetWorkContextWith(ctx, Float64ToUint64.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfFloat64ToUint64) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfFloat64ToUint64) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfFloat64ToUint8 struct {
	handler func(context.Context, float64) (uint8, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfFloat64ToUint8
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfFloat64ToUint8(ctx context.Context, h func(context.Context, float64) (uint8, error), n int) *FuncWorkerOfFloat64ToUint8 {
	__ := &FuncWorkerOfFloat64ToUint8{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfFloat64ToUint8, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go Float64ToUint8.CallAsAsync(work.Context, work.WorkOfFloat64ToUint8.Value, work.WorkOfFloat64ToUint8.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				Float64ToUint8.PutWork(work.WorkOfFloat64ToUint8)
				Float64ToUint8.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfFloat64ToUint8) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := Float64ToUint8.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfFloat64ToUint8) Push(ctx context.Context, value float64, returnCh chan<- *ReturnOfUint8) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := Float64ToUint8.GetWorkContextWith(ctx, Float64ToUint8.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfFloat64ToUint8) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfFloat64ToUint8) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfFloat64ToUintptr struct {
	handler func(context.Context, float64) (uintptr, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfFloat64ToUintptr
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfFloat64ToUintptr(ctx context.Context, h func(context.Context, float64) (uintptr, error), n int) *FuncWorkerOfFloat64ToUintptr {
	__ := &FuncWorkerOfFloat64ToUintptr{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfFloat64ToUintptr, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go Float64ToUintptr.CallAsAsync(work.Context, work.WorkOfFloat64ToUintptr.Value, work.WorkOfFloat64ToUintptr.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				Float64ToUintptr.PutWork(work.WorkOfFloat64ToUintptr)
				Float64ToUintptr.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfFloat64ToUintptr) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := Float64ToUintptr.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfFloat64ToUintptr) Push(ctx context.Context, value float64, returnCh chan<- *ReturnOfUintptr) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := Float64ToUintptr.GetWorkContextWith(ctx, Float64ToUintptr.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfFloat64ToUintptr) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfFloat64ToUintptr) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfFloat64ToBytes struct {
	handler func(context.Context, float64) (Bytes, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfFloat64ToBytes
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfFloat64ToBytes(ctx context.Context, h func(context.Context, float64) (Bytes, error), n int) *FuncWorkerOfFloat64ToBytes {
	__ := &FuncWorkerOfFloat64ToBytes{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfFloat64ToBytes, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go Float64ToBytes.CallAsAsync(work.Context, work.WorkOfFloat64ToBytes.Value, work.WorkOfFloat64ToBytes.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				Float64ToBytes.PutWork(work.WorkOfFloat64ToBytes)
				Float64ToBytes.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfFloat64ToBytes) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := Float64ToBytes.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfFloat64ToBytes) Push(ctx context.Context, value float64, returnCh chan<- *ReturnOfBytes) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := Float64ToBytes.GetWorkContextWith(ctx, Float64ToBytes.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfFloat64ToBytes) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfFloat64ToBytes) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfFloat64ToInterface struct {
	handler func(context.Context, float64) (interface{}, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfFloat64ToInterface
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfFloat64ToInterface(ctx context.Context, h func(context.Context, float64) (interface{}, error), n int) *FuncWorkerOfFloat64ToInterface {
	__ := &FuncWorkerOfFloat64ToInterface{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfFloat64ToInterface, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go Float64ToInterface.CallAsAsync(work.Context, work.WorkOfFloat64ToInterface.Value, work.WorkOfFloat64ToInterface.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				Float64ToInterface.PutWork(work.WorkOfFloat64ToInterface)
				Float64ToInterface.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfFloat64ToInterface) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := Float64ToInterface.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfFloat64ToInterface) Push(ctx context.Context, value float64, returnCh chan<- *ReturnOfInterface) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := Float64ToInterface.GetWorkContextWith(ctx, Float64ToInterface.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfFloat64ToInterface) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfFloat64ToInterface) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfIntToBool struct {
	handler func(context.Context, int) (bool, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfIntToBool
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfIntToBool(ctx context.Context, h func(context.Context, int) (bool, error), n int) *FuncWorkerOfIntToBool {
	__ := &FuncWorkerOfIntToBool{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfIntToBool, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go IntToBool.CallAsAsync(work.Context, work.WorkOfIntToBool.Value, work.WorkOfIntToBool.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				IntToBool.PutWork(work.WorkOfIntToBool)
				IntToBool.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfIntToBool) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := IntToBool.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfIntToBool) Push(ctx context.Context, value int, returnCh chan<- *ReturnOfBool) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := IntToBool.GetWorkContextWith(ctx, IntToBool.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfIntToBool) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfIntToBool) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfIntToByte struct {
	handler func(context.Context, int) (byte, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfIntToByte
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfIntToByte(ctx context.Context, h func(context.Context, int) (byte, error), n int) *FuncWorkerOfIntToByte {
	__ := &FuncWorkerOfIntToByte{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfIntToByte, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go IntToByte.CallAsAsync(work.Context, work.WorkOfIntToByte.Value, work.WorkOfIntToByte.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				IntToByte.PutWork(work.WorkOfIntToByte)
				IntToByte.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfIntToByte) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := IntToByte.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfIntToByte) Push(ctx context.Context, value int, returnCh chan<- *ReturnOfByte) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := IntToByte.GetWorkContextWith(ctx, IntToByte.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfIntToByte) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfIntToByte) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfIntToComplex128 struct {
	handler func(context.Context, int) (complex128, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfIntToComplex128
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfIntToComplex128(ctx context.Context, h func(context.Context, int) (complex128, error), n int) *FuncWorkerOfIntToComplex128 {
	__ := &FuncWorkerOfIntToComplex128{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfIntToComplex128, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go IntToComplex128.CallAsAsync(work.Context, work.WorkOfIntToComplex128.Value, work.WorkOfIntToComplex128.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				IntToComplex128.PutWork(work.WorkOfIntToComplex128)
				IntToComplex128.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfIntToComplex128) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := IntToComplex128.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfIntToComplex128) Push(ctx context.Context, value int, returnCh chan<- *ReturnOfComplex128) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := IntToComplex128.GetWorkContextWith(ctx, IntToComplex128.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfIntToComplex128) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfIntToComplex128) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfIntToComplex64 struct {
	handler func(context.Context, int) (complex64, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfIntToComplex64
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfIntToComplex64(ctx context.Context, h func(context.Context, int) (complex64, error), n int) *FuncWorkerOfIntToComplex64 {
	__ := &FuncWorkerOfIntToComplex64{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfIntToComplex64, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go IntToComplex64.CallAsAsync(work.Context, work.WorkOfIntToComplex64.Value, work.WorkOfIntToComplex64.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				IntToComplex64.PutWork(work.WorkOfIntToComplex64)
				IntToComplex64.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfIntToComplex64) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := IntToComplex64.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfIntToComplex64) Push(ctx context.Context, value int, returnCh chan<- *ReturnOfComplex64) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := IntToComplex64.GetWorkContextWith(ctx, IntToComplex64.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfIntToComplex64) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfIntToComplex64) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfIntToError struct {
	handler func(context.Context, int) (error, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfIntToError
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfIntToError(ctx context.Context, h func(context.Context, int) (error, error), n int) *FuncWorkerOfIntToError {
	__ := &FuncWorkerOfIntToError{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfIntToError, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go IntToError.CallAsAsync(work.Context, work.WorkOfIntToError.Value, work.WorkOfIntToError.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				IntToError.PutWork(work.WorkOfIntToError)
				IntToError.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfIntToError) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := IntToError.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfIntToError) Push(ctx context.Context, value int, returnCh chan<- *ReturnOfError) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := IntToError.GetWorkContextWith(ctx, IntToError.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfIntToError) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfIntToError) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfIntToFloat32 struct {
	handler func(context.Context, int) (float32, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfIntToFloat32
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfIntToFloat32(ctx context.Context, h func(context.Context, int) (float32, error), n int) *FuncWorkerOfIntToFloat32 {
	__ := &FuncWorkerOfIntToFloat32{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfIntToFloat32, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go IntToFloat32.CallAsAsync(work.Context, work.WorkOfIntToFloat32.Value, work.WorkOfIntToFloat32.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				IntToFloat32.PutWork(work.WorkOfIntToFloat32)
				IntToFloat32.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfIntToFloat32) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := IntToFloat32.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfIntToFloat32) Push(ctx context.Context, value int, returnCh chan<- *ReturnOfFloat32) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := IntToFloat32.GetWorkContextWith(ctx, IntToFloat32.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfIntToFloat32) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfIntToFloat32) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfIntToFloat64 struct {
	handler func(context.Context, int) (float64, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfIntToFloat64
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfIntToFloat64(ctx context.Context, h func(context.Context, int) (float64, error), n int) *FuncWorkerOfIntToFloat64 {
	__ := &FuncWorkerOfIntToFloat64{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfIntToFloat64, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go IntToFloat64.CallAsAsync(work.Context, work.WorkOfIntToFloat64.Value, work.WorkOfIntToFloat64.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				IntToFloat64.PutWork(work.WorkOfIntToFloat64)
				IntToFloat64.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfIntToFloat64) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := IntToFloat64.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfIntToFloat64) Push(ctx context.Context, value int, returnCh chan<- *ReturnOfFloat64) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := IntToFloat64.GetWorkContextWith(ctx, IntToFloat64.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfIntToFloat64) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfIntToFloat64) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfIntToInt struct {
	handler func(context.Context, int) (int, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfIntToInt
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfIntToInt(ctx context.Context, h func(context.Context, int) (int, error), n int) *FuncWorkerOfIntToInt {
	__ := &FuncWorkerOfIntToInt{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfIntToInt, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go IntToInt.CallAsAsync(work.Context, work.WorkOfIntToInt.Value, work.WorkOfIntToInt.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				IntToInt.PutWork(work.WorkOfIntToInt)
				IntToInt.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfIntToInt) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := IntToInt.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfIntToInt) Push(ctx context.Context, value int, returnCh chan<- *ReturnOfInt) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := IntToInt.GetWorkContextWith(ctx, IntToInt.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfIntToInt) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfIntToInt) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfIntToInt16 struct {
	handler func(context.Context, int) (int16, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfIntToInt16
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfIntToInt16(ctx context.Context, h func(context.Context, int) (int16, error), n int) *FuncWorkerOfIntToInt16 {
	__ := &FuncWorkerOfIntToInt16{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfIntToInt16, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go IntToInt16.CallAsAsync(work.Context, work.WorkOfIntToInt16.Value, work.WorkOfIntToInt16.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				IntToInt16.PutWork(work.WorkOfIntToInt16)
				IntToInt16.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfIntToInt16) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := IntToInt16.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfIntToInt16) Push(ctx context.Context, value int, returnCh chan<- *ReturnOfInt16) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := IntToInt16.GetWorkContextWith(ctx, IntToInt16.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfIntToInt16) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfIntToInt16) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfIntToInt32 struct {
	handler func(context.Context, int) (int32, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfIntToInt32
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfIntToInt32(ctx context.Context, h func(context.Context, int) (int32, error), n int) *FuncWorkerOfIntToInt32 {
	__ := &FuncWorkerOfIntToInt32{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfIntToInt32, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go IntToInt32.CallAsAsync(work.Context, work.WorkOfIntToInt32.Value, work.WorkOfIntToInt32.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				IntToInt32.PutWork(work.WorkOfIntToInt32)
				IntToInt32.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfIntToInt32) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := IntToInt32.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfIntToInt32) Push(ctx context.Context, value int, returnCh chan<- *ReturnOfInt32) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := IntToInt32.GetWorkContextWith(ctx, IntToInt32.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfIntToInt32) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfIntToInt32) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfIntToInt64 struct {
	handler func(context.Context, int) (int64, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfIntToInt64
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfIntToInt64(ctx context.Context, h func(context.Context, int) (int64, error), n int) *FuncWorkerOfIntToInt64 {
	__ := &FuncWorkerOfIntToInt64{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfIntToInt64, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go IntToInt64.CallAsAsync(work.Context, work.WorkOfIntToInt64.Value, work.WorkOfIntToInt64.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				IntToInt64.PutWork(work.WorkOfIntToInt64)
				IntToInt64.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfIntToInt64) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := IntToInt64.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfIntToInt64) Push(ctx context.Context, value int, returnCh chan<- *ReturnOfInt64) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := IntToInt64.GetWorkContextWith(ctx, IntToInt64.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfIntToInt64) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfIntToInt64) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfIntToInt8 struct {
	handler func(context.Context, int) (int8, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfIntToInt8
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfIntToInt8(ctx context.Context, h func(context.Context, int) (int8, error), n int) *FuncWorkerOfIntToInt8 {
	__ := &FuncWorkerOfIntToInt8{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfIntToInt8, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go IntToInt8.CallAsAsync(work.Context, work.WorkOfIntToInt8.Value, work.WorkOfIntToInt8.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				IntToInt8.PutWork(work.WorkOfIntToInt8)
				IntToInt8.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfIntToInt8) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := IntToInt8.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfIntToInt8) Push(ctx context.Context, value int, returnCh chan<- *ReturnOfInt8) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := IntToInt8.GetWorkContextWith(ctx, IntToInt8.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfIntToInt8) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfIntToInt8) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfIntToRune struct {
	handler func(context.Context, int) (rune, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfIntToRune
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfIntToRune(ctx context.Context, h func(context.Context, int) (rune, error), n int) *FuncWorkerOfIntToRune {
	__ := &FuncWorkerOfIntToRune{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfIntToRune, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go IntToRune.CallAsAsync(work.Context, work.WorkOfIntToRune.Value, work.WorkOfIntToRune.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				IntToRune.PutWork(work.WorkOfIntToRune)
				IntToRune.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfIntToRune) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := IntToRune.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfIntToRune) Push(ctx context.Context, value int, returnCh chan<- *ReturnOfRune) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := IntToRune.GetWorkContextWith(ctx, IntToRune.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfIntToRune) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfIntToRune) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfIntToString struct {
	handler func(context.Context, int) (string, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfIntToString
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfIntToString(ctx context.Context, h func(context.Context, int) (string, error), n int) *FuncWorkerOfIntToString {
	__ := &FuncWorkerOfIntToString{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfIntToString, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go IntToString.CallAsAsync(work.Context, work.WorkOfIntToString.Value, work.WorkOfIntToString.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				IntToString.PutWork(work.WorkOfIntToString)
				IntToString.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfIntToString) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := IntToString.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfIntToString) Push(ctx context.Context, value int, returnCh chan<- *ReturnOfString) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := IntToString.GetWorkContextWith(ctx, IntToString.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfIntToString) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfIntToString) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfIntToUint struct {
	handler func(context.Context, int) (uint, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfIntToUint
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfIntToUint(ctx context.Context, h func(context.Context, int) (uint, error), n int) *FuncWorkerOfIntToUint {
	__ := &FuncWorkerOfIntToUint{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfIntToUint, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go IntToUint.CallAsAsync(work.Context, work.WorkOfIntToUint.Value, work.WorkOfIntToUint.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				IntToUint.PutWork(work.WorkOfIntToUint)
				IntToUint.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfIntToUint) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := IntToUint.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfIntToUint) Push(ctx context.Context, value int, returnCh chan<- *ReturnOfUint) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := IntToUint.GetWorkContextWith(ctx, IntToUint.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfIntToUint) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfIntToUint) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfIntToUint16 struct {
	handler func(context.Context, int) (uint16, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfIntToUint16
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfIntToUint16(ctx context.Context, h func(context.Context, int) (uint16, error), n int) *FuncWorkerOfIntToUint16 {
	__ := &FuncWorkerOfIntToUint16{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfIntToUint16, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go IntToUint16.CallAsAsync(work.Context, work.WorkOfIntToUint16.Value, work.WorkOfIntToUint16.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				IntToUint16.PutWork(work.WorkOfIntToUint16)
				IntToUint16.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfIntToUint16) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := IntToUint16.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfIntToUint16) Push(ctx context.Context, value int, returnCh chan<- *ReturnOfUint16) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := IntToUint16.GetWorkContextWith(ctx, IntToUint16.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfIntToUint16) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfIntToUint16) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfIntToUint32 struct {
	handler func(context.Context, int) (uint32, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfIntToUint32
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfIntToUint32(ctx context.Context, h func(context.Context, int) (uint32, error), n int) *FuncWorkerOfIntToUint32 {
	__ := &FuncWorkerOfIntToUint32{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfIntToUint32, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go IntToUint32.CallAsAsync(work.Context, work.WorkOfIntToUint32.Value, work.WorkOfIntToUint32.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				IntToUint32.PutWork(work.WorkOfIntToUint32)
				IntToUint32.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfIntToUint32) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := IntToUint32.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfIntToUint32) Push(ctx context.Context, value int, returnCh chan<- *ReturnOfUint32) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := IntToUint32.GetWorkContextWith(ctx, IntToUint32.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfIntToUint32) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfIntToUint32) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfIntToUint64 struct {
	handler func(context.Context, int) (uint64, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfIntToUint64
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfIntToUint64(ctx context.Context, h func(context.Context, int) (uint64, error), n int) *FuncWorkerOfIntToUint64 {
	__ := &FuncWorkerOfIntToUint64{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfIntToUint64, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go IntToUint64.CallAsAsync(work.Context, work.WorkOfIntToUint64.Value, work.WorkOfIntToUint64.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				IntToUint64.PutWork(work.WorkOfIntToUint64)
				IntToUint64.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfIntToUint64) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := IntToUint64.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfIntToUint64) Push(ctx context.Context, value int, returnCh chan<- *ReturnOfUint64) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := IntToUint64.GetWorkContextWith(ctx, IntToUint64.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfIntToUint64) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfIntToUint64) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfIntToUint8 struct {
	handler func(context.Context, int) (uint8, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfIntToUint8
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfIntToUint8(ctx context.Context, h func(context.Context, int) (uint8, error), n int) *FuncWorkerOfIntToUint8 {
	__ := &FuncWorkerOfIntToUint8{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfIntToUint8, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go IntToUint8.CallAsAsync(work.Context, work.WorkOfIntToUint8.Value, work.WorkOfIntToUint8.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				IntToUint8.PutWork(work.WorkOfIntToUint8)
				IntToUint8.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfIntToUint8) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := IntToUint8.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfIntToUint8) Push(ctx context.Context, value int, returnCh chan<- *ReturnOfUint8) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := IntToUint8.GetWorkContextWith(ctx, IntToUint8.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfIntToUint8) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfIntToUint8) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfIntToUintptr struct {
	handler func(context.Context, int) (uintptr, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfIntToUintptr
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfIntToUintptr(ctx context.Context, h func(context.Context, int) (uintptr, error), n int) *FuncWorkerOfIntToUintptr {
	__ := &FuncWorkerOfIntToUintptr{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfIntToUintptr, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go IntToUintptr.CallAsAsync(work.Context, work.WorkOfIntToUintptr.Value, work.WorkOfIntToUintptr.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				IntToUintptr.PutWork(work.WorkOfIntToUintptr)
				IntToUintptr.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfIntToUintptr) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := IntToUintptr.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfIntToUintptr) Push(ctx context.Context, value int, returnCh chan<- *ReturnOfUintptr) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := IntToUintptr.GetWorkContextWith(ctx, IntToUintptr.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfIntToUintptr) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfIntToUintptr) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfIntToBytes struct {
	handler func(context.Context, int) (Bytes, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfIntToBytes
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfIntToBytes(ctx context.Context, h func(context.Context, int) (Bytes, error), n int) *FuncWorkerOfIntToBytes {
	__ := &FuncWorkerOfIntToBytes{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfIntToBytes, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go IntToBytes.CallAsAsync(work.Context, work.WorkOfIntToBytes.Value, work.WorkOfIntToBytes.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				IntToBytes.PutWork(work.WorkOfIntToBytes)
				IntToBytes.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfIntToBytes) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := IntToBytes.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfIntToBytes) Push(ctx context.Context, value int, returnCh chan<- *ReturnOfBytes) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := IntToBytes.GetWorkContextWith(ctx, IntToBytes.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfIntToBytes) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfIntToBytes) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfIntToInterface struct {
	handler func(context.Context, int) (interface{}, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfIntToInterface
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfIntToInterface(ctx context.Context, h func(context.Context, int) (interface{}, error), n int) *FuncWorkerOfIntToInterface {
	__ := &FuncWorkerOfIntToInterface{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfIntToInterface, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go IntToInterface.CallAsAsync(work.Context, work.WorkOfIntToInterface.Value, work.WorkOfIntToInterface.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				IntToInterface.PutWork(work.WorkOfIntToInterface)
				IntToInterface.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfIntToInterface) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := IntToInterface.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfIntToInterface) Push(ctx context.Context, value int, returnCh chan<- *ReturnOfInterface) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := IntToInterface.GetWorkContextWith(ctx, IntToInterface.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfIntToInterface) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfIntToInterface) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfInt16ToBool struct {
	handler func(context.Context, int16) (bool, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfInt16ToBool
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfInt16ToBool(ctx context.Context, h func(context.Context, int16) (bool, error), n int) *FuncWorkerOfInt16ToBool {
	__ := &FuncWorkerOfInt16ToBool{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfInt16ToBool, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go Int16ToBool.CallAsAsync(work.Context, work.WorkOfInt16ToBool.Value, work.WorkOfInt16ToBool.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				Int16ToBool.PutWork(work.WorkOfInt16ToBool)
				Int16ToBool.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfInt16ToBool) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := Int16ToBool.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfInt16ToBool) Push(ctx context.Context, value int16, returnCh chan<- *ReturnOfBool) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := Int16ToBool.GetWorkContextWith(ctx, Int16ToBool.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfInt16ToBool) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfInt16ToBool) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfInt16ToByte struct {
	handler func(context.Context, int16) (byte, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfInt16ToByte
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfInt16ToByte(ctx context.Context, h func(context.Context, int16) (byte, error), n int) *FuncWorkerOfInt16ToByte {
	__ := &FuncWorkerOfInt16ToByte{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfInt16ToByte, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go Int16ToByte.CallAsAsync(work.Context, work.WorkOfInt16ToByte.Value, work.WorkOfInt16ToByte.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				Int16ToByte.PutWork(work.WorkOfInt16ToByte)
				Int16ToByte.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfInt16ToByte) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := Int16ToByte.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfInt16ToByte) Push(ctx context.Context, value int16, returnCh chan<- *ReturnOfByte) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := Int16ToByte.GetWorkContextWith(ctx, Int16ToByte.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfInt16ToByte) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfInt16ToByte) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfInt16ToComplex128 struct {
	handler func(context.Context, int16) (complex128, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfInt16ToComplex128
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfInt16ToComplex128(ctx context.Context, h func(context.Context, int16) (complex128, error), n int) *FuncWorkerOfInt16ToComplex128 {
	__ := &FuncWorkerOfInt16ToComplex128{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfInt16ToComplex128, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go Int16ToComplex128.CallAsAsync(work.Context, work.WorkOfInt16ToComplex128.Value, work.WorkOfInt16ToComplex128.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				Int16ToComplex128.PutWork(work.WorkOfInt16ToComplex128)
				Int16ToComplex128.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfInt16ToComplex128) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := Int16ToComplex128.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfInt16ToComplex128) Push(ctx context.Context, value int16, returnCh chan<- *ReturnOfComplex128) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := Int16ToComplex128.GetWorkContextWith(ctx, Int16ToComplex128.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfInt16ToComplex128) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfInt16ToComplex128) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfInt16ToComplex64 struct {
	handler func(context.Context, int16) (complex64, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfInt16ToComplex64
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfInt16ToComplex64(ctx context.Context, h func(context.Context, int16) (complex64, error), n int) *FuncWorkerOfInt16ToComplex64 {
	__ := &FuncWorkerOfInt16ToComplex64{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfInt16ToComplex64, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go Int16ToComplex64.CallAsAsync(work.Context, work.WorkOfInt16ToComplex64.Value, work.WorkOfInt16ToComplex64.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				Int16ToComplex64.PutWork(work.WorkOfInt16ToComplex64)
				Int16ToComplex64.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfInt16ToComplex64) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := Int16ToComplex64.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfInt16ToComplex64) Push(ctx context.Context, value int16, returnCh chan<- *ReturnOfComplex64) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := Int16ToComplex64.GetWorkContextWith(ctx, Int16ToComplex64.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfInt16ToComplex64) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfInt16ToComplex64) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfInt16ToError struct {
	handler func(context.Context, int16) (error, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfInt16ToError
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfInt16ToError(ctx context.Context, h func(context.Context, int16) (error, error), n int) *FuncWorkerOfInt16ToError {
	__ := &FuncWorkerOfInt16ToError{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfInt16ToError, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go Int16ToError.CallAsAsync(work.Context, work.WorkOfInt16ToError.Value, work.WorkOfInt16ToError.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				Int16ToError.PutWork(work.WorkOfInt16ToError)
				Int16ToError.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfInt16ToError) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := Int16ToError.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfInt16ToError) Push(ctx context.Context, value int16, returnCh chan<- *ReturnOfError) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := Int16ToError.GetWorkContextWith(ctx, Int16ToError.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfInt16ToError) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfInt16ToError) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfInt16ToFloat32 struct {
	handler func(context.Context, int16) (float32, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfInt16ToFloat32
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfInt16ToFloat32(ctx context.Context, h func(context.Context, int16) (float32, error), n int) *FuncWorkerOfInt16ToFloat32 {
	__ := &FuncWorkerOfInt16ToFloat32{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfInt16ToFloat32, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go Int16ToFloat32.CallAsAsync(work.Context, work.WorkOfInt16ToFloat32.Value, work.WorkOfInt16ToFloat32.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				Int16ToFloat32.PutWork(work.WorkOfInt16ToFloat32)
				Int16ToFloat32.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfInt16ToFloat32) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := Int16ToFloat32.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfInt16ToFloat32) Push(ctx context.Context, value int16, returnCh chan<- *ReturnOfFloat32) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := Int16ToFloat32.GetWorkContextWith(ctx, Int16ToFloat32.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfInt16ToFloat32) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfInt16ToFloat32) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfInt16ToFloat64 struct {
	handler func(context.Context, int16) (float64, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfInt16ToFloat64
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfInt16ToFloat64(ctx context.Context, h func(context.Context, int16) (float64, error), n int) *FuncWorkerOfInt16ToFloat64 {
	__ := &FuncWorkerOfInt16ToFloat64{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfInt16ToFloat64, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go Int16ToFloat64.CallAsAsync(work.Context, work.WorkOfInt16ToFloat64.Value, work.WorkOfInt16ToFloat64.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				Int16ToFloat64.PutWork(work.WorkOfInt16ToFloat64)
				Int16ToFloat64.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfInt16ToFloat64) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := Int16ToFloat64.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfInt16ToFloat64) Push(ctx context.Context, value int16, returnCh chan<- *ReturnOfFloat64) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := Int16ToFloat64.GetWorkContextWith(ctx, Int16ToFloat64.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfInt16ToFloat64) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfInt16ToFloat64) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfInt16ToInt struct {
	handler func(context.Context, int16) (int, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfInt16ToInt
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfInt16ToInt(ctx context.Context, h func(context.Context, int16) (int, error), n int) *FuncWorkerOfInt16ToInt {
	__ := &FuncWorkerOfInt16ToInt{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfInt16ToInt, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go Int16ToInt.CallAsAsync(work.Context, work.WorkOfInt16ToInt.Value, work.WorkOfInt16ToInt.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				Int16ToInt.PutWork(work.WorkOfInt16ToInt)
				Int16ToInt.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfInt16ToInt) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := Int16ToInt.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfInt16ToInt) Push(ctx context.Context, value int16, returnCh chan<- *ReturnOfInt) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := Int16ToInt.GetWorkContextWith(ctx, Int16ToInt.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfInt16ToInt) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfInt16ToInt) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfInt16ToInt16 struct {
	handler func(context.Context, int16) (int16, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfInt16ToInt16
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfInt16ToInt16(ctx context.Context, h func(context.Context, int16) (int16, error), n int) *FuncWorkerOfInt16ToInt16 {
	__ := &FuncWorkerOfInt16ToInt16{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfInt16ToInt16, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go Int16ToInt16.CallAsAsync(work.Context, work.WorkOfInt16ToInt16.Value, work.WorkOfInt16ToInt16.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				Int16ToInt16.PutWork(work.WorkOfInt16ToInt16)
				Int16ToInt16.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfInt16ToInt16) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := Int16ToInt16.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfInt16ToInt16) Push(ctx context.Context, value int16, returnCh chan<- *ReturnOfInt16) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := Int16ToInt16.GetWorkContextWith(ctx, Int16ToInt16.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfInt16ToInt16) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfInt16ToInt16) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfInt16ToInt32 struct {
	handler func(context.Context, int16) (int32, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfInt16ToInt32
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfInt16ToInt32(ctx context.Context, h func(context.Context, int16) (int32, error), n int) *FuncWorkerOfInt16ToInt32 {
	__ := &FuncWorkerOfInt16ToInt32{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfInt16ToInt32, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go Int16ToInt32.CallAsAsync(work.Context, work.WorkOfInt16ToInt32.Value, work.WorkOfInt16ToInt32.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				Int16ToInt32.PutWork(work.WorkOfInt16ToInt32)
				Int16ToInt32.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfInt16ToInt32) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := Int16ToInt32.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfInt16ToInt32) Push(ctx context.Context, value int16, returnCh chan<- *ReturnOfInt32) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := Int16ToInt32.GetWorkContextWith(ctx, Int16ToInt32.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfInt16ToInt32) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfInt16ToInt32) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfInt16ToInt64 struct {
	handler func(context.Context, int16) (int64, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfInt16ToInt64
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfInt16ToInt64(ctx context.Context, h func(context.Context, int16) (int64, error), n int) *FuncWorkerOfInt16ToInt64 {
	__ := &FuncWorkerOfInt16ToInt64{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfInt16ToInt64, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go Int16ToInt64.CallAsAsync(work.Context, work.WorkOfInt16ToInt64.Value, work.WorkOfInt16ToInt64.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				Int16ToInt64.PutWork(work.WorkOfInt16ToInt64)
				Int16ToInt64.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfInt16ToInt64) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := Int16ToInt64.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfInt16ToInt64) Push(ctx context.Context, value int16, returnCh chan<- *ReturnOfInt64) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := Int16ToInt64.GetWorkContextWith(ctx, Int16ToInt64.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfInt16ToInt64) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfInt16ToInt64) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfInt16ToInt8 struct {
	handler func(context.Context, int16) (int8, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfInt16ToInt8
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfInt16ToInt8(ctx context.Context, h func(context.Context, int16) (int8, error), n int) *FuncWorkerOfInt16ToInt8 {
	__ := &FuncWorkerOfInt16ToInt8{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfInt16ToInt8, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go Int16ToInt8.CallAsAsync(work.Context, work.WorkOfInt16ToInt8.Value, work.WorkOfInt16ToInt8.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				Int16ToInt8.PutWork(work.WorkOfInt16ToInt8)
				Int16ToInt8.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfInt16ToInt8) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := Int16ToInt8.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfInt16ToInt8) Push(ctx context.Context, value int16, returnCh chan<- *ReturnOfInt8) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := Int16ToInt8.GetWorkContextWith(ctx, Int16ToInt8.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfInt16ToInt8) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfInt16ToInt8) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfInt16ToRune struct {
	handler func(context.Context, int16) (rune, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfInt16ToRune
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfInt16ToRune(ctx context.Context, h func(context.Context, int16) (rune, error), n int) *FuncWorkerOfInt16ToRune {
	__ := &FuncWorkerOfInt16ToRune{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfInt16ToRune, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go Int16ToRune.CallAsAsync(work.Context, work.WorkOfInt16ToRune.Value, work.WorkOfInt16ToRune.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				Int16ToRune.PutWork(work.WorkOfInt16ToRune)
				Int16ToRune.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfInt16ToRune) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := Int16ToRune.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfInt16ToRune) Push(ctx context.Context, value int16, returnCh chan<- *ReturnOfRune) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := Int16ToRune.GetWorkContextWith(ctx, Int16ToRune.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfInt16ToRune) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfInt16ToRune) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfInt16ToString struct {
	handler func(context.Context, int16) (string, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfInt16ToString
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfInt16ToString(ctx context.Context, h func(context.Context, int16) (string, error), n int) *FuncWorkerOfInt16ToString {
	__ := &FuncWorkerOfInt16ToString{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfInt16ToString, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go Int16ToString.CallAsAsync(work.Context, work.WorkOfInt16ToString.Value, work.WorkOfInt16ToString.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				Int16ToString.PutWork(work.WorkOfInt16ToString)
				Int16ToString.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfInt16ToString) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := Int16ToString.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfInt16ToString) Push(ctx context.Context, value int16, returnCh chan<- *ReturnOfString) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := Int16ToString.GetWorkContextWith(ctx, Int16ToString.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfInt16ToString) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfInt16ToString) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfInt16ToUint struct {
	handler func(context.Context, int16) (uint, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfInt16ToUint
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfInt16ToUint(ctx context.Context, h func(context.Context, int16) (uint, error), n int) *FuncWorkerOfInt16ToUint {
	__ := &FuncWorkerOfInt16ToUint{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfInt16ToUint, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go Int16ToUint.CallAsAsync(work.Context, work.WorkOfInt16ToUint.Value, work.WorkOfInt16ToUint.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				Int16ToUint.PutWork(work.WorkOfInt16ToUint)
				Int16ToUint.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfInt16ToUint) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := Int16ToUint.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfInt16ToUint) Push(ctx context.Context, value int16, returnCh chan<- *ReturnOfUint) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := Int16ToUint.GetWorkContextWith(ctx, Int16ToUint.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfInt16ToUint) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfInt16ToUint) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfInt16ToUint16 struct {
	handler func(context.Context, int16) (uint16, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfInt16ToUint16
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfInt16ToUint16(ctx context.Context, h func(context.Context, int16) (uint16, error), n int) *FuncWorkerOfInt16ToUint16 {
	__ := &FuncWorkerOfInt16ToUint16{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfInt16ToUint16, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go Int16ToUint16.CallAsAsync(work.Context, work.WorkOfInt16ToUint16.Value, work.WorkOfInt16ToUint16.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				Int16ToUint16.PutWork(work.WorkOfInt16ToUint16)
				Int16ToUint16.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfInt16ToUint16) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := Int16ToUint16.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfInt16ToUint16) Push(ctx context.Context, value int16, returnCh chan<- *ReturnOfUint16) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := Int16ToUint16.GetWorkContextWith(ctx, Int16ToUint16.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfInt16ToUint16) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfInt16ToUint16) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfInt16ToUint32 struct {
	handler func(context.Context, int16) (uint32, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfInt16ToUint32
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfInt16ToUint32(ctx context.Context, h func(context.Context, int16) (uint32, error), n int) *FuncWorkerOfInt16ToUint32 {
	__ := &FuncWorkerOfInt16ToUint32{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfInt16ToUint32, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go Int16ToUint32.CallAsAsync(work.Context, work.WorkOfInt16ToUint32.Value, work.WorkOfInt16ToUint32.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				Int16ToUint32.PutWork(work.WorkOfInt16ToUint32)
				Int16ToUint32.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfInt16ToUint32) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := Int16ToUint32.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfInt16ToUint32) Push(ctx context.Context, value int16, returnCh chan<- *ReturnOfUint32) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := Int16ToUint32.GetWorkContextWith(ctx, Int16ToUint32.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfInt16ToUint32) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfInt16ToUint32) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfInt16ToUint64 struct {
	handler func(context.Context, int16) (uint64, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfInt16ToUint64
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfInt16ToUint64(ctx context.Context, h func(context.Context, int16) (uint64, error), n int) *FuncWorkerOfInt16ToUint64 {
	__ := &FuncWorkerOfInt16ToUint64{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfInt16ToUint64, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go Int16ToUint64.CallAsAsync(work.Context, work.WorkOfInt16ToUint64.Value, work.WorkOfInt16ToUint64.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				Int16ToUint64.PutWork(work.WorkOfInt16ToUint64)
				Int16ToUint64.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfInt16ToUint64) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := Int16ToUint64.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfInt16ToUint64) Push(ctx context.Context, value int16, returnCh chan<- *ReturnOfUint64) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := Int16ToUint64.GetWorkContextWith(ctx, Int16ToUint64.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfInt16ToUint64) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfInt16ToUint64) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfInt16ToUint8 struct {
	handler func(context.Context, int16) (uint8, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfInt16ToUint8
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfInt16ToUint8(ctx context.Context, h func(context.Context, int16) (uint8, error), n int) *FuncWorkerOfInt16ToUint8 {
	__ := &FuncWorkerOfInt16ToUint8{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfInt16ToUint8, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go Int16ToUint8.CallAsAsync(work.Context, work.WorkOfInt16ToUint8.Value, work.WorkOfInt16ToUint8.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				Int16ToUint8.PutWork(work.WorkOfInt16ToUint8)
				Int16ToUint8.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfInt16ToUint8) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := Int16ToUint8.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfInt16ToUint8) Push(ctx context.Context, value int16, returnCh chan<- *ReturnOfUint8) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := Int16ToUint8.GetWorkContextWith(ctx, Int16ToUint8.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfInt16ToUint8) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfInt16ToUint8) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfInt16ToUintptr struct {
	handler func(context.Context, int16) (uintptr, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfInt16ToUintptr
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfInt16ToUintptr(ctx context.Context, h func(context.Context, int16) (uintptr, error), n int) *FuncWorkerOfInt16ToUintptr {
	__ := &FuncWorkerOfInt16ToUintptr{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfInt16ToUintptr, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go Int16ToUintptr.CallAsAsync(work.Context, work.WorkOfInt16ToUintptr.Value, work.WorkOfInt16ToUintptr.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				Int16ToUintptr.PutWork(work.WorkOfInt16ToUintptr)
				Int16ToUintptr.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfInt16ToUintptr) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := Int16ToUintptr.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfInt16ToUintptr) Push(ctx context.Context, value int16, returnCh chan<- *ReturnOfUintptr) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := Int16ToUintptr.GetWorkContextWith(ctx, Int16ToUintptr.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfInt16ToUintptr) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfInt16ToUintptr) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfInt16ToBytes struct {
	handler func(context.Context, int16) (Bytes, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfInt16ToBytes
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfInt16ToBytes(ctx context.Context, h func(context.Context, int16) (Bytes, error), n int) *FuncWorkerOfInt16ToBytes {
	__ := &FuncWorkerOfInt16ToBytes{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfInt16ToBytes, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go Int16ToBytes.CallAsAsync(work.Context, work.WorkOfInt16ToBytes.Value, work.WorkOfInt16ToBytes.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				Int16ToBytes.PutWork(work.WorkOfInt16ToBytes)
				Int16ToBytes.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfInt16ToBytes) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := Int16ToBytes.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfInt16ToBytes) Push(ctx context.Context, value int16, returnCh chan<- *ReturnOfBytes) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := Int16ToBytes.GetWorkContextWith(ctx, Int16ToBytes.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfInt16ToBytes) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfInt16ToBytes) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfInt16ToInterface struct {
	handler func(context.Context, int16) (interface{}, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfInt16ToInterface
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfInt16ToInterface(ctx context.Context, h func(context.Context, int16) (interface{}, error), n int) *FuncWorkerOfInt16ToInterface {
	__ := &FuncWorkerOfInt16ToInterface{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfInt16ToInterface, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go Int16ToInterface.CallAsAsync(work.Context, work.WorkOfInt16ToInterface.Value, work.WorkOfInt16ToInterface.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				Int16ToInterface.PutWork(work.WorkOfInt16ToInterface)
				Int16ToInterface.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfInt16ToInterface) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := Int16ToInterface.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfInt16ToInterface) Push(ctx context.Context, value int16, returnCh chan<- *ReturnOfInterface) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := Int16ToInterface.GetWorkContextWith(ctx, Int16ToInterface.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfInt16ToInterface) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfInt16ToInterface) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfInt32ToBool struct {
	handler func(context.Context, int32) (bool, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfInt32ToBool
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfInt32ToBool(ctx context.Context, h func(context.Context, int32) (bool, error), n int) *FuncWorkerOfInt32ToBool {
	__ := &FuncWorkerOfInt32ToBool{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfInt32ToBool, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go Int32ToBool.CallAsAsync(work.Context, work.WorkOfInt32ToBool.Value, work.WorkOfInt32ToBool.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				Int32ToBool.PutWork(work.WorkOfInt32ToBool)
				Int32ToBool.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfInt32ToBool) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := Int32ToBool.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfInt32ToBool) Push(ctx context.Context, value int32, returnCh chan<- *ReturnOfBool) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := Int32ToBool.GetWorkContextWith(ctx, Int32ToBool.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfInt32ToBool) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfInt32ToBool) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfInt32ToByte struct {
	handler func(context.Context, int32) (byte, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfInt32ToByte
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfInt32ToByte(ctx context.Context, h func(context.Context, int32) (byte, error), n int) *FuncWorkerOfInt32ToByte {
	__ := &FuncWorkerOfInt32ToByte{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfInt32ToByte, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go Int32ToByte.CallAsAsync(work.Context, work.WorkOfInt32ToByte.Value, work.WorkOfInt32ToByte.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				Int32ToByte.PutWork(work.WorkOfInt32ToByte)
				Int32ToByte.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfInt32ToByte) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := Int32ToByte.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfInt32ToByte) Push(ctx context.Context, value int32, returnCh chan<- *ReturnOfByte) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := Int32ToByte.GetWorkContextWith(ctx, Int32ToByte.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfInt32ToByte) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfInt32ToByte) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfInt32ToComplex128 struct {
	handler func(context.Context, int32) (complex128, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfInt32ToComplex128
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfInt32ToComplex128(ctx context.Context, h func(context.Context, int32) (complex128, error), n int) *FuncWorkerOfInt32ToComplex128 {
	__ := &FuncWorkerOfInt32ToComplex128{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfInt32ToComplex128, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go Int32ToComplex128.CallAsAsync(work.Context, work.WorkOfInt32ToComplex128.Value, work.WorkOfInt32ToComplex128.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				Int32ToComplex128.PutWork(work.WorkOfInt32ToComplex128)
				Int32ToComplex128.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfInt32ToComplex128) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := Int32ToComplex128.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfInt32ToComplex128) Push(ctx context.Context, value int32, returnCh chan<- *ReturnOfComplex128) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := Int32ToComplex128.GetWorkContextWith(ctx, Int32ToComplex128.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfInt32ToComplex128) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfInt32ToComplex128) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfInt32ToComplex64 struct {
	handler func(context.Context, int32) (complex64, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfInt32ToComplex64
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfInt32ToComplex64(ctx context.Context, h func(context.Context, int32) (complex64, error), n int) *FuncWorkerOfInt32ToComplex64 {
	__ := &FuncWorkerOfInt32ToComplex64{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfInt32ToComplex64, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go Int32ToComplex64.CallAsAsync(work.Context, work.WorkOfInt32ToComplex64.Value, work.WorkOfInt32ToComplex64.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				Int32ToComplex64.PutWork(work.WorkOfInt32ToComplex64)
				Int32ToComplex64.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfInt32ToComplex64) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := Int32ToComplex64.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfInt32ToComplex64) Push(ctx context.Context, value int32, returnCh chan<- *ReturnOfComplex64) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := Int32ToComplex64.GetWorkContextWith(ctx, Int32ToComplex64.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfInt32ToComplex64) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfInt32ToComplex64) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfInt32ToError struct {
	handler func(context.Context, int32) (error, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfInt32ToError
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfInt32ToError(ctx context.Context, h func(context.Context, int32) (error, error), n int) *FuncWorkerOfInt32ToError {
	__ := &FuncWorkerOfInt32ToError{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfInt32ToError, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go Int32ToError.CallAsAsync(work.Context, work.WorkOfInt32ToError.Value, work.WorkOfInt32ToError.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				Int32ToError.PutWork(work.WorkOfInt32ToError)
				Int32ToError.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfInt32ToError) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := Int32ToError.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfInt32ToError) Push(ctx context.Context, value int32, returnCh chan<- *ReturnOfError) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := Int32ToError.GetWorkContextWith(ctx, Int32ToError.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfInt32ToError) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfInt32ToError) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfInt32ToFloat32 struct {
	handler func(context.Context, int32) (float32, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfInt32ToFloat32
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfInt32ToFloat32(ctx context.Context, h func(context.Context, int32) (float32, error), n int) *FuncWorkerOfInt32ToFloat32 {
	__ := &FuncWorkerOfInt32ToFloat32{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfInt32ToFloat32, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go Int32ToFloat32.CallAsAsync(work.Context, work.WorkOfInt32ToFloat32.Value, work.WorkOfInt32ToFloat32.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				Int32ToFloat32.PutWork(work.WorkOfInt32ToFloat32)
				Int32ToFloat32.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfInt32ToFloat32) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := Int32ToFloat32.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfInt32ToFloat32) Push(ctx context.Context, value int32, returnCh chan<- *ReturnOfFloat32) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := Int32ToFloat32.GetWorkContextWith(ctx, Int32ToFloat32.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfInt32ToFloat32) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfInt32ToFloat32) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfInt32ToFloat64 struct {
	handler func(context.Context, int32) (float64, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfInt32ToFloat64
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfInt32ToFloat64(ctx context.Context, h func(context.Context, int32) (float64, error), n int) *FuncWorkerOfInt32ToFloat64 {
	__ := &FuncWorkerOfInt32ToFloat64{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfInt32ToFloat64, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go Int32ToFloat64.CallAsAsync(work.Context, work.WorkOfInt32ToFloat64.Value, work.WorkOfInt32ToFloat64.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				Int32ToFloat64.PutWork(work.WorkOfInt32ToFloat64)
				Int32ToFloat64.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfInt32ToFloat64) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := Int32ToFloat64.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfInt32ToFloat64) Push(ctx context.Context, value int32, returnCh chan<- *ReturnOfFloat64) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := Int32ToFloat64.GetWorkContextWith(ctx, Int32ToFloat64.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfInt32ToFloat64) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfInt32ToFloat64) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfInt32ToInt struct {
	handler func(context.Context, int32) (int, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfInt32ToInt
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfInt32ToInt(ctx context.Context, h func(context.Context, int32) (int, error), n int) *FuncWorkerOfInt32ToInt {
	__ := &FuncWorkerOfInt32ToInt{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfInt32ToInt, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go Int32ToInt.CallAsAsync(work.Context, work.WorkOfInt32ToInt.Value, work.WorkOfInt32ToInt.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				Int32ToInt.PutWork(work.WorkOfInt32ToInt)
				Int32ToInt.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfInt32ToInt) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := Int32ToInt.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfInt32ToInt) Push(ctx context.Context, value int32, returnCh chan<- *ReturnOfInt) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := Int32ToInt.GetWorkContextWith(ctx, Int32ToInt.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfInt32ToInt) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfInt32ToInt) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfInt32ToInt16 struct {
	handler func(context.Context, int32) (int16, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfInt32ToInt16
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfInt32ToInt16(ctx context.Context, h func(context.Context, int32) (int16, error), n int) *FuncWorkerOfInt32ToInt16 {
	__ := &FuncWorkerOfInt32ToInt16{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfInt32ToInt16, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go Int32ToInt16.CallAsAsync(work.Context, work.WorkOfInt32ToInt16.Value, work.WorkOfInt32ToInt16.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				Int32ToInt16.PutWork(work.WorkOfInt32ToInt16)
				Int32ToInt16.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfInt32ToInt16) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := Int32ToInt16.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfInt32ToInt16) Push(ctx context.Context, value int32, returnCh chan<- *ReturnOfInt16) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := Int32ToInt16.GetWorkContextWith(ctx, Int32ToInt16.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfInt32ToInt16) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfInt32ToInt16) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfInt32ToInt32 struct {
	handler func(context.Context, int32) (int32, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfInt32ToInt32
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfInt32ToInt32(ctx context.Context, h func(context.Context, int32) (int32, error), n int) *FuncWorkerOfInt32ToInt32 {
	__ := &FuncWorkerOfInt32ToInt32{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfInt32ToInt32, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go Int32ToInt32.CallAsAsync(work.Context, work.WorkOfInt32ToInt32.Value, work.WorkOfInt32ToInt32.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				Int32ToInt32.PutWork(work.WorkOfInt32ToInt32)
				Int32ToInt32.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfInt32ToInt32) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := Int32ToInt32.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfInt32ToInt32) Push(ctx context.Context, value int32, returnCh chan<- *ReturnOfInt32) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := Int32ToInt32.GetWorkContextWith(ctx, Int32ToInt32.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfInt32ToInt32) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfInt32ToInt32) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfInt32ToInt64 struct {
	handler func(context.Context, int32) (int64, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfInt32ToInt64
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfInt32ToInt64(ctx context.Context, h func(context.Context, int32) (int64, error), n int) *FuncWorkerOfInt32ToInt64 {
	__ := &FuncWorkerOfInt32ToInt64{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfInt32ToInt64, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go Int32ToInt64.CallAsAsync(work.Context, work.WorkOfInt32ToInt64.Value, work.WorkOfInt32ToInt64.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				Int32ToInt64.PutWork(work.WorkOfInt32ToInt64)
				Int32ToInt64.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfInt32ToInt64) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := Int32ToInt64.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfInt32ToInt64) Push(ctx context.Context, value int32, returnCh chan<- *ReturnOfInt64) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := Int32ToInt64.GetWorkContextWith(ctx, Int32ToInt64.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfInt32ToInt64) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfInt32ToInt64) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfInt32ToInt8 struct {
	handler func(context.Context, int32) (int8, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfInt32ToInt8
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfInt32ToInt8(ctx context.Context, h func(context.Context, int32) (int8, error), n int) *FuncWorkerOfInt32ToInt8 {
	__ := &FuncWorkerOfInt32ToInt8{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfInt32ToInt8, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go Int32ToInt8.CallAsAsync(work.Context, work.WorkOfInt32ToInt8.Value, work.WorkOfInt32ToInt8.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				Int32ToInt8.PutWork(work.WorkOfInt32ToInt8)
				Int32ToInt8.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfInt32ToInt8) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := Int32ToInt8.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfInt32ToInt8) Push(ctx context.Context, value int32, returnCh chan<- *ReturnOfInt8) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := Int32ToInt8.GetWorkContextWith(ctx, Int32ToInt8.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfInt32ToInt8) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfInt32ToInt8) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfInt32ToRune struct {
	handler func(context.Context, int32) (rune, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfInt32ToRune
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfInt32ToRune(ctx context.Context, h func(context.Context, int32) (rune, error), n int) *FuncWorkerOfInt32ToRune {
	__ := &FuncWorkerOfInt32ToRune{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfInt32ToRune, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go Int32ToRune.CallAsAsync(work.Context, work.WorkOfInt32ToRune.Value, work.WorkOfInt32ToRune.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				Int32ToRune.PutWork(work.WorkOfInt32ToRune)
				Int32ToRune.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfInt32ToRune) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := Int32ToRune.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfInt32ToRune) Push(ctx context.Context, value int32, returnCh chan<- *ReturnOfRune) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := Int32ToRune.GetWorkContextWith(ctx, Int32ToRune.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfInt32ToRune) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfInt32ToRune) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfInt32ToString struct {
	handler func(context.Context, int32) (string, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfInt32ToString
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfInt32ToString(ctx context.Context, h func(context.Context, int32) (string, error), n int) *FuncWorkerOfInt32ToString {
	__ := &FuncWorkerOfInt32ToString{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfInt32ToString, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go Int32ToString.CallAsAsync(work.Context, work.WorkOfInt32ToString.Value, work.WorkOfInt32ToString.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				Int32ToString.PutWork(work.WorkOfInt32ToString)
				Int32ToString.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfInt32ToString) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := Int32ToString.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfInt32ToString) Push(ctx context.Context, value int32, returnCh chan<- *ReturnOfString) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := Int32ToString.GetWorkContextWith(ctx, Int32ToString.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfInt32ToString) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfInt32ToString) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfInt32ToUint struct {
	handler func(context.Context, int32) (uint, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfInt32ToUint
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfInt32ToUint(ctx context.Context, h func(context.Context, int32) (uint, error), n int) *FuncWorkerOfInt32ToUint {
	__ := &FuncWorkerOfInt32ToUint{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfInt32ToUint, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go Int32ToUint.CallAsAsync(work.Context, work.WorkOfInt32ToUint.Value, work.WorkOfInt32ToUint.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				Int32ToUint.PutWork(work.WorkOfInt32ToUint)
				Int32ToUint.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfInt32ToUint) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := Int32ToUint.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfInt32ToUint) Push(ctx context.Context, value int32, returnCh chan<- *ReturnOfUint) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := Int32ToUint.GetWorkContextWith(ctx, Int32ToUint.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfInt32ToUint) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfInt32ToUint) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfInt32ToUint16 struct {
	handler func(context.Context, int32) (uint16, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfInt32ToUint16
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfInt32ToUint16(ctx context.Context, h func(context.Context, int32) (uint16, error), n int) *FuncWorkerOfInt32ToUint16 {
	__ := &FuncWorkerOfInt32ToUint16{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfInt32ToUint16, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go Int32ToUint16.CallAsAsync(work.Context, work.WorkOfInt32ToUint16.Value, work.WorkOfInt32ToUint16.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				Int32ToUint16.PutWork(work.WorkOfInt32ToUint16)
				Int32ToUint16.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfInt32ToUint16) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := Int32ToUint16.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfInt32ToUint16) Push(ctx context.Context, value int32, returnCh chan<- *ReturnOfUint16) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := Int32ToUint16.GetWorkContextWith(ctx, Int32ToUint16.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfInt32ToUint16) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfInt32ToUint16) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfInt32ToUint32 struct {
	handler func(context.Context, int32) (uint32, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfInt32ToUint32
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfInt32ToUint32(ctx context.Context, h func(context.Context, int32) (uint32, error), n int) *FuncWorkerOfInt32ToUint32 {
	__ := &FuncWorkerOfInt32ToUint32{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfInt32ToUint32, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go Int32ToUint32.CallAsAsync(work.Context, work.WorkOfInt32ToUint32.Value, work.WorkOfInt32ToUint32.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				Int32ToUint32.PutWork(work.WorkOfInt32ToUint32)
				Int32ToUint32.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfInt32ToUint32) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := Int32ToUint32.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfInt32ToUint32) Push(ctx context.Context, value int32, returnCh chan<- *ReturnOfUint32) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := Int32ToUint32.GetWorkContextWith(ctx, Int32ToUint32.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfInt32ToUint32) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfInt32ToUint32) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfInt32ToUint64 struct {
	handler func(context.Context, int32) (uint64, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfInt32ToUint64
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfInt32ToUint64(ctx context.Context, h func(context.Context, int32) (uint64, error), n int) *FuncWorkerOfInt32ToUint64 {
	__ := &FuncWorkerOfInt32ToUint64{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfInt32ToUint64, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go Int32ToUint64.CallAsAsync(work.Context, work.WorkOfInt32ToUint64.Value, work.WorkOfInt32ToUint64.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				Int32ToUint64.PutWork(work.WorkOfInt32ToUint64)
				Int32ToUint64.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfInt32ToUint64) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := Int32ToUint64.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfInt32ToUint64) Push(ctx context.Context, value int32, returnCh chan<- *ReturnOfUint64) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := Int32ToUint64.GetWorkContextWith(ctx, Int32ToUint64.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfInt32ToUint64) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfInt32ToUint64) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfInt32ToUint8 struct {
	handler func(context.Context, int32) (uint8, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfInt32ToUint8
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfInt32ToUint8(ctx context.Context, h func(context.Context, int32) (uint8, error), n int) *FuncWorkerOfInt32ToUint8 {
	__ := &FuncWorkerOfInt32ToUint8{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfInt32ToUint8, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go Int32ToUint8.CallAsAsync(work.Context, work.WorkOfInt32ToUint8.Value, work.WorkOfInt32ToUint8.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				Int32ToUint8.PutWork(work.WorkOfInt32ToUint8)
				Int32ToUint8.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfInt32ToUint8) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := Int32ToUint8.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfInt32ToUint8) Push(ctx context.Context, value int32, returnCh chan<- *ReturnOfUint8) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := Int32ToUint8.GetWorkContextWith(ctx, Int32ToUint8.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfInt32ToUint8) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfInt32ToUint8) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfInt32ToUintptr struct {
	handler func(context.Context, int32) (uintptr, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfInt32ToUintptr
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfInt32ToUintptr(ctx context.Context, h func(context.Context, int32) (uintptr, error), n int) *FuncWorkerOfInt32ToUintptr {
	__ := &FuncWorkerOfInt32ToUintptr{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfInt32ToUintptr, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go Int32ToUintptr.CallAsAsync(work.Context, work.WorkOfInt32ToUintptr.Value, work.WorkOfInt32ToUintptr.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				Int32ToUintptr.PutWork(work.WorkOfInt32ToUintptr)
				Int32ToUintptr.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfInt32ToUintptr) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := Int32ToUintptr.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfInt32ToUintptr) Push(ctx context.Context, value int32, returnCh chan<- *ReturnOfUintptr) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := Int32ToUintptr.GetWorkContextWith(ctx, Int32ToUintptr.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfInt32ToUintptr) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfInt32ToUintptr) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfInt32ToBytes struct {
	handler func(context.Context, int32) (Bytes, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfInt32ToBytes
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfInt32ToBytes(ctx context.Context, h func(context.Context, int32) (Bytes, error), n int) *FuncWorkerOfInt32ToBytes {
	__ := &FuncWorkerOfInt32ToBytes{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfInt32ToBytes, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go Int32ToBytes.CallAsAsync(work.Context, work.WorkOfInt32ToBytes.Value, work.WorkOfInt32ToBytes.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				Int32ToBytes.PutWork(work.WorkOfInt32ToBytes)
				Int32ToBytes.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfInt32ToBytes) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := Int32ToBytes.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfInt32ToBytes) Push(ctx context.Context, value int32, returnCh chan<- *ReturnOfBytes) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := Int32ToBytes.GetWorkContextWith(ctx, Int32ToBytes.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfInt32ToBytes) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfInt32ToBytes) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfInt32ToInterface struct {
	handler func(context.Context, int32) (interface{}, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfInt32ToInterface
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfInt32ToInterface(ctx context.Context, h func(context.Context, int32) (interface{}, error), n int) *FuncWorkerOfInt32ToInterface {
	__ := &FuncWorkerOfInt32ToInterface{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfInt32ToInterface, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go Int32ToInterface.CallAsAsync(work.Context, work.WorkOfInt32ToInterface.Value, work.WorkOfInt32ToInterface.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				Int32ToInterface.PutWork(work.WorkOfInt32ToInterface)
				Int32ToInterface.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfInt32ToInterface) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := Int32ToInterface.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfInt32ToInterface) Push(ctx context.Context, value int32, returnCh chan<- *ReturnOfInterface) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := Int32ToInterface.GetWorkContextWith(ctx, Int32ToInterface.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfInt32ToInterface) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfInt32ToInterface) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfInt64ToBool struct {
	handler func(context.Context, int64) (bool, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfInt64ToBool
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfInt64ToBool(ctx context.Context, h func(context.Context, int64) (bool, error), n int) *FuncWorkerOfInt64ToBool {
	__ := &FuncWorkerOfInt64ToBool{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfInt64ToBool, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go Int64ToBool.CallAsAsync(work.Context, work.WorkOfInt64ToBool.Value, work.WorkOfInt64ToBool.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				Int64ToBool.PutWork(work.WorkOfInt64ToBool)
				Int64ToBool.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfInt64ToBool) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := Int64ToBool.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfInt64ToBool) Push(ctx context.Context, value int64, returnCh chan<- *ReturnOfBool) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := Int64ToBool.GetWorkContextWith(ctx, Int64ToBool.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfInt64ToBool) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfInt64ToBool) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfInt64ToByte struct {
	handler func(context.Context, int64) (byte, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfInt64ToByte
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfInt64ToByte(ctx context.Context, h func(context.Context, int64) (byte, error), n int) *FuncWorkerOfInt64ToByte {
	__ := &FuncWorkerOfInt64ToByte{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfInt64ToByte, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go Int64ToByte.CallAsAsync(work.Context, work.WorkOfInt64ToByte.Value, work.WorkOfInt64ToByte.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				Int64ToByte.PutWork(work.WorkOfInt64ToByte)
				Int64ToByte.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfInt64ToByte) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := Int64ToByte.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfInt64ToByte) Push(ctx context.Context, value int64, returnCh chan<- *ReturnOfByte) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := Int64ToByte.GetWorkContextWith(ctx, Int64ToByte.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfInt64ToByte) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfInt64ToByte) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfInt64ToComplex128 struct {
	handler func(context.Context, int64) (complex128, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfInt64ToComplex128
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfInt64ToComplex128(ctx context.Context, h func(context.Context, int64) (complex128, error), n int) *FuncWorkerOfInt64ToComplex128 {
	__ := &FuncWorkerOfInt64ToComplex128{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfInt64ToComplex128, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go Int64ToComplex128.CallAsAsync(work.Context, work.WorkOfInt64ToComplex128.Value, work.WorkOfInt64ToComplex128.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				Int64ToComplex128.PutWork(work.WorkOfInt64ToComplex128)
				Int64ToComplex128.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfInt64ToComplex128) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := Int64ToComplex128.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfInt64ToComplex128) Push(ctx context.Context, value int64, returnCh chan<- *ReturnOfComplex128) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := Int64ToComplex128.GetWorkContextWith(ctx, Int64ToComplex128.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfInt64ToComplex128) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfInt64ToComplex128) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfInt64ToComplex64 struct {
	handler func(context.Context, int64) (complex64, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfInt64ToComplex64
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfInt64ToComplex64(ctx context.Context, h func(context.Context, int64) (complex64, error), n int) *FuncWorkerOfInt64ToComplex64 {
	__ := &FuncWorkerOfInt64ToComplex64{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfInt64ToComplex64, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go Int64ToComplex64.CallAsAsync(work.Context, work.WorkOfInt64ToComplex64.Value, work.WorkOfInt64ToComplex64.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				Int64ToComplex64.PutWork(work.WorkOfInt64ToComplex64)
				Int64ToComplex64.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfInt64ToComplex64) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := Int64ToComplex64.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfInt64ToComplex64) Push(ctx context.Context, value int64, returnCh chan<- *ReturnOfComplex64) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := Int64ToComplex64.GetWorkContextWith(ctx, Int64ToComplex64.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfInt64ToComplex64) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfInt64ToComplex64) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfInt64ToError struct {
	handler func(context.Context, int64) (error, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfInt64ToError
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfInt64ToError(ctx context.Context, h func(context.Context, int64) (error, error), n int) *FuncWorkerOfInt64ToError {
	__ := &FuncWorkerOfInt64ToError{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfInt64ToError, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go Int64ToError.CallAsAsync(work.Context, work.WorkOfInt64ToError.Value, work.WorkOfInt64ToError.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				Int64ToError.PutWork(work.WorkOfInt64ToError)
				Int64ToError.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfInt64ToError) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := Int64ToError.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfInt64ToError) Push(ctx context.Context, value int64, returnCh chan<- *ReturnOfError) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := Int64ToError.GetWorkContextWith(ctx, Int64ToError.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfInt64ToError) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfInt64ToError) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfInt64ToFloat32 struct {
	handler func(context.Context, int64) (float32, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfInt64ToFloat32
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfInt64ToFloat32(ctx context.Context, h func(context.Context, int64) (float32, error), n int) *FuncWorkerOfInt64ToFloat32 {
	__ := &FuncWorkerOfInt64ToFloat32{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfInt64ToFloat32, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go Int64ToFloat32.CallAsAsync(work.Context, work.WorkOfInt64ToFloat32.Value, work.WorkOfInt64ToFloat32.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				Int64ToFloat32.PutWork(work.WorkOfInt64ToFloat32)
				Int64ToFloat32.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfInt64ToFloat32) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := Int64ToFloat32.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfInt64ToFloat32) Push(ctx context.Context, value int64, returnCh chan<- *ReturnOfFloat32) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := Int64ToFloat32.GetWorkContextWith(ctx, Int64ToFloat32.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfInt64ToFloat32) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfInt64ToFloat32) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfInt64ToFloat64 struct {
	handler func(context.Context, int64) (float64, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfInt64ToFloat64
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfInt64ToFloat64(ctx context.Context, h func(context.Context, int64) (float64, error), n int) *FuncWorkerOfInt64ToFloat64 {
	__ := &FuncWorkerOfInt64ToFloat64{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfInt64ToFloat64, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go Int64ToFloat64.CallAsAsync(work.Context, work.WorkOfInt64ToFloat64.Value, work.WorkOfInt64ToFloat64.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				Int64ToFloat64.PutWork(work.WorkOfInt64ToFloat64)
				Int64ToFloat64.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfInt64ToFloat64) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := Int64ToFloat64.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfInt64ToFloat64) Push(ctx context.Context, value int64, returnCh chan<- *ReturnOfFloat64) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := Int64ToFloat64.GetWorkContextWith(ctx, Int64ToFloat64.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfInt64ToFloat64) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfInt64ToFloat64) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfInt64ToInt struct {
	handler func(context.Context, int64) (int, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfInt64ToInt
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfInt64ToInt(ctx context.Context, h func(context.Context, int64) (int, error), n int) *FuncWorkerOfInt64ToInt {
	__ := &FuncWorkerOfInt64ToInt{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfInt64ToInt, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go Int64ToInt.CallAsAsync(work.Context, work.WorkOfInt64ToInt.Value, work.WorkOfInt64ToInt.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				Int64ToInt.PutWork(work.WorkOfInt64ToInt)
				Int64ToInt.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfInt64ToInt) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := Int64ToInt.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfInt64ToInt) Push(ctx context.Context, value int64, returnCh chan<- *ReturnOfInt) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := Int64ToInt.GetWorkContextWith(ctx, Int64ToInt.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfInt64ToInt) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfInt64ToInt) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfInt64ToInt16 struct {
	handler func(context.Context, int64) (int16, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfInt64ToInt16
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfInt64ToInt16(ctx context.Context, h func(context.Context, int64) (int16, error), n int) *FuncWorkerOfInt64ToInt16 {
	__ := &FuncWorkerOfInt64ToInt16{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfInt64ToInt16, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go Int64ToInt16.CallAsAsync(work.Context, work.WorkOfInt64ToInt16.Value, work.WorkOfInt64ToInt16.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				Int64ToInt16.PutWork(work.WorkOfInt64ToInt16)
				Int64ToInt16.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfInt64ToInt16) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := Int64ToInt16.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfInt64ToInt16) Push(ctx context.Context, value int64, returnCh chan<- *ReturnOfInt16) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := Int64ToInt16.GetWorkContextWith(ctx, Int64ToInt16.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfInt64ToInt16) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfInt64ToInt16) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfInt64ToInt32 struct {
	handler func(context.Context, int64) (int32, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfInt64ToInt32
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfInt64ToInt32(ctx context.Context, h func(context.Context, int64) (int32, error), n int) *FuncWorkerOfInt64ToInt32 {
	__ := &FuncWorkerOfInt64ToInt32{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfInt64ToInt32, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go Int64ToInt32.CallAsAsync(work.Context, work.WorkOfInt64ToInt32.Value, work.WorkOfInt64ToInt32.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				Int64ToInt32.PutWork(work.WorkOfInt64ToInt32)
				Int64ToInt32.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfInt64ToInt32) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := Int64ToInt32.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfInt64ToInt32) Push(ctx context.Context, value int64, returnCh chan<- *ReturnOfInt32) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := Int64ToInt32.GetWorkContextWith(ctx, Int64ToInt32.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfInt64ToInt32) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfInt64ToInt32) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfInt64ToInt64 struct {
	handler func(context.Context, int64) (int64, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfInt64ToInt64
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfInt64ToInt64(ctx context.Context, h func(context.Context, int64) (int64, error), n int) *FuncWorkerOfInt64ToInt64 {
	__ := &FuncWorkerOfInt64ToInt64{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfInt64ToInt64, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go Int64ToInt64.CallAsAsync(work.Context, work.WorkOfInt64ToInt64.Value, work.WorkOfInt64ToInt64.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				Int64ToInt64.PutWork(work.WorkOfInt64ToInt64)
				Int64ToInt64.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfInt64ToInt64) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := Int64ToInt64.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfInt64ToInt64) Push(ctx context.Context, value int64, returnCh chan<- *ReturnOfInt64) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := Int64ToInt64.GetWorkContextWith(ctx, Int64ToInt64.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfInt64ToInt64) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfInt64ToInt64) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfInt64ToInt8 struct {
	handler func(context.Context, int64) (int8, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfInt64ToInt8
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfInt64ToInt8(ctx context.Context, h func(context.Context, int64) (int8, error), n int) *FuncWorkerOfInt64ToInt8 {
	__ := &FuncWorkerOfInt64ToInt8{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfInt64ToInt8, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go Int64ToInt8.CallAsAsync(work.Context, work.WorkOfInt64ToInt8.Value, work.WorkOfInt64ToInt8.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				Int64ToInt8.PutWork(work.WorkOfInt64ToInt8)
				Int64ToInt8.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfInt64ToInt8) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := Int64ToInt8.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfInt64ToInt8) Push(ctx context.Context, value int64, returnCh chan<- *ReturnOfInt8) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := Int64ToInt8.GetWorkContextWith(ctx, Int64ToInt8.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfInt64ToInt8) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfInt64ToInt8) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfInt64ToRune struct {
	handler func(context.Context, int64) (rune, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfInt64ToRune
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfInt64ToRune(ctx context.Context, h func(context.Context, int64) (rune, error), n int) *FuncWorkerOfInt64ToRune {
	__ := &FuncWorkerOfInt64ToRune{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfInt64ToRune, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go Int64ToRune.CallAsAsync(work.Context, work.WorkOfInt64ToRune.Value, work.WorkOfInt64ToRune.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				Int64ToRune.PutWork(work.WorkOfInt64ToRune)
				Int64ToRune.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfInt64ToRune) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := Int64ToRune.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfInt64ToRune) Push(ctx context.Context, value int64, returnCh chan<- *ReturnOfRune) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := Int64ToRune.GetWorkContextWith(ctx, Int64ToRune.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfInt64ToRune) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfInt64ToRune) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfInt64ToString struct {
	handler func(context.Context, int64) (string, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfInt64ToString
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfInt64ToString(ctx context.Context, h func(context.Context, int64) (string, error), n int) *FuncWorkerOfInt64ToString {
	__ := &FuncWorkerOfInt64ToString{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfInt64ToString, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go Int64ToString.CallAsAsync(work.Context, work.WorkOfInt64ToString.Value, work.WorkOfInt64ToString.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				Int64ToString.PutWork(work.WorkOfInt64ToString)
				Int64ToString.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfInt64ToString) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := Int64ToString.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfInt64ToString) Push(ctx context.Context, value int64, returnCh chan<- *ReturnOfString) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := Int64ToString.GetWorkContextWith(ctx, Int64ToString.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfInt64ToString) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfInt64ToString) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfInt64ToUint struct {
	handler func(context.Context, int64) (uint, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfInt64ToUint
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfInt64ToUint(ctx context.Context, h func(context.Context, int64) (uint, error), n int) *FuncWorkerOfInt64ToUint {
	__ := &FuncWorkerOfInt64ToUint{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfInt64ToUint, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go Int64ToUint.CallAsAsync(work.Context, work.WorkOfInt64ToUint.Value, work.WorkOfInt64ToUint.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				Int64ToUint.PutWork(work.WorkOfInt64ToUint)
				Int64ToUint.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfInt64ToUint) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := Int64ToUint.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfInt64ToUint) Push(ctx context.Context, value int64, returnCh chan<- *ReturnOfUint) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := Int64ToUint.GetWorkContextWith(ctx, Int64ToUint.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfInt64ToUint) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfInt64ToUint) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfInt64ToUint16 struct {
	handler func(context.Context, int64) (uint16, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfInt64ToUint16
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfInt64ToUint16(ctx context.Context, h func(context.Context, int64) (uint16, error), n int) *FuncWorkerOfInt64ToUint16 {
	__ := &FuncWorkerOfInt64ToUint16{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfInt64ToUint16, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go Int64ToUint16.CallAsAsync(work.Context, work.WorkOfInt64ToUint16.Value, work.WorkOfInt64ToUint16.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				Int64ToUint16.PutWork(work.WorkOfInt64ToUint16)
				Int64ToUint16.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfInt64ToUint16) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := Int64ToUint16.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfInt64ToUint16) Push(ctx context.Context, value int64, returnCh chan<- *ReturnOfUint16) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := Int64ToUint16.GetWorkContextWith(ctx, Int64ToUint16.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfInt64ToUint16) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfInt64ToUint16) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfInt64ToUint32 struct {
	handler func(context.Context, int64) (uint32, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfInt64ToUint32
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfInt64ToUint32(ctx context.Context, h func(context.Context, int64) (uint32, error), n int) *FuncWorkerOfInt64ToUint32 {
	__ := &FuncWorkerOfInt64ToUint32{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfInt64ToUint32, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go Int64ToUint32.CallAsAsync(work.Context, work.WorkOfInt64ToUint32.Value, work.WorkOfInt64ToUint32.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				Int64ToUint32.PutWork(work.WorkOfInt64ToUint32)
				Int64ToUint32.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfInt64ToUint32) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := Int64ToUint32.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfInt64ToUint32) Push(ctx context.Context, value int64, returnCh chan<- *ReturnOfUint32) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := Int64ToUint32.GetWorkContextWith(ctx, Int64ToUint32.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfInt64ToUint32) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfInt64ToUint32) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfInt64ToUint64 struct {
	handler func(context.Context, int64) (uint64, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfInt64ToUint64
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfInt64ToUint64(ctx context.Context, h func(context.Context, int64) (uint64, error), n int) *FuncWorkerOfInt64ToUint64 {
	__ := &FuncWorkerOfInt64ToUint64{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfInt64ToUint64, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go Int64ToUint64.CallAsAsync(work.Context, work.WorkOfInt64ToUint64.Value, work.WorkOfInt64ToUint64.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				Int64ToUint64.PutWork(work.WorkOfInt64ToUint64)
				Int64ToUint64.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfInt64ToUint64) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := Int64ToUint64.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfInt64ToUint64) Push(ctx context.Context, value int64, returnCh chan<- *ReturnOfUint64) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := Int64ToUint64.GetWorkContextWith(ctx, Int64ToUint64.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfInt64ToUint64) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfInt64ToUint64) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfInt64ToUint8 struct {
	handler func(context.Context, int64) (uint8, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfInt64ToUint8
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfInt64ToUint8(ctx context.Context, h func(context.Context, int64) (uint8, error), n int) *FuncWorkerOfInt64ToUint8 {
	__ := &FuncWorkerOfInt64ToUint8{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfInt64ToUint8, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go Int64ToUint8.CallAsAsync(work.Context, work.WorkOfInt64ToUint8.Value, work.WorkOfInt64ToUint8.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				Int64ToUint8.PutWork(work.WorkOfInt64ToUint8)
				Int64ToUint8.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfInt64ToUint8) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := Int64ToUint8.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfInt64ToUint8) Push(ctx context.Context, value int64, returnCh chan<- *ReturnOfUint8) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := Int64ToUint8.GetWorkContextWith(ctx, Int64ToUint8.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfInt64ToUint8) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfInt64ToUint8) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfInt64ToUintptr struct {
	handler func(context.Context, int64) (uintptr, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfInt64ToUintptr
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfInt64ToUintptr(ctx context.Context, h func(context.Context, int64) (uintptr, error), n int) *FuncWorkerOfInt64ToUintptr {
	__ := &FuncWorkerOfInt64ToUintptr{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfInt64ToUintptr, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go Int64ToUintptr.CallAsAsync(work.Context, work.WorkOfInt64ToUintptr.Value, work.WorkOfInt64ToUintptr.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				Int64ToUintptr.PutWork(work.WorkOfInt64ToUintptr)
				Int64ToUintptr.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfInt64ToUintptr) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := Int64ToUintptr.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfInt64ToUintptr) Push(ctx context.Context, value int64, returnCh chan<- *ReturnOfUintptr) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := Int64ToUintptr.GetWorkContextWith(ctx, Int64ToUintptr.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfInt64ToUintptr) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfInt64ToUintptr) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfInt64ToBytes struct {
	handler func(context.Context, int64) (Bytes, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfInt64ToBytes
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfInt64ToBytes(ctx context.Context, h func(context.Context, int64) (Bytes, error), n int) *FuncWorkerOfInt64ToBytes {
	__ := &FuncWorkerOfInt64ToBytes{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfInt64ToBytes, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go Int64ToBytes.CallAsAsync(work.Context, work.WorkOfInt64ToBytes.Value, work.WorkOfInt64ToBytes.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				Int64ToBytes.PutWork(work.WorkOfInt64ToBytes)
				Int64ToBytes.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfInt64ToBytes) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := Int64ToBytes.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfInt64ToBytes) Push(ctx context.Context, value int64, returnCh chan<- *ReturnOfBytes) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := Int64ToBytes.GetWorkContextWith(ctx, Int64ToBytes.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfInt64ToBytes) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfInt64ToBytes) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfInt64ToInterface struct {
	handler func(context.Context, int64) (interface{}, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfInt64ToInterface
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfInt64ToInterface(ctx context.Context, h func(context.Context, int64) (interface{}, error), n int) *FuncWorkerOfInt64ToInterface {
	__ := &FuncWorkerOfInt64ToInterface{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfInt64ToInterface, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go Int64ToInterface.CallAsAsync(work.Context, work.WorkOfInt64ToInterface.Value, work.WorkOfInt64ToInterface.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				Int64ToInterface.PutWork(work.WorkOfInt64ToInterface)
				Int64ToInterface.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfInt64ToInterface) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := Int64ToInterface.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfInt64ToInterface) Push(ctx context.Context, value int64, returnCh chan<- *ReturnOfInterface) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := Int64ToInterface.GetWorkContextWith(ctx, Int64ToInterface.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfInt64ToInterface) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfInt64ToInterface) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfInt8ToBool struct {
	handler func(context.Context, int8) (bool, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfInt8ToBool
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfInt8ToBool(ctx context.Context, h func(context.Context, int8) (bool, error), n int) *FuncWorkerOfInt8ToBool {
	__ := &FuncWorkerOfInt8ToBool{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfInt8ToBool, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go Int8ToBool.CallAsAsync(work.Context, work.WorkOfInt8ToBool.Value, work.WorkOfInt8ToBool.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				Int8ToBool.PutWork(work.WorkOfInt8ToBool)
				Int8ToBool.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfInt8ToBool) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := Int8ToBool.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfInt8ToBool) Push(ctx context.Context, value int8, returnCh chan<- *ReturnOfBool) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := Int8ToBool.GetWorkContextWith(ctx, Int8ToBool.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfInt8ToBool) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfInt8ToBool) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfInt8ToByte struct {
	handler func(context.Context, int8) (byte, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfInt8ToByte
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfInt8ToByte(ctx context.Context, h func(context.Context, int8) (byte, error), n int) *FuncWorkerOfInt8ToByte {
	__ := &FuncWorkerOfInt8ToByte{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfInt8ToByte, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go Int8ToByte.CallAsAsync(work.Context, work.WorkOfInt8ToByte.Value, work.WorkOfInt8ToByte.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				Int8ToByte.PutWork(work.WorkOfInt8ToByte)
				Int8ToByte.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfInt8ToByte) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := Int8ToByte.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfInt8ToByte) Push(ctx context.Context, value int8, returnCh chan<- *ReturnOfByte) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := Int8ToByte.GetWorkContextWith(ctx, Int8ToByte.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfInt8ToByte) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfInt8ToByte) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfInt8ToComplex128 struct {
	handler func(context.Context, int8) (complex128, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfInt8ToComplex128
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfInt8ToComplex128(ctx context.Context, h func(context.Context, int8) (complex128, error), n int) *FuncWorkerOfInt8ToComplex128 {
	__ := &FuncWorkerOfInt8ToComplex128{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfInt8ToComplex128, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go Int8ToComplex128.CallAsAsync(work.Context, work.WorkOfInt8ToComplex128.Value, work.WorkOfInt8ToComplex128.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				Int8ToComplex128.PutWork(work.WorkOfInt8ToComplex128)
				Int8ToComplex128.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfInt8ToComplex128) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := Int8ToComplex128.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfInt8ToComplex128) Push(ctx context.Context, value int8, returnCh chan<- *ReturnOfComplex128) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := Int8ToComplex128.GetWorkContextWith(ctx, Int8ToComplex128.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfInt8ToComplex128) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfInt8ToComplex128) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfInt8ToComplex64 struct {
	handler func(context.Context, int8) (complex64, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfInt8ToComplex64
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfInt8ToComplex64(ctx context.Context, h func(context.Context, int8) (complex64, error), n int) *FuncWorkerOfInt8ToComplex64 {
	__ := &FuncWorkerOfInt8ToComplex64{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfInt8ToComplex64, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go Int8ToComplex64.CallAsAsync(work.Context, work.WorkOfInt8ToComplex64.Value, work.WorkOfInt8ToComplex64.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				Int8ToComplex64.PutWork(work.WorkOfInt8ToComplex64)
				Int8ToComplex64.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfInt8ToComplex64) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := Int8ToComplex64.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfInt8ToComplex64) Push(ctx context.Context, value int8, returnCh chan<- *ReturnOfComplex64) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := Int8ToComplex64.GetWorkContextWith(ctx, Int8ToComplex64.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfInt8ToComplex64) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfInt8ToComplex64) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfInt8ToError struct {
	handler func(context.Context, int8) (error, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfInt8ToError
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfInt8ToError(ctx context.Context, h func(context.Context, int8) (error, error), n int) *FuncWorkerOfInt8ToError {
	__ := &FuncWorkerOfInt8ToError{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfInt8ToError, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go Int8ToError.CallAsAsync(work.Context, work.WorkOfInt8ToError.Value, work.WorkOfInt8ToError.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				Int8ToError.PutWork(work.WorkOfInt8ToError)
				Int8ToError.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfInt8ToError) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := Int8ToError.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfInt8ToError) Push(ctx context.Context, value int8, returnCh chan<- *ReturnOfError) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := Int8ToError.GetWorkContextWith(ctx, Int8ToError.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfInt8ToError) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfInt8ToError) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfInt8ToFloat32 struct {
	handler func(context.Context, int8) (float32, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfInt8ToFloat32
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfInt8ToFloat32(ctx context.Context, h func(context.Context, int8) (float32, error), n int) *FuncWorkerOfInt8ToFloat32 {
	__ := &FuncWorkerOfInt8ToFloat32{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfInt8ToFloat32, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go Int8ToFloat32.CallAsAsync(work.Context, work.WorkOfInt8ToFloat32.Value, work.WorkOfInt8ToFloat32.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				Int8ToFloat32.PutWork(work.WorkOfInt8ToFloat32)
				Int8ToFloat32.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfInt8ToFloat32) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := Int8ToFloat32.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfInt8ToFloat32) Push(ctx context.Context, value int8, returnCh chan<- *ReturnOfFloat32) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := Int8ToFloat32.GetWorkContextWith(ctx, Int8ToFloat32.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfInt8ToFloat32) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfInt8ToFloat32) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfInt8ToFloat64 struct {
	handler func(context.Context, int8) (float64, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfInt8ToFloat64
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfInt8ToFloat64(ctx context.Context, h func(context.Context, int8) (float64, error), n int) *FuncWorkerOfInt8ToFloat64 {
	__ := &FuncWorkerOfInt8ToFloat64{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfInt8ToFloat64, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go Int8ToFloat64.CallAsAsync(work.Context, work.WorkOfInt8ToFloat64.Value, work.WorkOfInt8ToFloat64.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				Int8ToFloat64.PutWork(work.WorkOfInt8ToFloat64)
				Int8ToFloat64.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfInt8ToFloat64) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := Int8ToFloat64.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfInt8ToFloat64) Push(ctx context.Context, value int8, returnCh chan<- *ReturnOfFloat64) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := Int8ToFloat64.GetWorkContextWith(ctx, Int8ToFloat64.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfInt8ToFloat64) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfInt8ToFloat64) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfInt8ToInt struct {
	handler func(context.Context, int8) (int, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfInt8ToInt
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfInt8ToInt(ctx context.Context, h func(context.Context, int8) (int, error), n int) *FuncWorkerOfInt8ToInt {
	__ := &FuncWorkerOfInt8ToInt{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfInt8ToInt, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go Int8ToInt.CallAsAsync(work.Context, work.WorkOfInt8ToInt.Value, work.WorkOfInt8ToInt.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				Int8ToInt.PutWork(work.WorkOfInt8ToInt)
				Int8ToInt.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfInt8ToInt) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := Int8ToInt.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfInt8ToInt) Push(ctx context.Context, value int8, returnCh chan<- *ReturnOfInt) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := Int8ToInt.GetWorkContextWith(ctx, Int8ToInt.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfInt8ToInt) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfInt8ToInt) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfInt8ToInt16 struct {
	handler func(context.Context, int8) (int16, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfInt8ToInt16
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfInt8ToInt16(ctx context.Context, h func(context.Context, int8) (int16, error), n int) *FuncWorkerOfInt8ToInt16 {
	__ := &FuncWorkerOfInt8ToInt16{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfInt8ToInt16, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go Int8ToInt16.CallAsAsync(work.Context, work.WorkOfInt8ToInt16.Value, work.WorkOfInt8ToInt16.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				Int8ToInt16.PutWork(work.WorkOfInt8ToInt16)
				Int8ToInt16.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfInt8ToInt16) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := Int8ToInt16.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfInt8ToInt16) Push(ctx context.Context, value int8, returnCh chan<- *ReturnOfInt16) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := Int8ToInt16.GetWorkContextWith(ctx, Int8ToInt16.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfInt8ToInt16) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfInt8ToInt16) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfInt8ToInt32 struct {
	handler func(context.Context, int8) (int32, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfInt8ToInt32
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfInt8ToInt32(ctx context.Context, h func(context.Context, int8) (int32, error), n int) *FuncWorkerOfInt8ToInt32 {
	__ := &FuncWorkerOfInt8ToInt32{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfInt8ToInt32, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go Int8ToInt32.CallAsAsync(work.Context, work.WorkOfInt8ToInt32.Value, work.WorkOfInt8ToInt32.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				Int8ToInt32.PutWork(work.WorkOfInt8ToInt32)
				Int8ToInt32.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfInt8ToInt32) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := Int8ToInt32.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfInt8ToInt32) Push(ctx context.Context, value int8, returnCh chan<- *ReturnOfInt32) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := Int8ToInt32.GetWorkContextWith(ctx, Int8ToInt32.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfInt8ToInt32) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfInt8ToInt32) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfInt8ToInt64 struct {
	handler func(context.Context, int8) (int64, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfInt8ToInt64
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfInt8ToInt64(ctx context.Context, h func(context.Context, int8) (int64, error), n int) *FuncWorkerOfInt8ToInt64 {
	__ := &FuncWorkerOfInt8ToInt64{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfInt8ToInt64, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go Int8ToInt64.CallAsAsync(work.Context, work.WorkOfInt8ToInt64.Value, work.WorkOfInt8ToInt64.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				Int8ToInt64.PutWork(work.WorkOfInt8ToInt64)
				Int8ToInt64.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfInt8ToInt64) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := Int8ToInt64.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfInt8ToInt64) Push(ctx context.Context, value int8, returnCh chan<- *ReturnOfInt64) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := Int8ToInt64.GetWorkContextWith(ctx, Int8ToInt64.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfInt8ToInt64) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfInt8ToInt64) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfInt8ToInt8 struct {
	handler func(context.Context, int8) (int8, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfInt8ToInt8
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfInt8ToInt8(ctx context.Context, h func(context.Context, int8) (int8, error), n int) *FuncWorkerOfInt8ToInt8 {
	__ := &FuncWorkerOfInt8ToInt8{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfInt8ToInt8, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go Int8ToInt8.CallAsAsync(work.Context, work.WorkOfInt8ToInt8.Value, work.WorkOfInt8ToInt8.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				Int8ToInt8.PutWork(work.WorkOfInt8ToInt8)
				Int8ToInt8.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfInt8ToInt8) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := Int8ToInt8.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfInt8ToInt8) Push(ctx context.Context, value int8, returnCh chan<- *ReturnOfInt8) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := Int8ToInt8.GetWorkContextWith(ctx, Int8ToInt8.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfInt8ToInt8) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfInt8ToInt8) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfInt8ToRune struct {
	handler func(context.Context, int8) (rune, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfInt8ToRune
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfInt8ToRune(ctx context.Context, h func(context.Context, int8) (rune, error), n int) *FuncWorkerOfInt8ToRune {
	__ := &FuncWorkerOfInt8ToRune{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfInt8ToRune, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go Int8ToRune.CallAsAsync(work.Context, work.WorkOfInt8ToRune.Value, work.WorkOfInt8ToRune.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				Int8ToRune.PutWork(work.WorkOfInt8ToRune)
				Int8ToRune.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfInt8ToRune) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := Int8ToRune.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfInt8ToRune) Push(ctx context.Context, value int8, returnCh chan<- *ReturnOfRune) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := Int8ToRune.GetWorkContextWith(ctx, Int8ToRune.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfInt8ToRune) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfInt8ToRune) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfInt8ToString struct {
	handler func(context.Context, int8) (string, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfInt8ToString
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfInt8ToString(ctx context.Context, h func(context.Context, int8) (string, error), n int) *FuncWorkerOfInt8ToString {
	__ := &FuncWorkerOfInt8ToString{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfInt8ToString, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go Int8ToString.CallAsAsync(work.Context, work.WorkOfInt8ToString.Value, work.WorkOfInt8ToString.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				Int8ToString.PutWork(work.WorkOfInt8ToString)
				Int8ToString.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfInt8ToString) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := Int8ToString.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfInt8ToString) Push(ctx context.Context, value int8, returnCh chan<- *ReturnOfString) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := Int8ToString.GetWorkContextWith(ctx, Int8ToString.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfInt8ToString) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfInt8ToString) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfInt8ToUint struct {
	handler func(context.Context, int8) (uint, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfInt8ToUint
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfInt8ToUint(ctx context.Context, h func(context.Context, int8) (uint, error), n int) *FuncWorkerOfInt8ToUint {
	__ := &FuncWorkerOfInt8ToUint{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfInt8ToUint, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go Int8ToUint.CallAsAsync(work.Context, work.WorkOfInt8ToUint.Value, work.WorkOfInt8ToUint.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				Int8ToUint.PutWork(work.WorkOfInt8ToUint)
				Int8ToUint.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfInt8ToUint) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := Int8ToUint.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfInt8ToUint) Push(ctx context.Context, value int8, returnCh chan<- *ReturnOfUint) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := Int8ToUint.GetWorkContextWith(ctx, Int8ToUint.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfInt8ToUint) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfInt8ToUint) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfInt8ToUint16 struct {
	handler func(context.Context, int8) (uint16, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfInt8ToUint16
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfInt8ToUint16(ctx context.Context, h func(context.Context, int8) (uint16, error), n int) *FuncWorkerOfInt8ToUint16 {
	__ := &FuncWorkerOfInt8ToUint16{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfInt8ToUint16, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go Int8ToUint16.CallAsAsync(work.Context, work.WorkOfInt8ToUint16.Value, work.WorkOfInt8ToUint16.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				Int8ToUint16.PutWork(work.WorkOfInt8ToUint16)
				Int8ToUint16.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfInt8ToUint16) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := Int8ToUint16.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfInt8ToUint16) Push(ctx context.Context, value int8, returnCh chan<- *ReturnOfUint16) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := Int8ToUint16.GetWorkContextWith(ctx, Int8ToUint16.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfInt8ToUint16) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfInt8ToUint16) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfInt8ToUint32 struct {
	handler func(context.Context, int8) (uint32, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfInt8ToUint32
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfInt8ToUint32(ctx context.Context, h func(context.Context, int8) (uint32, error), n int) *FuncWorkerOfInt8ToUint32 {
	__ := &FuncWorkerOfInt8ToUint32{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfInt8ToUint32, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go Int8ToUint32.CallAsAsync(work.Context, work.WorkOfInt8ToUint32.Value, work.WorkOfInt8ToUint32.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				Int8ToUint32.PutWork(work.WorkOfInt8ToUint32)
				Int8ToUint32.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfInt8ToUint32) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := Int8ToUint32.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfInt8ToUint32) Push(ctx context.Context, value int8, returnCh chan<- *ReturnOfUint32) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := Int8ToUint32.GetWorkContextWith(ctx, Int8ToUint32.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfInt8ToUint32) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfInt8ToUint32) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfInt8ToUint64 struct {
	handler func(context.Context, int8) (uint64, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfInt8ToUint64
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfInt8ToUint64(ctx context.Context, h func(context.Context, int8) (uint64, error), n int) *FuncWorkerOfInt8ToUint64 {
	__ := &FuncWorkerOfInt8ToUint64{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfInt8ToUint64, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go Int8ToUint64.CallAsAsync(work.Context, work.WorkOfInt8ToUint64.Value, work.WorkOfInt8ToUint64.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				Int8ToUint64.PutWork(work.WorkOfInt8ToUint64)
				Int8ToUint64.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfInt8ToUint64) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := Int8ToUint64.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfInt8ToUint64) Push(ctx context.Context, value int8, returnCh chan<- *ReturnOfUint64) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := Int8ToUint64.GetWorkContextWith(ctx, Int8ToUint64.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfInt8ToUint64) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfInt8ToUint64) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfInt8ToUint8 struct {
	handler func(context.Context, int8) (uint8, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfInt8ToUint8
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfInt8ToUint8(ctx context.Context, h func(context.Context, int8) (uint8, error), n int) *FuncWorkerOfInt8ToUint8 {
	__ := &FuncWorkerOfInt8ToUint8{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfInt8ToUint8, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go Int8ToUint8.CallAsAsync(work.Context, work.WorkOfInt8ToUint8.Value, work.WorkOfInt8ToUint8.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				Int8ToUint8.PutWork(work.WorkOfInt8ToUint8)
				Int8ToUint8.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfInt8ToUint8) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := Int8ToUint8.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfInt8ToUint8) Push(ctx context.Context, value int8, returnCh chan<- *ReturnOfUint8) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := Int8ToUint8.GetWorkContextWith(ctx, Int8ToUint8.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfInt8ToUint8) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfInt8ToUint8) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfInt8ToUintptr struct {
	handler func(context.Context, int8) (uintptr, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfInt8ToUintptr
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfInt8ToUintptr(ctx context.Context, h func(context.Context, int8) (uintptr, error), n int) *FuncWorkerOfInt8ToUintptr {
	__ := &FuncWorkerOfInt8ToUintptr{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfInt8ToUintptr, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go Int8ToUintptr.CallAsAsync(work.Context, work.WorkOfInt8ToUintptr.Value, work.WorkOfInt8ToUintptr.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				Int8ToUintptr.PutWork(work.WorkOfInt8ToUintptr)
				Int8ToUintptr.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfInt8ToUintptr) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := Int8ToUintptr.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfInt8ToUintptr) Push(ctx context.Context, value int8, returnCh chan<- *ReturnOfUintptr) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := Int8ToUintptr.GetWorkContextWith(ctx, Int8ToUintptr.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfInt8ToUintptr) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfInt8ToUintptr) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfInt8ToBytes struct {
	handler func(context.Context, int8) (Bytes, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfInt8ToBytes
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfInt8ToBytes(ctx context.Context, h func(context.Context, int8) (Bytes, error), n int) *FuncWorkerOfInt8ToBytes {
	__ := &FuncWorkerOfInt8ToBytes{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfInt8ToBytes, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go Int8ToBytes.CallAsAsync(work.Context, work.WorkOfInt8ToBytes.Value, work.WorkOfInt8ToBytes.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				Int8ToBytes.PutWork(work.WorkOfInt8ToBytes)
				Int8ToBytes.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfInt8ToBytes) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := Int8ToBytes.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfInt8ToBytes) Push(ctx context.Context, value int8, returnCh chan<- *ReturnOfBytes) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := Int8ToBytes.GetWorkContextWith(ctx, Int8ToBytes.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfInt8ToBytes) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfInt8ToBytes) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfInt8ToInterface struct {
	handler func(context.Context, int8) (interface{}, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfInt8ToInterface
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfInt8ToInterface(ctx context.Context, h func(context.Context, int8) (interface{}, error), n int) *FuncWorkerOfInt8ToInterface {
	__ := &FuncWorkerOfInt8ToInterface{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfInt8ToInterface, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go Int8ToInterface.CallAsAsync(work.Context, work.WorkOfInt8ToInterface.Value, work.WorkOfInt8ToInterface.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				Int8ToInterface.PutWork(work.WorkOfInt8ToInterface)
				Int8ToInterface.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfInt8ToInterface) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := Int8ToInterface.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfInt8ToInterface) Push(ctx context.Context, value int8, returnCh chan<- *ReturnOfInterface) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := Int8ToInterface.GetWorkContextWith(ctx, Int8ToInterface.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfInt8ToInterface) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfInt8ToInterface) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfRuneToBool struct {
	handler func(context.Context, rune) (bool, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfRuneToBool
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfRuneToBool(ctx context.Context, h func(context.Context, rune) (bool, error), n int) *FuncWorkerOfRuneToBool {
	__ := &FuncWorkerOfRuneToBool{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfRuneToBool, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go RuneToBool.CallAsAsync(work.Context, work.WorkOfRuneToBool.Value, work.WorkOfRuneToBool.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				RuneToBool.PutWork(work.WorkOfRuneToBool)
				RuneToBool.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfRuneToBool) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := RuneToBool.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfRuneToBool) Push(ctx context.Context, value rune, returnCh chan<- *ReturnOfBool) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := RuneToBool.GetWorkContextWith(ctx, RuneToBool.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfRuneToBool) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfRuneToBool) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfRuneToByte struct {
	handler func(context.Context, rune) (byte, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfRuneToByte
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfRuneToByte(ctx context.Context, h func(context.Context, rune) (byte, error), n int) *FuncWorkerOfRuneToByte {
	__ := &FuncWorkerOfRuneToByte{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfRuneToByte, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go RuneToByte.CallAsAsync(work.Context, work.WorkOfRuneToByte.Value, work.WorkOfRuneToByte.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				RuneToByte.PutWork(work.WorkOfRuneToByte)
				RuneToByte.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfRuneToByte) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := RuneToByte.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfRuneToByte) Push(ctx context.Context, value rune, returnCh chan<- *ReturnOfByte) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := RuneToByte.GetWorkContextWith(ctx, RuneToByte.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfRuneToByte) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfRuneToByte) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfRuneToComplex128 struct {
	handler func(context.Context, rune) (complex128, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfRuneToComplex128
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfRuneToComplex128(ctx context.Context, h func(context.Context, rune) (complex128, error), n int) *FuncWorkerOfRuneToComplex128 {
	__ := &FuncWorkerOfRuneToComplex128{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfRuneToComplex128, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go RuneToComplex128.CallAsAsync(work.Context, work.WorkOfRuneToComplex128.Value, work.WorkOfRuneToComplex128.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				RuneToComplex128.PutWork(work.WorkOfRuneToComplex128)
				RuneToComplex128.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfRuneToComplex128) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := RuneToComplex128.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfRuneToComplex128) Push(ctx context.Context, value rune, returnCh chan<- *ReturnOfComplex128) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := RuneToComplex128.GetWorkContextWith(ctx, RuneToComplex128.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfRuneToComplex128) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfRuneToComplex128) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfRuneToComplex64 struct {
	handler func(context.Context, rune) (complex64, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfRuneToComplex64
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfRuneToComplex64(ctx context.Context, h func(context.Context, rune) (complex64, error), n int) *FuncWorkerOfRuneToComplex64 {
	__ := &FuncWorkerOfRuneToComplex64{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfRuneToComplex64, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go RuneToComplex64.CallAsAsync(work.Context, work.WorkOfRuneToComplex64.Value, work.WorkOfRuneToComplex64.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				RuneToComplex64.PutWork(work.WorkOfRuneToComplex64)
				RuneToComplex64.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfRuneToComplex64) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := RuneToComplex64.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfRuneToComplex64) Push(ctx context.Context, value rune, returnCh chan<- *ReturnOfComplex64) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := RuneToComplex64.GetWorkContextWith(ctx, RuneToComplex64.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfRuneToComplex64) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfRuneToComplex64) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfRuneToError struct {
	handler func(context.Context, rune) (error, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfRuneToError
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfRuneToError(ctx context.Context, h func(context.Context, rune) (error, error), n int) *FuncWorkerOfRuneToError {
	__ := &FuncWorkerOfRuneToError{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfRuneToError, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go RuneToError.CallAsAsync(work.Context, work.WorkOfRuneToError.Value, work.WorkOfRuneToError.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				RuneToError.PutWork(work.WorkOfRuneToError)
				RuneToError.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfRuneToError) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := RuneToError.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfRuneToError) Push(ctx context.Context, value rune, returnCh chan<- *ReturnOfError) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := RuneToError.GetWorkContextWith(ctx, RuneToError.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfRuneToError) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfRuneToError) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfRuneToFloat32 struct {
	handler func(context.Context, rune) (float32, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfRuneToFloat32
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfRuneToFloat32(ctx context.Context, h func(context.Context, rune) (float32, error), n int) *FuncWorkerOfRuneToFloat32 {
	__ := &FuncWorkerOfRuneToFloat32{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfRuneToFloat32, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go RuneToFloat32.CallAsAsync(work.Context, work.WorkOfRuneToFloat32.Value, work.WorkOfRuneToFloat32.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				RuneToFloat32.PutWork(work.WorkOfRuneToFloat32)
				RuneToFloat32.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfRuneToFloat32) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := RuneToFloat32.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfRuneToFloat32) Push(ctx context.Context, value rune, returnCh chan<- *ReturnOfFloat32) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := RuneToFloat32.GetWorkContextWith(ctx, RuneToFloat32.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfRuneToFloat32) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfRuneToFloat32) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfRuneToFloat64 struct {
	handler func(context.Context, rune) (float64, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfRuneToFloat64
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfRuneToFloat64(ctx context.Context, h func(context.Context, rune) (float64, error), n int) *FuncWorkerOfRuneToFloat64 {
	__ := &FuncWorkerOfRuneToFloat64{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfRuneToFloat64, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go RuneToFloat64.CallAsAsync(work.Context, work.WorkOfRuneToFloat64.Value, work.WorkOfRuneToFloat64.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				RuneToFloat64.PutWork(work.WorkOfRuneToFloat64)
				RuneToFloat64.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfRuneToFloat64) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := RuneToFloat64.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfRuneToFloat64) Push(ctx context.Context, value rune, returnCh chan<- *ReturnOfFloat64) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := RuneToFloat64.GetWorkContextWith(ctx, RuneToFloat64.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfRuneToFloat64) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfRuneToFloat64) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfRuneToInt struct {
	handler func(context.Context, rune) (int, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfRuneToInt
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfRuneToInt(ctx context.Context, h func(context.Context, rune) (int, error), n int) *FuncWorkerOfRuneToInt {
	__ := &FuncWorkerOfRuneToInt{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfRuneToInt, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go RuneToInt.CallAsAsync(work.Context, work.WorkOfRuneToInt.Value, work.WorkOfRuneToInt.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				RuneToInt.PutWork(work.WorkOfRuneToInt)
				RuneToInt.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfRuneToInt) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := RuneToInt.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfRuneToInt) Push(ctx context.Context, value rune, returnCh chan<- *ReturnOfInt) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := RuneToInt.GetWorkContextWith(ctx, RuneToInt.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfRuneToInt) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfRuneToInt) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfRuneToInt16 struct {
	handler func(context.Context, rune) (int16, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfRuneToInt16
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfRuneToInt16(ctx context.Context, h func(context.Context, rune) (int16, error), n int) *FuncWorkerOfRuneToInt16 {
	__ := &FuncWorkerOfRuneToInt16{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfRuneToInt16, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go RuneToInt16.CallAsAsync(work.Context, work.WorkOfRuneToInt16.Value, work.WorkOfRuneToInt16.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				RuneToInt16.PutWork(work.WorkOfRuneToInt16)
				RuneToInt16.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfRuneToInt16) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := RuneToInt16.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfRuneToInt16) Push(ctx context.Context, value rune, returnCh chan<- *ReturnOfInt16) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := RuneToInt16.GetWorkContextWith(ctx, RuneToInt16.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfRuneToInt16) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfRuneToInt16) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfRuneToInt32 struct {
	handler func(context.Context, rune) (int32, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfRuneToInt32
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfRuneToInt32(ctx context.Context, h func(context.Context, rune) (int32, error), n int) *FuncWorkerOfRuneToInt32 {
	__ := &FuncWorkerOfRuneToInt32{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfRuneToInt32, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go RuneToInt32.CallAsAsync(work.Context, work.WorkOfRuneToInt32.Value, work.WorkOfRuneToInt32.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				RuneToInt32.PutWork(work.WorkOfRuneToInt32)
				RuneToInt32.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfRuneToInt32) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := RuneToInt32.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfRuneToInt32) Push(ctx context.Context, value rune, returnCh chan<- *ReturnOfInt32) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := RuneToInt32.GetWorkContextWith(ctx, RuneToInt32.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfRuneToInt32) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfRuneToInt32) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfRuneToInt64 struct {
	handler func(context.Context, rune) (int64, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfRuneToInt64
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfRuneToInt64(ctx context.Context, h func(context.Context, rune) (int64, error), n int) *FuncWorkerOfRuneToInt64 {
	__ := &FuncWorkerOfRuneToInt64{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfRuneToInt64, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go RuneToInt64.CallAsAsync(work.Context, work.WorkOfRuneToInt64.Value, work.WorkOfRuneToInt64.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				RuneToInt64.PutWork(work.WorkOfRuneToInt64)
				RuneToInt64.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfRuneToInt64) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := RuneToInt64.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfRuneToInt64) Push(ctx context.Context, value rune, returnCh chan<- *ReturnOfInt64) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := RuneToInt64.GetWorkContextWith(ctx, RuneToInt64.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfRuneToInt64) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfRuneToInt64) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfRuneToInt8 struct {
	handler func(context.Context, rune) (int8, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfRuneToInt8
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfRuneToInt8(ctx context.Context, h func(context.Context, rune) (int8, error), n int) *FuncWorkerOfRuneToInt8 {
	__ := &FuncWorkerOfRuneToInt8{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfRuneToInt8, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go RuneToInt8.CallAsAsync(work.Context, work.WorkOfRuneToInt8.Value, work.WorkOfRuneToInt8.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				RuneToInt8.PutWork(work.WorkOfRuneToInt8)
				RuneToInt8.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfRuneToInt8) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := RuneToInt8.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfRuneToInt8) Push(ctx context.Context, value rune, returnCh chan<- *ReturnOfInt8) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := RuneToInt8.GetWorkContextWith(ctx, RuneToInt8.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfRuneToInt8) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfRuneToInt8) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfRuneToRune struct {
	handler func(context.Context, rune) (rune, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfRuneToRune
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfRuneToRune(ctx context.Context, h func(context.Context, rune) (rune, error), n int) *FuncWorkerOfRuneToRune {
	__ := &FuncWorkerOfRuneToRune{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfRuneToRune, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go RuneToRune.CallAsAsync(work.Context, work.WorkOfRuneToRune.Value, work.WorkOfRuneToRune.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				RuneToRune.PutWork(work.WorkOfRuneToRune)
				RuneToRune.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfRuneToRune) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := RuneToRune.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfRuneToRune) Push(ctx context.Context, value rune, returnCh chan<- *ReturnOfRune) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := RuneToRune.GetWorkContextWith(ctx, RuneToRune.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfRuneToRune) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfRuneToRune) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfRuneToString struct {
	handler func(context.Context, rune) (string, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfRuneToString
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfRuneToString(ctx context.Context, h func(context.Context, rune) (string, error), n int) *FuncWorkerOfRuneToString {
	__ := &FuncWorkerOfRuneToString{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfRuneToString, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go RuneToString.CallAsAsync(work.Context, work.WorkOfRuneToString.Value, work.WorkOfRuneToString.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				RuneToString.PutWork(work.WorkOfRuneToString)
				RuneToString.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfRuneToString) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := RuneToString.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfRuneToString) Push(ctx context.Context, value rune, returnCh chan<- *ReturnOfString) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := RuneToString.GetWorkContextWith(ctx, RuneToString.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfRuneToString) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfRuneToString) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfRuneToUint struct {
	handler func(context.Context, rune) (uint, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfRuneToUint
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfRuneToUint(ctx context.Context, h func(context.Context, rune) (uint, error), n int) *FuncWorkerOfRuneToUint {
	__ := &FuncWorkerOfRuneToUint{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfRuneToUint, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go RuneToUint.CallAsAsync(work.Context, work.WorkOfRuneToUint.Value, work.WorkOfRuneToUint.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				RuneToUint.PutWork(work.WorkOfRuneToUint)
				RuneToUint.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfRuneToUint) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := RuneToUint.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfRuneToUint) Push(ctx context.Context, value rune, returnCh chan<- *ReturnOfUint) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := RuneToUint.GetWorkContextWith(ctx, RuneToUint.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfRuneToUint) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfRuneToUint) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfRuneToUint16 struct {
	handler func(context.Context, rune) (uint16, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfRuneToUint16
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfRuneToUint16(ctx context.Context, h func(context.Context, rune) (uint16, error), n int) *FuncWorkerOfRuneToUint16 {
	__ := &FuncWorkerOfRuneToUint16{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfRuneToUint16, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go RuneToUint16.CallAsAsync(work.Context, work.WorkOfRuneToUint16.Value, work.WorkOfRuneToUint16.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				RuneToUint16.PutWork(work.WorkOfRuneToUint16)
				RuneToUint16.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfRuneToUint16) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := RuneToUint16.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfRuneToUint16) Push(ctx context.Context, value rune, returnCh chan<- *ReturnOfUint16) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := RuneToUint16.GetWorkContextWith(ctx, RuneToUint16.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfRuneToUint16) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfRuneToUint16) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfRuneToUint32 struct {
	handler func(context.Context, rune) (uint32, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfRuneToUint32
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfRuneToUint32(ctx context.Context, h func(context.Context, rune) (uint32, error), n int) *FuncWorkerOfRuneToUint32 {
	__ := &FuncWorkerOfRuneToUint32{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfRuneToUint32, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go RuneToUint32.CallAsAsync(work.Context, work.WorkOfRuneToUint32.Value, work.WorkOfRuneToUint32.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				RuneToUint32.PutWork(work.WorkOfRuneToUint32)
				RuneToUint32.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfRuneToUint32) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := RuneToUint32.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfRuneToUint32) Push(ctx context.Context, value rune, returnCh chan<- *ReturnOfUint32) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := RuneToUint32.GetWorkContextWith(ctx, RuneToUint32.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfRuneToUint32) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfRuneToUint32) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfRuneToUint64 struct {
	handler func(context.Context, rune) (uint64, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfRuneToUint64
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfRuneToUint64(ctx context.Context, h func(context.Context, rune) (uint64, error), n int) *FuncWorkerOfRuneToUint64 {
	__ := &FuncWorkerOfRuneToUint64{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfRuneToUint64, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go RuneToUint64.CallAsAsync(work.Context, work.WorkOfRuneToUint64.Value, work.WorkOfRuneToUint64.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				RuneToUint64.PutWork(work.WorkOfRuneToUint64)
				RuneToUint64.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfRuneToUint64) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := RuneToUint64.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfRuneToUint64) Push(ctx context.Context, value rune, returnCh chan<- *ReturnOfUint64) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := RuneToUint64.GetWorkContextWith(ctx, RuneToUint64.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfRuneToUint64) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfRuneToUint64) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfRuneToUint8 struct {
	handler func(context.Context, rune) (uint8, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfRuneToUint8
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfRuneToUint8(ctx context.Context, h func(context.Context, rune) (uint8, error), n int) *FuncWorkerOfRuneToUint8 {
	__ := &FuncWorkerOfRuneToUint8{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfRuneToUint8, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go RuneToUint8.CallAsAsync(work.Context, work.WorkOfRuneToUint8.Value, work.WorkOfRuneToUint8.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				RuneToUint8.PutWork(work.WorkOfRuneToUint8)
				RuneToUint8.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfRuneToUint8) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := RuneToUint8.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfRuneToUint8) Push(ctx context.Context, value rune, returnCh chan<- *ReturnOfUint8) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := RuneToUint8.GetWorkContextWith(ctx, RuneToUint8.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfRuneToUint8) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfRuneToUint8) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfRuneToUintptr struct {
	handler func(context.Context, rune) (uintptr, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfRuneToUintptr
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfRuneToUintptr(ctx context.Context, h func(context.Context, rune) (uintptr, error), n int) *FuncWorkerOfRuneToUintptr {
	__ := &FuncWorkerOfRuneToUintptr{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfRuneToUintptr, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go RuneToUintptr.CallAsAsync(work.Context, work.WorkOfRuneToUintptr.Value, work.WorkOfRuneToUintptr.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				RuneToUintptr.PutWork(work.WorkOfRuneToUintptr)
				RuneToUintptr.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfRuneToUintptr) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := RuneToUintptr.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfRuneToUintptr) Push(ctx context.Context, value rune, returnCh chan<- *ReturnOfUintptr) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := RuneToUintptr.GetWorkContextWith(ctx, RuneToUintptr.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfRuneToUintptr) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfRuneToUintptr) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfRuneToBytes struct {
	handler func(context.Context, rune) (Bytes, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfRuneToBytes
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfRuneToBytes(ctx context.Context, h func(context.Context, rune) (Bytes, error), n int) *FuncWorkerOfRuneToBytes {
	__ := &FuncWorkerOfRuneToBytes{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfRuneToBytes, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go RuneToBytes.CallAsAsync(work.Context, work.WorkOfRuneToBytes.Value, work.WorkOfRuneToBytes.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				RuneToBytes.PutWork(work.WorkOfRuneToBytes)
				RuneToBytes.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfRuneToBytes) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := RuneToBytes.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfRuneToBytes) Push(ctx context.Context, value rune, returnCh chan<- *ReturnOfBytes) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := RuneToBytes.GetWorkContextWith(ctx, RuneToBytes.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfRuneToBytes) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfRuneToBytes) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfRuneToInterface struct {
	handler func(context.Context, rune) (interface{}, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfRuneToInterface
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfRuneToInterface(ctx context.Context, h func(context.Context, rune) (interface{}, error), n int) *FuncWorkerOfRuneToInterface {
	__ := &FuncWorkerOfRuneToInterface{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfRuneToInterface, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go RuneToInterface.CallAsAsync(work.Context, work.WorkOfRuneToInterface.Value, work.WorkOfRuneToInterface.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				RuneToInterface.PutWork(work.WorkOfRuneToInterface)
				RuneToInterface.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfRuneToInterface) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := RuneToInterface.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfRuneToInterface) Push(ctx context.Context, value rune, returnCh chan<- *ReturnOfInterface) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := RuneToInterface.GetWorkContextWith(ctx, RuneToInterface.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfRuneToInterface) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfRuneToInterface) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfStringToBool struct {
	handler func(context.Context, string) (bool, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfStringToBool
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfStringToBool(ctx context.Context, h func(context.Context, string) (bool, error), n int) *FuncWorkerOfStringToBool {
	__ := &FuncWorkerOfStringToBool{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfStringToBool, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go StringToBool.CallAsAsync(work.Context, work.WorkOfStringToBool.Value, work.WorkOfStringToBool.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				StringToBool.PutWork(work.WorkOfStringToBool)
				StringToBool.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfStringToBool) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := StringToBool.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfStringToBool) Push(ctx context.Context, value string, returnCh chan<- *ReturnOfBool) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := StringToBool.GetWorkContextWith(ctx, StringToBool.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfStringToBool) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfStringToBool) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfStringToByte struct {
	handler func(context.Context, string) (byte, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfStringToByte
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfStringToByte(ctx context.Context, h func(context.Context, string) (byte, error), n int) *FuncWorkerOfStringToByte {
	__ := &FuncWorkerOfStringToByte{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfStringToByte, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go StringToByte.CallAsAsync(work.Context, work.WorkOfStringToByte.Value, work.WorkOfStringToByte.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				StringToByte.PutWork(work.WorkOfStringToByte)
				StringToByte.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfStringToByte) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := StringToByte.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfStringToByte) Push(ctx context.Context, value string, returnCh chan<- *ReturnOfByte) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := StringToByte.GetWorkContextWith(ctx, StringToByte.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfStringToByte) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfStringToByte) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfStringToComplex128 struct {
	handler func(context.Context, string) (complex128, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfStringToComplex128
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfStringToComplex128(ctx context.Context, h func(context.Context, string) (complex128, error), n int) *FuncWorkerOfStringToComplex128 {
	__ := &FuncWorkerOfStringToComplex128{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfStringToComplex128, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go StringToComplex128.CallAsAsync(work.Context, work.WorkOfStringToComplex128.Value, work.WorkOfStringToComplex128.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				StringToComplex128.PutWork(work.WorkOfStringToComplex128)
				StringToComplex128.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfStringToComplex128) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := StringToComplex128.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfStringToComplex128) Push(ctx context.Context, value string, returnCh chan<- *ReturnOfComplex128) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := StringToComplex128.GetWorkContextWith(ctx, StringToComplex128.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfStringToComplex128) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfStringToComplex128) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfStringToComplex64 struct {
	handler func(context.Context, string) (complex64, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfStringToComplex64
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfStringToComplex64(ctx context.Context, h func(context.Context, string) (complex64, error), n int) *FuncWorkerOfStringToComplex64 {
	__ := &FuncWorkerOfStringToComplex64{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfStringToComplex64, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go StringToComplex64.CallAsAsync(work.Context, work.WorkOfStringToComplex64.Value, work.WorkOfStringToComplex64.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				StringToComplex64.PutWork(work.WorkOfStringToComplex64)
				StringToComplex64.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfStringToComplex64) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := StringToComplex64.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfStringToComplex64) Push(ctx context.Context, value string, returnCh chan<- *ReturnOfComplex64) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := StringToComplex64.GetWorkContextWith(ctx, StringToComplex64.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfStringToComplex64) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfStringToComplex64) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfStringToError struct {
	handler func(context.Context, string) (error, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfStringToError
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfStringToError(ctx context.Context, h func(context.Context, string) (error, error), n int) *FuncWorkerOfStringToError {
	__ := &FuncWorkerOfStringToError{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfStringToError, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go StringToError.CallAsAsync(work.Context, work.WorkOfStringToError.Value, work.WorkOfStringToError.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				StringToError.PutWork(work.WorkOfStringToError)
				StringToError.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfStringToError) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := StringToError.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfStringToError) Push(ctx context.Context, value string, returnCh chan<- *ReturnOfError) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := StringToError.GetWorkContextWith(ctx, StringToError.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfStringToError) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfStringToError) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfStringToFloat32 struct {
	handler func(context.Context, string) (float32, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfStringToFloat32
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfStringToFloat32(ctx context.Context, h func(context.Context, string) (float32, error), n int) *FuncWorkerOfStringToFloat32 {
	__ := &FuncWorkerOfStringToFloat32{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfStringToFloat32, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go StringToFloat32.CallAsAsync(work.Context, work.WorkOfStringToFloat32.Value, work.WorkOfStringToFloat32.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				StringToFloat32.PutWork(work.WorkOfStringToFloat32)
				StringToFloat32.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfStringToFloat32) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := StringToFloat32.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfStringToFloat32) Push(ctx context.Context, value string, returnCh chan<- *ReturnOfFloat32) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := StringToFloat32.GetWorkContextWith(ctx, StringToFloat32.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfStringToFloat32) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfStringToFloat32) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfStringToFloat64 struct {
	handler func(context.Context, string) (float64, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfStringToFloat64
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfStringToFloat64(ctx context.Context, h func(context.Context, string) (float64, error), n int) *FuncWorkerOfStringToFloat64 {
	__ := &FuncWorkerOfStringToFloat64{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfStringToFloat64, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go StringToFloat64.CallAsAsync(work.Context, work.WorkOfStringToFloat64.Value, work.WorkOfStringToFloat64.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				StringToFloat64.PutWork(work.WorkOfStringToFloat64)
				StringToFloat64.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfStringToFloat64) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := StringToFloat64.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfStringToFloat64) Push(ctx context.Context, value string, returnCh chan<- *ReturnOfFloat64) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := StringToFloat64.GetWorkContextWith(ctx, StringToFloat64.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfStringToFloat64) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfStringToFloat64) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfStringToInt struct {
	handler func(context.Context, string) (int, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfStringToInt
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfStringToInt(ctx context.Context, h func(context.Context, string) (int, error), n int) *FuncWorkerOfStringToInt {
	__ := &FuncWorkerOfStringToInt{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfStringToInt, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go StringToInt.CallAsAsync(work.Context, work.WorkOfStringToInt.Value, work.WorkOfStringToInt.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				StringToInt.PutWork(work.WorkOfStringToInt)
				StringToInt.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfStringToInt) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := StringToInt.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfStringToInt) Push(ctx context.Context, value string, returnCh chan<- *ReturnOfInt) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := StringToInt.GetWorkContextWith(ctx, StringToInt.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfStringToInt) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfStringToInt) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfStringToInt16 struct {
	handler func(context.Context, string) (int16, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfStringToInt16
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfStringToInt16(ctx context.Context, h func(context.Context, string) (int16, error), n int) *FuncWorkerOfStringToInt16 {
	__ := &FuncWorkerOfStringToInt16{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfStringToInt16, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go StringToInt16.CallAsAsync(work.Context, work.WorkOfStringToInt16.Value, work.WorkOfStringToInt16.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				StringToInt16.PutWork(work.WorkOfStringToInt16)
				StringToInt16.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfStringToInt16) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := StringToInt16.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfStringToInt16) Push(ctx context.Context, value string, returnCh chan<- *ReturnOfInt16) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := StringToInt16.GetWorkContextWith(ctx, StringToInt16.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfStringToInt16) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfStringToInt16) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfStringToInt32 struct {
	handler func(context.Context, string) (int32, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfStringToInt32
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfStringToInt32(ctx context.Context, h func(context.Context, string) (int32, error), n int) *FuncWorkerOfStringToInt32 {
	__ := &FuncWorkerOfStringToInt32{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfStringToInt32, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go StringToInt32.CallAsAsync(work.Context, work.WorkOfStringToInt32.Value, work.WorkOfStringToInt32.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				StringToInt32.PutWork(work.WorkOfStringToInt32)
				StringToInt32.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfStringToInt32) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := StringToInt32.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfStringToInt32) Push(ctx context.Context, value string, returnCh chan<- *ReturnOfInt32) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := StringToInt32.GetWorkContextWith(ctx, StringToInt32.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfStringToInt32) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfStringToInt32) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfStringToInt64 struct {
	handler func(context.Context, string) (int64, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfStringToInt64
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfStringToInt64(ctx context.Context, h func(context.Context, string) (int64, error), n int) *FuncWorkerOfStringToInt64 {
	__ := &FuncWorkerOfStringToInt64{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfStringToInt64, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go StringToInt64.CallAsAsync(work.Context, work.WorkOfStringToInt64.Value, work.WorkOfStringToInt64.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				StringToInt64.PutWork(work.WorkOfStringToInt64)
				StringToInt64.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfStringToInt64) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := StringToInt64.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfStringToInt64) Push(ctx context.Context, value string, returnCh chan<- *ReturnOfInt64) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := StringToInt64.GetWorkContextWith(ctx, StringToInt64.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfStringToInt64) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfStringToInt64) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfStringToInt8 struct {
	handler func(context.Context, string) (int8, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfStringToInt8
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfStringToInt8(ctx context.Context, h func(context.Context, string) (int8, error), n int) *FuncWorkerOfStringToInt8 {
	__ := &FuncWorkerOfStringToInt8{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfStringToInt8, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go StringToInt8.CallAsAsync(work.Context, work.WorkOfStringToInt8.Value, work.WorkOfStringToInt8.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				StringToInt8.PutWork(work.WorkOfStringToInt8)
				StringToInt8.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfStringToInt8) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := StringToInt8.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfStringToInt8) Push(ctx context.Context, value string, returnCh chan<- *ReturnOfInt8) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := StringToInt8.GetWorkContextWith(ctx, StringToInt8.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfStringToInt8) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfStringToInt8) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfStringToRune struct {
	handler func(context.Context, string) (rune, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfStringToRune
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfStringToRune(ctx context.Context, h func(context.Context, string) (rune, error), n int) *FuncWorkerOfStringToRune {
	__ := &FuncWorkerOfStringToRune{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfStringToRune, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go StringToRune.CallAsAsync(work.Context, work.WorkOfStringToRune.Value, work.WorkOfStringToRune.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				StringToRune.PutWork(work.WorkOfStringToRune)
				StringToRune.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfStringToRune) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := StringToRune.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfStringToRune) Push(ctx context.Context, value string, returnCh chan<- *ReturnOfRune) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := StringToRune.GetWorkContextWith(ctx, StringToRune.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfStringToRune) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfStringToRune) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfStringToString struct {
	handler func(context.Context, string) (string, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfStringToString
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfStringToString(ctx context.Context, h func(context.Context, string) (string, error), n int) *FuncWorkerOfStringToString {
	__ := &FuncWorkerOfStringToString{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfStringToString, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go StringToString.CallAsAsync(work.Context, work.WorkOfStringToString.Value, work.WorkOfStringToString.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				StringToString.PutWork(work.WorkOfStringToString)
				StringToString.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfStringToString) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := StringToString.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfStringToString) Push(ctx context.Context, value string, returnCh chan<- *ReturnOfString) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := StringToString.GetWorkContextWith(ctx, StringToString.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfStringToString) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfStringToString) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfStringToUint struct {
	handler func(context.Context, string) (uint, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfStringToUint
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfStringToUint(ctx context.Context, h func(context.Context, string) (uint, error), n int) *FuncWorkerOfStringToUint {
	__ := &FuncWorkerOfStringToUint{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfStringToUint, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go StringToUint.CallAsAsync(work.Context, work.WorkOfStringToUint.Value, work.WorkOfStringToUint.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				StringToUint.PutWork(work.WorkOfStringToUint)
				StringToUint.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfStringToUint) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := StringToUint.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfStringToUint) Push(ctx context.Context, value string, returnCh chan<- *ReturnOfUint) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := StringToUint.GetWorkContextWith(ctx, StringToUint.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfStringToUint) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfStringToUint) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfStringToUint16 struct {
	handler func(context.Context, string) (uint16, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfStringToUint16
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfStringToUint16(ctx context.Context, h func(context.Context, string) (uint16, error), n int) *FuncWorkerOfStringToUint16 {
	__ := &FuncWorkerOfStringToUint16{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfStringToUint16, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go StringToUint16.CallAsAsync(work.Context, work.WorkOfStringToUint16.Value, work.WorkOfStringToUint16.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				StringToUint16.PutWork(work.WorkOfStringToUint16)
				StringToUint16.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfStringToUint16) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := StringToUint16.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfStringToUint16) Push(ctx context.Context, value string, returnCh chan<- *ReturnOfUint16) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := StringToUint16.GetWorkContextWith(ctx, StringToUint16.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfStringToUint16) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfStringToUint16) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfStringToUint32 struct {
	handler func(context.Context, string) (uint32, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfStringToUint32
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfStringToUint32(ctx context.Context, h func(context.Context, string) (uint32, error), n int) *FuncWorkerOfStringToUint32 {
	__ := &FuncWorkerOfStringToUint32{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfStringToUint32, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go StringToUint32.CallAsAsync(work.Context, work.WorkOfStringToUint32.Value, work.WorkOfStringToUint32.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				StringToUint32.PutWork(work.WorkOfStringToUint32)
				StringToUint32.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfStringToUint32) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := StringToUint32.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfStringToUint32) Push(ctx context.Context, value string, returnCh chan<- *ReturnOfUint32) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := StringToUint32.GetWorkContextWith(ctx, StringToUint32.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfStringToUint32) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfStringToUint32) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfStringToUint64 struct {
	handler func(context.Context, string) (uint64, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfStringToUint64
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfStringToUint64(ctx context.Context, h func(context.Context, string) (uint64, error), n int) *FuncWorkerOfStringToUint64 {
	__ := &FuncWorkerOfStringToUint64{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfStringToUint64, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go StringToUint64.CallAsAsync(work.Context, work.WorkOfStringToUint64.Value, work.WorkOfStringToUint64.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				StringToUint64.PutWork(work.WorkOfStringToUint64)
				StringToUint64.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfStringToUint64) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := StringToUint64.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfStringToUint64) Push(ctx context.Context, value string, returnCh chan<- *ReturnOfUint64) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := StringToUint64.GetWorkContextWith(ctx, StringToUint64.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfStringToUint64) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfStringToUint64) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfStringToUint8 struct {
	handler func(context.Context, string) (uint8, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfStringToUint8
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfStringToUint8(ctx context.Context, h func(context.Context, string) (uint8, error), n int) *FuncWorkerOfStringToUint8 {
	__ := &FuncWorkerOfStringToUint8{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfStringToUint8, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go StringToUint8.CallAsAsync(work.Context, work.WorkOfStringToUint8.Value, work.WorkOfStringToUint8.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				StringToUint8.PutWork(work.WorkOfStringToUint8)
				StringToUint8.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfStringToUint8) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := StringToUint8.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfStringToUint8) Push(ctx context.Context, value string, returnCh chan<- *ReturnOfUint8) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := StringToUint8.GetWorkContextWith(ctx, StringToUint8.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfStringToUint8) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfStringToUint8) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfStringToUintptr struct {
	handler func(context.Context, string) (uintptr, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfStringToUintptr
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfStringToUintptr(ctx context.Context, h func(context.Context, string) (uintptr, error), n int) *FuncWorkerOfStringToUintptr {
	__ := &FuncWorkerOfStringToUintptr{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfStringToUintptr, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go StringToUintptr.CallAsAsync(work.Context, work.WorkOfStringToUintptr.Value, work.WorkOfStringToUintptr.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				StringToUintptr.PutWork(work.WorkOfStringToUintptr)
				StringToUintptr.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfStringToUintptr) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := StringToUintptr.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfStringToUintptr) Push(ctx context.Context, value string, returnCh chan<- *ReturnOfUintptr) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := StringToUintptr.GetWorkContextWith(ctx, StringToUintptr.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfStringToUintptr) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfStringToUintptr) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfStringToBytes struct {
	handler func(context.Context, string) (Bytes, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfStringToBytes
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfStringToBytes(ctx context.Context, h func(context.Context, string) (Bytes, error), n int) *FuncWorkerOfStringToBytes {
	__ := &FuncWorkerOfStringToBytes{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfStringToBytes, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go StringToBytes.CallAsAsync(work.Context, work.WorkOfStringToBytes.Value, work.WorkOfStringToBytes.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				StringToBytes.PutWork(work.WorkOfStringToBytes)
				StringToBytes.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfStringToBytes) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := StringToBytes.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfStringToBytes) Push(ctx context.Context, value string, returnCh chan<- *ReturnOfBytes) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := StringToBytes.GetWorkContextWith(ctx, StringToBytes.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfStringToBytes) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfStringToBytes) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfStringToInterface struct {
	handler func(context.Context, string) (interface{}, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfStringToInterface
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfStringToInterface(ctx context.Context, h func(context.Context, string) (interface{}, error), n int) *FuncWorkerOfStringToInterface {
	__ := &FuncWorkerOfStringToInterface{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfStringToInterface, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go StringToInterface.CallAsAsync(work.Context, work.WorkOfStringToInterface.Value, work.WorkOfStringToInterface.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				StringToInterface.PutWork(work.WorkOfStringToInterface)
				StringToInterface.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfStringToInterface) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := StringToInterface.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfStringToInterface) Push(ctx context.Context, value string, returnCh chan<- *ReturnOfInterface) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := StringToInterface.GetWorkContextWith(ctx, StringToInterface.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfStringToInterface) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfStringToInterface) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfUintToBool struct {
	handler func(context.Context, uint) (bool, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfUintToBool
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfUintToBool(ctx context.Context, h func(context.Context, uint) (bool, error), n int) *FuncWorkerOfUintToBool {
	__ := &FuncWorkerOfUintToBool{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfUintToBool, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go UintToBool.CallAsAsync(work.Context, work.WorkOfUintToBool.Value, work.WorkOfUintToBool.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				UintToBool.PutWork(work.WorkOfUintToBool)
				UintToBool.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfUintToBool) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := UintToBool.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfUintToBool) Push(ctx context.Context, value uint, returnCh chan<- *ReturnOfBool) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := UintToBool.GetWorkContextWith(ctx, UintToBool.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfUintToBool) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfUintToBool) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfUintToByte struct {
	handler func(context.Context, uint) (byte, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfUintToByte
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfUintToByte(ctx context.Context, h func(context.Context, uint) (byte, error), n int) *FuncWorkerOfUintToByte {
	__ := &FuncWorkerOfUintToByte{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfUintToByte, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go UintToByte.CallAsAsync(work.Context, work.WorkOfUintToByte.Value, work.WorkOfUintToByte.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				UintToByte.PutWork(work.WorkOfUintToByte)
				UintToByte.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfUintToByte) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := UintToByte.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfUintToByte) Push(ctx context.Context, value uint, returnCh chan<- *ReturnOfByte) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := UintToByte.GetWorkContextWith(ctx, UintToByte.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfUintToByte) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfUintToByte) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfUintToComplex128 struct {
	handler func(context.Context, uint) (complex128, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfUintToComplex128
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfUintToComplex128(ctx context.Context, h func(context.Context, uint) (complex128, error), n int) *FuncWorkerOfUintToComplex128 {
	__ := &FuncWorkerOfUintToComplex128{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfUintToComplex128, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go UintToComplex128.CallAsAsync(work.Context, work.WorkOfUintToComplex128.Value, work.WorkOfUintToComplex128.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				UintToComplex128.PutWork(work.WorkOfUintToComplex128)
				UintToComplex128.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfUintToComplex128) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := UintToComplex128.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfUintToComplex128) Push(ctx context.Context, value uint, returnCh chan<- *ReturnOfComplex128) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := UintToComplex128.GetWorkContextWith(ctx, UintToComplex128.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfUintToComplex128) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfUintToComplex128) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfUintToComplex64 struct {
	handler func(context.Context, uint) (complex64, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfUintToComplex64
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfUintToComplex64(ctx context.Context, h func(context.Context, uint) (complex64, error), n int) *FuncWorkerOfUintToComplex64 {
	__ := &FuncWorkerOfUintToComplex64{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfUintToComplex64, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go UintToComplex64.CallAsAsync(work.Context, work.WorkOfUintToComplex64.Value, work.WorkOfUintToComplex64.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				UintToComplex64.PutWork(work.WorkOfUintToComplex64)
				UintToComplex64.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfUintToComplex64) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := UintToComplex64.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfUintToComplex64) Push(ctx context.Context, value uint, returnCh chan<- *ReturnOfComplex64) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := UintToComplex64.GetWorkContextWith(ctx, UintToComplex64.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfUintToComplex64) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfUintToComplex64) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfUintToError struct {
	handler func(context.Context, uint) (error, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfUintToError
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfUintToError(ctx context.Context, h func(context.Context, uint) (error, error), n int) *FuncWorkerOfUintToError {
	__ := &FuncWorkerOfUintToError{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfUintToError, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go UintToError.CallAsAsync(work.Context, work.WorkOfUintToError.Value, work.WorkOfUintToError.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				UintToError.PutWork(work.WorkOfUintToError)
				UintToError.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfUintToError) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := UintToError.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfUintToError) Push(ctx context.Context, value uint, returnCh chan<- *ReturnOfError) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := UintToError.GetWorkContextWith(ctx, UintToError.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfUintToError) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfUintToError) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfUintToFloat32 struct {
	handler func(context.Context, uint) (float32, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfUintToFloat32
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfUintToFloat32(ctx context.Context, h func(context.Context, uint) (float32, error), n int) *FuncWorkerOfUintToFloat32 {
	__ := &FuncWorkerOfUintToFloat32{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfUintToFloat32, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go UintToFloat32.CallAsAsync(work.Context, work.WorkOfUintToFloat32.Value, work.WorkOfUintToFloat32.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				UintToFloat32.PutWork(work.WorkOfUintToFloat32)
				UintToFloat32.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfUintToFloat32) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := UintToFloat32.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfUintToFloat32) Push(ctx context.Context, value uint, returnCh chan<- *ReturnOfFloat32) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := UintToFloat32.GetWorkContextWith(ctx, UintToFloat32.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfUintToFloat32) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfUintToFloat32) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfUintToFloat64 struct {
	handler func(context.Context, uint) (float64, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfUintToFloat64
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfUintToFloat64(ctx context.Context, h func(context.Context, uint) (float64, error), n int) *FuncWorkerOfUintToFloat64 {
	__ := &FuncWorkerOfUintToFloat64{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfUintToFloat64, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go UintToFloat64.CallAsAsync(work.Context, work.WorkOfUintToFloat64.Value, work.WorkOfUintToFloat64.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				UintToFloat64.PutWork(work.WorkOfUintToFloat64)
				UintToFloat64.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfUintToFloat64) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := UintToFloat64.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfUintToFloat64) Push(ctx context.Context, value uint, returnCh chan<- *ReturnOfFloat64) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := UintToFloat64.GetWorkContextWith(ctx, UintToFloat64.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfUintToFloat64) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfUintToFloat64) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfUintToInt struct {
	handler func(context.Context, uint) (int, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfUintToInt
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfUintToInt(ctx context.Context, h func(context.Context, uint) (int, error), n int) *FuncWorkerOfUintToInt {
	__ := &FuncWorkerOfUintToInt{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfUintToInt, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go UintToInt.CallAsAsync(work.Context, work.WorkOfUintToInt.Value, work.WorkOfUintToInt.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				UintToInt.PutWork(work.WorkOfUintToInt)
				UintToInt.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfUintToInt) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := UintToInt.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfUintToInt) Push(ctx context.Context, value uint, returnCh chan<- *ReturnOfInt) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := UintToInt.GetWorkContextWith(ctx, UintToInt.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfUintToInt) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfUintToInt) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfUintToInt16 struct {
	handler func(context.Context, uint) (int16, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfUintToInt16
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfUintToInt16(ctx context.Context, h func(context.Context, uint) (int16, error), n int) *FuncWorkerOfUintToInt16 {
	__ := &FuncWorkerOfUintToInt16{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfUintToInt16, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go UintToInt16.CallAsAsync(work.Context, work.WorkOfUintToInt16.Value, work.WorkOfUintToInt16.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				UintToInt16.PutWork(work.WorkOfUintToInt16)
				UintToInt16.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfUintToInt16) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := UintToInt16.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfUintToInt16) Push(ctx context.Context, value uint, returnCh chan<- *ReturnOfInt16) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := UintToInt16.GetWorkContextWith(ctx, UintToInt16.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfUintToInt16) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfUintToInt16) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfUintToInt32 struct {
	handler func(context.Context, uint) (int32, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfUintToInt32
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfUintToInt32(ctx context.Context, h func(context.Context, uint) (int32, error), n int) *FuncWorkerOfUintToInt32 {
	__ := &FuncWorkerOfUintToInt32{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfUintToInt32, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go UintToInt32.CallAsAsync(work.Context, work.WorkOfUintToInt32.Value, work.WorkOfUintToInt32.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				UintToInt32.PutWork(work.WorkOfUintToInt32)
				UintToInt32.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfUintToInt32) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := UintToInt32.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfUintToInt32) Push(ctx context.Context, value uint, returnCh chan<- *ReturnOfInt32) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := UintToInt32.GetWorkContextWith(ctx, UintToInt32.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfUintToInt32) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfUintToInt32) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfUintToInt64 struct {
	handler func(context.Context, uint) (int64, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfUintToInt64
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfUintToInt64(ctx context.Context, h func(context.Context, uint) (int64, error), n int) *FuncWorkerOfUintToInt64 {
	__ := &FuncWorkerOfUintToInt64{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfUintToInt64, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go UintToInt64.CallAsAsync(work.Context, work.WorkOfUintToInt64.Value, work.WorkOfUintToInt64.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				UintToInt64.PutWork(work.WorkOfUintToInt64)
				UintToInt64.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfUintToInt64) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := UintToInt64.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfUintToInt64) Push(ctx context.Context, value uint, returnCh chan<- *ReturnOfInt64) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := UintToInt64.GetWorkContextWith(ctx, UintToInt64.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfUintToInt64) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfUintToInt64) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfUintToInt8 struct {
	handler func(context.Context, uint) (int8, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfUintToInt8
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfUintToInt8(ctx context.Context, h func(context.Context, uint) (int8, error), n int) *FuncWorkerOfUintToInt8 {
	__ := &FuncWorkerOfUintToInt8{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfUintToInt8, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go UintToInt8.CallAsAsync(work.Context, work.WorkOfUintToInt8.Value, work.WorkOfUintToInt8.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				UintToInt8.PutWork(work.WorkOfUintToInt8)
				UintToInt8.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfUintToInt8) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := UintToInt8.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfUintToInt8) Push(ctx context.Context, value uint, returnCh chan<- *ReturnOfInt8) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := UintToInt8.GetWorkContextWith(ctx, UintToInt8.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfUintToInt8) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfUintToInt8) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfUintToRune struct {
	handler func(context.Context, uint) (rune, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfUintToRune
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfUintToRune(ctx context.Context, h func(context.Context, uint) (rune, error), n int) *FuncWorkerOfUintToRune {
	__ := &FuncWorkerOfUintToRune{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfUintToRune, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go UintToRune.CallAsAsync(work.Context, work.WorkOfUintToRune.Value, work.WorkOfUintToRune.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				UintToRune.PutWork(work.WorkOfUintToRune)
				UintToRune.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfUintToRune) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := UintToRune.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfUintToRune) Push(ctx context.Context, value uint, returnCh chan<- *ReturnOfRune) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := UintToRune.GetWorkContextWith(ctx, UintToRune.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfUintToRune) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfUintToRune) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfUintToString struct {
	handler func(context.Context, uint) (string, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfUintToString
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfUintToString(ctx context.Context, h func(context.Context, uint) (string, error), n int) *FuncWorkerOfUintToString {
	__ := &FuncWorkerOfUintToString{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfUintToString, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go UintToString.CallAsAsync(work.Context, work.WorkOfUintToString.Value, work.WorkOfUintToString.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				UintToString.PutWork(work.WorkOfUintToString)
				UintToString.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfUintToString) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := UintToString.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfUintToString) Push(ctx context.Context, value uint, returnCh chan<- *ReturnOfString) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := UintToString.GetWorkContextWith(ctx, UintToString.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfUintToString) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfUintToString) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfUintToUint struct {
	handler func(context.Context, uint) (uint, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfUintToUint
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfUintToUint(ctx context.Context, h func(context.Context, uint) (uint, error), n int) *FuncWorkerOfUintToUint {
	__ := &FuncWorkerOfUintToUint{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfUintToUint, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go UintToUint.CallAsAsync(work.Context, work.WorkOfUintToUint.Value, work.WorkOfUintToUint.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				UintToUint.PutWork(work.WorkOfUintToUint)
				UintToUint.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfUintToUint) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := UintToUint.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfUintToUint) Push(ctx context.Context, value uint, returnCh chan<- *ReturnOfUint) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := UintToUint.GetWorkContextWith(ctx, UintToUint.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfUintToUint) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfUintToUint) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfUintToUint16 struct {
	handler func(context.Context, uint) (uint16, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfUintToUint16
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfUintToUint16(ctx context.Context, h func(context.Context, uint) (uint16, error), n int) *FuncWorkerOfUintToUint16 {
	__ := &FuncWorkerOfUintToUint16{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfUintToUint16, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go UintToUint16.CallAsAsync(work.Context, work.WorkOfUintToUint16.Value, work.WorkOfUintToUint16.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				UintToUint16.PutWork(work.WorkOfUintToUint16)
				UintToUint16.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfUintToUint16) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := UintToUint16.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfUintToUint16) Push(ctx context.Context, value uint, returnCh chan<- *ReturnOfUint16) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := UintToUint16.GetWorkContextWith(ctx, UintToUint16.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfUintToUint16) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfUintToUint16) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfUintToUint32 struct {
	handler func(context.Context, uint) (uint32, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfUintToUint32
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfUintToUint32(ctx context.Context, h func(context.Context, uint) (uint32, error), n int) *FuncWorkerOfUintToUint32 {
	__ := &FuncWorkerOfUintToUint32{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfUintToUint32, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go UintToUint32.CallAsAsync(work.Context, work.WorkOfUintToUint32.Value, work.WorkOfUintToUint32.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				UintToUint32.PutWork(work.WorkOfUintToUint32)
				UintToUint32.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfUintToUint32) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := UintToUint32.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfUintToUint32) Push(ctx context.Context, value uint, returnCh chan<- *ReturnOfUint32) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := UintToUint32.GetWorkContextWith(ctx, UintToUint32.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfUintToUint32) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfUintToUint32) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfUintToUint64 struct {
	handler func(context.Context, uint) (uint64, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfUintToUint64
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfUintToUint64(ctx context.Context, h func(context.Context, uint) (uint64, error), n int) *FuncWorkerOfUintToUint64 {
	__ := &FuncWorkerOfUintToUint64{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfUintToUint64, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go UintToUint64.CallAsAsync(work.Context, work.WorkOfUintToUint64.Value, work.WorkOfUintToUint64.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				UintToUint64.PutWork(work.WorkOfUintToUint64)
				UintToUint64.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfUintToUint64) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := UintToUint64.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfUintToUint64) Push(ctx context.Context, value uint, returnCh chan<- *ReturnOfUint64) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := UintToUint64.GetWorkContextWith(ctx, UintToUint64.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfUintToUint64) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfUintToUint64) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfUintToUint8 struct {
	handler func(context.Context, uint) (uint8, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfUintToUint8
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfUintToUint8(ctx context.Context, h func(context.Context, uint) (uint8, error), n int) *FuncWorkerOfUintToUint8 {
	__ := &FuncWorkerOfUintToUint8{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfUintToUint8, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go UintToUint8.CallAsAsync(work.Context, work.WorkOfUintToUint8.Value, work.WorkOfUintToUint8.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				UintToUint8.PutWork(work.WorkOfUintToUint8)
				UintToUint8.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfUintToUint8) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := UintToUint8.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfUintToUint8) Push(ctx context.Context, value uint, returnCh chan<- *ReturnOfUint8) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := UintToUint8.GetWorkContextWith(ctx, UintToUint8.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfUintToUint8) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfUintToUint8) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfUintToUintptr struct {
	handler func(context.Context, uint) (uintptr, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfUintToUintptr
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfUintToUintptr(ctx context.Context, h func(context.Context, uint) (uintptr, error), n int) *FuncWorkerOfUintToUintptr {
	__ := &FuncWorkerOfUintToUintptr{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfUintToUintptr, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go UintToUintptr.CallAsAsync(work.Context, work.WorkOfUintToUintptr.Value, work.WorkOfUintToUintptr.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				UintToUintptr.PutWork(work.WorkOfUintToUintptr)
				UintToUintptr.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfUintToUintptr) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := UintToUintptr.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfUintToUintptr) Push(ctx context.Context, value uint, returnCh chan<- *ReturnOfUintptr) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := UintToUintptr.GetWorkContextWith(ctx, UintToUintptr.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfUintToUintptr) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfUintToUintptr) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfUintToBytes struct {
	handler func(context.Context, uint) (Bytes, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfUintToBytes
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfUintToBytes(ctx context.Context, h func(context.Context, uint) (Bytes, error), n int) *FuncWorkerOfUintToBytes {
	__ := &FuncWorkerOfUintToBytes{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfUintToBytes, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go UintToBytes.CallAsAsync(work.Context, work.WorkOfUintToBytes.Value, work.WorkOfUintToBytes.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				UintToBytes.PutWork(work.WorkOfUintToBytes)
				UintToBytes.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfUintToBytes) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := UintToBytes.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfUintToBytes) Push(ctx context.Context, value uint, returnCh chan<- *ReturnOfBytes) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := UintToBytes.GetWorkContextWith(ctx, UintToBytes.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfUintToBytes) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfUintToBytes) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfUintToInterface struct {
	handler func(context.Context, uint) (interface{}, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfUintToInterface
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfUintToInterface(ctx context.Context, h func(context.Context, uint) (interface{}, error), n int) *FuncWorkerOfUintToInterface {
	__ := &FuncWorkerOfUintToInterface{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfUintToInterface, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go UintToInterface.CallAsAsync(work.Context, work.WorkOfUintToInterface.Value, work.WorkOfUintToInterface.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				UintToInterface.PutWork(work.WorkOfUintToInterface)
				UintToInterface.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfUintToInterface) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := UintToInterface.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfUintToInterface) Push(ctx context.Context, value uint, returnCh chan<- *ReturnOfInterface) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := UintToInterface.GetWorkContextWith(ctx, UintToInterface.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfUintToInterface) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfUintToInterface) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfUint16ToBool struct {
	handler func(context.Context, uint16) (bool, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfUint16ToBool
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfUint16ToBool(ctx context.Context, h func(context.Context, uint16) (bool, error), n int) *FuncWorkerOfUint16ToBool {
	__ := &FuncWorkerOfUint16ToBool{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfUint16ToBool, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go Uint16ToBool.CallAsAsync(work.Context, work.WorkOfUint16ToBool.Value, work.WorkOfUint16ToBool.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				Uint16ToBool.PutWork(work.WorkOfUint16ToBool)
				Uint16ToBool.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfUint16ToBool) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := Uint16ToBool.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfUint16ToBool) Push(ctx context.Context, value uint16, returnCh chan<- *ReturnOfBool) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := Uint16ToBool.GetWorkContextWith(ctx, Uint16ToBool.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfUint16ToBool) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfUint16ToBool) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfUint16ToByte struct {
	handler func(context.Context, uint16) (byte, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfUint16ToByte
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfUint16ToByte(ctx context.Context, h func(context.Context, uint16) (byte, error), n int) *FuncWorkerOfUint16ToByte {
	__ := &FuncWorkerOfUint16ToByte{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfUint16ToByte, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go Uint16ToByte.CallAsAsync(work.Context, work.WorkOfUint16ToByte.Value, work.WorkOfUint16ToByte.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				Uint16ToByte.PutWork(work.WorkOfUint16ToByte)
				Uint16ToByte.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfUint16ToByte) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := Uint16ToByte.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfUint16ToByte) Push(ctx context.Context, value uint16, returnCh chan<- *ReturnOfByte) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := Uint16ToByte.GetWorkContextWith(ctx, Uint16ToByte.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfUint16ToByte) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfUint16ToByte) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfUint16ToComplex128 struct {
	handler func(context.Context, uint16) (complex128, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfUint16ToComplex128
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfUint16ToComplex128(ctx context.Context, h func(context.Context, uint16) (complex128, error), n int) *FuncWorkerOfUint16ToComplex128 {
	__ := &FuncWorkerOfUint16ToComplex128{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfUint16ToComplex128, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go Uint16ToComplex128.CallAsAsync(work.Context, work.WorkOfUint16ToComplex128.Value, work.WorkOfUint16ToComplex128.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				Uint16ToComplex128.PutWork(work.WorkOfUint16ToComplex128)
				Uint16ToComplex128.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfUint16ToComplex128) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := Uint16ToComplex128.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfUint16ToComplex128) Push(ctx context.Context, value uint16, returnCh chan<- *ReturnOfComplex128) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := Uint16ToComplex128.GetWorkContextWith(ctx, Uint16ToComplex128.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfUint16ToComplex128) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfUint16ToComplex128) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfUint16ToComplex64 struct {
	handler func(context.Context, uint16) (complex64, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfUint16ToComplex64
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfUint16ToComplex64(ctx context.Context, h func(context.Context, uint16) (complex64, error), n int) *FuncWorkerOfUint16ToComplex64 {
	__ := &FuncWorkerOfUint16ToComplex64{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfUint16ToComplex64, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go Uint16ToComplex64.CallAsAsync(work.Context, work.WorkOfUint16ToComplex64.Value, work.WorkOfUint16ToComplex64.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				Uint16ToComplex64.PutWork(work.WorkOfUint16ToComplex64)
				Uint16ToComplex64.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfUint16ToComplex64) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := Uint16ToComplex64.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfUint16ToComplex64) Push(ctx context.Context, value uint16, returnCh chan<- *ReturnOfComplex64) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := Uint16ToComplex64.GetWorkContextWith(ctx, Uint16ToComplex64.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfUint16ToComplex64) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfUint16ToComplex64) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfUint16ToError struct {
	handler func(context.Context, uint16) (error, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfUint16ToError
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfUint16ToError(ctx context.Context, h func(context.Context, uint16) (error, error), n int) *FuncWorkerOfUint16ToError {
	__ := &FuncWorkerOfUint16ToError{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfUint16ToError, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go Uint16ToError.CallAsAsync(work.Context, work.WorkOfUint16ToError.Value, work.WorkOfUint16ToError.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				Uint16ToError.PutWork(work.WorkOfUint16ToError)
				Uint16ToError.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfUint16ToError) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := Uint16ToError.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfUint16ToError) Push(ctx context.Context, value uint16, returnCh chan<- *ReturnOfError) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := Uint16ToError.GetWorkContextWith(ctx, Uint16ToError.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfUint16ToError) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfUint16ToError) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfUint16ToFloat32 struct {
	handler func(context.Context, uint16) (float32, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfUint16ToFloat32
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfUint16ToFloat32(ctx context.Context, h func(context.Context, uint16) (float32, error), n int) *FuncWorkerOfUint16ToFloat32 {
	__ := &FuncWorkerOfUint16ToFloat32{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfUint16ToFloat32, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go Uint16ToFloat32.CallAsAsync(work.Context, work.WorkOfUint16ToFloat32.Value, work.WorkOfUint16ToFloat32.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				Uint16ToFloat32.PutWork(work.WorkOfUint16ToFloat32)
				Uint16ToFloat32.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfUint16ToFloat32) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := Uint16ToFloat32.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfUint16ToFloat32) Push(ctx context.Context, value uint16, returnCh chan<- *ReturnOfFloat32) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := Uint16ToFloat32.GetWorkContextWith(ctx, Uint16ToFloat32.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfUint16ToFloat32) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfUint16ToFloat32) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfUint16ToFloat64 struct {
	handler func(context.Context, uint16) (float64, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfUint16ToFloat64
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfUint16ToFloat64(ctx context.Context, h func(context.Context, uint16) (float64, error), n int) *FuncWorkerOfUint16ToFloat64 {
	__ := &FuncWorkerOfUint16ToFloat64{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfUint16ToFloat64, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go Uint16ToFloat64.CallAsAsync(work.Context, work.WorkOfUint16ToFloat64.Value, work.WorkOfUint16ToFloat64.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				Uint16ToFloat64.PutWork(work.WorkOfUint16ToFloat64)
				Uint16ToFloat64.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfUint16ToFloat64) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := Uint16ToFloat64.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfUint16ToFloat64) Push(ctx context.Context, value uint16, returnCh chan<- *ReturnOfFloat64) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := Uint16ToFloat64.GetWorkContextWith(ctx, Uint16ToFloat64.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfUint16ToFloat64) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfUint16ToFloat64) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfUint16ToInt struct {
	handler func(context.Context, uint16) (int, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfUint16ToInt
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfUint16ToInt(ctx context.Context, h func(context.Context, uint16) (int, error), n int) *FuncWorkerOfUint16ToInt {
	__ := &FuncWorkerOfUint16ToInt{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfUint16ToInt, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go Uint16ToInt.CallAsAsync(work.Context, work.WorkOfUint16ToInt.Value, work.WorkOfUint16ToInt.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				Uint16ToInt.PutWork(work.WorkOfUint16ToInt)
				Uint16ToInt.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfUint16ToInt) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := Uint16ToInt.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfUint16ToInt) Push(ctx context.Context, value uint16, returnCh chan<- *ReturnOfInt) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := Uint16ToInt.GetWorkContextWith(ctx, Uint16ToInt.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfUint16ToInt) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfUint16ToInt) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfUint16ToInt16 struct {
	handler func(context.Context, uint16) (int16, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfUint16ToInt16
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfUint16ToInt16(ctx context.Context, h func(context.Context, uint16) (int16, error), n int) *FuncWorkerOfUint16ToInt16 {
	__ := &FuncWorkerOfUint16ToInt16{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfUint16ToInt16, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go Uint16ToInt16.CallAsAsync(work.Context, work.WorkOfUint16ToInt16.Value, work.WorkOfUint16ToInt16.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				Uint16ToInt16.PutWork(work.WorkOfUint16ToInt16)
				Uint16ToInt16.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfUint16ToInt16) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := Uint16ToInt16.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfUint16ToInt16) Push(ctx context.Context, value uint16, returnCh chan<- *ReturnOfInt16) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := Uint16ToInt16.GetWorkContextWith(ctx, Uint16ToInt16.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfUint16ToInt16) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfUint16ToInt16) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfUint16ToInt32 struct {
	handler func(context.Context, uint16) (int32, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfUint16ToInt32
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfUint16ToInt32(ctx context.Context, h func(context.Context, uint16) (int32, error), n int) *FuncWorkerOfUint16ToInt32 {
	__ := &FuncWorkerOfUint16ToInt32{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfUint16ToInt32, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go Uint16ToInt32.CallAsAsync(work.Context, work.WorkOfUint16ToInt32.Value, work.WorkOfUint16ToInt32.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				Uint16ToInt32.PutWork(work.WorkOfUint16ToInt32)
				Uint16ToInt32.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfUint16ToInt32) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := Uint16ToInt32.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfUint16ToInt32) Push(ctx context.Context, value uint16, returnCh chan<- *ReturnOfInt32) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := Uint16ToInt32.GetWorkContextWith(ctx, Uint16ToInt32.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfUint16ToInt32) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfUint16ToInt32) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfUint16ToInt64 struct {
	handler func(context.Context, uint16) (int64, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfUint16ToInt64
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfUint16ToInt64(ctx context.Context, h func(context.Context, uint16) (int64, error), n int) *FuncWorkerOfUint16ToInt64 {
	__ := &FuncWorkerOfUint16ToInt64{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfUint16ToInt64, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go Uint16ToInt64.CallAsAsync(work.Context, work.WorkOfUint16ToInt64.Value, work.WorkOfUint16ToInt64.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				Uint16ToInt64.PutWork(work.WorkOfUint16ToInt64)
				Uint16ToInt64.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfUint16ToInt64) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := Uint16ToInt64.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfUint16ToInt64) Push(ctx context.Context, value uint16, returnCh chan<- *ReturnOfInt64) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := Uint16ToInt64.GetWorkContextWith(ctx, Uint16ToInt64.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfUint16ToInt64) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfUint16ToInt64) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfUint16ToInt8 struct {
	handler func(context.Context, uint16) (int8, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfUint16ToInt8
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfUint16ToInt8(ctx context.Context, h func(context.Context, uint16) (int8, error), n int) *FuncWorkerOfUint16ToInt8 {
	__ := &FuncWorkerOfUint16ToInt8{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfUint16ToInt8, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go Uint16ToInt8.CallAsAsync(work.Context, work.WorkOfUint16ToInt8.Value, work.WorkOfUint16ToInt8.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				Uint16ToInt8.PutWork(work.WorkOfUint16ToInt8)
				Uint16ToInt8.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfUint16ToInt8) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := Uint16ToInt8.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfUint16ToInt8) Push(ctx context.Context, value uint16, returnCh chan<- *ReturnOfInt8) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := Uint16ToInt8.GetWorkContextWith(ctx, Uint16ToInt8.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfUint16ToInt8) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfUint16ToInt8) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfUint16ToRune struct {
	handler func(context.Context, uint16) (rune, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfUint16ToRune
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfUint16ToRune(ctx context.Context, h func(context.Context, uint16) (rune, error), n int) *FuncWorkerOfUint16ToRune {
	__ := &FuncWorkerOfUint16ToRune{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfUint16ToRune, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go Uint16ToRune.CallAsAsync(work.Context, work.WorkOfUint16ToRune.Value, work.WorkOfUint16ToRune.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				Uint16ToRune.PutWork(work.WorkOfUint16ToRune)
				Uint16ToRune.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfUint16ToRune) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := Uint16ToRune.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfUint16ToRune) Push(ctx context.Context, value uint16, returnCh chan<- *ReturnOfRune) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := Uint16ToRune.GetWorkContextWith(ctx, Uint16ToRune.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfUint16ToRune) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfUint16ToRune) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfUint16ToString struct {
	handler func(context.Context, uint16) (string, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfUint16ToString
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfUint16ToString(ctx context.Context, h func(context.Context, uint16) (string, error), n int) *FuncWorkerOfUint16ToString {
	__ := &FuncWorkerOfUint16ToString{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfUint16ToString, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go Uint16ToString.CallAsAsync(work.Context, work.WorkOfUint16ToString.Value, work.WorkOfUint16ToString.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				Uint16ToString.PutWork(work.WorkOfUint16ToString)
				Uint16ToString.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfUint16ToString) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := Uint16ToString.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfUint16ToString) Push(ctx context.Context, value uint16, returnCh chan<- *ReturnOfString) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := Uint16ToString.GetWorkContextWith(ctx, Uint16ToString.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfUint16ToString) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfUint16ToString) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfUint16ToUint struct {
	handler func(context.Context, uint16) (uint, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfUint16ToUint
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfUint16ToUint(ctx context.Context, h func(context.Context, uint16) (uint, error), n int) *FuncWorkerOfUint16ToUint {
	__ := &FuncWorkerOfUint16ToUint{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfUint16ToUint, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go Uint16ToUint.CallAsAsync(work.Context, work.WorkOfUint16ToUint.Value, work.WorkOfUint16ToUint.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				Uint16ToUint.PutWork(work.WorkOfUint16ToUint)
				Uint16ToUint.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfUint16ToUint) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := Uint16ToUint.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfUint16ToUint) Push(ctx context.Context, value uint16, returnCh chan<- *ReturnOfUint) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := Uint16ToUint.GetWorkContextWith(ctx, Uint16ToUint.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfUint16ToUint) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfUint16ToUint) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfUint16ToUint16 struct {
	handler func(context.Context, uint16) (uint16, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfUint16ToUint16
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfUint16ToUint16(ctx context.Context, h func(context.Context, uint16) (uint16, error), n int) *FuncWorkerOfUint16ToUint16 {
	__ := &FuncWorkerOfUint16ToUint16{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfUint16ToUint16, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go Uint16ToUint16.CallAsAsync(work.Context, work.WorkOfUint16ToUint16.Value, work.WorkOfUint16ToUint16.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				Uint16ToUint16.PutWork(work.WorkOfUint16ToUint16)
				Uint16ToUint16.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfUint16ToUint16) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := Uint16ToUint16.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfUint16ToUint16) Push(ctx context.Context, value uint16, returnCh chan<- *ReturnOfUint16) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := Uint16ToUint16.GetWorkContextWith(ctx, Uint16ToUint16.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfUint16ToUint16) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfUint16ToUint16) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfUint16ToUint32 struct {
	handler func(context.Context, uint16) (uint32, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfUint16ToUint32
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfUint16ToUint32(ctx context.Context, h func(context.Context, uint16) (uint32, error), n int) *FuncWorkerOfUint16ToUint32 {
	__ := &FuncWorkerOfUint16ToUint32{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfUint16ToUint32, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go Uint16ToUint32.CallAsAsync(work.Context, work.WorkOfUint16ToUint32.Value, work.WorkOfUint16ToUint32.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				Uint16ToUint32.PutWork(work.WorkOfUint16ToUint32)
				Uint16ToUint32.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfUint16ToUint32) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := Uint16ToUint32.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfUint16ToUint32) Push(ctx context.Context, value uint16, returnCh chan<- *ReturnOfUint32) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := Uint16ToUint32.GetWorkContextWith(ctx, Uint16ToUint32.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfUint16ToUint32) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfUint16ToUint32) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfUint16ToUint64 struct {
	handler func(context.Context, uint16) (uint64, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfUint16ToUint64
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfUint16ToUint64(ctx context.Context, h func(context.Context, uint16) (uint64, error), n int) *FuncWorkerOfUint16ToUint64 {
	__ := &FuncWorkerOfUint16ToUint64{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfUint16ToUint64, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go Uint16ToUint64.CallAsAsync(work.Context, work.WorkOfUint16ToUint64.Value, work.WorkOfUint16ToUint64.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				Uint16ToUint64.PutWork(work.WorkOfUint16ToUint64)
				Uint16ToUint64.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfUint16ToUint64) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := Uint16ToUint64.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfUint16ToUint64) Push(ctx context.Context, value uint16, returnCh chan<- *ReturnOfUint64) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := Uint16ToUint64.GetWorkContextWith(ctx, Uint16ToUint64.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfUint16ToUint64) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfUint16ToUint64) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfUint16ToUint8 struct {
	handler func(context.Context, uint16) (uint8, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfUint16ToUint8
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfUint16ToUint8(ctx context.Context, h func(context.Context, uint16) (uint8, error), n int) *FuncWorkerOfUint16ToUint8 {
	__ := &FuncWorkerOfUint16ToUint8{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfUint16ToUint8, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go Uint16ToUint8.CallAsAsync(work.Context, work.WorkOfUint16ToUint8.Value, work.WorkOfUint16ToUint8.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				Uint16ToUint8.PutWork(work.WorkOfUint16ToUint8)
				Uint16ToUint8.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfUint16ToUint8) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := Uint16ToUint8.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfUint16ToUint8) Push(ctx context.Context, value uint16, returnCh chan<- *ReturnOfUint8) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := Uint16ToUint8.GetWorkContextWith(ctx, Uint16ToUint8.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfUint16ToUint8) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfUint16ToUint8) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfUint16ToUintptr struct {
	handler func(context.Context, uint16) (uintptr, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfUint16ToUintptr
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfUint16ToUintptr(ctx context.Context, h func(context.Context, uint16) (uintptr, error), n int) *FuncWorkerOfUint16ToUintptr {
	__ := &FuncWorkerOfUint16ToUintptr{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfUint16ToUintptr, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go Uint16ToUintptr.CallAsAsync(work.Context, work.WorkOfUint16ToUintptr.Value, work.WorkOfUint16ToUintptr.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				Uint16ToUintptr.PutWork(work.WorkOfUint16ToUintptr)
				Uint16ToUintptr.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfUint16ToUintptr) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := Uint16ToUintptr.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfUint16ToUintptr) Push(ctx context.Context, value uint16, returnCh chan<- *ReturnOfUintptr) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := Uint16ToUintptr.GetWorkContextWith(ctx, Uint16ToUintptr.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfUint16ToUintptr) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfUint16ToUintptr) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfUint16ToBytes struct {
	handler func(context.Context, uint16) (Bytes, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfUint16ToBytes
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfUint16ToBytes(ctx context.Context, h func(context.Context, uint16) (Bytes, error), n int) *FuncWorkerOfUint16ToBytes {
	__ := &FuncWorkerOfUint16ToBytes{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfUint16ToBytes, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go Uint16ToBytes.CallAsAsync(work.Context, work.WorkOfUint16ToBytes.Value, work.WorkOfUint16ToBytes.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				Uint16ToBytes.PutWork(work.WorkOfUint16ToBytes)
				Uint16ToBytes.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfUint16ToBytes) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := Uint16ToBytes.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfUint16ToBytes) Push(ctx context.Context, value uint16, returnCh chan<- *ReturnOfBytes) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := Uint16ToBytes.GetWorkContextWith(ctx, Uint16ToBytes.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfUint16ToBytes) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfUint16ToBytes) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfUint16ToInterface struct {
	handler func(context.Context, uint16) (interface{}, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfUint16ToInterface
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfUint16ToInterface(ctx context.Context, h func(context.Context, uint16) (interface{}, error), n int) *FuncWorkerOfUint16ToInterface {
	__ := &FuncWorkerOfUint16ToInterface{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfUint16ToInterface, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go Uint16ToInterface.CallAsAsync(work.Context, work.WorkOfUint16ToInterface.Value, work.WorkOfUint16ToInterface.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				Uint16ToInterface.PutWork(work.WorkOfUint16ToInterface)
				Uint16ToInterface.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfUint16ToInterface) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := Uint16ToInterface.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfUint16ToInterface) Push(ctx context.Context, value uint16, returnCh chan<- *ReturnOfInterface) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := Uint16ToInterface.GetWorkContextWith(ctx, Uint16ToInterface.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfUint16ToInterface) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfUint16ToInterface) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfUint32ToBool struct {
	handler func(context.Context, uint32) (bool, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfUint32ToBool
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfUint32ToBool(ctx context.Context, h func(context.Context, uint32) (bool, error), n int) *FuncWorkerOfUint32ToBool {
	__ := &FuncWorkerOfUint32ToBool{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfUint32ToBool, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go Uint32ToBool.CallAsAsync(work.Context, work.WorkOfUint32ToBool.Value, work.WorkOfUint32ToBool.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				Uint32ToBool.PutWork(work.WorkOfUint32ToBool)
				Uint32ToBool.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfUint32ToBool) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := Uint32ToBool.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfUint32ToBool) Push(ctx context.Context, value uint32, returnCh chan<- *ReturnOfBool) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := Uint32ToBool.GetWorkContextWith(ctx, Uint32ToBool.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfUint32ToBool) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfUint32ToBool) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfUint32ToByte struct {
	handler func(context.Context, uint32) (byte, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfUint32ToByte
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfUint32ToByte(ctx context.Context, h func(context.Context, uint32) (byte, error), n int) *FuncWorkerOfUint32ToByte {
	__ := &FuncWorkerOfUint32ToByte{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfUint32ToByte, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go Uint32ToByte.CallAsAsync(work.Context, work.WorkOfUint32ToByte.Value, work.WorkOfUint32ToByte.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				Uint32ToByte.PutWork(work.WorkOfUint32ToByte)
				Uint32ToByte.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfUint32ToByte) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := Uint32ToByte.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfUint32ToByte) Push(ctx context.Context, value uint32, returnCh chan<- *ReturnOfByte) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := Uint32ToByte.GetWorkContextWith(ctx, Uint32ToByte.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfUint32ToByte) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfUint32ToByte) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfUint32ToComplex128 struct {
	handler func(context.Context, uint32) (complex128, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfUint32ToComplex128
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfUint32ToComplex128(ctx context.Context, h func(context.Context, uint32) (complex128, error), n int) *FuncWorkerOfUint32ToComplex128 {
	__ := &FuncWorkerOfUint32ToComplex128{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfUint32ToComplex128, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go Uint32ToComplex128.CallAsAsync(work.Context, work.WorkOfUint32ToComplex128.Value, work.WorkOfUint32ToComplex128.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				Uint32ToComplex128.PutWork(work.WorkOfUint32ToComplex128)
				Uint32ToComplex128.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfUint32ToComplex128) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := Uint32ToComplex128.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfUint32ToComplex128) Push(ctx context.Context, value uint32, returnCh chan<- *ReturnOfComplex128) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := Uint32ToComplex128.GetWorkContextWith(ctx, Uint32ToComplex128.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfUint32ToComplex128) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfUint32ToComplex128) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfUint32ToComplex64 struct {
	handler func(context.Context, uint32) (complex64, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfUint32ToComplex64
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfUint32ToComplex64(ctx context.Context, h func(context.Context, uint32) (complex64, error), n int) *FuncWorkerOfUint32ToComplex64 {
	__ := &FuncWorkerOfUint32ToComplex64{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfUint32ToComplex64, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go Uint32ToComplex64.CallAsAsync(work.Context, work.WorkOfUint32ToComplex64.Value, work.WorkOfUint32ToComplex64.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				Uint32ToComplex64.PutWork(work.WorkOfUint32ToComplex64)
				Uint32ToComplex64.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfUint32ToComplex64) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := Uint32ToComplex64.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfUint32ToComplex64) Push(ctx context.Context, value uint32, returnCh chan<- *ReturnOfComplex64) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := Uint32ToComplex64.GetWorkContextWith(ctx, Uint32ToComplex64.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfUint32ToComplex64) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfUint32ToComplex64) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfUint32ToError struct {
	handler func(context.Context, uint32) (error, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfUint32ToError
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfUint32ToError(ctx context.Context, h func(context.Context, uint32) (error, error), n int) *FuncWorkerOfUint32ToError {
	__ := &FuncWorkerOfUint32ToError{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfUint32ToError, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go Uint32ToError.CallAsAsync(work.Context, work.WorkOfUint32ToError.Value, work.WorkOfUint32ToError.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				Uint32ToError.PutWork(work.WorkOfUint32ToError)
				Uint32ToError.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfUint32ToError) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := Uint32ToError.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfUint32ToError) Push(ctx context.Context, value uint32, returnCh chan<- *ReturnOfError) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := Uint32ToError.GetWorkContextWith(ctx, Uint32ToError.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfUint32ToError) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfUint32ToError) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfUint32ToFloat32 struct {
	handler func(context.Context, uint32) (float32, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfUint32ToFloat32
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfUint32ToFloat32(ctx context.Context, h func(context.Context, uint32) (float32, error), n int) *FuncWorkerOfUint32ToFloat32 {
	__ := &FuncWorkerOfUint32ToFloat32{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfUint32ToFloat32, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go Uint32ToFloat32.CallAsAsync(work.Context, work.WorkOfUint32ToFloat32.Value, work.WorkOfUint32ToFloat32.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				Uint32ToFloat32.PutWork(work.WorkOfUint32ToFloat32)
				Uint32ToFloat32.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfUint32ToFloat32) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := Uint32ToFloat32.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfUint32ToFloat32) Push(ctx context.Context, value uint32, returnCh chan<- *ReturnOfFloat32) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := Uint32ToFloat32.GetWorkContextWith(ctx, Uint32ToFloat32.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfUint32ToFloat32) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfUint32ToFloat32) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfUint32ToFloat64 struct {
	handler func(context.Context, uint32) (float64, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfUint32ToFloat64
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfUint32ToFloat64(ctx context.Context, h func(context.Context, uint32) (float64, error), n int) *FuncWorkerOfUint32ToFloat64 {
	__ := &FuncWorkerOfUint32ToFloat64{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfUint32ToFloat64, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go Uint32ToFloat64.CallAsAsync(work.Context, work.WorkOfUint32ToFloat64.Value, work.WorkOfUint32ToFloat64.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				Uint32ToFloat64.PutWork(work.WorkOfUint32ToFloat64)
				Uint32ToFloat64.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfUint32ToFloat64) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := Uint32ToFloat64.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfUint32ToFloat64) Push(ctx context.Context, value uint32, returnCh chan<- *ReturnOfFloat64) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := Uint32ToFloat64.GetWorkContextWith(ctx, Uint32ToFloat64.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfUint32ToFloat64) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfUint32ToFloat64) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfUint32ToInt struct {
	handler func(context.Context, uint32) (int, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfUint32ToInt
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfUint32ToInt(ctx context.Context, h func(context.Context, uint32) (int, error), n int) *FuncWorkerOfUint32ToInt {
	__ := &FuncWorkerOfUint32ToInt{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfUint32ToInt, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go Uint32ToInt.CallAsAsync(work.Context, work.WorkOfUint32ToInt.Value, work.WorkOfUint32ToInt.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				Uint32ToInt.PutWork(work.WorkOfUint32ToInt)
				Uint32ToInt.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfUint32ToInt) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := Uint32ToInt.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfUint32ToInt) Push(ctx context.Context, value uint32, returnCh chan<- *ReturnOfInt) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := Uint32ToInt.GetWorkContextWith(ctx, Uint32ToInt.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfUint32ToInt) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfUint32ToInt) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfUint32ToInt16 struct {
	handler func(context.Context, uint32) (int16, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfUint32ToInt16
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfUint32ToInt16(ctx context.Context, h func(context.Context, uint32) (int16, error), n int) *FuncWorkerOfUint32ToInt16 {
	__ := &FuncWorkerOfUint32ToInt16{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfUint32ToInt16, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go Uint32ToInt16.CallAsAsync(work.Context, work.WorkOfUint32ToInt16.Value, work.WorkOfUint32ToInt16.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				Uint32ToInt16.PutWork(work.WorkOfUint32ToInt16)
				Uint32ToInt16.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfUint32ToInt16) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := Uint32ToInt16.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfUint32ToInt16) Push(ctx context.Context, value uint32, returnCh chan<- *ReturnOfInt16) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := Uint32ToInt16.GetWorkContextWith(ctx, Uint32ToInt16.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfUint32ToInt16) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfUint32ToInt16) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfUint32ToInt32 struct {
	handler func(context.Context, uint32) (int32, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfUint32ToInt32
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfUint32ToInt32(ctx context.Context, h func(context.Context, uint32) (int32, error), n int) *FuncWorkerOfUint32ToInt32 {
	__ := &FuncWorkerOfUint32ToInt32{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfUint32ToInt32, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go Uint32ToInt32.CallAsAsync(work.Context, work.WorkOfUint32ToInt32.Value, work.WorkOfUint32ToInt32.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				Uint32ToInt32.PutWork(work.WorkOfUint32ToInt32)
				Uint32ToInt32.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfUint32ToInt32) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := Uint32ToInt32.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfUint32ToInt32) Push(ctx context.Context, value uint32, returnCh chan<- *ReturnOfInt32) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := Uint32ToInt32.GetWorkContextWith(ctx, Uint32ToInt32.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfUint32ToInt32) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfUint32ToInt32) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfUint32ToInt64 struct {
	handler func(context.Context, uint32) (int64, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfUint32ToInt64
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfUint32ToInt64(ctx context.Context, h func(context.Context, uint32) (int64, error), n int) *FuncWorkerOfUint32ToInt64 {
	__ := &FuncWorkerOfUint32ToInt64{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfUint32ToInt64, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go Uint32ToInt64.CallAsAsync(work.Context, work.WorkOfUint32ToInt64.Value, work.WorkOfUint32ToInt64.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				Uint32ToInt64.PutWork(work.WorkOfUint32ToInt64)
				Uint32ToInt64.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfUint32ToInt64) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := Uint32ToInt64.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfUint32ToInt64) Push(ctx context.Context, value uint32, returnCh chan<- *ReturnOfInt64) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := Uint32ToInt64.GetWorkContextWith(ctx, Uint32ToInt64.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfUint32ToInt64) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfUint32ToInt64) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfUint32ToInt8 struct {
	handler func(context.Context, uint32) (int8, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfUint32ToInt8
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfUint32ToInt8(ctx context.Context, h func(context.Context, uint32) (int8, error), n int) *FuncWorkerOfUint32ToInt8 {
	__ := &FuncWorkerOfUint32ToInt8{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfUint32ToInt8, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go Uint32ToInt8.CallAsAsync(work.Context, work.WorkOfUint32ToInt8.Value, work.WorkOfUint32ToInt8.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				Uint32ToInt8.PutWork(work.WorkOfUint32ToInt8)
				Uint32ToInt8.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfUint32ToInt8) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := Uint32ToInt8.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfUint32ToInt8) Push(ctx context.Context, value uint32, returnCh chan<- *ReturnOfInt8) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := Uint32ToInt8.GetWorkContextWith(ctx, Uint32ToInt8.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfUint32ToInt8) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfUint32ToInt8) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfUint32ToRune struct {
	handler func(context.Context, uint32) (rune, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfUint32ToRune
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfUint32ToRune(ctx context.Context, h func(context.Context, uint32) (rune, error), n int) *FuncWorkerOfUint32ToRune {
	__ := &FuncWorkerOfUint32ToRune{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfUint32ToRune, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go Uint32ToRune.CallAsAsync(work.Context, work.WorkOfUint32ToRune.Value, work.WorkOfUint32ToRune.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				Uint32ToRune.PutWork(work.WorkOfUint32ToRune)
				Uint32ToRune.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfUint32ToRune) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := Uint32ToRune.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfUint32ToRune) Push(ctx context.Context, value uint32, returnCh chan<- *ReturnOfRune) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := Uint32ToRune.GetWorkContextWith(ctx, Uint32ToRune.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfUint32ToRune) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfUint32ToRune) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfUint32ToString struct {
	handler func(context.Context, uint32) (string, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfUint32ToString
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfUint32ToString(ctx context.Context, h func(context.Context, uint32) (string, error), n int) *FuncWorkerOfUint32ToString {
	__ := &FuncWorkerOfUint32ToString{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfUint32ToString, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go Uint32ToString.CallAsAsync(work.Context, work.WorkOfUint32ToString.Value, work.WorkOfUint32ToString.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				Uint32ToString.PutWork(work.WorkOfUint32ToString)
				Uint32ToString.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfUint32ToString) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := Uint32ToString.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfUint32ToString) Push(ctx context.Context, value uint32, returnCh chan<- *ReturnOfString) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := Uint32ToString.GetWorkContextWith(ctx, Uint32ToString.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfUint32ToString) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfUint32ToString) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfUint32ToUint struct {
	handler func(context.Context, uint32) (uint, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfUint32ToUint
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfUint32ToUint(ctx context.Context, h func(context.Context, uint32) (uint, error), n int) *FuncWorkerOfUint32ToUint {
	__ := &FuncWorkerOfUint32ToUint{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfUint32ToUint, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go Uint32ToUint.CallAsAsync(work.Context, work.WorkOfUint32ToUint.Value, work.WorkOfUint32ToUint.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				Uint32ToUint.PutWork(work.WorkOfUint32ToUint)
				Uint32ToUint.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfUint32ToUint) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := Uint32ToUint.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfUint32ToUint) Push(ctx context.Context, value uint32, returnCh chan<- *ReturnOfUint) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := Uint32ToUint.GetWorkContextWith(ctx, Uint32ToUint.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfUint32ToUint) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfUint32ToUint) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfUint32ToUint16 struct {
	handler func(context.Context, uint32) (uint16, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfUint32ToUint16
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfUint32ToUint16(ctx context.Context, h func(context.Context, uint32) (uint16, error), n int) *FuncWorkerOfUint32ToUint16 {
	__ := &FuncWorkerOfUint32ToUint16{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfUint32ToUint16, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go Uint32ToUint16.CallAsAsync(work.Context, work.WorkOfUint32ToUint16.Value, work.WorkOfUint32ToUint16.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				Uint32ToUint16.PutWork(work.WorkOfUint32ToUint16)
				Uint32ToUint16.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfUint32ToUint16) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := Uint32ToUint16.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfUint32ToUint16) Push(ctx context.Context, value uint32, returnCh chan<- *ReturnOfUint16) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := Uint32ToUint16.GetWorkContextWith(ctx, Uint32ToUint16.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfUint32ToUint16) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfUint32ToUint16) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfUint32ToUint32 struct {
	handler func(context.Context, uint32) (uint32, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfUint32ToUint32
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfUint32ToUint32(ctx context.Context, h func(context.Context, uint32) (uint32, error), n int) *FuncWorkerOfUint32ToUint32 {
	__ := &FuncWorkerOfUint32ToUint32{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfUint32ToUint32, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go Uint32ToUint32.CallAsAsync(work.Context, work.WorkOfUint32ToUint32.Value, work.WorkOfUint32ToUint32.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				Uint32ToUint32.PutWork(work.WorkOfUint32ToUint32)
				Uint32ToUint32.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfUint32ToUint32) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := Uint32ToUint32.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfUint32ToUint32) Push(ctx context.Context, value uint32, returnCh chan<- *ReturnOfUint32) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := Uint32ToUint32.GetWorkContextWith(ctx, Uint32ToUint32.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfUint32ToUint32) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfUint32ToUint32) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfUint32ToUint64 struct {
	handler func(context.Context, uint32) (uint64, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfUint32ToUint64
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfUint32ToUint64(ctx context.Context, h func(context.Context, uint32) (uint64, error), n int) *FuncWorkerOfUint32ToUint64 {
	__ := &FuncWorkerOfUint32ToUint64{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfUint32ToUint64, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go Uint32ToUint64.CallAsAsync(work.Context, work.WorkOfUint32ToUint64.Value, work.WorkOfUint32ToUint64.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				Uint32ToUint64.PutWork(work.WorkOfUint32ToUint64)
				Uint32ToUint64.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfUint32ToUint64) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := Uint32ToUint64.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfUint32ToUint64) Push(ctx context.Context, value uint32, returnCh chan<- *ReturnOfUint64) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := Uint32ToUint64.GetWorkContextWith(ctx, Uint32ToUint64.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfUint32ToUint64) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfUint32ToUint64) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfUint32ToUint8 struct {
	handler func(context.Context, uint32) (uint8, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfUint32ToUint8
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfUint32ToUint8(ctx context.Context, h func(context.Context, uint32) (uint8, error), n int) *FuncWorkerOfUint32ToUint8 {
	__ := &FuncWorkerOfUint32ToUint8{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfUint32ToUint8, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go Uint32ToUint8.CallAsAsync(work.Context, work.WorkOfUint32ToUint8.Value, work.WorkOfUint32ToUint8.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				Uint32ToUint8.PutWork(work.WorkOfUint32ToUint8)
				Uint32ToUint8.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfUint32ToUint8) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := Uint32ToUint8.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfUint32ToUint8) Push(ctx context.Context, value uint32, returnCh chan<- *ReturnOfUint8) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := Uint32ToUint8.GetWorkContextWith(ctx, Uint32ToUint8.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfUint32ToUint8) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfUint32ToUint8) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfUint32ToUintptr struct {
	handler func(context.Context, uint32) (uintptr, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfUint32ToUintptr
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfUint32ToUintptr(ctx context.Context, h func(context.Context, uint32) (uintptr, error), n int) *FuncWorkerOfUint32ToUintptr {
	__ := &FuncWorkerOfUint32ToUintptr{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfUint32ToUintptr, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go Uint32ToUintptr.CallAsAsync(work.Context, work.WorkOfUint32ToUintptr.Value, work.WorkOfUint32ToUintptr.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				Uint32ToUintptr.PutWork(work.WorkOfUint32ToUintptr)
				Uint32ToUintptr.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfUint32ToUintptr) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := Uint32ToUintptr.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfUint32ToUintptr) Push(ctx context.Context, value uint32, returnCh chan<- *ReturnOfUintptr) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := Uint32ToUintptr.GetWorkContextWith(ctx, Uint32ToUintptr.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfUint32ToUintptr) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfUint32ToUintptr) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfUint32ToBytes struct {
	handler func(context.Context, uint32) (Bytes, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfUint32ToBytes
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfUint32ToBytes(ctx context.Context, h func(context.Context, uint32) (Bytes, error), n int) *FuncWorkerOfUint32ToBytes {
	__ := &FuncWorkerOfUint32ToBytes{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfUint32ToBytes, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go Uint32ToBytes.CallAsAsync(work.Context, work.WorkOfUint32ToBytes.Value, work.WorkOfUint32ToBytes.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				Uint32ToBytes.PutWork(work.WorkOfUint32ToBytes)
				Uint32ToBytes.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfUint32ToBytes) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := Uint32ToBytes.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfUint32ToBytes) Push(ctx context.Context, value uint32, returnCh chan<- *ReturnOfBytes) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := Uint32ToBytes.GetWorkContextWith(ctx, Uint32ToBytes.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfUint32ToBytes) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfUint32ToBytes) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfUint32ToInterface struct {
	handler func(context.Context, uint32) (interface{}, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfUint32ToInterface
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfUint32ToInterface(ctx context.Context, h func(context.Context, uint32) (interface{}, error), n int) *FuncWorkerOfUint32ToInterface {
	__ := &FuncWorkerOfUint32ToInterface{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfUint32ToInterface, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go Uint32ToInterface.CallAsAsync(work.Context, work.WorkOfUint32ToInterface.Value, work.WorkOfUint32ToInterface.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				Uint32ToInterface.PutWork(work.WorkOfUint32ToInterface)
				Uint32ToInterface.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfUint32ToInterface) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := Uint32ToInterface.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfUint32ToInterface) Push(ctx context.Context, value uint32, returnCh chan<- *ReturnOfInterface) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := Uint32ToInterface.GetWorkContextWith(ctx, Uint32ToInterface.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfUint32ToInterface) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfUint32ToInterface) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfUint64ToBool struct {
	handler func(context.Context, uint64) (bool, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfUint64ToBool
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfUint64ToBool(ctx context.Context, h func(context.Context, uint64) (bool, error), n int) *FuncWorkerOfUint64ToBool {
	__ := &FuncWorkerOfUint64ToBool{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfUint64ToBool, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go Uint64ToBool.CallAsAsync(work.Context, work.WorkOfUint64ToBool.Value, work.WorkOfUint64ToBool.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				Uint64ToBool.PutWork(work.WorkOfUint64ToBool)
				Uint64ToBool.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfUint64ToBool) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := Uint64ToBool.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfUint64ToBool) Push(ctx context.Context, value uint64, returnCh chan<- *ReturnOfBool) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := Uint64ToBool.GetWorkContextWith(ctx, Uint64ToBool.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfUint64ToBool) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfUint64ToBool) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfUint64ToByte struct {
	handler func(context.Context, uint64) (byte, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfUint64ToByte
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfUint64ToByte(ctx context.Context, h func(context.Context, uint64) (byte, error), n int) *FuncWorkerOfUint64ToByte {
	__ := &FuncWorkerOfUint64ToByte{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfUint64ToByte, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go Uint64ToByte.CallAsAsync(work.Context, work.WorkOfUint64ToByte.Value, work.WorkOfUint64ToByte.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				Uint64ToByte.PutWork(work.WorkOfUint64ToByte)
				Uint64ToByte.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfUint64ToByte) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := Uint64ToByte.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfUint64ToByte) Push(ctx context.Context, value uint64, returnCh chan<- *ReturnOfByte) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := Uint64ToByte.GetWorkContextWith(ctx, Uint64ToByte.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfUint64ToByte) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfUint64ToByte) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfUint64ToComplex128 struct {
	handler func(context.Context, uint64) (complex128, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfUint64ToComplex128
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfUint64ToComplex128(ctx context.Context, h func(context.Context, uint64) (complex128, error), n int) *FuncWorkerOfUint64ToComplex128 {
	__ := &FuncWorkerOfUint64ToComplex128{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfUint64ToComplex128, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go Uint64ToComplex128.CallAsAsync(work.Context, work.WorkOfUint64ToComplex128.Value, work.WorkOfUint64ToComplex128.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				Uint64ToComplex128.PutWork(work.WorkOfUint64ToComplex128)
				Uint64ToComplex128.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfUint64ToComplex128) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := Uint64ToComplex128.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfUint64ToComplex128) Push(ctx context.Context, value uint64, returnCh chan<- *ReturnOfComplex128) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := Uint64ToComplex128.GetWorkContextWith(ctx, Uint64ToComplex128.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfUint64ToComplex128) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfUint64ToComplex128) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfUint64ToComplex64 struct {
	handler func(context.Context, uint64) (complex64, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfUint64ToComplex64
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfUint64ToComplex64(ctx context.Context, h func(context.Context, uint64) (complex64, error), n int) *FuncWorkerOfUint64ToComplex64 {
	__ := &FuncWorkerOfUint64ToComplex64{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfUint64ToComplex64, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go Uint64ToComplex64.CallAsAsync(work.Context, work.WorkOfUint64ToComplex64.Value, work.WorkOfUint64ToComplex64.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				Uint64ToComplex64.PutWork(work.WorkOfUint64ToComplex64)
				Uint64ToComplex64.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfUint64ToComplex64) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := Uint64ToComplex64.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfUint64ToComplex64) Push(ctx context.Context, value uint64, returnCh chan<- *ReturnOfComplex64) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := Uint64ToComplex64.GetWorkContextWith(ctx, Uint64ToComplex64.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfUint64ToComplex64) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfUint64ToComplex64) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfUint64ToError struct {
	handler func(context.Context, uint64) (error, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfUint64ToError
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfUint64ToError(ctx context.Context, h func(context.Context, uint64) (error, error), n int) *FuncWorkerOfUint64ToError {
	__ := &FuncWorkerOfUint64ToError{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfUint64ToError, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go Uint64ToError.CallAsAsync(work.Context, work.WorkOfUint64ToError.Value, work.WorkOfUint64ToError.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				Uint64ToError.PutWork(work.WorkOfUint64ToError)
				Uint64ToError.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfUint64ToError) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := Uint64ToError.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfUint64ToError) Push(ctx context.Context, value uint64, returnCh chan<- *ReturnOfError) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := Uint64ToError.GetWorkContextWith(ctx, Uint64ToError.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfUint64ToError) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfUint64ToError) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfUint64ToFloat32 struct {
	handler func(context.Context, uint64) (float32, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfUint64ToFloat32
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfUint64ToFloat32(ctx context.Context, h func(context.Context, uint64) (float32, error), n int) *FuncWorkerOfUint64ToFloat32 {
	__ := &FuncWorkerOfUint64ToFloat32{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfUint64ToFloat32, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go Uint64ToFloat32.CallAsAsync(work.Context, work.WorkOfUint64ToFloat32.Value, work.WorkOfUint64ToFloat32.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				Uint64ToFloat32.PutWork(work.WorkOfUint64ToFloat32)
				Uint64ToFloat32.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfUint64ToFloat32) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := Uint64ToFloat32.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfUint64ToFloat32) Push(ctx context.Context, value uint64, returnCh chan<- *ReturnOfFloat32) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := Uint64ToFloat32.GetWorkContextWith(ctx, Uint64ToFloat32.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfUint64ToFloat32) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfUint64ToFloat32) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfUint64ToFloat64 struct {
	handler func(context.Context, uint64) (float64, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfUint64ToFloat64
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfUint64ToFloat64(ctx context.Context, h func(context.Context, uint64) (float64, error), n int) *FuncWorkerOfUint64ToFloat64 {
	__ := &FuncWorkerOfUint64ToFloat64{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfUint64ToFloat64, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go Uint64ToFloat64.CallAsAsync(work.Context, work.WorkOfUint64ToFloat64.Value, work.WorkOfUint64ToFloat64.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				Uint64ToFloat64.PutWork(work.WorkOfUint64ToFloat64)
				Uint64ToFloat64.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfUint64ToFloat64) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := Uint64ToFloat64.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfUint64ToFloat64) Push(ctx context.Context, value uint64, returnCh chan<- *ReturnOfFloat64) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := Uint64ToFloat64.GetWorkContextWith(ctx, Uint64ToFloat64.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfUint64ToFloat64) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfUint64ToFloat64) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfUint64ToInt struct {
	handler func(context.Context, uint64) (int, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfUint64ToInt
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfUint64ToInt(ctx context.Context, h func(context.Context, uint64) (int, error), n int) *FuncWorkerOfUint64ToInt {
	__ := &FuncWorkerOfUint64ToInt{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfUint64ToInt, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go Uint64ToInt.CallAsAsync(work.Context, work.WorkOfUint64ToInt.Value, work.WorkOfUint64ToInt.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				Uint64ToInt.PutWork(work.WorkOfUint64ToInt)
				Uint64ToInt.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfUint64ToInt) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := Uint64ToInt.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfUint64ToInt) Push(ctx context.Context, value uint64, returnCh chan<- *ReturnOfInt) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := Uint64ToInt.GetWorkContextWith(ctx, Uint64ToInt.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfUint64ToInt) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfUint64ToInt) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfUint64ToInt16 struct {
	handler func(context.Context, uint64) (int16, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfUint64ToInt16
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfUint64ToInt16(ctx context.Context, h func(context.Context, uint64) (int16, error), n int) *FuncWorkerOfUint64ToInt16 {
	__ := &FuncWorkerOfUint64ToInt16{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfUint64ToInt16, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go Uint64ToInt16.CallAsAsync(work.Context, work.WorkOfUint64ToInt16.Value, work.WorkOfUint64ToInt16.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				Uint64ToInt16.PutWork(work.WorkOfUint64ToInt16)
				Uint64ToInt16.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfUint64ToInt16) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := Uint64ToInt16.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfUint64ToInt16) Push(ctx context.Context, value uint64, returnCh chan<- *ReturnOfInt16) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := Uint64ToInt16.GetWorkContextWith(ctx, Uint64ToInt16.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfUint64ToInt16) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfUint64ToInt16) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfUint64ToInt32 struct {
	handler func(context.Context, uint64) (int32, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfUint64ToInt32
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfUint64ToInt32(ctx context.Context, h func(context.Context, uint64) (int32, error), n int) *FuncWorkerOfUint64ToInt32 {
	__ := &FuncWorkerOfUint64ToInt32{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfUint64ToInt32, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go Uint64ToInt32.CallAsAsync(work.Context, work.WorkOfUint64ToInt32.Value, work.WorkOfUint64ToInt32.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				Uint64ToInt32.PutWork(work.WorkOfUint64ToInt32)
				Uint64ToInt32.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfUint64ToInt32) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := Uint64ToInt32.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfUint64ToInt32) Push(ctx context.Context, value uint64, returnCh chan<- *ReturnOfInt32) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := Uint64ToInt32.GetWorkContextWith(ctx, Uint64ToInt32.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfUint64ToInt32) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfUint64ToInt32) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfUint64ToInt64 struct {
	handler func(context.Context, uint64) (int64, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfUint64ToInt64
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfUint64ToInt64(ctx context.Context, h func(context.Context, uint64) (int64, error), n int) *FuncWorkerOfUint64ToInt64 {
	__ := &FuncWorkerOfUint64ToInt64{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfUint64ToInt64, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go Uint64ToInt64.CallAsAsync(work.Context, work.WorkOfUint64ToInt64.Value, work.WorkOfUint64ToInt64.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				Uint64ToInt64.PutWork(work.WorkOfUint64ToInt64)
				Uint64ToInt64.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfUint64ToInt64) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := Uint64ToInt64.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfUint64ToInt64) Push(ctx context.Context, value uint64, returnCh chan<- *ReturnOfInt64) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := Uint64ToInt64.GetWorkContextWith(ctx, Uint64ToInt64.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfUint64ToInt64) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfUint64ToInt64) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfUint64ToInt8 struct {
	handler func(context.Context, uint64) (int8, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfUint64ToInt8
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfUint64ToInt8(ctx context.Context, h func(context.Context, uint64) (int8, error), n int) *FuncWorkerOfUint64ToInt8 {
	__ := &FuncWorkerOfUint64ToInt8{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfUint64ToInt8, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go Uint64ToInt8.CallAsAsync(work.Context, work.WorkOfUint64ToInt8.Value, work.WorkOfUint64ToInt8.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				Uint64ToInt8.PutWork(work.WorkOfUint64ToInt8)
				Uint64ToInt8.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfUint64ToInt8) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := Uint64ToInt8.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfUint64ToInt8) Push(ctx context.Context, value uint64, returnCh chan<- *ReturnOfInt8) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := Uint64ToInt8.GetWorkContextWith(ctx, Uint64ToInt8.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfUint64ToInt8) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfUint64ToInt8) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfUint64ToRune struct {
	handler func(context.Context, uint64) (rune, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfUint64ToRune
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfUint64ToRune(ctx context.Context, h func(context.Context, uint64) (rune, error), n int) *FuncWorkerOfUint64ToRune {
	__ := &FuncWorkerOfUint64ToRune{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfUint64ToRune, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go Uint64ToRune.CallAsAsync(work.Context, work.WorkOfUint64ToRune.Value, work.WorkOfUint64ToRune.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				Uint64ToRune.PutWork(work.WorkOfUint64ToRune)
				Uint64ToRune.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfUint64ToRune) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := Uint64ToRune.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfUint64ToRune) Push(ctx context.Context, value uint64, returnCh chan<- *ReturnOfRune) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := Uint64ToRune.GetWorkContextWith(ctx, Uint64ToRune.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfUint64ToRune) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfUint64ToRune) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfUint64ToString struct {
	handler func(context.Context, uint64) (string, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfUint64ToString
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfUint64ToString(ctx context.Context, h func(context.Context, uint64) (string, error), n int) *FuncWorkerOfUint64ToString {
	__ := &FuncWorkerOfUint64ToString{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfUint64ToString, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go Uint64ToString.CallAsAsync(work.Context, work.WorkOfUint64ToString.Value, work.WorkOfUint64ToString.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				Uint64ToString.PutWork(work.WorkOfUint64ToString)
				Uint64ToString.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfUint64ToString) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := Uint64ToString.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfUint64ToString) Push(ctx context.Context, value uint64, returnCh chan<- *ReturnOfString) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := Uint64ToString.GetWorkContextWith(ctx, Uint64ToString.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfUint64ToString) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfUint64ToString) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfUint64ToUint struct {
	handler func(context.Context, uint64) (uint, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfUint64ToUint
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfUint64ToUint(ctx context.Context, h func(context.Context, uint64) (uint, error), n int) *FuncWorkerOfUint64ToUint {
	__ := &FuncWorkerOfUint64ToUint{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfUint64ToUint, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go Uint64ToUint.CallAsAsync(work.Context, work.WorkOfUint64ToUint.Value, work.WorkOfUint64ToUint.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				Uint64ToUint.PutWork(work.WorkOfUint64ToUint)
				Uint64ToUint.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfUint64ToUint) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := Uint64ToUint.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfUint64ToUint) Push(ctx context.Context, value uint64, returnCh chan<- *ReturnOfUint) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := Uint64ToUint.GetWorkContextWith(ctx, Uint64ToUint.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfUint64ToUint) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfUint64ToUint) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfUint64ToUint16 struct {
	handler func(context.Context, uint64) (uint16, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfUint64ToUint16
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfUint64ToUint16(ctx context.Context, h func(context.Context, uint64) (uint16, error), n int) *FuncWorkerOfUint64ToUint16 {
	__ := &FuncWorkerOfUint64ToUint16{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfUint64ToUint16, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go Uint64ToUint16.CallAsAsync(work.Context, work.WorkOfUint64ToUint16.Value, work.WorkOfUint64ToUint16.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				Uint64ToUint16.PutWork(work.WorkOfUint64ToUint16)
				Uint64ToUint16.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfUint64ToUint16) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := Uint64ToUint16.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfUint64ToUint16) Push(ctx context.Context, value uint64, returnCh chan<- *ReturnOfUint16) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := Uint64ToUint16.GetWorkContextWith(ctx, Uint64ToUint16.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfUint64ToUint16) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfUint64ToUint16) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfUint64ToUint32 struct {
	handler func(context.Context, uint64) (uint32, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfUint64ToUint32
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfUint64ToUint32(ctx context.Context, h func(context.Context, uint64) (uint32, error), n int) *FuncWorkerOfUint64ToUint32 {
	__ := &FuncWorkerOfUint64ToUint32{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfUint64ToUint32, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go Uint64ToUint32.CallAsAsync(work.Context, work.WorkOfUint64ToUint32.Value, work.WorkOfUint64ToUint32.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				Uint64ToUint32.PutWork(work.WorkOfUint64ToUint32)
				Uint64ToUint32.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfUint64ToUint32) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := Uint64ToUint32.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfUint64ToUint32) Push(ctx context.Context, value uint64, returnCh chan<- *ReturnOfUint32) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := Uint64ToUint32.GetWorkContextWith(ctx, Uint64ToUint32.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfUint64ToUint32) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfUint64ToUint32) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfUint64ToUint64 struct {
	handler func(context.Context, uint64) (uint64, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfUint64ToUint64
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfUint64ToUint64(ctx context.Context, h func(context.Context, uint64) (uint64, error), n int) *FuncWorkerOfUint64ToUint64 {
	__ := &FuncWorkerOfUint64ToUint64{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfUint64ToUint64, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go Uint64ToUint64.CallAsAsync(work.Context, work.WorkOfUint64ToUint64.Value, work.WorkOfUint64ToUint64.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				Uint64ToUint64.PutWork(work.WorkOfUint64ToUint64)
				Uint64ToUint64.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfUint64ToUint64) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := Uint64ToUint64.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfUint64ToUint64) Push(ctx context.Context, value uint64, returnCh chan<- *ReturnOfUint64) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := Uint64ToUint64.GetWorkContextWith(ctx, Uint64ToUint64.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfUint64ToUint64) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfUint64ToUint64) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfUint64ToUint8 struct {
	handler func(context.Context, uint64) (uint8, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfUint64ToUint8
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfUint64ToUint8(ctx context.Context, h func(context.Context, uint64) (uint8, error), n int) *FuncWorkerOfUint64ToUint8 {
	__ := &FuncWorkerOfUint64ToUint8{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfUint64ToUint8, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go Uint64ToUint8.CallAsAsync(work.Context, work.WorkOfUint64ToUint8.Value, work.WorkOfUint64ToUint8.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				Uint64ToUint8.PutWork(work.WorkOfUint64ToUint8)
				Uint64ToUint8.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfUint64ToUint8) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := Uint64ToUint8.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfUint64ToUint8) Push(ctx context.Context, value uint64, returnCh chan<- *ReturnOfUint8) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := Uint64ToUint8.GetWorkContextWith(ctx, Uint64ToUint8.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfUint64ToUint8) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfUint64ToUint8) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfUint64ToUintptr struct {
	handler func(context.Context, uint64) (uintptr, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfUint64ToUintptr
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfUint64ToUintptr(ctx context.Context, h func(context.Context, uint64) (uintptr, error), n int) *FuncWorkerOfUint64ToUintptr {
	__ := &FuncWorkerOfUint64ToUintptr{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfUint64ToUintptr, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go Uint64ToUintptr.CallAsAsync(work.Context, work.WorkOfUint64ToUintptr.Value, work.WorkOfUint64ToUintptr.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				Uint64ToUintptr.PutWork(work.WorkOfUint64ToUintptr)
				Uint64ToUintptr.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfUint64ToUintptr) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := Uint64ToUintptr.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfUint64ToUintptr) Push(ctx context.Context, value uint64, returnCh chan<- *ReturnOfUintptr) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := Uint64ToUintptr.GetWorkContextWith(ctx, Uint64ToUintptr.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfUint64ToUintptr) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfUint64ToUintptr) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfUint64ToBytes struct {
	handler func(context.Context, uint64) (Bytes, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfUint64ToBytes
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfUint64ToBytes(ctx context.Context, h func(context.Context, uint64) (Bytes, error), n int) *FuncWorkerOfUint64ToBytes {
	__ := &FuncWorkerOfUint64ToBytes{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfUint64ToBytes, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go Uint64ToBytes.CallAsAsync(work.Context, work.WorkOfUint64ToBytes.Value, work.WorkOfUint64ToBytes.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				Uint64ToBytes.PutWork(work.WorkOfUint64ToBytes)
				Uint64ToBytes.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfUint64ToBytes) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := Uint64ToBytes.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfUint64ToBytes) Push(ctx context.Context, value uint64, returnCh chan<- *ReturnOfBytes) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := Uint64ToBytes.GetWorkContextWith(ctx, Uint64ToBytes.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfUint64ToBytes) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfUint64ToBytes) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfUint64ToInterface struct {
	handler func(context.Context, uint64) (interface{}, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfUint64ToInterface
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfUint64ToInterface(ctx context.Context, h func(context.Context, uint64) (interface{}, error), n int) *FuncWorkerOfUint64ToInterface {
	__ := &FuncWorkerOfUint64ToInterface{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfUint64ToInterface, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go Uint64ToInterface.CallAsAsync(work.Context, work.WorkOfUint64ToInterface.Value, work.WorkOfUint64ToInterface.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				Uint64ToInterface.PutWork(work.WorkOfUint64ToInterface)
				Uint64ToInterface.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfUint64ToInterface) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := Uint64ToInterface.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfUint64ToInterface) Push(ctx context.Context, value uint64, returnCh chan<- *ReturnOfInterface) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := Uint64ToInterface.GetWorkContextWith(ctx, Uint64ToInterface.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfUint64ToInterface) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfUint64ToInterface) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfUint8ToBool struct {
	handler func(context.Context, uint8) (bool, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfUint8ToBool
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfUint8ToBool(ctx context.Context, h func(context.Context, uint8) (bool, error), n int) *FuncWorkerOfUint8ToBool {
	__ := &FuncWorkerOfUint8ToBool{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfUint8ToBool, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go Uint8ToBool.CallAsAsync(work.Context, work.WorkOfUint8ToBool.Value, work.WorkOfUint8ToBool.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				Uint8ToBool.PutWork(work.WorkOfUint8ToBool)
				Uint8ToBool.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfUint8ToBool) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := Uint8ToBool.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfUint8ToBool) Push(ctx context.Context, value uint8, returnCh chan<- *ReturnOfBool) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := Uint8ToBool.GetWorkContextWith(ctx, Uint8ToBool.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfUint8ToBool) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfUint8ToBool) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfUint8ToByte struct {
	handler func(context.Context, uint8) (byte, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfUint8ToByte
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfUint8ToByte(ctx context.Context, h func(context.Context, uint8) (byte, error), n int) *FuncWorkerOfUint8ToByte {
	__ := &FuncWorkerOfUint8ToByte{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfUint8ToByte, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go Uint8ToByte.CallAsAsync(work.Context, work.WorkOfUint8ToByte.Value, work.WorkOfUint8ToByte.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				Uint8ToByte.PutWork(work.WorkOfUint8ToByte)
				Uint8ToByte.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfUint8ToByte) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := Uint8ToByte.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfUint8ToByte) Push(ctx context.Context, value uint8, returnCh chan<- *ReturnOfByte) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := Uint8ToByte.GetWorkContextWith(ctx, Uint8ToByte.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfUint8ToByte) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfUint8ToByte) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfUint8ToComplex128 struct {
	handler func(context.Context, uint8) (complex128, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfUint8ToComplex128
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfUint8ToComplex128(ctx context.Context, h func(context.Context, uint8) (complex128, error), n int) *FuncWorkerOfUint8ToComplex128 {
	__ := &FuncWorkerOfUint8ToComplex128{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfUint8ToComplex128, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go Uint8ToComplex128.CallAsAsync(work.Context, work.WorkOfUint8ToComplex128.Value, work.WorkOfUint8ToComplex128.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				Uint8ToComplex128.PutWork(work.WorkOfUint8ToComplex128)
				Uint8ToComplex128.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfUint8ToComplex128) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := Uint8ToComplex128.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfUint8ToComplex128) Push(ctx context.Context, value uint8, returnCh chan<- *ReturnOfComplex128) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := Uint8ToComplex128.GetWorkContextWith(ctx, Uint8ToComplex128.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfUint8ToComplex128) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfUint8ToComplex128) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfUint8ToComplex64 struct {
	handler func(context.Context, uint8) (complex64, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfUint8ToComplex64
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfUint8ToComplex64(ctx context.Context, h func(context.Context, uint8) (complex64, error), n int) *FuncWorkerOfUint8ToComplex64 {
	__ := &FuncWorkerOfUint8ToComplex64{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfUint8ToComplex64, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go Uint8ToComplex64.CallAsAsync(work.Context, work.WorkOfUint8ToComplex64.Value, work.WorkOfUint8ToComplex64.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				Uint8ToComplex64.PutWork(work.WorkOfUint8ToComplex64)
				Uint8ToComplex64.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfUint8ToComplex64) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := Uint8ToComplex64.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfUint8ToComplex64) Push(ctx context.Context, value uint8, returnCh chan<- *ReturnOfComplex64) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := Uint8ToComplex64.GetWorkContextWith(ctx, Uint8ToComplex64.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfUint8ToComplex64) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfUint8ToComplex64) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfUint8ToError struct {
	handler func(context.Context, uint8) (error, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfUint8ToError
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfUint8ToError(ctx context.Context, h func(context.Context, uint8) (error, error), n int) *FuncWorkerOfUint8ToError {
	__ := &FuncWorkerOfUint8ToError{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfUint8ToError, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go Uint8ToError.CallAsAsync(work.Context, work.WorkOfUint8ToError.Value, work.WorkOfUint8ToError.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				Uint8ToError.PutWork(work.WorkOfUint8ToError)
				Uint8ToError.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfUint8ToError) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := Uint8ToError.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfUint8ToError) Push(ctx context.Context, value uint8, returnCh chan<- *ReturnOfError) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := Uint8ToError.GetWorkContextWith(ctx, Uint8ToError.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfUint8ToError) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfUint8ToError) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfUint8ToFloat32 struct {
	handler func(context.Context, uint8) (float32, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfUint8ToFloat32
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfUint8ToFloat32(ctx context.Context, h func(context.Context, uint8) (float32, error), n int) *FuncWorkerOfUint8ToFloat32 {
	__ := &FuncWorkerOfUint8ToFloat32{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfUint8ToFloat32, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go Uint8ToFloat32.CallAsAsync(work.Context, work.WorkOfUint8ToFloat32.Value, work.WorkOfUint8ToFloat32.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				Uint8ToFloat32.PutWork(work.WorkOfUint8ToFloat32)
				Uint8ToFloat32.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfUint8ToFloat32) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := Uint8ToFloat32.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfUint8ToFloat32) Push(ctx context.Context, value uint8, returnCh chan<- *ReturnOfFloat32) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := Uint8ToFloat32.GetWorkContextWith(ctx, Uint8ToFloat32.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfUint8ToFloat32) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfUint8ToFloat32) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfUint8ToFloat64 struct {
	handler func(context.Context, uint8) (float64, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfUint8ToFloat64
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfUint8ToFloat64(ctx context.Context, h func(context.Context, uint8) (float64, error), n int) *FuncWorkerOfUint8ToFloat64 {
	__ := &FuncWorkerOfUint8ToFloat64{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfUint8ToFloat64, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go Uint8ToFloat64.CallAsAsync(work.Context, work.WorkOfUint8ToFloat64.Value, work.WorkOfUint8ToFloat64.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				Uint8ToFloat64.PutWork(work.WorkOfUint8ToFloat64)
				Uint8ToFloat64.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfUint8ToFloat64) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := Uint8ToFloat64.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfUint8ToFloat64) Push(ctx context.Context, value uint8, returnCh chan<- *ReturnOfFloat64) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := Uint8ToFloat64.GetWorkContextWith(ctx, Uint8ToFloat64.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfUint8ToFloat64) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfUint8ToFloat64) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfUint8ToInt struct {
	handler func(context.Context, uint8) (int, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfUint8ToInt
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfUint8ToInt(ctx context.Context, h func(context.Context, uint8) (int, error), n int) *FuncWorkerOfUint8ToInt {
	__ := &FuncWorkerOfUint8ToInt{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfUint8ToInt, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go Uint8ToInt.CallAsAsync(work.Context, work.WorkOfUint8ToInt.Value, work.WorkOfUint8ToInt.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				Uint8ToInt.PutWork(work.WorkOfUint8ToInt)
				Uint8ToInt.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfUint8ToInt) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := Uint8ToInt.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfUint8ToInt) Push(ctx context.Context, value uint8, returnCh chan<- *ReturnOfInt) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := Uint8ToInt.GetWorkContextWith(ctx, Uint8ToInt.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfUint8ToInt) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfUint8ToInt) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfUint8ToInt16 struct {
	handler func(context.Context, uint8) (int16, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfUint8ToInt16
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfUint8ToInt16(ctx context.Context, h func(context.Context, uint8) (int16, error), n int) *FuncWorkerOfUint8ToInt16 {
	__ := &FuncWorkerOfUint8ToInt16{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfUint8ToInt16, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go Uint8ToInt16.CallAsAsync(work.Context, work.WorkOfUint8ToInt16.Value, work.WorkOfUint8ToInt16.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				Uint8ToInt16.PutWork(work.WorkOfUint8ToInt16)
				Uint8ToInt16.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfUint8ToInt16) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := Uint8ToInt16.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfUint8ToInt16) Push(ctx context.Context, value uint8, returnCh chan<- *ReturnOfInt16) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := Uint8ToInt16.GetWorkContextWith(ctx, Uint8ToInt16.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfUint8ToInt16) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfUint8ToInt16) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfUint8ToInt32 struct {
	handler func(context.Context, uint8) (int32, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfUint8ToInt32
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfUint8ToInt32(ctx context.Context, h func(context.Context, uint8) (int32, error), n int) *FuncWorkerOfUint8ToInt32 {
	__ := &FuncWorkerOfUint8ToInt32{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfUint8ToInt32, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go Uint8ToInt32.CallAsAsync(work.Context, work.WorkOfUint8ToInt32.Value, work.WorkOfUint8ToInt32.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				Uint8ToInt32.PutWork(work.WorkOfUint8ToInt32)
				Uint8ToInt32.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfUint8ToInt32) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := Uint8ToInt32.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfUint8ToInt32) Push(ctx context.Context, value uint8, returnCh chan<- *ReturnOfInt32) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := Uint8ToInt32.GetWorkContextWith(ctx, Uint8ToInt32.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfUint8ToInt32) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfUint8ToInt32) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfUint8ToInt64 struct {
	handler func(context.Context, uint8) (int64, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfUint8ToInt64
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfUint8ToInt64(ctx context.Context, h func(context.Context, uint8) (int64, error), n int) *FuncWorkerOfUint8ToInt64 {
	__ := &FuncWorkerOfUint8ToInt64{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfUint8ToInt64, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go Uint8ToInt64.CallAsAsync(work.Context, work.WorkOfUint8ToInt64.Value, work.WorkOfUint8ToInt64.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				Uint8ToInt64.PutWork(work.WorkOfUint8ToInt64)
				Uint8ToInt64.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfUint8ToInt64) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := Uint8ToInt64.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfUint8ToInt64) Push(ctx context.Context, value uint8, returnCh chan<- *ReturnOfInt64) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := Uint8ToInt64.GetWorkContextWith(ctx, Uint8ToInt64.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfUint8ToInt64) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfUint8ToInt64) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfUint8ToInt8 struct {
	handler func(context.Context, uint8) (int8, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfUint8ToInt8
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfUint8ToInt8(ctx context.Context, h func(context.Context, uint8) (int8, error), n int) *FuncWorkerOfUint8ToInt8 {
	__ := &FuncWorkerOfUint8ToInt8{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfUint8ToInt8, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go Uint8ToInt8.CallAsAsync(work.Context, work.WorkOfUint8ToInt8.Value, work.WorkOfUint8ToInt8.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				Uint8ToInt8.PutWork(work.WorkOfUint8ToInt8)
				Uint8ToInt8.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfUint8ToInt8) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := Uint8ToInt8.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfUint8ToInt8) Push(ctx context.Context, value uint8, returnCh chan<- *ReturnOfInt8) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := Uint8ToInt8.GetWorkContextWith(ctx, Uint8ToInt8.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfUint8ToInt8) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfUint8ToInt8) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfUint8ToRune struct {
	handler func(context.Context, uint8) (rune, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfUint8ToRune
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfUint8ToRune(ctx context.Context, h func(context.Context, uint8) (rune, error), n int) *FuncWorkerOfUint8ToRune {
	__ := &FuncWorkerOfUint8ToRune{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfUint8ToRune, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go Uint8ToRune.CallAsAsync(work.Context, work.WorkOfUint8ToRune.Value, work.WorkOfUint8ToRune.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				Uint8ToRune.PutWork(work.WorkOfUint8ToRune)
				Uint8ToRune.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfUint8ToRune) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := Uint8ToRune.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfUint8ToRune) Push(ctx context.Context, value uint8, returnCh chan<- *ReturnOfRune) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := Uint8ToRune.GetWorkContextWith(ctx, Uint8ToRune.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfUint8ToRune) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfUint8ToRune) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfUint8ToString struct {
	handler func(context.Context, uint8) (string, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfUint8ToString
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfUint8ToString(ctx context.Context, h func(context.Context, uint8) (string, error), n int) *FuncWorkerOfUint8ToString {
	__ := &FuncWorkerOfUint8ToString{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfUint8ToString, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go Uint8ToString.CallAsAsync(work.Context, work.WorkOfUint8ToString.Value, work.WorkOfUint8ToString.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				Uint8ToString.PutWork(work.WorkOfUint8ToString)
				Uint8ToString.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfUint8ToString) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := Uint8ToString.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfUint8ToString) Push(ctx context.Context, value uint8, returnCh chan<- *ReturnOfString) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := Uint8ToString.GetWorkContextWith(ctx, Uint8ToString.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfUint8ToString) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfUint8ToString) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfUint8ToUint struct {
	handler func(context.Context, uint8) (uint, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfUint8ToUint
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfUint8ToUint(ctx context.Context, h func(context.Context, uint8) (uint, error), n int) *FuncWorkerOfUint8ToUint {
	__ := &FuncWorkerOfUint8ToUint{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfUint8ToUint, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go Uint8ToUint.CallAsAsync(work.Context, work.WorkOfUint8ToUint.Value, work.WorkOfUint8ToUint.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				Uint8ToUint.PutWork(work.WorkOfUint8ToUint)
				Uint8ToUint.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfUint8ToUint) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := Uint8ToUint.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfUint8ToUint) Push(ctx context.Context, value uint8, returnCh chan<- *ReturnOfUint) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := Uint8ToUint.GetWorkContextWith(ctx, Uint8ToUint.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfUint8ToUint) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfUint8ToUint) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfUint8ToUint16 struct {
	handler func(context.Context, uint8) (uint16, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfUint8ToUint16
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfUint8ToUint16(ctx context.Context, h func(context.Context, uint8) (uint16, error), n int) *FuncWorkerOfUint8ToUint16 {
	__ := &FuncWorkerOfUint8ToUint16{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfUint8ToUint16, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go Uint8ToUint16.CallAsAsync(work.Context, work.WorkOfUint8ToUint16.Value, work.WorkOfUint8ToUint16.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				Uint8ToUint16.PutWork(work.WorkOfUint8ToUint16)
				Uint8ToUint16.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfUint8ToUint16) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := Uint8ToUint16.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfUint8ToUint16) Push(ctx context.Context, value uint8, returnCh chan<- *ReturnOfUint16) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := Uint8ToUint16.GetWorkContextWith(ctx, Uint8ToUint16.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfUint8ToUint16) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfUint8ToUint16) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfUint8ToUint32 struct {
	handler func(context.Context, uint8) (uint32, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfUint8ToUint32
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfUint8ToUint32(ctx context.Context, h func(context.Context, uint8) (uint32, error), n int) *FuncWorkerOfUint8ToUint32 {
	__ := &FuncWorkerOfUint8ToUint32{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfUint8ToUint32, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go Uint8ToUint32.CallAsAsync(work.Context, work.WorkOfUint8ToUint32.Value, work.WorkOfUint8ToUint32.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				Uint8ToUint32.PutWork(work.WorkOfUint8ToUint32)
				Uint8ToUint32.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfUint8ToUint32) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := Uint8ToUint32.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfUint8ToUint32) Push(ctx context.Context, value uint8, returnCh chan<- *ReturnOfUint32) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := Uint8ToUint32.GetWorkContextWith(ctx, Uint8ToUint32.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfUint8ToUint32) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfUint8ToUint32) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfUint8ToUint64 struct {
	handler func(context.Context, uint8) (uint64, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfUint8ToUint64
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfUint8ToUint64(ctx context.Context, h func(context.Context, uint8) (uint64, error), n int) *FuncWorkerOfUint8ToUint64 {
	__ := &FuncWorkerOfUint8ToUint64{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfUint8ToUint64, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go Uint8ToUint64.CallAsAsync(work.Context, work.WorkOfUint8ToUint64.Value, work.WorkOfUint8ToUint64.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				Uint8ToUint64.PutWork(work.WorkOfUint8ToUint64)
				Uint8ToUint64.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfUint8ToUint64) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := Uint8ToUint64.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfUint8ToUint64) Push(ctx context.Context, value uint8, returnCh chan<- *ReturnOfUint64) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := Uint8ToUint64.GetWorkContextWith(ctx, Uint8ToUint64.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfUint8ToUint64) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfUint8ToUint64) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfUint8ToUint8 struct {
	handler func(context.Context, uint8) (uint8, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfUint8ToUint8
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfUint8ToUint8(ctx context.Context, h func(context.Context, uint8) (uint8, error), n int) *FuncWorkerOfUint8ToUint8 {
	__ := &FuncWorkerOfUint8ToUint8{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfUint8ToUint8, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go Uint8ToUint8.CallAsAsync(work.Context, work.WorkOfUint8ToUint8.Value, work.WorkOfUint8ToUint8.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				Uint8ToUint8.PutWork(work.WorkOfUint8ToUint8)
				Uint8ToUint8.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfUint8ToUint8) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := Uint8ToUint8.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfUint8ToUint8) Push(ctx context.Context, value uint8, returnCh chan<- *ReturnOfUint8) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := Uint8ToUint8.GetWorkContextWith(ctx, Uint8ToUint8.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfUint8ToUint8) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfUint8ToUint8) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfUint8ToUintptr struct {
	handler func(context.Context, uint8) (uintptr, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfUint8ToUintptr
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfUint8ToUintptr(ctx context.Context, h func(context.Context, uint8) (uintptr, error), n int) *FuncWorkerOfUint8ToUintptr {
	__ := &FuncWorkerOfUint8ToUintptr{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfUint8ToUintptr, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go Uint8ToUintptr.CallAsAsync(work.Context, work.WorkOfUint8ToUintptr.Value, work.WorkOfUint8ToUintptr.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				Uint8ToUintptr.PutWork(work.WorkOfUint8ToUintptr)
				Uint8ToUintptr.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfUint8ToUintptr) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := Uint8ToUintptr.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfUint8ToUintptr) Push(ctx context.Context, value uint8, returnCh chan<- *ReturnOfUintptr) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := Uint8ToUintptr.GetWorkContextWith(ctx, Uint8ToUintptr.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfUint8ToUintptr) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfUint8ToUintptr) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfUint8ToBytes struct {
	handler func(context.Context, uint8) (Bytes, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfUint8ToBytes
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfUint8ToBytes(ctx context.Context, h func(context.Context, uint8) (Bytes, error), n int) *FuncWorkerOfUint8ToBytes {
	__ := &FuncWorkerOfUint8ToBytes{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfUint8ToBytes, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go Uint8ToBytes.CallAsAsync(work.Context, work.WorkOfUint8ToBytes.Value, work.WorkOfUint8ToBytes.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				Uint8ToBytes.PutWork(work.WorkOfUint8ToBytes)
				Uint8ToBytes.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfUint8ToBytes) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := Uint8ToBytes.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfUint8ToBytes) Push(ctx context.Context, value uint8, returnCh chan<- *ReturnOfBytes) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := Uint8ToBytes.GetWorkContextWith(ctx, Uint8ToBytes.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfUint8ToBytes) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfUint8ToBytes) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfUint8ToInterface struct {
	handler func(context.Context, uint8) (interface{}, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfUint8ToInterface
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfUint8ToInterface(ctx context.Context, h func(context.Context, uint8) (interface{}, error), n int) *FuncWorkerOfUint8ToInterface {
	__ := &FuncWorkerOfUint8ToInterface{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfUint8ToInterface, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go Uint8ToInterface.CallAsAsync(work.Context, work.WorkOfUint8ToInterface.Value, work.WorkOfUint8ToInterface.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				Uint8ToInterface.PutWork(work.WorkOfUint8ToInterface)
				Uint8ToInterface.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfUint8ToInterface) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := Uint8ToInterface.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfUint8ToInterface) Push(ctx context.Context, value uint8, returnCh chan<- *ReturnOfInterface) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := Uint8ToInterface.GetWorkContextWith(ctx, Uint8ToInterface.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfUint8ToInterface) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfUint8ToInterface) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfUintptrToBool struct {
	handler func(context.Context, uintptr) (bool, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfUintptrToBool
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfUintptrToBool(ctx context.Context, h func(context.Context, uintptr) (bool, error), n int) *FuncWorkerOfUintptrToBool {
	__ := &FuncWorkerOfUintptrToBool{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfUintptrToBool, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go UintptrToBool.CallAsAsync(work.Context, work.WorkOfUintptrToBool.Value, work.WorkOfUintptrToBool.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				UintptrToBool.PutWork(work.WorkOfUintptrToBool)
				UintptrToBool.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfUintptrToBool) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := UintptrToBool.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfUintptrToBool) Push(ctx context.Context, value uintptr, returnCh chan<- *ReturnOfBool) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := UintptrToBool.GetWorkContextWith(ctx, UintptrToBool.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfUintptrToBool) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfUintptrToBool) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfUintptrToByte struct {
	handler func(context.Context, uintptr) (byte, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfUintptrToByte
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfUintptrToByte(ctx context.Context, h func(context.Context, uintptr) (byte, error), n int) *FuncWorkerOfUintptrToByte {
	__ := &FuncWorkerOfUintptrToByte{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfUintptrToByte, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go UintptrToByte.CallAsAsync(work.Context, work.WorkOfUintptrToByte.Value, work.WorkOfUintptrToByte.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				UintptrToByte.PutWork(work.WorkOfUintptrToByte)
				UintptrToByte.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfUintptrToByte) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := UintptrToByte.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfUintptrToByte) Push(ctx context.Context, value uintptr, returnCh chan<- *ReturnOfByte) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := UintptrToByte.GetWorkContextWith(ctx, UintptrToByte.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfUintptrToByte) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfUintptrToByte) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfUintptrToComplex128 struct {
	handler func(context.Context, uintptr) (complex128, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfUintptrToComplex128
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfUintptrToComplex128(ctx context.Context, h func(context.Context, uintptr) (complex128, error), n int) *FuncWorkerOfUintptrToComplex128 {
	__ := &FuncWorkerOfUintptrToComplex128{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfUintptrToComplex128, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go UintptrToComplex128.CallAsAsync(work.Context, work.WorkOfUintptrToComplex128.Value, work.WorkOfUintptrToComplex128.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				UintptrToComplex128.PutWork(work.WorkOfUintptrToComplex128)
				UintptrToComplex128.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfUintptrToComplex128) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := UintptrToComplex128.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfUintptrToComplex128) Push(ctx context.Context, value uintptr, returnCh chan<- *ReturnOfComplex128) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := UintptrToComplex128.GetWorkContextWith(ctx, UintptrToComplex128.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfUintptrToComplex128) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfUintptrToComplex128) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfUintptrToComplex64 struct {
	handler func(context.Context, uintptr) (complex64, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfUintptrToComplex64
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfUintptrToComplex64(ctx context.Context, h func(context.Context, uintptr) (complex64, error), n int) *FuncWorkerOfUintptrToComplex64 {
	__ := &FuncWorkerOfUintptrToComplex64{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfUintptrToComplex64, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go UintptrToComplex64.CallAsAsync(work.Context, work.WorkOfUintptrToComplex64.Value, work.WorkOfUintptrToComplex64.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				UintptrToComplex64.PutWork(work.WorkOfUintptrToComplex64)
				UintptrToComplex64.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfUintptrToComplex64) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := UintptrToComplex64.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfUintptrToComplex64) Push(ctx context.Context, value uintptr, returnCh chan<- *ReturnOfComplex64) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := UintptrToComplex64.GetWorkContextWith(ctx, UintptrToComplex64.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfUintptrToComplex64) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfUintptrToComplex64) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfUintptrToError struct {
	handler func(context.Context, uintptr) (error, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfUintptrToError
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfUintptrToError(ctx context.Context, h func(context.Context, uintptr) (error, error), n int) *FuncWorkerOfUintptrToError {
	__ := &FuncWorkerOfUintptrToError{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfUintptrToError, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go UintptrToError.CallAsAsync(work.Context, work.WorkOfUintptrToError.Value, work.WorkOfUintptrToError.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				UintptrToError.PutWork(work.WorkOfUintptrToError)
				UintptrToError.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfUintptrToError) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := UintptrToError.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfUintptrToError) Push(ctx context.Context, value uintptr, returnCh chan<- *ReturnOfError) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := UintptrToError.GetWorkContextWith(ctx, UintptrToError.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfUintptrToError) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfUintptrToError) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfUintptrToFloat32 struct {
	handler func(context.Context, uintptr) (float32, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfUintptrToFloat32
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfUintptrToFloat32(ctx context.Context, h func(context.Context, uintptr) (float32, error), n int) *FuncWorkerOfUintptrToFloat32 {
	__ := &FuncWorkerOfUintptrToFloat32{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfUintptrToFloat32, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go UintptrToFloat32.CallAsAsync(work.Context, work.WorkOfUintptrToFloat32.Value, work.WorkOfUintptrToFloat32.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				UintptrToFloat32.PutWork(work.WorkOfUintptrToFloat32)
				UintptrToFloat32.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfUintptrToFloat32) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := UintptrToFloat32.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfUintptrToFloat32) Push(ctx context.Context, value uintptr, returnCh chan<- *ReturnOfFloat32) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := UintptrToFloat32.GetWorkContextWith(ctx, UintptrToFloat32.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfUintptrToFloat32) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfUintptrToFloat32) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfUintptrToFloat64 struct {
	handler func(context.Context, uintptr) (float64, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfUintptrToFloat64
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfUintptrToFloat64(ctx context.Context, h func(context.Context, uintptr) (float64, error), n int) *FuncWorkerOfUintptrToFloat64 {
	__ := &FuncWorkerOfUintptrToFloat64{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfUintptrToFloat64, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go UintptrToFloat64.CallAsAsync(work.Context, work.WorkOfUintptrToFloat64.Value, work.WorkOfUintptrToFloat64.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				UintptrToFloat64.PutWork(work.WorkOfUintptrToFloat64)
				UintptrToFloat64.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfUintptrToFloat64) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := UintptrToFloat64.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfUintptrToFloat64) Push(ctx context.Context, value uintptr, returnCh chan<- *ReturnOfFloat64) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := UintptrToFloat64.GetWorkContextWith(ctx, UintptrToFloat64.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfUintptrToFloat64) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfUintptrToFloat64) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfUintptrToInt struct {
	handler func(context.Context, uintptr) (int, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfUintptrToInt
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfUintptrToInt(ctx context.Context, h func(context.Context, uintptr) (int, error), n int) *FuncWorkerOfUintptrToInt {
	__ := &FuncWorkerOfUintptrToInt{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfUintptrToInt, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go UintptrToInt.CallAsAsync(work.Context, work.WorkOfUintptrToInt.Value, work.WorkOfUintptrToInt.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				UintptrToInt.PutWork(work.WorkOfUintptrToInt)
				UintptrToInt.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfUintptrToInt) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := UintptrToInt.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfUintptrToInt) Push(ctx context.Context, value uintptr, returnCh chan<- *ReturnOfInt) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := UintptrToInt.GetWorkContextWith(ctx, UintptrToInt.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfUintptrToInt) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfUintptrToInt) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfUintptrToInt16 struct {
	handler func(context.Context, uintptr) (int16, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfUintptrToInt16
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfUintptrToInt16(ctx context.Context, h func(context.Context, uintptr) (int16, error), n int) *FuncWorkerOfUintptrToInt16 {
	__ := &FuncWorkerOfUintptrToInt16{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfUintptrToInt16, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go UintptrToInt16.CallAsAsync(work.Context, work.WorkOfUintptrToInt16.Value, work.WorkOfUintptrToInt16.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				UintptrToInt16.PutWork(work.WorkOfUintptrToInt16)
				UintptrToInt16.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfUintptrToInt16) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := UintptrToInt16.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfUintptrToInt16) Push(ctx context.Context, value uintptr, returnCh chan<- *ReturnOfInt16) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := UintptrToInt16.GetWorkContextWith(ctx, UintptrToInt16.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfUintptrToInt16) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfUintptrToInt16) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfUintptrToInt32 struct {
	handler func(context.Context, uintptr) (int32, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfUintptrToInt32
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfUintptrToInt32(ctx context.Context, h func(context.Context, uintptr) (int32, error), n int) *FuncWorkerOfUintptrToInt32 {
	__ := &FuncWorkerOfUintptrToInt32{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfUintptrToInt32, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go UintptrToInt32.CallAsAsync(work.Context, work.WorkOfUintptrToInt32.Value, work.WorkOfUintptrToInt32.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				UintptrToInt32.PutWork(work.WorkOfUintptrToInt32)
				UintptrToInt32.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfUintptrToInt32) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := UintptrToInt32.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfUintptrToInt32) Push(ctx context.Context, value uintptr, returnCh chan<- *ReturnOfInt32) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := UintptrToInt32.GetWorkContextWith(ctx, UintptrToInt32.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfUintptrToInt32) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfUintptrToInt32) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfUintptrToInt64 struct {
	handler func(context.Context, uintptr) (int64, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfUintptrToInt64
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfUintptrToInt64(ctx context.Context, h func(context.Context, uintptr) (int64, error), n int) *FuncWorkerOfUintptrToInt64 {
	__ := &FuncWorkerOfUintptrToInt64{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfUintptrToInt64, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go UintptrToInt64.CallAsAsync(work.Context, work.WorkOfUintptrToInt64.Value, work.WorkOfUintptrToInt64.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				UintptrToInt64.PutWork(work.WorkOfUintptrToInt64)
				UintptrToInt64.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfUintptrToInt64) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := UintptrToInt64.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfUintptrToInt64) Push(ctx context.Context, value uintptr, returnCh chan<- *ReturnOfInt64) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := UintptrToInt64.GetWorkContextWith(ctx, UintptrToInt64.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfUintptrToInt64) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfUintptrToInt64) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfUintptrToInt8 struct {
	handler func(context.Context, uintptr) (int8, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfUintptrToInt8
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfUintptrToInt8(ctx context.Context, h func(context.Context, uintptr) (int8, error), n int) *FuncWorkerOfUintptrToInt8 {
	__ := &FuncWorkerOfUintptrToInt8{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfUintptrToInt8, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go UintptrToInt8.CallAsAsync(work.Context, work.WorkOfUintptrToInt8.Value, work.WorkOfUintptrToInt8.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				UintptrToInt8.PutWork(work.WorkOfUintptrToInt8)
				UintptrToInt8.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfUintptrToInt8) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := UintptrToInt8.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfUintptrToInt8) Push(ctx context.Context, value uintptr, returnCh chan<- *ReturnOfInt8) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := UintptrToInt8.GetWorkContextWith(ctx, UintptrToInt8.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfUintptrToInt8) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfUintptrToInt8) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfUintptrToRune struct {
	handler func(context.Context, uintptr) (rune, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfUintptrToRune
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfUintptrToRune(ctx context.Context, h func(context.Context, uintptr) (rune, error), n int) *FuncWorkerOfUintptrToRune {
	__ := &FuncWorkerOfUintptrToRune{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfUintptrToRune, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go UintptrToRune.CallAsAsync(work.Context, work.WorkOfUintptrToRune.Value, work.WorkOfUintptrToRune.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				UintptrToRune.PutWork(work.WorkOfUintptrToRune)
				UintptrToRune.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfUintptrToRune) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := UintptrToRune.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfUintptrToRune) Push(ctx context.Context, value uintptr, returnCh chan<- *ReturnOfRune) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := UintptrToRune.GetWorkContextWith(ctx, UintptrToRune.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfUintptrToRune) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfUintptrToRune) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfUintptrToString struct {
	handler func(context.Context, uintptr) (string, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfUintptrToString
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfUintptrToString(ctx context.Context, h func(context.Context, uintptr) (string, error), n int) *FuncWorkerOfUintptrToString {
	__ := &FuncWorkerOfUintptrToString{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfUintptrToString, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go UintptrToString.CallAsAsync(work.Context, work.WorkOfUintptrToString.Value, work.WorkOfUintptrToString.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				UintptrToString.PutWork(work.WorkOfUintptrToString)
				UintptrToString.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfUintptrToString) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := UintptrToString.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfUintptrToString) Push(ctx context.Context, value uintptr, returnCh chan<- *ReturnOfString) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := UintptrToString.GetWorkContextWith(ctx, UintptrToString.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfUintptrToString) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfUintptrToString) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfUintptrToUint struct {
	handler func(context.Context, uintptr) (uint, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfUintptrToUint
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfUintptrToUint(ctx context.Context, h func(context.Context, uintptr) (uint, error), n int) *FuncWorkerOfUintptrToUint {
	__ := &FuncWorkerOfUintptrToUint{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfUintptrToUint, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go UintptrToUint.CallAsAsync(work.Context, work.WorkOfUintptrToUint.Value, work.WorkOfUintptrToUint.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				UintptrToUint.PutWork(work.WorkOfUintptrToUint)
				UintptrToUint.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfUintptrToUint) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := UintptrToUint.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfUintptrToUint) Push(ctx context.Context, value uintptr, returnCh chan<- *ReturnOfUint) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := UintptrToUint.GetWorkContextWith(ctx, UintptrToUint.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfUintptrToUint) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfUintptrToUint) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfUintptrToUint16 struct {
	handler func(context.Context, uintptr) (uint16, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfUintptrToUint16
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfUintptrToUint16(ctx context.Context, h func(context.Context, uintptr) (uint16, error), n int) *FuncWorkerOfUintptrToUint16 {
	__ := &FuncWorkerOfUintptrToUint16{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfUintptrToUint16, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go UintptrToUint16.CallAsAsync(work.Context, work.WorkOfUintptrToUint16.Value, work.WorkOfUintptrToUint16.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				UintptrToUint16.PutWork(work.WorkOfUintptrToUint16)
				UintptrToUint16.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfUintptrToUint16) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := UintptrToUint16.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfUintptrToUint16) Push(ctx context.Context, value uintptr, returnCh chan<- *ReturnOfUint16) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := UintptrToUint16.GetWorkContextWith(ctx, UintptrToUint16.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfUintptrToUint16) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfUintptrToUint16) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfUintptrToUint32 struct {
	handler func(context.Context, uintptr) (uint32, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfUintptrToUint32
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfUintptrToUint32(ctx context.Context, h func(context.Context, uintptr) (uint32, error), n int) *FuncWorkerOfUintptrToUint32 {
	__ := &FuncWorkerOfUintptrToUint32{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfUintptrToUint32, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go UintptrToUint32.CallAsAsync(work.Context, work.WorkOfUintptrToUint32.Value, work.WorkOfUintptrToUint32.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				UintptrToUint32.PutWork(work.WorkOfUintptrToUint32)
				UintptrToUint32.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfUintptrToUint32) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := UintptrToUint32.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfUintptrToUint32) Push(ctx context.Context, value uintptr, returnCh chan<- *ReturnOfUint32) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := UintptrToUint32.GetWorkContextWith(ctx, UintptrToUint32.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfUintptrToUint32) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfUintptrToUint32) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfUintptrToUint64 struct {
	handler func(context.Context, uintptr) (uint64, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfUintptrToUint64
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfUintptrToUint64(ctx context.Context, h func(context.Context, uintptr) (uint64, error), n int) *FuncWorkerOfUintptrToUint64 {
	__ := &FuncWorkerOfUintptrToUint64{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfUintptrToUint64, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go UintptrToUint64.CallAsAsync(work.Context, work.WorkOfUintptrToUint64.Value, work.WorkOfUintptrToUint64.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				UintptrToUint64.PutWork(work.WorkOfUintptrToUint64)
				UintptrToUint64.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfUintptrToUint64) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := UintptrToUint64.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfUintptrToUint64) Push(ctx context.Context, value uintptr, returnCh chan<- *ReturnOfUint64) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := UintptrToUint64.GetWorkContextWith(ctx, UintptrToUint64.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfUintptrToUint64) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfUintptrToUint64) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfUintptrToUint8 struct {
	handler func(context.Context, uintptr) (uint8, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfUintptrToUint8
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfUintptrToUint8(ctx context.Context, h func(context.Context, uintptr) (uint8, error), n int) *FuncWorkerOfUintptrToUint8 {
	__ := &FuncWorkerOfUintptrToUint8{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfUintptrToUint8, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go UintptrToUint8.CallAsAsync(work.Context, work.WorkOfUintptrToUint8.Value, work.WorkOfUintptrToUint8.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				UintptrToUint8.PutWork(work.WorkOfUintptrToUint8)
				UintptrToUint8.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfUintptrToUint8) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := UintptrToUint8.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfUintptrToUint8) Push(ctx context.Context, value uintptr, returnCh chan<- *ReturnOfUint8) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := UintptrToUint8.GetWorkContextWith(ctx, UintptrToUint8.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfUintptrToUint8) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfUintptrToUint8) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfUintptrToUintptr struct {
	handler func(context.Context, uintptr) (uintptr, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfUintptrToUintptr
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfUintptrToUintptr(ctx context.Context, h func(context.Context, uintptr) (uintptr, error), n int) *FuncWorkerOfUintptrToUintptr {
	__ := &FuncWorkerOfUintptrToUintptr{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfUintptrToUintptr, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go UintptrToUintptr.CallAsAsync(work.Context, work.WorkOfUintptrToUintptr.Value, work.WorkOfUintptrToUintptr.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				UintptrToUintptr.PutWork(work.WorkOfUintptrToUintptr)
				UintptrToUintptr.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfUintptrToUintptr) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := UintptrToUintptr.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfUintptrToUintptr) Push(ctx context.Context, value uintptr, returnCh chan<- *ReturnOfUintptr) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := UintptrToUintptr.GetWorkContextWith(ctx, UintptrToUintptr.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfUintptrToUintptr) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfUintptrToUintptr) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfUintptrToBytes struct {
	handler func(context.Context, uintptr) (Bytes, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfUintptrToBytes
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfUintptrToBytes(ctx context.Context, h func(context.Context, uintptr) (Bytes, error), n int) *FuncWorkerOfUintptrToBytes {
	__ := &FuncWorkerOfUintptrToBytes{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfUintptrToBytes, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go UintptrToBytes.CallAsAsync(work.Context, work.WorkOfUintptrToBytes.Value, work.WorkOfUintptrToBytes.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				UintptrToBytes.PutWork(work.WorkOfUintptrToBytes)
				UintptrToBytes.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfUintptrToBytes) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := UintptrToBytes.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfUintptrToBytes) Push(ctx context.Context, value uintptr, returnCh chan<- *ReturnOfBytes) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := UintptrToBytes.GetWorkContextWith(ctx, UintptrToBytes.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfUintptrToBytes) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfUintptrToBytes) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfUintptrToInterface struct {
	handler func(context.Context, uintptr) (interface{}, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfUintptrToInterface
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfUintptrToInterface(ctx context.Context, h func(context.Context, uintptr) (interface{}, error), n int) *FuncWorkerOfUintptrToInterface {
	__ := &FuncWorkerOfUintptrToInterface{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfUintptrToInterface, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go UintptrToInterface.CallAsAsync(work.Context, work.WorkOfUintptrToInterface.Value, work.WorkOfUintptrToInterface.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				UintptrToInterface.PutWork(work.WorkOfUintptrToInterface)
				UintptrToInterface.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfUintptrToInterface) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := UintptrToInterface.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfUintptrToInterface) Push(ctx context.Context, value uintptr, returnCh chan<- *ReturnOfInterface) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := UintptrToInterface.GetWorkContextWith(ctx, UintptrToInterface.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfUintptrToInterface) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfUintptrToInterface) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfBytesToBool struct {
	handler func(context.Context, Bytes) (bool, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfBytesToBool
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfBytesToBool(ctx context.Context, h func(context.Context, Bytes) (bool, error), n int) *FuncWorkerOfBytesToBool {
	__ := &FuncWorkerOfBytesToBool{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfBytesToBool, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go BytesToBool.CallAsAsync(work.Context, work.WorkOfBytesToBool.Value, work.WorkOfBytesToBool.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				BytesToBool.PutWork(work.WorkOfBytesToBool)
				BytesToBool.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfBytesToBool) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := BytesToBool.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfBytesToBool) Push(ctx context.Context, value Bytes, returnCh chan<- *ReturnOfBool) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := BytesToBool.GetWorkContextWith(ctx, BytesToBool.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfBytesToBool) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfBytesToBool) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfBytesToByte struct {
	handler func(context.Context, Bytes) (byte, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfBytesToByte
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfBytesToByte(ctx context.Context, h func(context.Context, Bytes) (byte, error), n int) *FuncWorkerOfBytesToByte {
	__ := &FuncWorkerOfBytesToByte{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfBytesToByte, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go BytesToByte.CallAsAsync(work.Context, work.WorkOfBytesToByte.Value, work.WorkOfBytesToByte.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				BytesToByte.PutWork(work.WorkOfBytesToByte)
				BytesToByte.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfBytesToByte) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := BytesToByte.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfBytesToByte) Push(ctx context.Context, value Bytes, returnCh chan<- *ReturnOfByte) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := BytesToByte.GetWorkContextWith(ctx, BytesToByte.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfBytesToByte) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfBytesToByte) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfBytesToComplex128 struct {
	handler func(context.Context, Bytes) (complex128, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfBytesToComplex128
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfBytesToComplex128(ctx context.Context, h func(context.Context, Bytes) (complex128, error), n int) *FuncWorkerOfBytesToComplex128 {
	__ := &FuncWorkerOfBytesToComplex128{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfBytesToComplex128, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go BytesToComplex128.CallAsAsync(work.Context, work.WorkOfBytesToComplex128.Value, work.WorkOfBytesToComplex128.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				BytesToComplex128.PutWork(work.WorkOfBytesToComplex128)
				BytesToComplex128.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfBytesToComplex128) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := BytesToComplex128.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfBytesToComplex128) Push(ctx context.Context, value Bytes, returnCh chan<- *ReturnOfComplex128) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := BytesToComplex128.GetWorkContextWith(ctx, BytesToComplex128.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfBytesToComplex128) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfBytesToComplex128) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfBytesToComplex64 struct {
	handler func(context.Context, Bytes) (complex64, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfBytesToComplex64
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfBytesToComplex64(ctx context.Context, h func(context.Context, Bytes) (complex64, error), n int) *FuncWorkerOfBytesToComplex64 {
	__ := &FuncWorkerOfBytesToComplex64{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfBytesToComplex64, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go BytesToComplex64.CallAsAsync(work.Context, work.WorkOfBytesToComplex64.Value, work.WorkOfBytesToComplex64.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				BytesToComplex64.PutWork(work.WorkOfBytesToComplex64)
				BytesToComplex64.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfBytesToComplex64) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := BytesToComplex64.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfBytesToComplex64) Push(ctx context.Context, value Bytes, returnCh chan<- *ReturnOfComplex64) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := BytesToComplex64.GetWorkContextWith(ctx, BytesToComplex64.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfBytesToComplex64) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfBytesToComplex64) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfBytesToError struct {
	handler func(context.Context, Bytes) (error, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfBytesToError
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfBytesToError(ctx context.Context, h func(context.Context, Bytes) (error, error), n int) *FuncWorkerOfBytesToError {
	__ := &FuncWorkerOfBytesToError{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfBytesToError, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go BytesToError.CallAsAsync(work.Context, work.WorkOfBytesToError.Value, work.WorkOfBytesToError.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				BytesToError.PutWork(work.WorkOfBytesToError)
				BytesToError.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfBytesToError) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := BytesToError.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfBytesToError) Push(ctx context.Context, value Bytes, returnCh chan<- *ReturnOfError) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := BytesToError.GetWorkContextWith(ctx, BytesToError.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfBytesToError) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfBytesToError) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfBytesToFloat32 struct {
	handler func(context.Context, Bytes) (float32, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfBytesToFloat32
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfBytesToFloat32(ctx context.Context, h func(context.Context, Bytes) (float32, error), n int) *FuncWorkerOfBytesToFloat32 {
	__ := &FuncWorkerOfBytesToFloat32{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfBytesToFloat32, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go BytesToFloat32.CallAsAsync(work.Context, work.WorkOfBytesToFloat32.Value, work.WorkOfBytesToFloat32.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				BytesToFloat32.PutWork(work.WorkOfBytesToFloat32)
				BytesToFloat32.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfBytesToFloat32) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := BytesToFloat32.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfBytesToFloat32) Push(ctx context.Context, value Bytes, returnCh chan<- *ReturnOfFloat32) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := BytesToFloat32.GetWorkContextWith(ctx, BytesToFloat32.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfBytesToFloat32) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfBytesToFloat32) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfBytesToFloat64 struct {
	handler func(context.Context, Bytes) (float64, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfBytesToFloat64
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfBytesToFloat64(ctx context.Context, h func(context.Context, Bytes) (float64, error), n int) *FuncWorkerOfBytesToFloat64 {
	__ := &FuncWorkerOfBytesToFloat64{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfBytesToFloat64, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go BytesToFloat64.CallAsAsync(work.Context, work.WorkOfBytesToFloat64.Value, work.WorkOfBytesToFloat64.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				BytesToFloat64.PutWork(work.WorkOfBytesToFloat64)
				BytesToFloat64.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfBytesToFloat64) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := BytesToFloat64.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfBytesToFloat64) Push(ctx context.Context, value Bytes, returnCh chan<- *ReturnOfFloat64) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := BytesToFloat64.GetWorkContextWith(ctx, BytesToFloat64.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfBytesToFloat64) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfBytesToFloat64) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfBytesToInt struct {
	handler func(context.Context, Bytes) (int, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfBytesToInt
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfBytesToInt(ctx context.Context, h func(context.Context, Bytes) (int, error), n int) *FuncWorkerOfBytesToInt {
	__ := &FuncWorkerOfBytesToInt{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfBytesToInt, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go BytesToInt.CallAsAsync(work.Context, work.WorkOfBytesToInt.Value, work.WorkOfBytesToInt.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				BytesToInt.PutWork(work.WorkOfBytesToInt)
				BytesToInt.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfBytesToInt) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := BytesToInt.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfBytesToInt) Push(ctx context.Context, value Bytes, returnCh chan<- *ReturnOfInt) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := BytesToInt.GetWorkContextWith(ctx, BytesToInt.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfBytesToInt) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfBytesToInt) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfBytesToInt16 struct {
	handler func(context.Context, Bytes) (int16, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfBytesToInt16
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfBytesToInt16(ctx context.Context, h func(context.Context, Bytes) (int16, error), n int) *FuncWorkerOfBytesToInt16 {
	__ := &FuncWorkerOfBytesToInt16{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfBytesToInt16, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go BytesToInt16.CallAsAsync(work.Context, work.WorkOfBytesToInt16.Value, work.WorkOfBytesToInt16.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				BytesToInt16.PutWork(work.WorkOfBytesToInt16)
				BytesToInt16.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfBytesToInt16) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := BytesToInt16.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfBytesToInt16) Push(ctx context.Context, value Bytes, returnCh chan<- *ReturnOfInt16) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := BytesToInt16.GetWorkContextWith(ctx, BytesToInt16.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfBytesToInt16) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfBytesToInt16) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfBytesToInt32 struct {
	handler func(context.Context, Bytes) (int32, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfBytesToInt32
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfBytesToInt32(ctx context.Context, h func(context.Context, Bytes) (int32, error), n int) *FuncWorkerOfBytesToInt32 {
	__ := &FuncWorkerOfBytesToInt32{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfBytesToInt32, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go BytesToInt32.CallAsAsync(work.Context, work.WorkOfBytesToInt32.Value, work.WorkOfBytesToInt32.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				BytesToInt32.PutWork(work.WorkOfBytesToInt32)
				BytesToInt32.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfBytesToInt32) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := BytesToInt32.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfBytesToInt32) Push(ctx context.Context, value Bytes, returnCh chan<- *ReturnOfInt32) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := BytesToInt32.GetWorkContextWith(ctx, BytesToInt32.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfBytesToInt32) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfBytesToInt32) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfBytesToInt64 struct {
	handler func(context.Context, Bytes) (int64, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfBytesToInt64
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfBytesToInt64(ctx context.Context, h func(context.Context, Bytes) (int64, error), n int) *FuncWorkerOfBytesToInt64 {
	__ := &FuncWorkerOfBytesToInt64{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfBytesToInt64, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go BytesToInt64.CallAsAsync(work.Context, work.WorkOfBytesToInt64.Value, work.WorkOfBytesToInt64.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				BytesToInt64.PutWork(work.WorkOfBytesToInt64)
				BytesToInt64.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfBytesToInt64) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := BytesToInt64.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfBytesToInt64) Push(ctx context.Context, value Bytes, returnCh chan<- *ReturnOfInt64) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := BytesToInt64.GetWorkContextWith(ctx, BytesToInt64.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfBytesToInt64) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfBytesToInt64) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfBytesToInt8 struct {
	handler func(context.Context, Bytes) (int8, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfBytesToInt8
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfBytesToInt8(ctx context.Context, h func(context.Context, Bytes) (int8, error), n int) *FuncWorkerOfBytesToInt8 {
	__ := &FuncWorkerOfBytesToInt8{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfBytesToInt8, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go BytesToInt8.CallAsAsync(work.Context, work.WorkOfBytesToInt8.Value, work.WorkOfBytesToInt8.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				BytesToInt8.PutWork(work.WorkOfBytesToInt8)
				BytesToInt8.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfBytesToInt8) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := BytesToInt8.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfBytesToInt8) Push(ctx context.Context, value Bytes, returnCh chan<- *ReturnOfInt8) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := BytesToInt8.GetWorkContextWith(ctx, BytesToInt8.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfBytesToInt8) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfBytesToInt8) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfBytesToRune struct {
	handler func(context.Context, Bytes) (rune, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfBytesToRune
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfBytesToRune(ctx context.Context, h func(context.Context, Bytes) (rune, error), n int) *FuncWorkerOfBytesToRune {
	__ := &FuncWorkerOfBytesToRune{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfBytesToRune, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go BytesToRune.CallAsAsync(work.Context, work.WorkOfBytesToRune.Value, work.WorkOfBytesToRune.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				BytesToRune.PutWork(work.WorkOfBytesToRune)
				BytesToRune.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfBytesToRune) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := BytesToRune.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfBytesToRune) Push(ctx context.Context, value Bytes, returnCh chan<- *ReturnOfRune) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := BytesToRune.GetWorkContextWith(ctx, BytesToRune.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfBytesToRune) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfBytesToRune) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfBytesToString struct {
	handler func(context.Context, Bytes) (string, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfBytesToString
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfBytesToString(ctx context.Context, h func(context.Context, Bytes) (string, error), n int) *FuncWorkerOfBytesToString {
	__ := &FuncWorkerOfBytesToString{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfBytesToString, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go BytesToString.CallAsAsync(work.Context, work.WorkOfBytesToString.Value, work.WorkOfBytesToString.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				BytesToString.PutWork(work.WorkOfBytesToString)
				BytesToString.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfBytesToString) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := BytesToString.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfBytesToString) Push(ctx context.Context, value Bytes, returnCh chan<- *ReturnOfString) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := BytesToString.GetWorkContextWith(ctx, BytesToString.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfBytesToString) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfBytesToString) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfBytesToUint struct {
	handler func(context.Context, Bytes) (uint, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfBytesToUint
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfBytesToUint(ctx context.Context, h func(context.Context, Bytes) (uint, error), n int) *FuncWorkerOfBytesToUint {
	__ := &FuncWorkerOfBytesToUint{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfBytesToUint, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go BytesToUint.CallAsAsync(work.Context, work.WorkOfBytesToUint.Value, work.WorkOfBytesToUint.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				BytesToUint.PutWork(work.WorkOfBytesToUint)
				BytesToUint.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfBytesToUint) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := BytesToUint.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfBytesToUint) Push(ctx context.Context, value Bytes, returnCh chan<- *ReturnOfUint) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := BytesToUint.GetWorkContextWith(ctx, BytesToUint.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfBytesToUint) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfBytesToUint) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfBytesToUint16 struct {
	handler func(context.Context, Bytes) (uint16, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfBytesToUint16
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfBytesToUint16(ctx context.Context, h func(context.Context, Bytes) (uint16, error), n int) *FuncWorkerOfBytesToUint16 {
	__ := &FuncWorkerOfBytesToUint16{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfBytesToUint16, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go BytesToUint16.CallAsAsync(work.Context, work.WorkOfBytesToUint16.Value, work.WorkOfBytesToUint16.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				BytesToUint16.PutWork(work.WorkOfBytesToUint16)
				BytesToUint16.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfBytesToUint16) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := BytesToUint16.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfBytesToUint16) Push(ctx context.Context, value Bytes, returnCh chan<- *ReturnOfUint16) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := BytesToUint16.GetWorkContextWith(ctx, BytesToUint16.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfBytesToUint16) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfBytesToUint16) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfBytesToUint32 struct {
	handler func(context.Context, Bytes) (uint32, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfBytesToUint32
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfBytesToUint32(ctx context.Context, h func(context.Context, Bytes) (uint32, error), n int) *FuncWorkerOfBytesToUint32 {
	__ := &FuncWorkerOfBytesToUint32{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfBytesToUint32, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go BytesToUint32.CallAsAsync(work.Context, work.WorkOfBytesToUint32.Value, work.WorkOfBytesToUint32.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				BytesToUint32.PutWork(work.WorkOfBytesToUint32)
				BytesToUint32.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfBytesToUint32) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := BytesToUint32.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfBytesToUint32) Push(ctx context.Context, value Bytes, returnCh chan<- *ReturnOfUint32) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := BytesToUint32.GetWorkContextWith(ctx, BytesToUint32.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfBytesToUint32) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfBytesToUint32) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfBytesToUint64 struct {
	handler func(context.Context, Bytes) (uint64, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfBytesToUint64
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfBytesToUint64(ctx context.Context, h func(context.Context, Bytes) (uint64, error), n int) *FuncWorkerOfBytesToUint64 {
	__ := &FuncWorkerOfBytesToUint64{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfBytesToUint64, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go BytesToUint64.CallAsAsync(work.Context, work.WorkOfBytesToUint64.Value, work.WorkOfBytesToUint64.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				BytesToUint64.PutWork(work.WorkOfBytesToUint64)
				BytesToUint64.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfBytesToUint64) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := BytesToUint64.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfBytesToUint64) Push(ctx context.Context, value Bytes, returnCh chan<- *ReturnOfUint64) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := BytesToUint64.GetWorkContextWith(ctx, BytesToUint64.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfBytesToUint64) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfBytesToUint64) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfBytesToUint8 struct {
	handler func(context.Context, Bytes) (uint8, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfBytesToUint8
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfBytesToUint8(ctx context.Context, h func(context.Context, Bytes) (uint8, error), n int) *FuncWorkerOfBytesToUint8 {
	__ := &FuncWorkerOfBytesToUint8{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfBytesToUint8, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go BytesToUint8.CallAsAsync(work.Context, work.WorkOfBytesToUint8.Value, work.WorkOfBytesToUint8.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				BytesToUint8.PutWork(work.WorkOfBytesToUint8)
				BytesToUint8.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfBytesToUint8) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := BytesToUint8.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfBytesToUint8) Push(ctx context.Context, value Bytes, returnCh chan<- *ReturnOfUint8) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := BytesToUint8.GetWorkContextWith(ctx, BytesToUint8.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfBytesToUint8) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfBytesToUint8) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfBytesToUintptr struct {
	handler func(context.Context, Bytes) (uintptr, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfBytesToUintptr
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfBytesToUintptr(ctx context.Context, h func(context.Context, Bytes) (uintptr, error), n int) *FuncWorkerOfBytesToUintptr {
	__ := &FuncWorkerOfBytesToUintptr{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfBytesToUintptr, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go BytesToUintptr.CallAsAsync(work.Context, work.WorkOfBytesToUintptr.Value, work.WorkOfBytesToUintptr.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				BytesToUintptr.PutWork(work.WorkOfBytesToUintptr)
				BytesToUintptr.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfBytesToUintptr) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := BytesToUintptr.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfBytesToUintptr) Push(ctx context.Context, value Bytes, returnCh chan<- *ReturnOfUintptr) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := BytesToUintptr.GetWorkContextWith(ctx, BytesToUintptr.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfBytesToUintptr) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfBytesToUintptr) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfBytesToBytes struct {
	handler func(context.Context, Bytes) (Bytes, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfBytesToBytes
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfBytesToBytes(ctx context.Context, h func(context.Context, Bytes) (Bytes, error), n int) *FuncWorkerOfBytesToBytes {
	__ := &FuncWorkerOfBytesToBytes{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfBytesToBytes, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go BytesToBytes.CallAsAsync(work.Context, work.WorkOfBytesToBytes.Value, work.WorkOfBytesToBytes.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				BytesToBytes.PutWork(work.WorkOfBytesToBytes)
				BytesToBytes.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfBytesToBytes) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := BytesToBytes.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfBytesToBytes) Push(ctx context.Context, value Bytes, returnCh chan<- *ReturnOfBytes) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := BytesToBytes.GetWorkContextWith(ctx, BytesToBytes.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfBytesToBytes) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfBytesToBytes) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfBytesToInterface struct {
	handler func(context.Context, Bytes) (interface{}, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfBytesToInterface
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfBytesToInterface(ctx context.Context, h func(context.Context, Bytes) (interface{}, error), n int) *FuncWorkerOfBytesToInterface {
	__ := &FuncWorkerOfBytesToInterface{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfBytesToInterface, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go BytesToInterface.CallAsAsync(work.Context, work.WorkOfBytesToInterface.Value, work.WorkOfBytesToInterface.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				BytesToInterface.PutWork(work.WorkOfBytesToInterface)
				BytesToInterface.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfBytesToInterface) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := BytesToInterface.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfBytesToInterface) Push(ctx context.Context, value Bytes, returnCh chan<- *ReturnOfInterface) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := BytesToInterface.GetWorkContextWith(ctx, BytesToInterface.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfBytesToInterface) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfBytesToInterface) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfInterfaceToBool struct {
	handler func(context.Context, interface{}) (bool, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfInterfaceToBool
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfInterfaceToBool(ctx context.Context, h func(context.Context, interface{}) (bool, error), n int) *FuncWorkerOfInterfaceToBool {
	__ := &FuncWorkerOfInterfaceToBool{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfInterfaceToBool, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go InterfaceToBool.CallAsAsync(work.Context, work.WorkOfInterfaceToBool.Value, work.WorkOfInterfaceToBool.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				InterfaceToBool.PutWork(work.WorkOfInterfaceToBool)
				InterfaceToBool.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfInterfaceToBool) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := InterfaceToBool.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfInterfaceToBool) Push(ctx context.Context, value interface{}, returnCh chan<- *ReturnOfBool) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := InterfaceToBool.GetWorkContextWith(ctx, InterfaceToBool.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfInterfaceToBool) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfInterfaceToBool) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfInterfaceToByte struct {
	handler func(context.Context, interface{}) (byte, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfInterfaceToByte
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfInterfaceToByte(ctx context.Context, h func(context.Context, interface{}) (byte, error), n int) *FuncWorkerOfInterfaceToByte {
	__ := &FuncWorkerOfInterfaceToByte{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfInterfaceToByte, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go InterfaceToByte.CallAsAsync(work.Context, work.WorkOfInterfaceToByte.Value, work.WorkOfInterfaceToByte.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				InterfaceToByte.PutWork(work.WorkOfInterfaceToByte)
				InterfaceToByte.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfInterfaceToByte) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := InterfaceToByte.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfInterfaceToByte) Push(ctx context.Context, value interface{}, returnCh chan<- *ReturnOfByte) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := InterfaceToByte.GetWorkContextWith(ctx, InterfaceToByte.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfInterfaceToByte) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfInterfaceToByte) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfInterfaceToComplex128 struct {
	handler func(context.Context, interface{}) (complex128, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfInterfaceToComplex128
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfInterfaceToComplex128(ctx context.Context, h func(context.Context, interface{}) (complex128, error), n int) *FuncWorkerOfInterfaceToComplex128 {
	__ := &FuncWorkerOfInterfaceToComplex128{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfInterfaceToComplex128, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go InterfaceToComplex128.CallAsAsync(work.Context, work.WorkOfInterfaceToComplex128.Value, work.WorkOfInterfaceToComplex128.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				InterfaceToComplex128.PutWork(work.WorkOfInterfaceToComplex128)
				InterfaceToComplex128.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfInterfaceToComplex128) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := InterfaceToComplex128.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfInterfaceToComplex128) Push(ctx context.Context, value interface{}, returnCh chan<- *ReturnOfComplex128) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := InterfaceToComplex128.GetWorkContextWith(ctx, InterfaceToComplex128.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfInterfaceToComplex128) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfInterfaceToComplex128) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfInterfaceToComplex64 struct {
	handler func(context.Context, interface{}) (complex64, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfInterfaceToComplex64
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfInterfaceToComplex64(ctx context.Context, h func(context.Context, interface{}) (complex64, error), n int) *FuncWorkerOfInterfaceToComplex64 {
	__ := &FuncWorkerOfInterfaceToComplex64{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfInterfaceToComplex64, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go InterfaceToComplex64.CallAsAsync(work.Context, work.WorkOfInterfaceToComplex64.Value, work.WorkOfInterfaceToComplex64.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				InterfaceToComplex64.PutWork(work.WorkOfInterfaceToComplex64)
				InterfaceToComplex64.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfInterfaceToComplex64) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := InterfaceToComplex64.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfInterfaceToComplex64) Push(ctx context.Context, value interface{}, returnCh chan<- *ReturnOfComplex64) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := InterfaceToComplex64.GetWorkContextWith(ctx, InterfaceToComplex64.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfInterfaceToComplex64) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfInterfaceToComplex64) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfInterfaceToError struct {
	handler func(context.Context, interface{}) (error, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfInterfaceToError
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfInterfaceToError(ctx context.Context, h func(context.Context, interface{}) (error, error), n int) *FuncWorkerOfInterfaceToError {
	__ := &FuncWorkerOfInterfaceToError{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfInterfaceToError, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go InterfaceToError.CallAsAsync(work.Context, work.WorkOfInterfaceToError.Value, work.WorkOfInterfaceToError.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				InterfaceToError.PutWork(work.WorkOfInterfaceToError)
				InterfaceToError.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfInterfaceToError) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := InterfaceToError.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfInterfaceToError) Push(ctx context.Context, value interface{}, returnCh chan<- *ReturnOfError) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := InterfaceToError.GetWorkContextWith(ctx, InterfaceToError.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfInterfaceToError) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfInterfaceToError) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfInterfaceToFloat32 struct {
	handler func(context.Context, interface{}) (float32, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfInterfaceToFloat32
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfInterfaceToFloat32(ctx context.Context, h func(context.Context, interface{}) (float32, error), n int) *FuncWorkerOfInterfaceToFloat32 {
	__ := &FuncWorkerOfInterfaceToFloat32{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfInterfaceToFloat32, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go InterfaceToFloat32.CallAsAsync(work.Context, work.WorkOfInterfaceToFloat32.Value, work.WorkOfInterfaceToFloat32.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				InterfaceToFloat32.PutWork(work.WorkOfInterfaceToFloat32)
				InterfaceToFloat32.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfInterfaceToFloat32) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := InterfaceToFloat32.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfInterfaceToFloat32) Push(ctx context.Context, value interface{}, returnCh chan<- *ReturnOfFloat32) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := InterfaceToFloat32.GetWorkContextWith(ctx, InterfaceToFloat32.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfInterfaceToFloat32) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfInterfaceToFloat32) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfInterfaceToFloat64 struct {
	handler func(context.Context, interface{}) (float64, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfInterfaceToFloat64
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfInterfaceToFloat64(ctx context.Context, h func(context.Context, interface{}) (float64, error), n int) *FuncWorkerOfInterfaceToFloat64 {
	__ := &FuncWorkerOfInterfaceToFloat64{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfInterfaceToFloat64, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go InterfaceToFloat64.CallAsAsync(work.Context, work.WorkOfInterfaceToFloat64.Value, work.WorkOfInterfaceToFloat64.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				InterfaceToFloat64.PutWork(work.WorkOfInterfaceToFloat64)
				InterfaceToFloat64.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfInterfaceToFloat64) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := InterfaceToFloat64.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfInterfaceToFloat64) Push(ctx context.Context, value interface{}, returnCh chan<- *ReturnOfFloat64) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := InterfaceToFloat64.GetWorkContextWith(ctx, InterfaceToFloat64.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfInterfaceToFloat64) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfInterfaceToFloat64) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfInterfaceToInt struct {
	handler func(context.Context, interface{}) (int, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfInterfaceToInt
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfInterfaceToInt(ctx context.Context, h func(context.Context, interface{}) (int, error), n int) *FuncWorkerOfInterfaceToInt {
	__ := &FuncWorkerOfInterfaceToInt{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfInterfaceToInt, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go InterfaceToInt.CallAsAsync(work.Context, work.WorkOfInterfaceToInt.Value, work.WorkOfInterfaceToInt.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				InterfaceToInt.PutWork(work.WorkOfInterfaceToInt)
				InterfaceToInt.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfInterfaceToInt) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := InterfaceToInt.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfInterfaceToInt) Push(ctx context.Context, value interface{}, returnCh chan<- *ReturnOfInt) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := InterfaceToInt.GetWorkContextWith(ctx, InterfaceToInt.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfInterfaceToInt) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfInterfaceToInt) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfInterfaceToInt16 struct {
	handler func(context.Context, interface{}) (int16, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfInterfaceToInt16
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfInterfaceToInt16(ctx context.Context, h func(context.Context, interface{}) (int16, error), n int) *FuncWorkerOfInterfaceToInt16 {
	__ := &FuncWorkerOfInterfaceToInt16{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfInterfaceToInt16, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go InterfaceToInt16.CallAsAsync(work.Context, work.WorkOfInterfaceToInt16.Value, work.WorkOfInterfaceToInt16.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				InterfaceToInt16.PutWork(work.WorkOfInterfaceToInt16)
				InterfaceToInt16.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfInterfaceToInt16) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := InterfaceToInt16.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfInterfaceToInt16) Push(ctx context.Context, value interface{}, returnCh chan<- *ReturnOfInt16) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := InterfaceToInt16.GetWorkContextWith(ctx, InterfaceToInt16.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfInterfaceToInt16) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfInterfaceToInt16) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfInterfaceToInt32 struct {
	handler func(context.Context, interface{}) (int32, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfInterfaceToInt32
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfInterfaceToInt32(ctx context.Context, h func(context.Context, interface{}) (int32, error), n int) *FuncWorkerOfInterfaceToInt32 {
	__ := &FuncWorkerOfInterfaceToInt32{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfInterfaceToInt32, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go InterfaceToInt32.CallAsAsync(work.Context, work.WorkOfInterfaceToInt32.Value, work.WorkOfInterfaceToInt32.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				InterfaceToInt32.PutWork(work.WorkOfInterfaceToInt32)
				InterfaceToInt32.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfInterfaceToInt32) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := InterfaceToInt32.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfInterfaceToInt32) Push(ctx context.Context, value interface{}, returnCh chan<- *ReturnOfInt32) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := InterfaceToInt32.GetWorkContextWith(ctx, InterfaceToInt32.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfInterfaceToInt32) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfInterfaceToInt32) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfInterfaceToInt64 struct {
	handler func(context.Context, interface{}) (int64, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfInterfaceToInt64
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfInterfaceToInt64(ctx context.Context, h func(context.Context, interface{}) (int64, error), n int) *FuncWorkerOfInterfaceToInt64 {
	__ := &FuncWorkerOfInterfaceToInt64{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfInterfaceToInt64, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go InterfaceToInt64.CallAsAsync(work.Context, work.WorkOfInterfaceToInt64.Value, work.WorkOfInterfaceToInt64.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				InterfaceToInt64.PutWork(work.WorkOfInterfaceToInt64)
				InterfaceToInt64.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfInterfaceToInt64) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := InterfaceToInt64.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfInterfaceToInt64) Push(ctx context.Context, value interface{}, returnCh chan<- *ReturnOfInt64) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := InterfaceToInt64.GetWorkContextWith(ctx, InterfaceToInt64.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfInterfaceToInt64) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfInterfaceToInt64) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfInterfaceToInt8 struct {
	handler func(context.Context, interface{}) (int8, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfInterfaceToInt8
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfInterfaceToInt8(ctx context.Context, h func(context.Context, interface{}) (int8, error), n int) *FuncWorkerOfInterfaceToInt8 {
	__ := &FuncWorkerOfInterfaceToInt8{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfInterfaceToInt8, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go InterfaceToInt8.CallAsAsync(work.Context, work.WorkOfInterfaceToInt8.Value, work.WorkOfInterfaceToInt8.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				InterfaceToInt8.PutWork(work.WorkOfInterfaceToInt8)
				InterfaceToInt8.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfInterfaceToInt8) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := InterfaceToInt8.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfInterfaceToInt8) Push(ctx context.Context, value interface{}, returnCh chan<- *ReturnOfInt8) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := InterfaceToInt8.GetWorkContextWith(ctx, InterfaceToInt8.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfInterfaceToInt8) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfInterfaceToInt8) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfInterfaceToRune struct {
	handler func(context.Context, interface{}) (rune, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfInterfaceToRune
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfInterfaceToRune(ctx context.Context, h func(context.Context, interface{}) (rune, error), n int) *FuncWorkerOfInterfaceToRune {
	__ := &FuncWorkerOfInterfaceToRune{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfInterfaceToRune, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go InterfaceToRune.CallAsAsync(work.Context, work.WorkOfInterfaceToRune.Value, work.WorkOfInterfaceToRune.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				InterfaceToRune.PutWork(work.WorkOfInterfaceToRune)
				InterfaceToRune.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfInterfaceToRune) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := InterfaceToRune.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfInterfaceToRune) Push(ctx context.Context, value interface{}, returnCh chan<- *ReturnOfRune) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := InterfaceToRune.GetWorkContextWith(ctx, InterfaceToRune.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfInterfaceToRune) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfInterfaceToRune) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfInterfaceToString struct {
	handler func(context.Context, interface{}) (string, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfInterfaceToString
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfInterfaceToString(ctx context.Context, h func(context.Context, interface{}) (string, error), n int) *FuncWorkerOfInterfaceToString {
	__ := &FuncWorkerOfInterfaceToString{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfInterfaceToString, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go InterfaceToString.CallAsAsync(work.Context, work.WorkOfInterfaceToString.Value, work.WorkOfInterfaceToString.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				InterfaceToString.PutWork(work.WorkOfInterfaceToString)
				InterfaceToString.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfInterfaceToString) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := InterfaceToString.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfInterfaceToString) Push(ctx context.Context, value interface{}, returnCh chan<- *ReturnOfString) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := InterfaceToString.GetWorkContextWith(ctx, InterfaceToString.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfInterfaceToString) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfInterfaceToString) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfInterfaceToUint struct {
	handler func(context.Context, interface{}) (uint, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfInterfaceToUint
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfInterfaceToUint(ctx context.Context, h func(context.Context, interface{}) (uint, error), n int) *FuncWorkerOfInterfaceToUint {
	__ := &FuncWorkerOfInterfaceToUint{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfInterfaceToUint, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go InterfaceToUint.CallAsAsync(work.Context, work.WorkOfInterfaceToUint.Value, work.WorkOfInterfaceToUint.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				InterfaceToUint.PutWork(work.WorkOfInterfaceToUint)
				InterfaceToUint.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfInterfaceToUint) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := InterfaceToUint.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfInterfaceToUint) Push(ctx context.Context, value interface{}, returnCh chan<- *ReturnOfUint) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := InterfaceToUint.GetWorkContextWith(ctx, InterfaceToUint.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfInterfaceToUint) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfInterfaceToUint) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfInterfaceToUint16 struct {
	handler func(context.Context, interface{}) (uint16, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfInterfaceToUint16
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfInterfaceToUint16(ctx context.Context, h func(context.Context, interface{}) (uint16, error), n int) *FuncWorkerOfInterfaceToUint16 {
	__ := &FuncWorkerOfInterfaceToUint16{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfInterfaceToUint16, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go InterfaceToUint16.CallAsAsync(work.Context, work.WorkOfInterfaceToUint16.Value, work.WorkOfInterfaceToUint16.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				InterfaceToUint16.PutWork(work.WorkOfInterfaceToUint16)
				InterfaceToUint16.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfInterfaceToUint16) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := InterfaceToUint16.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfInterfaceToUint16) Push(ctx context.Context, value interface{}, returnCh chan<- *ReturnOfUint16) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := InterfaceToUint16.GetWorkContextWith(ctx, InterfaceToUint16.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfInterfaceToUint16) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfInterfaceToUint16) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfInterfaceToUint32 struct {
	handler func(context.Context, interface{}) (uint32, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfInterfaceToUint32
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfInterfaceToUint32(ctx context.Context, h func(context.Context, interface{}) (uint32, error), n int) *FuncWorkerOfInterfaceToUint32 {
	__ := &FuncWorkerOfInterfaceToUint32{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfInterfaceToUint32, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go InterfaceToUint32.CallAsAsync(work.Context, work.WorkOfInterfaceToUint32.Value, work.WorkOfInterfaceToUint32.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				InterfaceToUint32.PutWork(work.WorkOfInterfaceToUint32)
				InterfaceToUint32.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfInterfaceToUint32) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := InterfaceToUint32.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfInterfaceToUint32) Push(ctx context.Context, value interface{}, returnCh chan<- *ReturnOfUint32) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := InterfaceToUint32.GetWorkContextWith(ctx, InterfaceToUint32.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfInterfaceToUint32) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfInterfaceToUint32) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfInterfaceToUint64 struct {
	handler func(context.Context, interface{}) (uint64, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfInterfaceToUint64
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfInterfaceToUint64(ctx context.Context, h func(context.Context, interface{}) (uint64, error), n int) *FuncWorkerOfInterfaceToUint64 {
	__ := &FuncWorkerOfInterfaceToUint64{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfInterfaceToUint64, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go InterfaceToUint64.CallAsAsync(work.Context, work.WorkOfInterfaceToUint64.Value, work.WorkOfInterfaceToUint64.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				InterfaceToUint64.PutWork(work.WorkOfInterfaceToUint64)
				InterfaceToUint64.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfInterfaceToUint64) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := InterfaceToUint64.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfInterfaceToUint64) Push(ctx context.Context, value interface{}, returnCh chan<- *ReturnOfUint64) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := InterfaceToUint64.GetWorkContextWith(ctx, InterfaceToUint64.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfInterfaceToUint64) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfInterfaceToUint64) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfInterfaceToUint8 struct {
	handler func(context.Context, interface{}) (uint8, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfInterfaceToUint8
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfInterfaceToUint8(ctx context.Context, h func(context.Context, interface{}) (uint8, error), n int) *FuncWorkerOfInterfaceToUint8 {
	__ := &FuncWorkerOfInterfaceToUint8{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfInterfaceToUint8, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go InterfaceToUint8.CallAsAsync(work.Context, work.WorkOfInterfaceToUint8.Value, work.WorkOfInterfaceToUint8.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				InterfaceToUint8.PutWork(work.WorkOfInterfaceToUint8)
				InterfaceToUint8.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfInterfaceToUint8) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := InterfaceToUint8.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfInterfaceToUint8) Push(ctx context.Context, value interface{}, returnCh chan<- *ReturnOfUint8) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := InterfaceToUint8.GetWorkContextWith(ctx, InterfaceToUint8.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfInterfaceToUint8) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfInterfaceToUint8) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfInterfaceToUintptr struct {
	handler func(context.Context, interface{}) (uintptr, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfInterfaceToUintptr
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfInterfaceToUintptr(ctx context.Context, h func(context.Context, interface{}) (uintptr, error), n int) *FuncWorkerOfInterfaceToUintptr {
	__ := &FuncWorkerOfInterfaceToUintptr{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfInterfaceToUintptr, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go InterfaceToUintptr.CallAsAsync(work.Context, work.WorkOfInterfaceToUintptr.Value, work.WorkOfInterfaceToUintptr.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				InterfaceToUintptr.PutWork(work.WorkOfInterfaceToUintptr)
				InterfaceToUintptr.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfInterfaceToUintptr) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := InterfaceToUintptr.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfInterfaceToUintptr) Push(ctx context.Context, value interface{}, returnCh chan<- *ReturnOfUintptr) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := InterfaceToUintptr.GetWorkContextWith(ctx, InterfaceToUintptr.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfInterfaceToUintptr) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfInterfaceToUintptr) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfInterfaceToBytes struct {
	handler func(context.Context, interface{}) (Bytes, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfInterfaceToBytes
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfInterfaceToBytes(ctx context.Context, h func(context.Context, interface{}) (Bytes, error), n int) *FuncWorkerOfInterfaceToBytes {
	__ := &FuncWorkerOfInterfaceToBytes{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfInterfaceToBytes, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go InterfaceToBytes.CallAsAsync(work.Context, work.WorkOfInterfaceToBytes.Value, work.WorkOfInterfaceToBytes.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				InterfaceToBytes.PutWork(work.WorkOfInterfaceToBytes)
				InterfaceToBytes.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfInterfaceToBytes) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := InterfaceToBytes.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfInterfaceToBytes) Push(ctx context.Context, value interface{}, returnCh chan<- *ReturnOfBytes) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := InterfaceToBytes.GetWorkContextWith(ctx, InterfaceToBytes.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfInterfaceToBytes) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfInterfaceToBytes) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

type FuncWorkerOfInterfaceToInterface struct {
	handler func(context.Context, interface{}) (interface{}, error)

	ctx context.Context

	threads  sync.WaitGroup
	work_ch  chan *WorkContextOfInterfaceToInterface
	done_ch  chan struct{}
	reset_ch chan chan error
}

func NewFuncWorkerOfInterfaceToInterface(ctx context.Context, h func(context.Context, interface{}) (interface{}, error), n int) *FuncWorkerOfInterfaceToInterface {
	__ := &FuncWorkerOfInterfaceToInterface{
		handler: h,

		ctx: ctx,

		work_ch:  make(chan *WorkContextOfInterfaceToInterface, n),
		done_ch:  make(chan struct{}),
		reset_ch: make(chan chan error, n),
	}

	go func() {
		defer func() {
			__.threads.Wait()
			__.reset_queue()
			for i := 0; i < len(__.reset_ch); i += 1 {
				rst_req := <-__.reset_ch
				rst_req <- fmt.Errorf("terminated worker")
				close(rst_req)
			}
			close(__.done_ch)
		}()

	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case work := <-__.work_ch:
				__.threads.Add(1)
				go InterfaceToInterface.CallAsAsync(work.Context, work.WorkOfInterfaceToInterface.Value, work.WorkOfInterfaceToInterface.ReturnCh, __.handler, func() {
					__.threads.Done()
				})
				InterfaceToInterface.PutWork(work.WorkOfInterfaceToInterface)
				InterfaceToInterface.PutWorkContext(work)
			case reset_done_ch := <-__.reset_ch:
				__.reset_queue()
				close(reset_done_ch)
			}
		}
	}()

	return __
}

func (__ *FuncWorkerOfInterfaceToInterface) reset_queue() {
	for i := 0; i < len(__.work_ch); i += 1 {
		req := <-__.work_ch
		rtn := InterfaceToInterface.GetReturn()
		rtn.Error = fmt.Errorf("canceled by reset")
		req.ReturnCh <- rtn
	}
}

func (__ *FuncWorkerOfInterfaceToInterface) Push(ctx context.Context, value interface{}, returnCh chan<- *ReturnOfInterface) {
	__.threads.Add(1)
	defer __.threads.Done()

	work_ctx := InterfaceToInterface.GetWorkContextWith(ctx, InterfaceToInterface.GetWorkWith(value, returnCh))
	__.work_ch <- work_ctx
}

func (__ *FuncWorkerOfInterfaceToInterface) DoneNotify() <-chan struct{} {
	return __.done_ch
}

func (__ *FuncWorkerOfInterfaceToInterface) Reset(ctx context.Context) <-chan error {
	__.threads.Add(1)
	defer __.threads.Done()

	done_ch := make(chan error, 1)
	select {
	case <-__.ctx.Done():
		done_ch <- fmt.Errorf("contex done")
		close(done_ch)
	default:
		__.reset_ch <- done_ch
	}

	return done_ch
}

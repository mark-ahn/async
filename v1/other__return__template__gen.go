// This file was automatically generated by genny.
// Any changes will be lost if this file is regenerated.
// see https://github.com/cheekybits/genny

package async

import (
	"context"
	"sync"
)

type ReturnOfBytes struct {
	Context context.Context
	Value   Bytes
	Error   error
}

func (__ *ReturnOfBytes) Unpack() (context.Context, Some, error) {
	return __.Context, __.Value, __.Error
}

var (
	zero_of_ReturnOfBytes       ReturnOfBytes
	zero_of_ReturnOfBytes_value Bytes
	pool_of_ReturnOfBytes       = sync.Pool{
		New: func() interface{} {
			return &ReturnOfBytes{}
		},
	}
	pool_of_ReturnOfBytes_ch = sync.Pool{
		New: func() interface{} {
			return make(chan *ReturnOfBytes, 1)
		},
	}
)

type pool_ReturnOfBytes struct{}

func (_ pool_ReturnOfBytes) Get() *ReturnOfBytes {
	return pool_of_ReturnOfBytes.Get().(*ReturnOfBytes)
}
func (_ pool_ReturnOfBytes) Put(d *ReturnOfBytes) {
	d.Context = nil
	d.Value = zero_of_ReturnOfBytes_value
	d.Error = nil
	pool_of_ReturnOfBytes.Put(d)
}

func (__ pool_ReturnOfBytes) GetWith(ctx context.Context, value Bytes, err error) *ReturnOfBytes {
	rtn := __.Get()
	rtn.Context = ctx
	rtn.Value = value
	rtn.Error = err
	return rtn
}

type pool_ChanReturnOfBytes struct{}

func (_ pool_ChanReturnOfBytes) Get() chan *ReturnOfBytes {
	return pool_of_ReturnOfBytes_ch.Get().(chan *ReturnOfBytes)
}
func (_ pool_ChanReturnOfBytes) Put(d chan *ReturnOfBytes) {
	pool_of_ReturnOfBytes_ch.Put(d)
}

type StackOfChanReturnOfBytes struct {
	chans []chan<- *ReturnOfBytes
	sync.Mutex
}

func NewStackOfChanReturnOfBytes(n int) *StackOfChanReturnOfBytes {
	return &StackOfChanReturnOfBytes{
		chans: make([]chan<- *ReturnOfBytes, 0, n),
	}
}

func (__ *StackOfChanReturnOfBytes) Push(ch chan<- *ReturnOfBytes) {
	__.Lock()
	__.chans = append(__.chans, ch)
	__.Unlock()
}
func (__ *StackOfChanReturnOfBytes) Pop() chan<- *ReturnOfBytes {
	var ch chan<- *ReturnOfBytes
	__.Lock()
	defer __.Unlock()
	last := len(__.chans) - 1
	if last < 0 {
		return ch
	}
	__.chans, ch = __.chans[:last], __.chans[last]
	return ch
}

func (__ *StackOfChanReturnOfBytes) Top() chan<- *ReturnOfBytes {
	var ch chan<- *ReturnOfBytes
	__.Lock()
	defer __.Unlock()
	last := len(__.chans) - 1
	if last < 0 {
		return ch
	}
	return __.chans[last]
}

type async_key_for_Bytes int

const (
	async_key_for_Bytes_return_ch_stack async_key_for_Bytes = iota
)

type chanReturnOfBytes struct{}

func (_ chanReturnOfBytes) WithStack(ctx context.Context, n int) context.Context {
	stack := NewStackOfChanReturnOfBytes(n)
	return context.WithValue(ctx, async_key_for_Bytes_return_ch_stack, stack)
}

func (_ chanReturnOfBytes) Pop(ctx Valuable) chan<- *ReturnOfBytes {
	stack, ok := ctx.Value(async_key_for_Bytes_return_ch_stack).(*StackOfChanReturnOfBytes)
	if !ok {
		return nil
	}
	return stack.Pop()
}

func (_ chanReturnOfBytes) Top(ctx Valuable) chan<- *ReturnOfBytes {
	stack, ok := ctx.Value(async_key_for_Bytes_return_ch_stack).(*StackOfChanReturnOfBytes)
	if !ok {
		return nil
	}
	return stack.Top()
}

func (_ chanReturnOfBytes) Push(ctx Valuable, ch chan<- *ReturnOfBytes) bool {
	stack, ok := ctx.Value(async_key_for_Bytes_return_ch_stack).(*StackOfChanReturnOfBytes)
	if !ok {
		return false
	}
	stack.Push(ch)
	return true
}

func (__ chanReturnOfBytes) Notify(ctx Valuable, rtn *ReturnOfBytes) bool {
	ch := __.Top(ctx)
	if ch == nil {
		return false
	}
	ch <- rtn
	return true
}

type _Bytes struct {
	Pool struct {
		Return     pool_ReturnOfBytes
		ChanReturn pool_ChanReturnOfBytes
	}
	Context struct {
		ChanReturn chanReturnOfBytes
	}
}

var Bytess = _Bytes{}

type ReturnOfString struct {
	Context context.Context
	Value   string
	Error   error
}

func (__ *ReturnOfString) Unpack() (context.Context, Some, error) {
	return __.Context, __.Value, __.Error
}

var (
	zero_of_ReturnOfString       ReturnOfString
	zero_of_ReturnOfString_value string
	pool_of_ReturnOfString       = sync.Pool{
		New: func() interface{} {
			return &ReturnOfString{}
		},
	}
	pool_of_ReturnOfString_ch = sync.Pool{
		New: func() interface{} {
			return make(chan *ReturnOfString, 1)
		},
	}
)

type pool_ReturnOfString struct{}

func (_ pool_ReturnOfString) Get() *ReturnOfString {
	return pool_of_ReturnOfString.Get().(*ReturnOfString)
}
func (_ pool_ReturnOfString) Put(d *ReturnOfString) {
	d.Context = nil
	d.Value = zero_of_ReturnOfString_value
	d.Error = nil
	pool_of_ReturnOfString.Put(d)
}

func (__ pool_ReturnOfString) GetWith(ctx context.Context, value string, err error) *ReturnOfString {
	rtn := __.Get()
	rtn.Context = ctx
	rtn.Value = value
	rtn.Error = err
	return rtn
}

type pool_ChanReturnOfString struct{}

func (_ pool_ChanReturnOfString) Get() chan *ReturnOfString {
	return pool_of_ReturnOfString_ch.Get().(chan *ReturnOfString)
}
func (_ pool_ChanReturnOfString) Put(d chan *ReturnOfString) {
	pool_of_ReturnOfString_ch.Put(d)
}

type StackOfChanReturnOfString struct {
	chans []chan<- *ReturnOfString
	sync.Mutex
}

func NewStackOfChanReturnOfString(n int) *StackOfChanReturnOfString {
	return &StackOfChanReturnOfString{
		chans: make([]chan<- *ReturnOfString, 0, n),
	}
}

func (__ *StackOfChanReturnOfString) Push(ch chan<- *ReturnOfString) {
	__.Lock()
	__.chans = append(__.chans, ch)
	__.Unlock()
}
func (__ *StackOfChanReturnOfString) Pop() chan<- *ReturnOfString {
	var ch chan<- *ReturnOfString
	__.Lock()
	defer __.Unlock()
	last := len(__.chans) - 1
	if last < 0 {
		return ch
	}
	__.chans, ch = __.chans[:last], __.chans[last]
	return ch
}

func (__ *StackOfChanReturnOfString) Top() chan<- *ReturnOfString {
	var ch chan<- *ReturnOfString
	__.Lock()
	defer __.Unlock()
	last := len(__.chans) - 1
	if last < 0 {
		return ch
	}
	return __.chans[last]
}

type async_key_for_String int

const (
	async_key_for_String_return_ch_stack async_key_for_String = iota
)

type chanReturnOfString struct{}

func (_ chanReturnOfString) WithStack(ctx context.Context, n int) context.Context {
	stack := NewStackOfChanReturnOfString(n)
	return context.WithValue(ctx, async_key_for_String_return_ch_stack, stack)
}

func (_ chanReturnOfString) Pop(ctx Valuable) chan<- *ReturnOfString {
	stack, ok := ctx.Value(async_key_for_String_return_ch_stack).(*StackOfChanReturnOfString)
	if !ok {
		return nil
	}
	return stack.Pop()
}

func (_ chanReturnOfString) Top(ctx Valuable) chan<- *ReturnOfString {
	stack, ok := ctx.Value(async_key_for_String_return_ch_stack).(*StackOfChanReturnOfString)
	if !ok {
		return nil
	}
	return stack.Top()
}

func (_ chanReturnOfString) Push(ctx Valuable, ch chan<- *ReturnOfString) bool {
	stack, ok := ctx.Value(async_key_for_String_return_ch_stack).(*StackOfChanReturnOfString)
	if !ok {
		return false
	}
	stack.Push(ch)
	return true
}

func (__ chanReturnOfString) Notify(ctx Valuable, rtn *ReturnOfString) bool {
	ch := __.Top(ctx)
	if ch == nil {
		return false
	}
	ch <- rtn
	return true
}

type _String struct {
	Pool struct {
		Return     pool_ReturnOfString
		ChanReturn pool_ChanReturnOfString
	}
	Context struct {
		ChanReturn chanReturnOfString
	}
}

var Strings = _String{}

type ReturnOfInterface struct {
	Context context.Context
	Value   interface{}
	Error   error
}

func (__ *ReturnOfInterface) Unpack() (context.Context, Some, error) {
	return __.Context, __.Value, __.Error
}

var (
	zero_of_ReturnOfInterface       ReturnOfInterface
	zero_of_ReturnOfInterface_value interface{}
	pool_of_ReturnOfInterface       = sync.Pool{
		New: func() interface{} {
			return &ReturnOfInterface{}
		},
	}
	pool_of_ReturnOfInterface_ch = sync.Pool{
		New: func() interface{} {
			return make(chan *ReturnOfInterface, 1)
		},
	}
)

type pool_ReturnOfInterface struct{}

func (_ pool_ReturnOfInterface) Get() *ReturnOfInterface {
	return pool_of_ReturnOfInterface.Get().(*ReturnOfInterface)
}
func (_ pool_ReturnOfInterface) Put(d *ReturnOfInterface) {
	d.Context = nil
	d.Value = zero_of_ReturnOfInterface_value
	d.Error = nil
	pool_of_ReturnOfInterface.Put(d)
}

func (__ pool_ReturnOfInterface) GetWith(ctx context.Context, value interface{}, err error) *ReturnOfInterface {
	rtn := __.Get()
	rtn.Context = ctx
	rtn.Value = value
	rtn.Error = err
	return rtn
}

type pool_ChanReturnOfInterface struct{}

func (_ pool_ChanReturnOfInterface) Get() chan *ReturnOfInterface {
	return pool_of_ReturnOfInterface_ch.Get().(chan *ReturnOfInterface)
}
func (_ pool_ChanReturnOfInterface) Put(d chan *ReturnOfInterface) {
	pool_of_ReturnOfInterface_ch.Put(d)
}

type StackOfChanReturnOfInterface struct {
	chans []chan<- *ReturnOfInterface
	sync.Mutex
}

func NewStackOfChanReturnOfInterface(n int) *StackOfChanReturnOfInterface {
	return &StackOfChanReturnOfInterface{
		chans: make([]chan<- *ReturnOfInterface, 0, n),
	}
}

func (__ *StackOfChanReturnOfInterface) Push(ch chan<- *ReturnOfInterface) {
	__.Lock()
	__.chans = append(__.chans, ch)
	__.Unlock()
}
func (__ *StackOfChanReturnOfInterface) Pop() chan<- *ReturnOfInterface {
	var ch chan<- *ReturnOfInterface
	__.Lock()
	defer __.Unlock()
	last := len(__.chans) - 1
	if last < 0 {
		return ch
	}
	__.chans, ch = __.chans[:last], __.chans[last]
	return ch
}

func (__ *StackOfChanReturnOfInterface) Top() chan<- *ReturnOfInterface {
	var ch chan<- *ReturnOfInterface
	__.Lock()
	defer __.Unlock()
	last := len(__.chans) - 1
	if last < 0 {
		return ch
	}
	return __.chans[last]
}

type async_key_for_Interface int

const (
	async_key_for_Interface_return_ch_stack async_key_for_Interface = iota
)

type chanReturnOfInterface struct{}

func (_ chanReturnOfInterface) WithStack(ctx context.Context, n int) context.Context {
	stack := NewStackOfChanReturnOfInterface(n)
	return context.WithValue(ctx, async_key_for_Interface_return_ch_stack, stack)
}

func (_ chanReturnOfInterface) Pop(ctx Valuable) chan<- *ReturnOfInterface {
	stack, ok := ctx.Value(async_key_for_Interface_return_ch_stack).(*StackOfChanReturnOfInterface)
	if !ok {
		return nil
	}
	return stack.Pop()
}

func (_ chanReturnOfInterface) Top(ctx Valuable) chan<- *ReturnOfInterface {
	stack, ok := ctx.Value(async_key_for_Interface_return_ch_stack).(*StackOfChanReturnOfInterface)
	if !ok {
		return nil
	}
	return stack.Top()
}

func (_ chanReturnOfInterface) Push(ctx Valuable, ch chan<- *ReturnOfInterface) bool {
	stack, ok := ctx.Value(async_key_for_Interface_return_ch_stack).(*StackOfChanReturnOfInterface)
	if !ok {
		return false
	}
	stack.Push(ch)
	return true
}

func (__ chanReturnOfInterface) Notify(ctx Valuable, rtn *ReturnOfInterface) bool {
	ch := __.Top(ctx)
	if ch == nil {
		return false
	}
	ch <- rtn
	return true
}

type _Interface struct {
	Pool struct {
		Return     pool_ReturnOfInterface
		ChanReturn pool_ChanReturnOfInterface
	}
	Context struct {
		ChanReturn chanReturnOfInterface
	}
}

var Interfaces = _Interface{}
